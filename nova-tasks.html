<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25b75b267ab5fbf8f1ea20f18ef59eea6a792cb0b6b83d655537b4440eeda38faa28c007b6add95b133662b9ba68e08f6be3ab2b653a78994e13b03f892e7a7e9552b85ea24dae0c68bfbdafc3e0805833000bbcff04235835d6e19e1875dd42c23539bb01b628ffc6426b0ca09e41eb2f384659e348fcc5f1ce41c2bc71f7065016cbdd8eca92a4fcf91a516f4ab729a9a0a21ced54890ae847c4ca8082b4b948c383076a5e627f5a0b0353d5c92c5c9ef85bbcc29955ab755ca76599993b4f25c1f3b824f5820dec5504693304616e29c0e4370ddd05c783bf17fd3cafa70f40960329280d9776aac968a14556c3b949ca41564901ee60fb651585012800f56668091eb9e600445715059e29541b22d65bc802cdc17b8ca8c56e0c0819bf3a96f6674b6bb8b3c782e38c03f71394a29c5a5d619a35244a2b90b9b1fa80c00049bc28a481cb35636b95b294e9dfa8ab4e5fbcbdc41f235757ab7122b7ab37b5280d5fb76432049da3577d4316cc20632b6c0a4bc8b16ab9a441789848d6fbb3eba47fd9c52842f432e340d7e10c3dfac666865284954469658513c293501ef273e0dcee08f0c5499268de35990bf6f4730f4c5989f8e0f3014cf21301c72cdb9b56c7dbf6ade338ef548b1e945671940295f6fb7ea57c95c18b71b107b3ab9dc6835b870a14ebf9529c0026aa801455b5c253289683b017732fd0f1810c1746f30e913ec99171d86d888882c75a2df4ce0ece303ac041fb6ded409fc4c87e902192ea493bfdc733d7e4dd01bec35d16269f19734386ff8be04d9929aac8018bc437386d537a783984b0a1fe70a3eec86b3ce77d113b624770a82e4accd692eacfff5bcef89064e9a7d8139a793456f2dd066b09e6451ee6d16a9d598aeae4b1ddde58e0dbfd11c7ea82467611baaf6f3aaf0d0de1714a21d51bf1fd24fab4bcb6c21d6bc6330419dfca924a0e39e499a538b2096d448c43c05b5f6d02d3984d30df8f698e0eea81eb8c39da250cca6ed02e0957733e681f45956da03f3b4449d84aeee1df0e9e51b92f0e0e3050a12b6dece4bf60533a6dc7480581cbc512c9fce451d741ebc0127683a7cad7448b254155445652666d2bc6cf855acc880cdf0d3abbf7c938b0e100adba347b12af3543e98b4ac6f66e509383e6a4466c675aecfaf307b71e1ef7e27d01c6ff3c37851db7ab76c36d815959430fb3e66075a77ef08a08c417576f3ed470f739d61fbc24462ec2126f6a2b5e11cbb0d4a2645975e065ee2809176d6ee1cdb7f518935b723ac59fb25e67b269a917f315aa16ef83b36b6984be9dbcd8b54ae550f5b70580b7988b93ecaf44b23158a89194147c9c5266255b2ea5b17b3753424e75a842940fc1081e069e768b4c2272b39953f503164f843a829d066e72d9492a036eef8f24c87ad0203f941b1802050116ba74aa03f406fa82d401b77612dc202bd95bd6419a23c1377ad0cf70f562e34a4ac8685dce15dead7a5b378a59192912fadc0efd30a4ae3cb10de1634bab0b05a42b25ca5087af12c0ffbd8260693c23a2d2a6e074156c804f5aea3480f844515b9f60feb0ac2ff9066cfe81856e7ba33eb15eae36a59d7c1008b14a5e1c77e4bb0c9a278fca7b9a6ed2993b5023d4d6dd05dc84b574672705fa6c29a24445001a5788620fd0224f50cb6851edf6dd6f54e6e111ff21249aee00bab91c6259c03e930779dc7a1a2c0b5dcecb0a4ccc4b28a0ad40685a53bd097d646f5de558073a3da4b740f2639732e2d7bcd7f3aa77092c2f4c7407c5b825bca297c96cf135c98fbc5db7e685ea20d1df3fe605633bc829fea913711f173429d9b963b781beb020932d014799fb7696f6ab82dfef78ff56ea3325bcd4bb39296e010b53a04fca2e2ec06c0150975ce09a04aa809451477320a45d12bf5b47c5b06f3e79a6bc8eeb6ed4a78dd0482d1d8929f15ab89c17ef4efc647a39109d6507cceac4eab48e78c0d72d1e74b5583d8dbf85837d1823bc5a1e992328cbb6d7612f65bcc5d772ef7cd4eade98316ac5508091d4524cd2a337de596bfba6067f45870dd9681b21333efb508b15eadd36fe5eb2ac8e17ce1d44b49b6fd1c1248a453b9d88e5d20d8ba7b687545e5d97b2b554fa64fa2fdd29555408494c228859fd42366bbf29d5d5697dde2cd4d873064dcd51fe1d1b2e6c29c1c7e5de0699d27eb87e183b9eb116e244e2a0a026b1ba68bbf2c7c5f5c93a881aa169edc50b4992da10b96ba939642965d77aee6301000b984e82a0a9a4b17779086791ef255b8ff9a7d527a56bdfd2d72cf11e1faf32064af0dd12af79c2e1e935f154c636a179776c7d8f28a0cd1e83b1921dbb01eaef3f39d1c32bb7b4e7fdb5f01769a7d619013e3af814e84d898de3874aff730a61498729078be8d4c45de7d9dca4dc653a3d5a677b9a383460155d8fa0d349471e1b2c351973ffcb325b6e8f08050a7034a0ab0ae6161db76dfbb445c92eb673a3a57c7506d5993683230b8ccf59834c72d339064cb5b984e1d924b4c5acf370e24fc72897548a62488e5f9eb9461123381632b20c41ce6682ac7f86ed3d74fce162e260828b6a295d724287a67ac322ff76f4d57f4a144c079830c0cbd0844a0af432015effeb22ee12f100f00ee4686d405bd0bef97dc670100a4174a90d6c1292e64d858fc29ba8e1e0ee3c18ec458f52d9aaee32fb14adf6a9b244de5c75bf46fe34bece1d7a508e04788057680f3bedb7fdc8373f03de9a7f108f33b3a3fef9030129846431fed40d25d0c138a6773540771b443ab0586b0a20cd00b119a76a31c0fb1f0764a6fd04ce80e85430331c36dcd626c48a06280c38246e6283db0e183749d18c15ea351a06a1b9b3cb7989fabf4c653ebab87cfcf7fb97ae109bcf2323e4d518b0178c5cdbe7e379bf91bf07cb65c74e1fafb2807b2b10364bc23a441a74618e7c69f55c31d07c3f5c3012a0475a42ee1f64133ae8ba0909139199ec640b7d26451cd1c6dfc6b2553cf78eba5b1e88689bf8d622828ff46b56af19f423b0362c5ee9e1a624f161eb652ccf351e76fc42d813284e04458391b72f2b8e81146f476c15ad2a001d6484bde4df84b33a7b7d37728a47c663c235b68d1ffd157364ed22a95227fc1ff4cf5f81300c7448139ffa768dfb92a1ab4a45ba101c87f72ead98923235b0ad20d0fa3532620f8abaeba8f2e99458464bedf0fa2235dda5567402a25580fe45f071212b3169b60c3f671649d10fad3a240eb25221325b0fa7d29c59846b6a96ca1689ae475c51458362bfdf5070b322b8375cf949fc0435c6bb160693301e69d311d590edc9f08bcef2c3a304cab7a3549f86d18bff2d65bbc57c7ae234746304d36b9bb3c1bf065f13c6ddfbf81efc5acfde4ced07a056221efb29b476e9bace310557b66de53aa2f7970b8c9b6b6b439c983bb522fd7f89d5388a3222989790ecd5d22c6f4c3e9da282dac5b3c61aed074234352af0d1742b8202fefdb91497f51d7910e5e2ab0825db884e83d1b3f87bfd8cb92e16eb3d88a0e2e0323158f00c9e76cf58eab53dcbf14e87b304cbb6a745f62a303443e7fc2e68268699c649714edad454197b56b8f5a38c6b548d4e1a885a6c3f43aaf64ad7f27e89d68707edf035943736ee59d75ef8f6bed5443acff9ee6a2cacb3f1febdc13c63d5b477e770d00d76364714d5d0c1b16b2f044d99d10bfbe697c48ffdbc275be74723ca03b4836c668dbfb5882174ecaa23ef2a511bb8fa840e5a25b3254f8b67ff15d6e56cf605f5687b6014fa40b1693f8572419fd1255f57d5236c821400d84f0baf2266188ac9549ec988f4fef2d4df2050ec7fdb9169c06dd423c7ebfe9bc9e7e336aaa2ca9e5f55e68ecae60513ad62deeee524b014e8d695bcba4e2c29a5681b93a53098c01ba306f1591063ff801ecfe66d307bfc7b40c07ab50f61d3c0ad8a8ee472d0c8a6062e60a950a27e136ba76de8f9f1f717dd7b962ba96beae539ea29e8a406ac45c1f8df3d22d95d828afae7b130a6ce6424fc20c3bc97e7b2b5e7e66f2753eae51d732a03673701d91a6b3a593b252a8d8da6d849727e80d3ef24bf0d0c1c5105fb35a1a24cf76f731186cbb5f87007f252b1586fe95c8ea73175b3bb0b8fcdf8654fe7497b0c18f9d7ba410a5981aa58ee947ae0fb80fb55147d3cc968c629bae90aec69370a7ec2a533e88a44ba73727e74231cd1c8f5c139bb9cbfbd4ff8bdd0cae597f9b2352b15452063020d412c85700841a64ecd8fce674665cf04c6464e1ec582f6df9e161148e42f6c1f9400c7fb6ab564d7be73d323c2071b79d224da982dc440d152a2b9102b8dcf1e93852e9d2dea7014b598df259a24619ce50a6c602eb267d465437377f24eb6c5f6f7d436016a264c87caee25d591db1d477486b6af7e05d499e9b6852c408afee839671b6ffb225bc9cbe8f037a27e02d27041f9b019298910b26623f9850f5b2dbbe014d06077cf8186e707c62e84e66f4e114bc1e8e1b7c7da20b965c01f8fa9be32729a7a9041b2e9b6697b80e4bedccb41e7e21d32001f4c9db399dcc75673c897480db4e5a17d2da2f88bfea782471b15973bab4d6539882b3e8011246ddab62168b89a31b4d2f7c47a3f70564dcf124660461dbdb2662705fe78074b9a796de21ded744383d39f458ad8fc13cbb1dfda464faa12267198ebd297373bd1ef91d78e1ccb679651fc7964aade4542753dfe0dd79acd61cd08307875574f2b1534b144233ef2ced02cdf8f709181727a18c39566b3365df04ec73e1ed029df4e070ea262dbef4e2d747b42a4332bac9c8a502f2e317a5c8f0a32d8c144778457225169be7cc36beb4bbd750e0b396be511d15c8921aab8c12fe992888c3f48a4f0707cd77bc94d67a4bae3bf9eb16606197342c59257e7d065a8f50f5e74109b346651eccf3601a9a925526f8222a2bad511a4363722bbaa7f3eea3e35d739527afffa3d93de8799d711b7f89f72d9224a575738f761760ead01cdbb8d8682677ef9319f212583630c43c983b28c082c4591c86eb644847dd13b4aba6ef8c4f79e9e0a7f6259e78e7956369877e711efc11f914725893519255b10b814e26e361cce9f796117885639989dd2d9216394d46de69082d28784741737b06b1ae321b23b7da658efe9d0db20393513507f206e01c78ee11f4efa58e43d6dc8228c2065e1cf50294adfb0b773549522c59dabee9d3dc28625c22617575edfbb91b288caf7933618c34caa5fc9a7ba3b5e990769cbe0b00f9f420e1d37fe7a04d449a05ec7b7e7049f4cc0c2d1e33d429eca90a392648dd5c29583be638aac21e19597fce87a11835c76eaa4711ba59e21c1a83fea4bd87a8e7c7ad0a00fecbd69becd1ec0f463cff4a71702a331b1e31ff998c93c0c246836a1d189b3d12497ab4a3be4c4e0813ef06b92b3fae40a399ca28ea4628ffeecd6f6a0cf0f7ed3f1b7c3a426bcb0fc0369738fe9ba60f8fa653c31056f352793dd6794ff387ea53d1f4d4fbf8791cb863f6ecc81645a227f011f97cedff22513fb3158bad337a6c6839a260399abc988e30a9170d97778724d6e56b9ae84a83ae03582c37246fffe194fec76a85efea1c56ae12d68743a87e4fae0fc267959f2c95f30e0bdf40ea454ccbec5266f9b467602187302b23a4f36d41fa7ee993fcbc3bb417c80f34876ea6015c6fe3ec6e7699897c58cea6a70fb2bb1be1fbb14a5e3081203be17d4a4b6c02e288f9166695b444a41b2f79a5c07ef7301d010c2245638a7aa978a154bc535c4348ee9e3616d5452144af46aacd35e949dd0a4fb2c92d348361b3250e81340c4cde52996c81becbb595d2aec579a879b445ffec3d1ac9f6d86aa27df0b320797f9ec43dce596c65bf012ae985b8c4046a3adedc1329f59b98a62524d184fdb6101c6e428d6dee2adb9b14a466db5fff4581fc3c4bcc50130d95009a476104c388c67e8f1916c0ecc3fac9118685c849a4cd53218c50bfffc7fb48f470cecd40b1298b97ca1520e62b3b9363a17360fbf035825446e7e0675b129ebb5342c7c3d61db2a55e4620c63d52dbb3ed9d4e5106d0ba563c05e43a2a293613b5cb77cc615cabe4e8856b9b62bbe40cd2681c9fa8bb9bc20133b477742ebd8c256fc78d9f95abc6e739e146910229fc15d6b15fc2d5fe55fdcdce16dacfe88c1c59962622e0d935bd87b42a62befadb099f3a3f63aca447fca37054da6d532490130626654fb2173425e9605e4d16d9c547371ec5e930284ebbad70ce7802aeb665ef8fb8eb3e52244b948c5d23d1d4d7e7bcf8f791a53fa748d7b9362a4aa92e5f5a0f819ff38451b70528cab9e0d1e0b5f96b8caca2ebf8a4df06f0c9b5635a765e7490514c03d42381b954a0be61c5524be3c8f26ee7d3d58b91b2aaa55611caa5a0a8c71bcfbd01162da1c5c41617c74ace4493bc8eccf6e056f6e57a5f914795901838e183a3376141cdeb167ee29040abf908339f9ad6568bd909b7ce00e5f82bd98cbde88f8d2828fa81cf8c775a4e27eb7dc21efa0e637c1ebbb0e4bdfdf3cb37a878b9cd6f8e129d87fa58d6398ab7d9cb3e758be9aeae16c7fbe623b3a052db93ec67a2c022afd3801bc4401f5f0171457110da02d3a9d06433b5d328c2780d67274ea396028b17e2bfebeae51d4f282ffb97ff3ff9ad04a72ecf1cf50fe720bd2749baae9923da31c06e8ab98d9c15c22c84a0584fa7c56e62066dd96451b81858f0422edaf0dca29e62d05bff54d8f94ccdd0ed67b28b50a62f35ec2712c5f58ed38fafe2ddb34b4fe78b3a6196902441ac6bc04ecc02ea6be7bae2fbf47c7e424aea167dfaedf6736b81edc05d25e5f18852ba5e1dcb4fccc34f4a2c461d1294de061b5ec2a9c9794d8f71ea997e5435c084ae6a2439b7018f99bedef9bb36b636e4773ef13a56a2816ae14308b36918e8a64e822efdeb0b5e93985115f66f79b3d9a3858242375103887eae7dfe7affa1502eb48ff2f7cf2a9ec6b7b33955fef31524f47c40a562616a81224dcb9e9e79b3939d513aa42b7b27dc7f2d6687c92588438c87d15a80faf0bdbe34204e1a21d18c0d3a211e5f58a58622d5f4e97b13295ec48da55f518098003d13b393896f6acfece6b7fa35f76bd4adcae37de0407e41a7a9cd7179fd3864caa25eda469007bf756a68362bc6b2d543bd1446cd6cd87c12c363e8d464b59705d2eee037864e73342d0cba5e1b6361556f4b7df4c249c371984e485f59c4871d5420753b0d68e11fb496762bf1a35081b774dc4523bc9ebf5aabc216bc62b412d4be4fff8b87fbf630889e58557a01f6f781238e3523581cd30cc2ff182c074cbe1e7110bab9a41f03fd46667c1a2069a60259affd2bccafe0524ab49ee04aabf11e605b7722d12dbb8912a75939a4c36242284ad3ea01265065c4a1a8dc68da1672e83550fb826d31c8079ae985febd55ed4a28ce1c352d3d75bbb656d50eda711f6bbc337db3801d11ea71e62a3cabddc37e6e9afd969043c9da173fe40918d4ad5f589cb90957cdf84acf8d7c5696d767be951e8904c59d50fbde9084eb3db0584c1304ef3345f980b08d2a4cbf80abc202843ee30e0cff03789f37a7806c2a076a5634bb9d5e3a20544469f374b0ae785ec0657c4968e36d4bce8afb7d6c842578768756ca9fe4dc4b0d0e939b46e1dcb66fff811cd9d649741001da6d7e42be5122b77707355a2b0347d5b0b7cc8b85d2546d9d322604f7f86019d3bb450084abaf1648bdb9c6f72d9cbafee49011d05cdbe617b9e2cab8ec63f7d97427e2ef477fd11022c9436ac915262d123a2b9de4e97b76004b73930134abdb000a0bec85f3e5010a4570120289deedea52969219cfcc8033d94512bd0c51e7ae9fd81be585a05338469b431dbc300f13d18025c6fdbb9ec49ed64da7e3233c9c46df4f4b18a7ec24c2e3159664731e1ad2ce234ec37ba567016a709b498c1d80b402dfb4c4e8ffaba754cc286074fd7ec27ac85f8b641200f24f5380f773252bd0053c3472cc2c12842574de28a60e4494a2103dce63fce5c2e5c0b1e78168041191bf98bfaaa207753327c0956b64483ed70841d64531507381110fb417be8f1efef83a04e4b3e928b420bc35b63ed29d5d63af6614d116f2d3957a48ce0688455e19a3835becff760b2ac13bd83d81747e3b2e5839ec4797f825c2be088551399698c6d82d9507957489809fc5921c17c2d969c48c4fb8314c97dea27e84c76c7ea94fd3c0989527ea7bbf40b21fa52d6767aa34e0bd161e1d97dbff38b827f210df6856bcb57fb4da87eece28c3634bec23c86e3bfa3d32e6280e8daac19ba536c1ee97565e399d46a5d8675343f1b8af2eb80fb520b4768c5411b2efd2df56b3f87d744d92b125204d9731cf75dc60c8c2fd03a5215b81ab6c70ae1ed47ed1e098320ac1fa293c7e1a99c38bc529125e755b8e67129161997abf4f716d9bea0cc9544d3edac0f1f3e5cd34ab9447c911651821d4f59f83c993537885b2b61f0396e147d0ed9ef781e82f40a524d2a91d1ca0ade15e9714a5b5a5fee1c143bc0f0cd84370d0d5c7b3246526e8907b8692ccbcfae7176bf17da207a2a325974d04a65508bef8e289988f89ce9887e2d9476e6a8798ee8e80b2f3e54e9052dae45a8ade6c7ea28371f37bf3fb45e9a800552cfa0cb74cfdf463f0479f45cff773358bf34a2ac756976496481aa614b69bfa2998a8652fa96643fda91e57e7144898622f7e5e0a4e84d8bafe46738ab16f7bb97d066cbe820a0b5dff400240f0b7df06c2e096234464e7cdd84a44e12905f1698f99fd795b1d3152dbe55f3d46a62b8f26e707e078f81858257a0819259110556f95d440627ba4deea7cd092d9b79fb8786370110494b43027ca19e96a495f24cc58a9f6bb25d101383221154cb795ea98a072a812e2d4f606ee590419ae46ea574cee86a077ec5017baf6edc0071055a5672ac161e697ddc258b7c1076b21ed2396d32032be428610134c5d40e9b95f02d5370076005aee7a251d6e18eac8f47b0deecaaa0809c18c522e89868e7e5c5c1f062d54ee0af4f89c8f99c1b524a317dc9f401aad93830503b81c859255d0ec32276b803ca39742f4119e55f9c2a35c02d4f2e82b1ee1490d3383787cfd219feeb057e1d6acf43fddd3c47ef17d93f25f171871d44f4c88b2cd8d91308d9663663d3a26dcee8b76e9bca84e5ad797a6ccdb245e27bafc06549dba89d1289c87954c9c0e8dcbe6d26bcc6a7779508ec72185d48f05dd52c15efdecd6c3715bd3a9a6233a22b810ef4617a086ebfc517add625e85df3954c457a10529c9773236027c9abd0d300f8888bdd8b7376e070747cd38c72dca9a3d343dbf962aba572e22781e1d11fd48dc7234d875d8bf898c02ef315d07ea48d983455a67bd65d96541ff8f2a5418e1c1e6e9886b2b02ce58b182682c66286d17500b5511b10b91eed19f1dda60828b21c81e410735eab492899899cece6a95f165e4cc47f7d9e96165a18b3abe87444384663d35f2012da0c34719a574ba4c0dd0e54960e47459051e5c1ec45da111c469af2001ac4a9e43f3b4389c828ef9bd4e14fea51fb74e3d43f0ab1664f81aafef4fdc257c863690bfa5b77c4f7594a6bb8b9c1d3a73d283c79debedf25052ef8b1363c8b8923f940990c6ac276d786cf07c168f517f7bdef4555b6599a0697a1ea51a79949419c3686db74730bef6e49f27e8e6a78c80bd9afd848061b0397593ec4e17a7f2a459b2fc4c8f6ce77420ec762ab1049e4c57cc2bea647a6ba155f8038ec337bdeb8dfcc04ba3f2726a0be272b44e1985722553ecebd171b0d8984a84f58511d63aa6d9599298cbcb98e52aa1354bbab83886f5eec6ec305f14db76e0ffd186ebc39066f7daeff9950c86134afb05432917822ca655476495e60a114ff7b8e75ac9a77b7631a56099bced5339232645ffdd14c331f704cbc2dc46490c42fec32cc3c4b6898a59e75e9b8213c53f475cf3444682f1a2c9a7efe97db121439405dd3806255f20b226202fd7e1dcfa57c82881f5ea9ac51eb2e4d84ee77350f05265b4a0335ad097185f1ab676edb4263c3a13d214d2cd39673d76425afc3ecb1e88fd460fc3f925850851547f51413f3c602f3c97a5f3b44e32310a2a0ddf1a2468b79ec9c1f7bd68740a56bd7b241c4fec88119434c73b1838ee8cba5971a941a0103cf0a7af83e75a06748500b5168cb47762206fee1222d083bfd0a9a336fd8bd52a4d6607d518b198bec18abc0295c3bfab7e2daed547b6219c99c27281c261ac3d3a104ddc5e3f3f90fa20739e3318d99b2176d40db601e62e882a18db0763b266c64c3b2b72b83820736a4aef7ab7b104635a26e646566db9092a1e6d646761f25989a86bbb3c087c1a1a7a182c14aec92fea602f1535e16c39bd79ffa81f66846d7bff4b42db7d2539ef48d0fcdd693aa84ada70d9c845cf4d6721bbc297c1240e5493a443a4a7f28aa2eaf9585a894bdc869578efd75acb6805dc1f9fe9d0e48e66faa460657f27a381d83e3f9c816ccb9bc7ffce213fb66e629d46587aa5df102655699a6e9a41d7d89b6b4c95b0f9675b3fce4fc0c7e9e06d346834ca7b8d0ae5b7b7af691ba8757b8dfdec39c40ff3baacc98117d1dad472e5ba3184edcc8b6317e718a7616a9f6437e884f22368192cc3bb29da1bcdd6ec7de85d79817731b6fad67ea596a72e6134d3a0fdb2aab47dae3b84fb197f8353adb5acdec687cb610878a2330f9783fc79b0a8ba957fd73a57cbee99ef6e25cf91937bacff0dc08c639ece155bc7be6a9210c0127d97e0e24fa5c6b723f5931128637aa21173eaeec80c21446cea2f6364d6986a3615e5cb198dfbc5857f2c5b62bfbffc4d00f583ff9f358c964114bca0233e0b0d6cb6775917e8f2e16aae8b1e24dd009b0e890fbb213f5fccd79dfa7bdbd00db3ea159c3abc31a98d317b50367fd5254ec9d2d48757ed3970a29fc0352dabacb7603d4faa87c8a46a1ee09592684ecdefb9a423406d5136f830d5be2cc04a59c93f7a1bd4ffaa1c4a3e3096ab48137bc49ea78c8ffbe59eca670425c8e69c214d85502c0c82e435a60a65d5fdb73c8c76ced595164ea65c055244d9a3cef235391730b8bef7d7ec7eaff24520bdfcf3f55fc8898d2ae16a7e8c37929d542ab5d2310ef2b8b2e2680b71ea153d6ba4e82a367b9c9e51b952701b50ebbba5dc4c238b319039aafe91341e8ad06992acaea458a19f009818e5b00592b5d92002f90a024542400732aeecd3f3eccc5775e5287ff3fa7c040a415dcf14df25694c8900b424cdbdafd732b6f71794815dbcb5706fd1b044638a696de35315d166f18349c1e8d696253d71346009503ec0c9cc9661cbf9001112bedd250a129e2117605611f4b492e30692adad60476d715929e44d628ee8c4d82e654ea24f392c4e70cec7462ee9072bd030ec349171c74280295212c3220a1bfe732b7b8f8c746d582f3cd7134979fae06a6dde44d9b6f65fad66254fabd0b087b27e702f6fc31d5c4b96e8a4a421aaeaa6daef9343c81e96b1ca80aa62c3f81298d5dc55a5735889aa90eb8f011e663ebcf2900976e9ac4598ec2cb40ab3a150464a0784db26200356b548271f2849522eaeb62ac8e540922fdf0859d31990246c0d512200d7c1c5cb6b18efcbd9ed4455768bab2da787887e7a2fe53d3a48cc7e762b67360ae58a3427503b6e0301459e3daec81e34d02ccb11b7b3a136d5cec4ad011a3dd3dc391ac2180111100e6f1d4f01f3b44f07763880829c73eb7514c3bc5408b02d68b87ac5bce28e20e12d83cc4bbd1427b88a9bde202d4da57cca4422310ef53ec56826d0e96affe4e3c981bbfdc86b5a1852fe5fa7bfe53d21f29e86c9f711396f0deb234f2032ba99b5d70e68ae6d7d1220a55ae461c083423e77468110868bc35e430a39c443e9df5e1b77b4bed319cb52874c377a8b7081dce18bc197aaa913b3cbb01240247fda8ae00755675b12fffa0083d9eed96de8283b34bb5ee9a4d335300a950693ad98b6562a45bd2eeef5cdde3b4f9925ef6d545d23ce1ed70634c9c55ffa93a2098acec9a687b9ee6099439df59d3de3cd99e6d34ac157ec4e9841664cd8eb4c1c813f710e4c2d6edc6fe03bcae3c996d620e65798f7c7e72e445c3e7ef79cb953bb2a107e75a6c92c362cb57b217fb77b6d1af3dbca27f3c0b0fbeff990df5c32401e5040fed0c6857aaf895a118900e565b52947371e4fc0647b032c58486e2b177518716ed1f4788aad1277691490597d83a0943ebedb4ff6bec961783cd7a3ec6da424d7aae60fe5798a3a4fe7396b6687461ccbbe89cc524a782325c7dac8ee72f2c60caa46c2b5f11d69c95f29bfd0aa8e6102ddd5680bdfd4c4b080db6a4477904726e43a7e6855dc51bc7d19db0826e5fb4ef9af1619215101838e2d9ed8a701deb9dd9e58876d77d78a370f10689c82ff75743f416d98adfc74a4bcbe447f60542189aeaf5719f6b7d4b9c33c13667e23f093df49506566a4a54559f35478355b21f49d2687cd8ff90c8fbfcda90a70baf8f9af5ac0a23f6ebf57f1701b5071610f0451596663f4a3d002010dc2aaceaf06efd1c4b4ae09b1da55a65a5585e81cc44c39f4551c24e8f2e613425d9f4257d8b5a7b7ef49b58b03c26665ef0f1f1e96e5fe56a30a8a47c2fb31554b7551cd2a4af8f58ae6d6e6bdb14f8bba5489634313317fc4904d621d3ae2833a6d49f70c102ab16079fadf7fad5ef565e74ed47ff7fb84cdd5842dac04644ed29c098217cee5ae0fa82ede2f00ff2ef490beaf06e416c3df53b62485234cc52598643070254bbc6fe8c214e078f17da62100f605776f9d38aecdbc96b3257a1c33ec8ad4a92ede67dddfb1371f6012cb2a88cfe810c87251b4c5ed1a572119b56e714594ee5df8accceaa8f9609b859c3077d47f7a83fd9396684a6b4dcaa95c9b95ef8ff6f5747445064ee472c16b09b93a804b89a4b678ae0daecee52c9c9c1f927ebad1adccf132c9906bf16cb55ce073afdc28a42ac59350ab96281644923fb362190a9b9682d2b6febb0521c32f1a1a21e7534f28fe1b1e0518d02dfdcab0d9a3a7a86f536e6ed11f065fb37127e463fb58cb25858ecf34676d9d448f10913712ebb7fdb1664a07f48ab850cbfe7fab9d5b294446dbcf8a56455f9b5b68acec1c3b849d9f8dcb15d9ffd519d9996fd47cf2444a358a4a358f7c8804d6c662df300d15a0853d195120494d439b29cb9377ed943787324f8cce8497d19cea771ab6e3978373e4492d7e50c8abc6a79da26b0479c2ec4036b7517c98da670f5d13d18f918d67116137b5d47a0ad13c4ba4cf3d01227089740ae7246b8b31dc7ac23e6681037188cd20b216cfae729e6ff388f102cc8ea63ba3d612fe336fcad7a49f7173464b19a041af5a78c11c75a41070df4c6ddb1682d5fd11013149b6e1f154923c18f6aa607fa356ba9509c030b15c90f76f37be498d2c848a3c055172946261b58f3a5bb2c908b186a8354866914975024c9b1b80f51ee2944072b252c5c80457764c99c705f2931d0a249a4530e6d0d7f0e7bf5d9ce73c0996d39a91f44b75c9e8db2ac796940eb0db93238c35063f18eea6ac919a248b9f2f0c4d264b0f6cedfdb0a06b9e8d839bd888d809d508d80f344adf938a409416d1653b3b97a6b1fd2befc427c46338a3783075b247377a11a83616e9b5330b6d7ab6d7b23e2282062719b3571abafdf568918d75f22a1a91e5b8823efb904494a5c9c72b5338c6d2dc7f4760321639b985cf5e7d7828cf51e251fc9a798798487749f246ce7deba4423ee3c2096d10db66004f956d1f2ced18eb02c58332fd39dd22e409b9bc929ff3c20a7c34e355bf7fb083425f8b9f072362c31f5be6bb1d2bdbce914889a77dc0771263337b526cd0eb4cc95dbbfe8cb785654e432d4ade6346a414fc6d78eb3ab067d5e2e9bc005f8f753a6bb6c1b98854f5aa310587497fb5d8ac0c8970a6702cc23a8934beba08f5de1d21917101d2834b7d69e94e66aae5a3f913bec9828f61416bfa75164dda8edccb363469aff5db54b43155df8790a","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
