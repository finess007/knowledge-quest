<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dfa0422df4c4e1f7f9c03e479f5c38cc2ff2957f60a0ad975804d612d7279905706b841f38ede6ae8570f494dd604df22ae6a52df201387e7a676852f1c518b58348ce3638339cda5fad1be80c9b535586b12cd100585bb6db73a6ef5d05236eb9bbf317d00b17019633e2394635732419a004cbe75f8b561980af173d03896bf976369f4cda2615b76d4367639a9abf7b51357abf9843ecf7f060dffe804b10e70ccb260bc124021716c084d1323c554ee3429031a57b5fedb94ea0ce45979194d16590b7589ac0f38c7d8cd52dfeae63743215c5e65867540d2217a98fdd50e40510fc879518e1cc82e8d528a7e70d114a4ea76a0f263de347283f95b533e890d836cdd76b918f7c97d681361db5454eaa93218f8db2753e690e07bed11ea6f5094d09a855e95040855bc6c7a0e3b6ecf4d4cc02ae48d6fdff65516e4dc95f919cd16e377fe3e6bbd18a2930efd15da89d0b91ebd3675913f13c82757d06a903bf42983bbefcacf74506e62359a762d290af4adfccb404178fa0fae1d19e7d6e10462eff90e7c2fe1533c97cb60aaecfc1a2df780920bb03a53c8aef8c9c862c0044b5f9491f68ffde1ce6846f83384b858181dafc122792ef2a025e35fdb533209be75763ed91ebd7d35ad3c9a7c3e51ddd6c86138ffc5ca320c6a670fbc24f9eac2473920c6dcabc075ef330b56010ca66b27f891ca15e70c2f6c40b698b59de0680ea9e4d0700853114193e749270ba0ea0b766daf39d42c3fa3a2230b6f8831abd6b271fc018aed505a4e5a8338c61ffe791dbd9245f52cce488ceb8a78d12b9be93f2bed94a1f1a070ca08857c64c4efc20c3b094d91930659784d471d59a3cbfff66d1c9a7d5e5acd84bf3015d4e6d75361723ed9f166a7254e7c45dc3e1bf8dbcc83b1cde553bbcd98456972a5dc6b7228d9358e37b55ebdec2e83f971f63ba9236ed4920690bacefaaaf1b8780cd805596f3abffd53c481b48427f74d27e39accebffede3c01ff3f1fc1d879e7e40a32392af4e52206268d587e564cb1e5c30cb8495a9e8ee71500b34dcb2c763da9c20436340ce63b34ed5e28d3692b078b937fd1321d07507730b42f965c1044c8fe1d3eebe030c3916fcfdc3730fdde081039fa8b4b9a90ab657983b00aa7d9e71cd8b0e4674ca0e2d2e066a4c2b39630f7d1d00264eb854f5bfd127cf9fd687fb53d52e8a113e669d489031632b068c7b2784730f5ad5df9011bfc236532814a52e45c3819cf7b2faecc70541c975c3c99ee604293caed92c62fcdf20e98f162951bc40b8d792b8dc3c344bda2a92806abd711734b2bb3a54806b7e3d30bfdc151fd325705ad6a0f9d59d50bc97fb38c990e13ed845f0d2425692c62ecfa3e56752c4b7fed083900ca46819ffd10a3321dc092606d138b0dc4da3178f70464146cf05bf88066871e146149835547ec7cf237f14dab54362f5fdc143f125bd6d3d32dbd7ac4f352c14ab45a9e8ee036aa50a68b5621de466d28bc5368e656725e16c3ec825bc741ab85b5f37cb6a67e867a58fac5e48303560e1273f90ffa23d0afca674fcc59d2cc7ab68310c0c4e094a6f86d918dc006ee4bd8c2f1238acfd0295789c15df1bb652ea449b27a657666650f5e2628ccdd4ab02466ab9f45d9b078e50cd39e10afe86ed77847875ab0d1d73a05d59ea4a629666a21bf5037e0961ad5f52e0670ed75016faa1edb5dd94b5ee6275d3aacc2ece39779898c380d3d6c53cde8d372e3ef7307de1ac093588acc92da7b540935bdc888814cfacd502dfb92ce1fc92fd3f2b24e959519f6c627b23fd6f3bc558a8292576802210d1ac5631469b79def2a6f4087e0b56f0fad57c9bf8302923148496ab7a3db06e686421c40bb1c2d593ba8b7511d1a79db3eff35f47d82d644c2fb2e0e35609759f20b10e415cbcd7c9fbf65e5a1016cfdc3beb43379ab93ebe68bd893b3920bbf174550e5c53d9bc1d009e37934dd6b0497cdae1689e5cab48bed5bf6686bb274e01bd06cc30e014c86ed49dd85e04c9d524cdac85e5fff147e8be256f9617bc1aab90a73857a67be102809c00055fbd541f777e9be7ef0b4cc335fc2064b08e6693a83e16b523e8091f28f2549ab16347d81ce6b69a8235e1c664b69d6c5d20af385957bdf2df95d6750d0616e77f56ec47cbfa37318e5188cbeda6619acdf3d24f5f2ee55a98b47b334eda93a452f675953a8a43ea36eb66b4c961820a9bed870cba28ad86671fb8f6df4f8d197c7515fc5b0ee99c95f507e51d3478faf4f6b8cdfc13d9d530b19a43f2291ba8281c08bfb24c3674f546a8200357248b59fbfc49dc67bf290e799ec4413e4e7f81a4d67aff04d16b4aab159004237d2bca1a6b07f909715557e06ef4477f2c432d51dce8c1fb340c0be392e43a7e679f882b9a7ccff5739883ee3f90a74849853a2c49fe9afa912c392fdff35a832218cb74d56c3ef61ed443859eceff3e368dfe68119a148816b8b4def1408b932624e134ba908c3993ba1aa99942cada0e8dd8e845fcdf340abca571371e594cec022ca03574cabf63c697cd5c6f63ee4b51f7298a3f9ee6263943989e44fe020d6de1b6836891fe6a623f4503f7ef9546267312c4c290d16905d02e22274b30029fb3b2313f004fda20af114527496a84a9e627dba75bb86db31799062f175fd71f9ddce3dbaed2a4229513d7259aceae515dc5743ecf6a4a289dabae4358b896d5ea30afbc723c2d464f9791cd01f27ad264dbbdf9ce2fb3f92fe104aafb52ccafc8d275d3f56b234ce91bde3515054118bafa3aaca9f7b9d677e0417280298904f61859368f5483dee7e055338b95077cb0b9f82d6d70db30aab4711a81f766a70d9b0595800cf8a276b78745d711e033c3040bb61cf3b0444d155793f8f1fbf3ef361b92c0a7be4bf5357379b9b1c4cb3d4d6258891344ac8df569e284e49fc4200bdba581b71a6ac8fa4c834b63fc7b2c699aba0d43caa386ffb8494fae2cb1559c8978fc4a1aa87cf6b1b1f5d0c16b038edee44158fe136e0a00a0b41128b3d5b5c5a13be0356db6305c6aa3c25d5aefd71c2ef144f6916368d34681b07d2477e892e8b4d5a936f8dc82313f2a2db0b870caf8973c1a9b59a413a7164423d0b46e70980735f50c5283d27ae231869744229413382793f9eb0b7547bc643b99d3ce16133a6e6c74ea1540c9e9d776f1e9b02616df6b3984ebe886a9f7ad748bc6bf47b861575fdf8222dd04c8946ea4bed76c4994f2d57c24706c64475215c177e68c6a3305f98391b7666d04375591aeae9082d1451abaf4beb129ddf816d2732f4ab6691e9af2b9a39a8b60f9c28407c28a593e3ba92fcc9cd5e3cbc588c33064008c0e433183179ca90b65e5c022777c705d95cf4d3c990c32ff07c7df2a8a552903d6ed10d00c61385a118b9a208ea6d5a879cba424e85552c49f8f0a771963b7fa696af68d7ec7571aa0b235fe1a2c3ffe9687376f3e09062a471f364b3fd248f4edec65b1a0c5e9099654d8d1e07a990a754c23a412b285b1545fa372c22a2117c871b51d9e9cf7c90ff5324c33daf10ba3ffcf735fcad3204c0ee38d30f7b411580dd1f3944e637db9727996b79287225e41669f7de4ce01645b546a22376487445ffd3b5cb304ff30ffa98273e478ddde8f7d98ee785b505b4f42beb4156627407a4d48508bbb2d4d3fb61ab8abbc4f33f6be79ee87d281a085c0b99d9a39bb4c90d01c48e9e9da20387e7cd82e370c476828e23ec1ae88ebdc66529908f18215da329075f7cabe7acaea508fbedaddcce8ea51319881c4d7e088fe8671148f391f5d17d2f7b7dc42dde0165ae974c535f7c71ac9e9ffbde27d138a40f5275da29a5f7a86e40c28ea14e2efe2f2b03f12c79462425557e8388a840a09ab982f571c97298509b3f86155782f0cddf7c6981202c9846e8988c225f947b084eb5bf5921add6e7923234999789f77042da40d8fa083e3aaba3978a8468f409265a2d162374613cf0eb3b955d2f11da24009383a8bde77db0212096a57475104f9b3d7bfe4cc986d4090cdd1119ea665a101213447534bc70f0313fdcc3bb6c162e00074d286693248e6cf21320c7744467c8ffd8a2358797f7d97554f0d2137784472ac78fcd6e2ed379ea7824d6a3c5438c55b731016ce2781c54e3e8177df4ebad68b2a10d86d0b31468c32dcdb17d064a5e6740d90248b9558f3643526eaf79b6834aea7ef43ec3d0d7ad5406cb8a69e3de5ed2505916692a8b9bb7b3dde250d056fce0fe9abc4c41928428ee08e81ba59c3422104a68e0fa8b3cc668b3ae88baf6d4e841655138949e465a90067bf45701bf307a3754177dced810eec8ccdb6becfac37bcc3d4efd0e19498ae4a756d45fd0c997861decda45d5a914042d7de7cb3d3e7558291a619131bc085ad39979ebf5f3cf4d70c9eca6f02882aea827627e8921f3bc289c39f2f6e29872c8283638501a692c93daaf5e1c6a70c380af82aab790be002c9348d1618abf3a8bb2603383af817d4106db14b0bb668e06effef13207ab93eb234244cf793060e8d6ac2ee44989559c6ae2fb63e9191efb9f51e2a12ee7e7eb16b07fc37935f874352a234b5c1c3a3bfbc393d57db5cd6fbbf11c67ee5a3889c246d8d48827e0708f2d6f27f521013a72acde0b704bb298b78d4e169948f150dc72181064667510fffb7342d1735f4e20c468ccfaf2cf055b58e6f6a6b47e7372389cff498e1fbd8f3d2d193a5909528c506adc7cc92fa2d1a9789d133586e7b83cfe0e97f08e3084effac1a0a396e1b47d61872793539b436344f030af014300e110d0e4168fbeead85c9fd899c82c88bf58911828d518eb96c5b9f8273459ec2c98be0d8f0c55bb6a3412535a6f883c09894290e9567c144795d365a40731bc8a30809c2fcfaa71067053b43fa5b12e1c556100a816b0187390c34333243cc9597e9976c3642092392529705de451e67a44fb9a1625dead124d1c2f6a561b8e9dd3c0987d10e0ceba8c47d6c75c53097c3b2564421b3bfc33cce883852ef4f3f3cabf53f85609e4889ed0d6175aa0dc0d44c28a849b4ac8df000e680ed7e2494d85f791a2a0aef4a90003baf794a8d889cf072741877cd8d74118b719c38d48dfb69f5d8bbcffcd1fbbbd67218fa8b0ca6317053eed445a2c39fcd511d34c3527b6e8d6716c5caba66ba9e0ee1255162b5b491fa737b740919c3feee01cf91808f1b188f11c1a7020e6cbc0ec18ca5f85c4b90d71b1b69748fb0c7d4aa5ab93152dc4e8fb5c4ee2426eb99f21dbb71c9dfda1370d46846da383dbdea5144cd58277571113e891a72f896f3832a3a2c1a271e6d68f990d7bc926d1eedd25a6a3d06347fc5440a5e032f289de63dfb843a9f031bf7056dcebcd9dcb3d2195b47d084f0af47da5e7f5f29651dd42f5715a623d0f5a076c4edcd2662030e33482f29cf9ea63b196400ea1104fd18b46180b9a022c8d8b2d3d59b81c53acf7eb609a13b1a4e882dba7012592f72a120d21252cff9ee65b4e24ab30fb63fb332f494b86b3350670e1a80435a95c05850c05db551358fc27bd72d9cc0d04be4965373d9cb6e97296b3f04b949b724ed7c3be97afed800a65233b6dd3966058aadd5c3edb827884e48ad31b421e6851d557c7669037230fe7f10a3b676378395b0a1aa086a9b0ffa331cb14f8e3452c7ece49f5456cb715a33f8893afc4f6a489e4e8ad98926c83af522953b686ed952170cdfe5d281573566fa90678cb0c3f0535b86f68d653779910c81aca58b9a95d7707e99dad79e61d4b8a5542abdde9c95a4c176d243018904695e06c270edc7d256794da860aec45a8eb8305c1aa9d49ce7316ea99a7543fa385c3391009c1880bef8b3aa5eec06f5c6737b2db0fea5d1a0e238c9d03b48922ad5b130160f05587499d05f48013d1136898e7d43b74414907fcfe34f7a81fa0996720428976669c266c2bc2b11443e2df4bae1e8165bcc3caa09ba0cd8448d0019cffa5cf2fbd07e97dc088591eccc9e9181a4035305d64f8a5b0137fbefab6138cf463fdc98e23c0bdf7a9c92f81885153ca0a1c239f299e45c56da9ae31347f44f121a52081147fc19fa81d52adee067adc5d7a99dcdd6d16627df8e0b996bcc66afd78640351f9f104c98cb841030c40568aabac45dede3bae9ae12b9945cd9cba44e5c7541c17eccd8b37553d070a84a501ff3f5e5fc319ec770dd08f6f2e3d92ceb699da7e824c9a123a9ab830fe0ef38ec394ae7eec680fa2de97b965092090e9b13f0e17e7a74407bbd5a6cd5dae027a0b2658f3c38c66532e6a63013e2a461a6de658b35212f0ba6c7b14e32ec9b595119f06a137c1b32618dd1186d3acf4a9c55935faabce31f6a68a2e79669725eee7edcd782024bed295494c15e52e28c0585e58b6489bc68baad2af343660aa9c73a1754af2613e0bc4bd95cca5263643c5a89e9b00a409b024d3bc1eceb6307f187251bf361e7df4553b22d80dc00900ba77746de661aae84e7d45a3f047d2c72d84b804dc28725fa61ffe79262080c5be0a8c46c417470c131c3ba2ca64c8d0f63063d04c54d4abfa9d2126844a09494f2d817d9445ba0dc5e4269358dd11fd7ff63dfe7c6a4d9c203ecfc229a88d0ba26b7ad6c3d5bc16eae03172b75797fb51b23db44d6f4fa4d7fdb270f673d0b5c372cf4847b94617c20c05f5f7358914736918b98e0de003f82c165aeeaf6897e3f0a620f3c9c98402c26f19fc3741777a81047fd95ee00a5b5312f465cb8fc30df24409ec062f676a6ff841d1a2b45146f64e6eec1bc02007db9174d613c93616110b27857702811ec320c35d265a649a1fd319759f2cbb334e490b22656219740448b2f46e0cb1207e1ddcbc596f07e3cdd4ea38178723356a59e4df1b670e7941616f69c72d4f1e10e95f5e122e2b211d5db05b6cf6d729977d6b774df13e8955aa055e90dc9b6c1835f4f11eff46a32df5657c8914ddc39ee4a35f174243fff2f2f45cea8fd7531a87da3e6c9752e9c38ff77632806b036affd6f6bff88d061dc40e08b8ea1196064ee78d12b7b3bfff518f96a7958209e6496190f700870f81ccb0a7df122bb7ab7ab55cfb5bacde77bd15c6af1a53765c8d4ef9f0654ab408312b7dedd79c36bf6d740211a2bdb5773b2cc92a03ad05e0bc933ff8f0e2f82f90e19befc061427bed5284e0708c87cf6fd5fffa500e81ed933b596437081720f126902a5fddd9dfdfdf55c22ef5cf74413ede969e6218a77c2a31bd954fcc8f20b9321d0643176d6fabc5854215d2293a4230789838c9976bd52d752cf399e6462444ca1241e3e42934026f9424754bca757913b675ad96c6928307fd72e7a018102672da04d96cb48ec3a9333415f560c0a954312f887c5a575e3200d4e8fb3ca4398a6e9dd11362d73f210d33e9f669007ca8b8df314fec07eb9bc7fbd2e5d70a37c01e49ac446e2115c34eca2956ed424b936a9bf17a8b57760e575c7bab87c501b6cfc794bc0b931b1afa203b6df348838d7311fcdc114849370db8f501cbc56716b40cc29b71e99e785f970a839fd58c5991580d82d9b1614d550e07d580db740d814674346093b2730cb744f10718b63be9dcf9518e88615212063f50b5ba8a339a851e362a6449f3addaf448affb9d55f82259714a5cccbe36e349c740530df044845b54abc44feee116d58e6611f8f1b392a5c905482d94410054f1ea67d0ec3bed8967a50f9efb4fcc2d451bd44fd509129139a489fbb466baa50dda95cf66aebf6002c180a859af2d94ff243b08be0524499f46bed02eed6212bf1b875f5a379f08f762bf4c988caa3642cd2f01d3d58ce2d97b147035d123be609af26a8ba52ba8c10cd8a7de6d464f9f8277c8fb4881381289fa568a1adbc16b290b8538805654cb02a23c480a9b05a3d6b4064aa1f5a4703edfd5d90be68771c4b8b5919e82cb29e32f1d32f2a91f9d8654b4cc59eac4b9d7e813ca993a3a2e4e2a77b76737c50acb1a406c1a90a2e16cb68ad35b63d3391b3dc95e2a2619502179b0ead1369c0895970d432be1a861ac3ea07fe0f4895ed16e2cfee97cf21101430ba17ca2af08a23dd09709106362d67473d61c7ea01601213e0211077a86e44c1cbf1b95c3a51f91c5252e57a79776a79f8554534b1dfcc353265ecfc34b97a434827a10f8ad67511b9f3d684d14001f605fefc39d429665d483aa6148bed130f0eae0ba391d9d2dc64d5ec3ef673aaac5e64afa3c223773c5e7358b9c9da2ff5412f4cc2826b82125eb002d6e79fc53a4adce1178fad08370cff9d5f357c7b7bdc967161be86b84dbda3e43896d32a4df6844a5768b4bac22294247da42ae0e10c07185a3f1ee14eb0238cd260a3df3e512aafe75832547cdf7b218851b5e90a0bdfe6c7efeea04931c16e2d43581889ea27cbea0749add0dc960a59b94306281ce1b048f7b5d838fbfc3636f10e128e2d8e40d7edbd50f42ed9d050360b82fa7b398753ba8624e27fd77c8bdc64ebb65c583ec37dd3a4cce1f00a1d3417ce3df8f920c96e3b63f52ceec8f92a5c2a2e274d90334791d4e41031a9eb9cce1453af76a5497a59024ff3b3bbdaf4bdae3ca8f36d90cc65b19a57325c7402599a8337e80a4e25007754abd83ced0026ae0b9513215f6fc65184616e282c275d7025313490e538bb41d741f982fe7fe20cf4ec61602ece97aecf59e7bcaffc0b4b2b7019898c610cf7111c8ca0405e052d6c01bd19839bfd3e6b6e7094abc5d2cd0d9645b44734fea7fb46f6e261be8e099dff5bcd201d13cfbca19049369415aa2706a865a4c0b3e01027fa306ed25ba353f013260d985ac336e587ff8a4455bb28be7dff8182ed54bacfdd981c2ee16d3dd7ae8169ec5f7020b371ee1d858b0ad6048a449ef412c79c9642b23620d0dd1f67840c001dc558cfd86a7403556773bdaab18b24234ed9534e1bcaa5936b5c30fc0e76ed7cb932c6eb3e139d35b747b21ddccc27abe3ac9ba19eb0b3a1e15fbc84d5a360073e8e80138a45dc64f442c48a3e5a44cf3e742664a93d209e019c241db9500a4f6966b97303c5afea1545c5f0de6c6105df08e18c53b2bec8e4fc880cd09f351671695882926623eb7d7b3092e1a868ea010cfb1b94a657b82d90d0e2ae3db48bd5aa37241ee2e050416af6fe72a1210016f71b25a3c2f6f815394be65d50a8d6cfd0fa6f157cfa20296781937ad016148cbc4c77480376e0c296f1de1924119155935109d5918e1832ae9084a8745a08e70321b62f67f043ebed68da056d0a37c0760742b923e875175fa35da82e1acb9b72ec205a589a04f44c59cbe2ed41020548409494bf3b8cdad0bd0fcbac447110682e5ffe74686e0dbf57dbfdfb1051dd352b22f4cfce3421f05e82f9e89f599645c4dc515f6d17a53f2eb2b005fae39e838fb9781ba8cff6257b25e21dc4ae0d176f3d4c44c21eea4c6d36e4cc172ebfc069e58c04464f5b460611577a1033b1f0b57555558cd145b5f9edd3ab04f99e5cae5e8d09fc00f047a09d8ee65b1130a586114943fe31063c64cee241dda4c1e6c54644b3d7ae67916a597be64e34a9bf1d19efef9e2eead2ee8ca791e5b94b28a59e455fd53f114fcaa53cdbf078a965bde17821ec960f3b302bd60d2506e4cecb18dcbca40321fbb0e42544353906df7116029eee2f9fe48308aaa7a4669665ed08815f20796b799af8f1e5641cba6d4cbc7c80307d30ab89dddc478f00cf22c30ff2c46ec4a3e29734dadca21a26df7cd10430d5cca0c9952b0c8797d78718ddfd9fa88bd1c76c90db1c755d760b41951bb458a4a9e3b02a0b81d70a24ef0b6820cf712c658d0ca8876489731d00efb374e7d55b785ab5ffcca0b995fa69118faa09cad45b52c7338708e799a526a80dd4e0ee95b2ccf4ef471a2dbf8e8e27a9238146ecc1c9702b221d3e120ae12115e4c49dfd76d217d4d6769bb9aa13f3e23b9fa93622aeedd11a65d0926ebcb58f4a0cce040ed0717fd97f588ef721f11f090de6188907f9f6de87054b0722e68ab248b94474501635e76c8d19aa8b5c10b7f8557c023302885e291ddd33fa43f7bf43411d7d4b14fa3c3ab2d4bddf44a2b29db2c0614ed24c67ae12995fc71b3115b99b3da79195a61e781c7416cbb360cc4e0472bf6eb94e2c8b27016c052a13c6b2410ff0d96bbd34957bbfe32cb4dc33af56d8ee0c1f4edf9dfd23b793775c528c065ff427e94999a8c71c788dd8ada9081c9bafe4dffc611827722b49ca98f4b9d8d71ab7c0a80fd9e92bdbed3c621945decf09c764d2b98132f8084a727b2b50f874b2f2b1b481f2014a4d20ea035c7ca98736f237aa59cd1e6330b2f4da5aaa2d4ce009aa3f298dc98d1b7ebe6c3e72927af94ac0aba5712d1f65a5a6930cf092f64b96ba7b3c86de91f0c670e37c50e22e042f9db4e3c73fbe7c59173695561b0c591dfa56700eaaae64550257452583fb344a25260c4ac7e39e73b482f060ff10139dcca871ffefd18b492e1c7519810ac625efc44ad97322f186dd137ae11ad329ae4df8ce7f3510cc206ccd4602eb815033e615744a07c60ad0c9c933c49b0ef4f028496034e2fc1c7fab565749f77934f4f91d7f22b34a4101071476c717c70e15bf0f826f3b3cb9a6fcac0cb7933b940fb7f3d1a063117bda93115a0b99c6c826b852219c7ba7466aeb0cc38d643d9dda755c836b717f28544cc494d968ef5a012941fcd583dbf94877862562dc53ff8c0b0c079811e2d990c7cffefa9f54584b894c60978fa1a96e3d2bb437fb1e4e29574ee5c950d12c958e6d8bd5cbeddc09c1c16a100cb21464e92822924bddec671382e8b0b5fe8c8a9a8856e365bf94b74aa8c98b0076974467dcd01d76e763a9998fbee5b5f3074373e0a9481cf270ac7ca9df95d8ba26620c5700b5e19ce101907e6024f22b1001dbb8027726d0c00b2dc2c169d44b75ab596fe2e2d3fbe859b678aecb4292781fc9b9aa0f8440099b4324e71ffb29f3246a47366e70ec7e9bdf5b44549411bf3d3ae790b82f2e87c98f1a000a174f1158b91b2a2510e36ea7413106dd10931e672c4948786c9a1fb19b12c03d5a0210cedfadbda3837aabcf70417fc782ffd9acd97920cc8a7edfd66ab9cf07e7f9d299de47b32fd38b961de2ac09897c32ac59161cb28e4d4d452593255824056acc8de58a6ba2918e04455733524224e45ee0bfed3c84c9bd404eab9a66407e37c83fd354dc2e33913a9c157bef905333dc5d165edcf47b54a5400844d3f63f2e90c661ffe265bbdf1f6b958a3ba47a7baa08a485f2ebaaf44bf1011973a4581476c24e67c3281ef941043bf4b7a3be32e950deb131bc027ec8fd26977e00cb7f8e8fac134fe78f55180068f980fc7fa95e37ecd7b232bb25adcee7b90008802d0eccb1013aad8dd4f77cb82219d2fd20ab7ce4f84605e985e48182118b4a377552046f064f80cf65e064aefd1f1eff2c043b3aee2306bbffbff50ac1aaed3dc032294d55b92603933eabab70e4ff650711bcd7b24eb8ec63df702b66b592a508fb16e989d45614dc4bf19eddaae224a33866e8084bf2d362a1fc43b17219b40ae457fc5250aea89b94dca80f6784e3c174c6c35369cd7c1e60d60f01c3070d33d1d9810a18884486f07662e2b6a71f704dcfedc4a2ba75d2cf2f53b298a787d51c988514535af04a4ea7bdfdda6d20d2ea2941ab872f9939b41682e3b85ea7dfbb0378d831700dde402a08ff31cc431e58c92ada89fb29396b42cb3147b232b2eabfbfe4b9a7cd989bc6e52a315addff17a0709c59e122b23b31dd4d74d474d33e0fecc41735fbe4819c55cfd0e3f3b18729c1ca94e0196f376c1086d113d13bb02cd226fb6d9b899e07b5207b82aff997250df745a52d68decfddf87b68a131142b5d16496ff69755e9224e15b29ccb8d89b9e745a6216ce254ceb76bf051c5b5583597368b91b457f8b48bb7f575598730955eda5f79253cc793dc7cac5177f49515fd2f2981e3aa8b7307b45d7cf82c2eabaeeb1ca8a697c8a0d8532e78609205bec0144437cf9ee8d3bdd10ff4b6cba5bc16831151042c21418329dcd16efb1f5499d0b55888a3d279dc2720f640bd1c92806ab0b9b0f169f0e9b309f35a41ad8910f55d6fbc3932c6e40c85b11dee81ac457d2ac6f81fb576a827a6ab93ca8de403122db0ea7b4c89a10d7f7136c2060796e877d54204da8dcdc760326d7e63ae210d7f0d3a249c9b911e9926f247e0f20cacf359458a4a6e10398b1dd9bce06ceaecb5c16bf6b2d03aee4daebba53ea6717bdbb510a75e8b6a918a73580b38694d443f5c41a3fb4927e8ee7d87cd824a88f123cc37b5cbc9d1ba5e09d35535243af32e0f568ec8904b84d00af40caa1bfb506ee8e7c549b066a7b44b48e28b610301d1b576d1b5cadc5afe6542a2f6bdb8114082b057defbf07eb02fe1071014fa9fa598326fcc17bdc4b0a211bfd7038cbd7880a433d8f5a605e942256f4c9f5c706d650513227adf4776de9eef0a7223eb209d2c14b979383ab4a1addfa1ebb6d833d02425a87b00081ad818ffded729501b0f2f185ae814b3929b2c68606e212de9d2fca0c8da9da96f449884ae4d35aa513155c1080b9091a617fc3283eb0ce69c784498a7c06f8b4814dcf2378fcac042748d3acfc8d4e98d9c63fb605726cf38b83e6fa71583e225e1f34bbcf2f1ab470705baf46be383d9e37d1be9ccec7a816fb515dc8757b4d26895a5fe639b745b00643c632d20b1a332d6ac968de2f6a5f846ea1913787c65d801a0746d4748c5067901cdc999f329add80da21de24374e8b324f76b87efb591adf2758ffe3030a23657b6dd1b6030610f23bb21474edf4d094b0e2689aee845da8e00e6a7ae55003ccde4ffd444f23a0736b3fffc923db5296e79e040c47736a2fdca2d0f27ac475c7090ad56548a452671bdcad6b0102901e5922505c4ef03208a8392821eb9378d81bab93eb3b76ff4d206658079f9f4ba12e04ed23500d38804c3528a2e03e1eafddc9c956ab970d508c917d8a89a86a59085832d5174ab1826bfcddec7c15799a9d2bf069c2ab777754ccca18c4a201504f3264add169ec38fb3a08fc48c30570a4077b619942fb0d8b73f3a448a731b6f73e6a5b9b6afcb17b1a45385f7d7d4ebe651953e1e1f1702dcbac835944d9aecc490bb2e3a03aae65dde14a19344c87c4fb6b8ebcb6e7d65cd5a3bd996270c3a6ba75db5e964439de147398a19a70672f914cc607b28ea88d98635fa05f1aa255222885639440ed59ea3b9c912c59188c1ef299df029dcf44d2363010c2959cb770bb9b8e3f4d3003d550039d942e0cacc290a141015b4a5a64e1eb325457bb9d8acb45ec39985059cdc21a08d774e579cd2e217bc1b1aaabcbe36eb48e17061ea152113bbae4115c6272c75c30367f9c6e2dd90b88d4c54360c63c0e2eb5a9945f0be72b41a8a409237267afc65197eef7d86ef459705c996b622dc8f5ebf34be206749d3a4e0fe0cf343c6f4ef87b1dd68e3b4bdb17e4b426d2c43b87a8fd649be3298b7297f7ad5650bfe82eb3c96956e6f173caad6893681a3975070ce87ddef710f050381b41b394a5baf49a91f55caf6a4cce3abe038f3eeec971317d00b55375756c43b47d03fab0b00a675f6234a4fd642d43e3a189a2eaec155624ab52bba557d0d4924750dd61d90968bc9a962a56b370f9859f663191978078d69cf4087f220341b515ed2d7e9ace5dd0afd030e11af96dfcbe813cde3c07038b943898d6fece9c21da4f6e89310953a1c239e727cd047a4431c4b378e95d7377439a1ee2e9790a7401741c85a034cb22be23b71fd20803b41ea3b96b9446ff4c489af5079cf1e4aceb54f5404ca26974af6a18357504885487fe927e0f725e09436cf6ac9a2fb668e8e01f0a9acf5e6e07a9d6c6786428268f173fb3310d3bf50f3603bc3c4395c93de667fba81664c3964131e619198db311de16580ef7eed89c37461f1ae50ca9f7391dabcfa9f2d9888de529748a924361c5c391751d3cf8e39481ff9b76b51c71abb642c8e6353959f56c1f93d94af404f1d176f5eb3edfbfd0d47439a54f4e144878b08a6e7b9309b8b38ced60cd73d38798f2dcd3601d18760c2e10af2d405142c9e5587aa44d92f5a2776e51affd51bd541929d984e2483f935599a1c05d1e0a9f645ff0b446cf19a25293fac250bab3d44216427428528ee2fc53ce2f8bf99184800f6cfd4f16ad04e0a8b523798d410205389ba2705ff8d4167c7533a5171a221cd9d2a187776122312dd18cc18fa9c8826a86d0fa0393c7b6ded6d82960e5f463aabe6d16ed21fb47ad392a28c21595dceb6e8b0a1cf521dabc027dea848006f887a64acc6af95248895cf2f33ff1","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
