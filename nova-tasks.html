<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"63d6c85b63724ca6cbf4043ccd1b413c1875f5c7104f118d28038dc7184b8621ae44c028cdb571f7597d4c7c3d1f543cce8a212db978e65c83d3fd87bbca01dba4ed7b2b08043cbd8cd77ad59569933bac571835caf2820c502dd8789d2fe4e9fda77268e59071ab59a544a9ba7e2db22963dacf86bc893f389e7dece6e03302bf558d099fab50ea285272fc942d09fa6f1fac739b831cbe466078f03ecb1ee55cc471490c8e36540ab9f083d9098ce0ebfd88dcc820b810a2f0f7dc4f6392a59b36acd349e685e1da3a034abc9a99dbbe709f3442d9672d00ac6fa47079d3c1fa4ed9e71a72d7e52bf78623e585514e5ad0e9e473e3e1903123a676d354a13bfcb38363203b077564048129bcd630fe0f3068547e72b20ba0e09f5a60235f08e95ff6392a901fc40d99276617f85776e53ca78c060cd70afc79f75e6e0ac7ea4ef44e00d3530906dd7aaa61c046a1af55b7ec62d6acafd9f0b38a28185e52718aa80c1b9a251f1e290167a408185b5a7a12ab9ebc155e620044f6e11703ecf1e1fbea857f8276b13aa0385934364074f6377cabb9800bc8a6dbcde39ad6708e68dfd7360ffe7fdf4000c58a19727e40da6b047352afa08c5181c7f6ae2fd2f55555de4c443352eec3c9ec754f12bdf00ee3cab72f5e89a79aca44c57c77fee75187632c024916b4d4c8b6fa34b365d55b3ba9637dee42e232995e371741797c585988303e8ee8b40b27d968834492b8cfdc2fe52920bacf53e1ffa226f8f73f073590ad45d857b94032b69066d889d23b1e6e54caced11ab6d88300419ddeea5661f1b8d828ea33ecfcb349627572f35a410e6632929df65beac29bbe374b974b9f2d94ecf4fa2ccbcd62aa816522ad3ed10ef60f838c6a7531856e7818f6f377597ab4528a58aa4db4f9e1307aa2b220f3957c9201542dba820987359e60052a655a8133d67eb13632f2e15a94988c18c2fb9203741b91685cfc9f7441a8dddcc7dcfec5befd4763b958e408d20fadd02951851b6869270bbcba12419403662914ae4f909768983e92444d7db5dc5f007bfa1226f4830c5fcddb9a283a67a3e0b8e2a774b3a565f661a7a639f03c2f13ad84072620295408efe773d09bb0083615dc992d403cfbcf1b0831d9ffd650ccede87f7a8c1075a4daf5b116d7eb98b3a38cad3365936e9f7a983678aa17c9b70835f48b04cb92e0e71b5e4ddc06780849f73659cb7d4dc9409c5c2c888fad5a7eb6c77a6768b2c4e0934327acba943a6c20c9825ae17b61b03bf8ee45010eb0c22013c86596a3ebd8c768eed082362b2f5a324bb63f1280cad78b799e2ccfb3347fd2455bdb7035f7332fd024e367a82dd6234e0a9fdc035bcdd0caccd4fcb88e915b6c99176ed29db3b3b427aefe14ffd99606316ec64a6c92e61e96ef5f350d2e2a423bed24b43ae38903da1ffdc67e9d21dc543d1e94177e8679a4986346d788c71e6e3382d660d3f8365f7c6b8dd8ebff02514e23d54b9cf8e5b615ce0dde5691cc94d6ce2d6e71d5f044fed99f8549b181c097ccfd180b9a54ff917ff0d718b75d8d19d56d5f107a434a75d32d1bd13c083c8cfebe686000f8e0e730554ddd8b28d09ebe6ff4b722b53a7d5db36f4fb6dd474b1767f6cf3efac993145ccb05cbb41932f967f2fd54a8518ba77c8f2110ef401014a1e9b7b7ec1a243512058f9e889fa48c1f562639529499cae86e2cf9a49337f74dbc0db27f82a5db2f6b3e9b3592edb2f80bba007735f51df79100758a2eb2184563931d3b51a8f31f6a825bffd0c2b08f9a352a1a1b912840724818f5d55b742a294c18cb8c34df7c2e65097f9cacd9945ea8bc17ade01937be6241f6eef8c0fa44077cbdcfe01bbb944c68ecee641fe9cdf5da44f71bc8ab649312da96f6a32d7da7a2e237e8bf49b412ac7ed8d20683ef1d7c4e920846cbfc91da68e614fe8369bd322207b65ea4877932919805c294768ca4eba749b1da5be8ebcc6d14831b97206614955ebbb418136a28af6094787ac3c3b32f9764efd132d3b74b028f0397f5140a6f10d22b286e610c9cc9003d60a48364772720e33e06f533e768994f1a029c37ffe18e19a9f9190eee542fbca87b48086905e0cbd1b89ec8c08386a834675ee8382bde11270546a730d92e993f90239243a0514931f58e72916446023814b7ea7f3f61f4808b531927c89f2083501f6a03a4352c28b625969ba48bee54b0e4e8dfb7083bf220fb5e011019f814a5de65fde61d06e81d6c4623be3673ab81ca1f2098b0ec604c080212129da94007bbd242e6f08379268e63bfc30896cf0a6b2431a6cadd89505d3064e6cf9e2067b99e8d8fb26e20a9aa3f1680f277d52175e823dd56e6e90c17d9bcba8d064e44b0286fec5eb5605279f74888a0ca0dd8cd1ad56dd658e385f974c3a7ecccca352929be6d5a83d36d03e52a0f0177893da9f02e67cb40386e46dc818e3997b940f23629b350fb6a3ddd6df37ced49a38adda0780dcd1ef2b28317542f5fc5b38910c5b6153211586a7232d266822f590ce22d86a37fab4ce12bed51d9dae70953f78852c42a4838dcc674e9fd228747c18bb4b6a77569c3e387a33a0d46f211b330c5422d982f2c1958882832fadf7ffa9ea7cd7631dc24d4b9a8ed0ee2dbc0bd19952770483b0ddc452a0de0bad4e5d2d55fc3f2898c59cda0b858e1eb8b11f255f889376d99c5cad2e77e5058ead4aca18d38cfcc685e6410e115e57b466679b31c580a300c66e6854ba7d2ba374e8447a56d3647b1f878585749b1cfd8044238d7679552e0bd7c956b06e489d8fa8aeff997e1c3d1bfefb1ef44e2a00e4de8cdced56ad8c9d4efebe4863b933ded176eb776f1e444f93dd7b3abc472037d44f7f3a9ddd698ea00f0f9c5b1e433ba84bdf2ca1f199316a113da96f2d27789011e9b316da7caf2eb90c96fc5e03f22f9556bc649eb2774bee36b11f88590b4cfffeab0ea50cba4fe708d39d54e74eafb3b446763ed0d613a208d77dfa70d6a112be735008efbe8a5de79bcb1f8a4eca40174bcce30503d22be7735bae64f1aa2537989bf0471417f073e7c3070311dfeca21a0bff13fb4d61070f71aaf1a66cb7fad612637077e27fe8b363f6965d5e74384270cc8cd1cabcba4376f9e4f123a7df1465f4e3978f2437948593dda7a50c836c1c13923454c9585a200ff1e269847be718f90e7f92e8c2f697104dee4897e2c495134ef850def04a4ca11380f320fb5202d50f5772b0a9b72a14b6f5102242c055c2918bd30bb80693cef820fc859b215882627f00d441b731a3e5d7af492d931bb547c5d707c26795c73aa7b50e2363f101ccbd92547c5bda422bab0c72aea64d27cb7875b5256f05ad4b3d983b72701770a392cdadbc2584ede4181e1c4537957144fb4f89ac25f66ba1e39909d4508f0b0148bcdba8888c0bffbf45479ce3570e4af7b11a58e64159b6cd0320205404da0c2978d2f5669e1e7c1b9706ad2f14ea1dc7fdd15a9cb4cd09f5b7d83fafa4fc5371776932b59bec0ea76aee756a9a77ad6caf187bf2e155d10aa5a53e4bef227dfe52140ed027477cddb0ef2f6b7014bced8a0056ab11dd647d7b53dd9290ab1a6bf84a3c0cea49381f77d33d5aca41280e6a326e211e035f093c9cef20929a5fdb86850b68107ffba5516759a0e4cf07857b90d96bda9bb65e541ee1e769e78469ed0d4375be6da953a2adc895487e8980a98f2994536e83ff3cda78768c60959dcbd189269275c9e1392410dce650bce931e138385a1c92b4fba54a08e74c98112110e4f7cd35616101a014d40a07ab335a91810749ff4ae66edc6c80dc3e2f82c1044cd81da2a73fa5dabe35d778128cfeb4feae83effcc0f19c65b93af20e1178d46da3779e8582263189f098efe2376813d16ef29e05db00dee3e704557e2b0eec7a680c65c62613f139ad64cfaad6dae8eef34a07cab9ccb2c0c29f077e753db9f6fba5f200c6910042f83395783f163fc291e1938340a23dcc0a088076b32eb1b86e3614a5b6f555954012713e8613f9d347891df093328161cd98e3363929e30fc7c5323bada5464753ae2868905af4a4ff71a83ae5246a9998fe95f613a0c5a033c9da888b528c22dd5ac67ea697fb288d85f1b4a7892ddb6a8450186b07f5cec0f09d87a88be2e73d79fce3fcad450eb2111d8c9eebd06c31670d6e2140d409314f00b6bb5c9e74f85c2d62dadd5052d9a5dfef9914f1cf9c03e8b7e9f25333d9907069cc1054bd20098517ecdbf270fd03a25c8d7e5d379e6f031d4a86517ddbe4b1eba8cee598ffba2b20af891881bf5fc5c440fd1a61ed4e328b57189ffb98754a86edc75fe5d84aea391d558123f893802d2907b803575928e4e86db1e88a1471c1386e061bd3fbce59a2a848043db479c71aba7bb8bb39d7b0a2c43f6aac3d1516b1bb4a2a2631e4cd70b31a5f5c3e611b4c6902dd31f0db08c3f866f49b418d95d2238afb8a6a035c2498cd9a95c5b781c9cfabf85dc8fced9c039898989f53d14b87aaeb54a0ca096d5fc6e1dd330382674aee04c555309cb665b35018e50f6052587a0bc05d369942037deadb39cd10ddff388d6828f947b1dbd34447b3bb6d5922366fb1c21407ea28c023f5a463567842907808777a24e67c625bf555761a71f8a6afaeb3ae3e16a4b369c5202dc5fdd26ceda8369e4eef064208b11c38c593cbd543b8d9b00b4fc7f19dd0616b5d90fc416fc5c6c9eb593ed4190a5e9bf6d934d4d7dc3e8f0ed02bf63f425a56bad3d0426d0e38a5d9d97755580a305c87c34c88fdb75857545fdd82bf2f4ffd93faddd93c97505751184d0a096b6cd0c809ce8a16cebda60faaf74e24bcc76ad8c94b14b5ae28ad3d62a7f05d98ca637f47ef60ce2f2be0151ce81c347d3e6d19fda7421be7e6ca45aebcddf78692e25574fbe26b9de662ab45ab11589213d89c4855f93671e142ee86bf2d0c922e9ed05c35285136269003670d3efc183c1bce28825439c578b41df9568dcf0341f9c059e21c7fabd3091dd59338bc34f32dea28fe707c721085a062c0627a4c398809873b4e6f9afc6c9ebd1b68681d4ab00f398036e9d7b001d0cd7f2fdef41894e13c2dea359edf3be1833a76d46830c17499aec671e4dae8840310c4bbc611e65408ed616fe183753a335b4a80b77496418d1cafd58652738b2993a83e9b3671009cf4a5f76c178f6fd49db202ab2b09e69f0fc6810a319d40596fa089f9f46dde0705390b5cbdd228bcce285d80266f5545e7e4b8e0c4c3eab496a78637c343f2fb9acbdae948e346d590ec370e127a4c80d81b6b7b0936bdefdd73fd561a4e244df7bf1a84a7e694da9c9839bb474f2bf21de6857b59062c9f1460d7b05d69bbc2b528c720882f3c511c6b3decddf1775b9296a41a3f65786a5355b5399f52659cb55cf5e445a6ad89e75923761c4744dc52460f1f173f61c153c7c161c904ac91d15a1b55f90fd569ea033ecd2eb0287fa309bf29c11bda13b7a3b722102cbeaeb5b26c98cdac109b45120a3a9bbb3cf54d620aae4a62c3458540da5e91d4c453b35667a92011f5f692ffb6e1b184d2efcca770fc11fa666e9bef3d52674ebe77350b4d90f8f5a8dc0cbec983b90d7d3b9d93c9f905e644bfc9f058e853669a8d04c7320a2ad13cf02622628c10961008d502a86a8e0342fa0bdd2d58fab373809d275e2296508bc771675017b1758d815cd27b37d00703dd44db5535b28f695d160a23c61258eec9a18be5c2d82d11c09004a9c13936df8daca120bcbde437548a6f960ac86126b47d943231bbdddc3788e09a8d5347b511c34e29d686d5d3ed4f219cc3924ff880fe3f9da7fd25987f4ed7f9bea8aa63649448854b51a094350bda74a7203901349e7857da94a7473ee824843d8213faeabc92f758feafc09990fed61fc03a10488b965ad7f98c820dfd3d8eca16746757ab873406fe680e4d7ffe84bbbe238dfca847f2e78bab4b4a02e65b692a2dbef7ebe522d84a16797b37996a915cc0afb380016b2e6e738640ce235dde2c74c52222fa7eb1bb5784a8713452730841ed25c270cd1dbcc305dc294cddae9c015e1ad00440d29cdd0b133fdee09144034fb9314a38a50c34635ea970e372683b9375bb65f8886b2df24dfb08bfe562c11e7d8c7b27b3fde97493f7b0a77c5016d8ad0253b899908e5162e7487e7038f95957b4d5409ead706d5726b3afacf48174b1359d7621ad3e8e0656c7fdaf263f2293710515dce6380228f3c9c07cb79ab93d4be30b6a5a0b2e667d890d457754eb4443f953f8df8640a6d96da892fe5128d4cc2a0853b34391201139b70309937b81d21ee6dc5fc7c324413dee07ada7031ecd7d6eb465e0d630a6ba5a83a09dbcf48c4cfe21b833e82dc14db56007f74f5034592b7ecfed83bcb861cdffb6e1bd754677f7bfd6c5f444f7fb15b9c816bf27e3baefae45d7e892eee1f85b7b8d02795435da1f9a6e34d2b6a44f1ca922942a886868fcce92b27bc4a60438636efa5d9ceabc43036cdfdec1f0686eff6112cefed32a6e16d14e75039bf4dd2918c3f8d5e17d938b7cc4f3c768fdc53b8b239f6499d4f75bcf4b2b18ace91de49dc6fc02e243f227b1f7ad624e9b89075480fa7e7cb991a8c4b28f1b759cd2930bccca530301542c76615f2d5a2960b3c29e7229d85fffe57f0d5a9cae71b3db105928a13dc57f725365653a86489c9d9cb26a94c8d588fa4e684b66338a76808e29a26742d456ce6b2ba306c4fa6a11fbf36d4a4ff4c0da70f0045ef3d118d042e09748470ba1d5f6e14eb63d10994858b9072c586366b24dd38ab9e746cf76d669866543c3625d53f2b85a8fa4aff9dd71720b712e113199962b6d5939c298e220ad675c1a89b4a08d766e9de2c2f8fab974d2939b419abfb1034cb319237abff52dc34113ba987f488592b15c1e2d9b8fc2128f340e0ac82c34e54d0504b07ee33fca9de76e3ec2703ad071a8ec411e80a1dc5264c644987c6a7c4d22ce58461ad3e9b1ada81798697eca7cd73d70d4cfee79e630fd84592a6a66799c4213217a87efdc44e94e5c022c353e3b6a03e478e09ea5ecda2b442804cbb6499b80b9037fd421f3115b2a4dbd98cad742efcdd9e115874f6a495ab18a169f2c9d815f3fbb09e9db92271e1931145bf80a70ebed156bc744ef1afb7e64835ca5b3bd46480095a9c6134de8e6945f456cf3efff84dad72059e67f1d85be101d2f20dee94f106afe73830dfd7d9797470960c7413c023fc83dd7cf08a734b0773a904831cd1c8395b0250fbc0bf8a5ffd0d7ebf37dfa4a2d5cc9be0566a3f6e01cb13cab86aa4230d0b44acd58a8ce569441aa2d12fa5e86ec46e327c073c5d7387a6510e98bd86c3c8ecc3f268ba9d82edd19eb1b4f3b03404e9dfb423ff941623b696ba66fa99e6d260139d3bfe656751007309ab2c879979783fe8d2bbed2b338ae2ff6523e8be37fa348bb910ce4b5aee89326b9bc69eaa2c7a51d902df0be083138914ecf4a4257edfa63ebcb501658630764a0eac72d3a494b1c0b6b8b603b5ea6d691c5ba375b757c7a98b84998eee1ff6feb31359215b617e1f12489a2ca8657c4c82868dec091fec7a0d8a4bfe901556640b5d0657da8b0ade11d4b97891a46e0080720d9d8aabee3c8964bc1c9939de4864d04bc20da261a0d423bdbf88020688f63e179c97d77ad96fa34401eb29ad30bc284d66fbd95d99d27129c027c81b57000afa597e8f529a217a24f1f3758d39ac2162d37b65424084c8d00643d4d3712be87fbec3faa1981f4a8f562c7431a2beb1aa3a4366ce57aa9612ade81e56ab20cbd1102e3cf2fd64b533dd4ecd0c34cd37aec67b57a0f81168e48f5c42de1b9d568ff0e0fcc864877d60b5a259612f351424abb8bebd7e1febcc7f8bfb10a15152a352d5da2577c7c0f7228513656eb90260eb0457ca6777748b9017c09f2d2e36bfc9f8175e6f0e76d0f0e76c3f045ab1c2787be702d73c521c80c79696eb17ce6afe3c75a675e263acb6ddd37c284c5d45e9955913f6d1839d4ff55176cd5d209aac6515191abfc5b42e5dd741a587ce793bfcfb7e1ce8fdf035abcbb5877415b92bbde4ea42658eeb7f9bf1d2bc8de12e629c1db8c0729f54f16a86254d0f587b57cd61c73e0c411c4f4eaf984cf34488d982a353b4490c2b4762cc135443142ff383647197d0afe22c288f7078ae3cc3c7b26b5c5937ae4bcd19dd0158df6621e24078a3e0199eb143d3ed428936f6df88b52d3bc1b90b1e4ceb62b510fee9cba3650a98c19d327318581cc83c146c487b34d79dfd92452c9635e827e12ab1df3dbb64f71c67e7b93d23fb3292157efbdb6fc34cefe4357876ee2a74013878b2796ec8847c7923f59eaee5c09ef78ff90c652d31bcbf46f88b75c1da0bf22c29e6960fbbaf540a772434050b2ab20121ef41859196a30f7cfa827c400300413b8c13ee611490a12517b5d1ddbdd72ddce7d41f1a285315d748a7cb475cde75e47510a5aad88e8082c518c795195ee49e1d952aac9dd63bb3cd428adee10cada2b4e2837b84ea869c51f3400c419fca2bc790af970e3998f201472ab9bc409041829a26ac189cb9cd79c4e5f1db1be6f504bee21f96d9713881dcac432728fcc7e9a30075d982ae1b974569bc969414a74c4ca1eca6506d043908636a176d968ea7b4300d7c39310075ba01d958a11ad8b3b5d9cdad182004b2af3d1aee333a5c3252277b9af2bc0a2949281478e0ffa0379d0c24851dbc4af80520ee9e87e77c399fc837114894690f8a6256c161ec687a4d8e0a201396b7095a787bfc6bed847c3522a3b39d35d379df4c938fb83bbdd937dadec8f96ebd950da99be7d0e9d30d5fa424522896d991da9a23d3fd87ebb45153af0e14103181eb434d4a36242e674d539fd005c71341742901ab13a09e82b59bcc7ea614983cb8cda46b83611a5359b41e7c09f7ce2d5381e0bba8f5481f3848120020d80f89ca2a90add56ac9b3dcb0ab9d2904909d659e9f8449685fad648b6712a4fddf0c48ebd8003a7415bebaaf84850b2befabdc5df9fd21278663287688d008313566c0cee4dc8fc9b79f8d575a0972c6a51fa463a3b12bd94412244eaeca92b959c3496f5ffbd1d857e4688ae134712e49655832f26b320331abd2a6c60e88fee7e8840bbbc4bee32ddfe2de782fdbafdcda42ee1cdef2c76f4ef29b3fbd8896445e87f1e374747d9c669f0fee0481b1299d9137f310cf7854f69b3489494d1103d64087f19a18fdcbb7b6153d0863b9078791d7bc0af8b4ef26ddce6c9077aca6a17b97b822c8f113494a6a088cf6a06edbb2a5566c99c48d64694e61ece8ce5e71eb422354be571b06885a7360e31a7e124a3afded5775b069e4cff19968d68bd58a1bdb25378a5426be48d583d98a87e1cfc471efea804bfee540ae05b857750795749819b8b33a3ad8cb5505b12cb25005be777e03af277f9c2673084dfbba8efabc9a996e9f38bd3eed3203f06afdcbb54ccfc88294f05c93417b7dcff8ebcd3bcc6fca6f97392a7139094ce1ab66e0ea9f0a6d3f6fc5442705c940b1f824542c66470e019118d7bdc90afbff3ba100dc293c6a2518506e5be2470d3050629aee8487d419a0f03b11bfa8ba0e4b0564ed1c75cca734fba38b7ecce923bd7c2390a4f5c31a923ff9074c88df239b2c29c5b836e64cf1a6496e665bbc8830c4e88a234b4246f212ca3d0e3a9733c36466b741f79040a7de4fa56abfb3961fe46d67b0b2b679e557c629c6cb1d834bfa9a0aea393589f874f8bfb9804a739e789db18ec482a8be70dc0310a4f0a47a2820c9bf490049ddb35c91f6057502c2fd8fef27c819c7a4f8f5473fc4b8eebed85f1f804d5ae4f66599697d905a54cec16d6305ac91f0116407e84bd8913d3c226c101ce7d9083e84a1a8f4f646024c1bc28da4f2e78e06e86ca16c91e8cd41e03d8ed6492a876a1ec995fff8cd938c0b1587d0fb55a7c671e08d9921c18764f05f58c20b23fb48383636d901bc8715a913962ce93dfaf4f88e4c2408aebf9f5955a8a0cee6eb7790c3fcf956d62264b414f1bab0f3e6207dab77f06a921431f7e66f723d0680220fe52e653fa6b060315f2969a6fd7b2c5f6f83a2c0a82e9fb7f5d549028655449f727a73b136ac1719fe3bea903f5d99d661eb6176bd0e9ade0dd612db73ed7f3dc2adda2b01f318c5099b60a6cba2ed4825df9d22ab45dee7b0ec9c3900b82b9494aee3b4387075243caf2e15e8a56dbd77c719e83c5fc16b2c93195f27f4a933e87b6681400edb7056c4dc06ad5ada55424be890cc239520d714d1f9bb5fdb51b90e15891b0e410727af6b954a23160b1517cfee89b3b30a0b4dd99c807cfbf573ed57c59d88f932a52c1e804637c39a240a6e0b3190db19d28755cc104adf83c08407ff31daecbfef07ded1c55141a45555fdb256a50e09c2c93a6fc5651331c27f25e8081add637915909891fdbc65b1dc050fffd15e56fccc12d77c9fe24c8681f3d0b55b6d8cd51d538446a9f59728f08fabea4a30ffcf0269d39758db518ee9dc2bd564c7ae218e4010492dba42081bb556d3338d5de2183711e0632efdfec65f2bfbb2f7ac16af8393e536d5829b858dd0a8cf047225117fde653a202e1c5c06dfd4aa2f51ca5f6be6e0df2249a4966ae3052044b3652523f2675ecee0279c7aa12eec7d7874fc2a0464cc9e85688124dbb8efa3f6037ecf91aedfbd4f3fc68c5daf1b6d1f08fc6b8a61e2b1e7cbc0223e934355c92fbabff1766243313bc702a6924f1d6f86c3719d50e2aaf99e35f1da686115f596a3c4d11fc08ad410bcab90a0c4a5bf68b44dd62e0931823a05a1a3c4387dcffe3a158558cd370b6d44f90ae542aa31871a2b24bfeec280d9e35fcd9872426293e76a596ac58a57b2f361625382516ea892efd857d75cf046d43a33637bf5f9ca44375de3c3820eaf9b4484f9d1d5e96704297742fd98674e99b20d9928da5f5bdc8a18860fb60da4e3b27413d157b8c6ae8709a1df577d9515e34d8b13e06c9421d218f61bf9f966746764cf80d48555336facee7f13d574587c58f6d292d46623eba6c66bde4ceec8ca913257a6a40b91b0fe2872bc4b53079342c662679182b5dbdfbad49961b5f4b3c3f188a1a5a2d81929817b6b01256437bd260dd7ce7826c72f469d453a3d38013078280bf3d54c086b0848df853c3ad81bbb4e0ed2ded7cc12cf69783f697ab8a70eb99c6da7478aa9efaca1f2eea6a4b68dcbd51fee1b74cbbc998a54972a7d662ffc65466880333d085b519a2fae6b06ae4d05d2b96ddeef28b64c1151875158dec69ed4a9042290adbf30a9244c2728ba09c6450caacc3d2c9d45341c47a0d3675eb1e9429576dd296a50e9c447a7a38c6e2f5e2fda81945babc4b190d2d27b813ed241f9a1e2eb3dc36a009e6ea08e0cfaa65b8ece477b4cbf7b56720aa1a48c649ffd59aba19355ff00906f748ff39adbb8a10fee0e62eefc15e0f24d41a4b3c0e510b1756fb6ac141937cd4114c9e424a9a1247ae5bddc22fdc9b9e3a141cf049e5c869e0bdef3f30795fc1a53630a88f24dd26443ccc659700228f99c5c71e84aff673a55306a49ec20fdd396be73252007b1572c533b54169b4a1ad54d1f0b9c391fb1c3e1940808c6a2f9d90487b171d0d422363cf4678736727420adf381cf7e86b0d01f3f4af2450f32b1207b196ec894a9037fa32b37694cc8aa501fd72a8e37150d9097a9929d4ed19408e77682d3317e1a894e7b025f4313c30ddab83a95904df3f658cfbb1d080bbb6616722141c0e2b1d8cb1adeab36ced964400bfd7aef48c9e9e5f069d72c77c5106c09a2f8c131a00bfe48d795932891bc6e779754a0356fd9e20c0cfa6c144ac94b55e66a64e92bcb3c239c5561239316c45289275e12548d3dee9e996adb66c22f8c3b20f61e9f22f2af26a2e00273a3c1a8e56569e72beb9846205affeab4d7bbad888f4a953ef4a9904194a4f86595708594cc01ff4dcc7663f3c8c13ea74be39a9f656fb1871b3ffa7a8c730ca478e24051a3d3c76324c865348a10d96035b9c952b407ef92d0354ad3d495d975fdfe2bc477d362dc43ef31f402c9f3b89225d3e0c2e1e8185a52b09071019a7430841285e53132f4c06edb231d54570f1b195f10aadbaa3944e34ba457446286f8d5251f83eec2d5e52f39bb5f422f1c039337ea3da253502bade0f45f5e7f69838a422deb2077ed55d67d478912640ef482215510bd2ca88016f908d3071972de33ca94e66b731292e58be7ea9078ee44c6ea1a64038685684517cf3c864dced492bd06d6698840c753155f29341a39a14f73e557a3671840531e0516b202cfd43e3fbf1e66d6c3fd97f690a1ffe43e387659cb5e7728a6de245193f4080f5dd0489db9e675c1973fbe551e6711ea39db4702ebda27f4e73e2b743697ff9a564ca3a7abc807b84b3614d7f3e18f4246ac372a302faca50e90b131093b9d0822c8d531e2d31d53dedfcb980c46ffba2122ed228a7d0983669737bbb7b68fadc2f9936ba1f758ec7816b4c9b9df38f6422bf36c9e77a64179775bcc9cf7ec57101f99979f4b2427afe0954687730ce2a87e3b080bc3f7e53a3c6be84e92cd81241773e27e0c103033c439caabd40a4b341441db9d36625fc1ba20c3477508760be1497d468fb07f8eed87fe43660cfb1733e5d2a94945073849845e7b2a0218711e27ed0705d5d5ba313ecb38b53c5e68da4c7c9aad318dc6523cfb05bb4a62b42f6e3703196a74a753855912f8d5fd53cceac6b48e90f0953901eff6a8cfee811e10048617accf45c71927df701cb26aaf884147d61d509fbe9a25d05de1127e2a3a5c740298529ff991f895916c7c3da986b36475d132cff79c3026916993e798c88d083575bd9f9114dacd0cb6d7f962cd477c057ad6ef8de3d26e7d5f99499a91349a2b2d7238561997a30caa8619d39d7a04d64446d67a2783b81694ccea1320e52f818b2092ec9de79da81c9af43e174b14886d45879e9175b8b41c47558e322d66b0ddb8ab485094d0a7cd508bec4fbba4342becf3e88e2017afd7cc7f5459aaf2d46faa824409e6d02f8113513d2aa5525dba9e45aaa758768187dee16bb2219a33d0385f364f28234effe23b26a515fd8551b2ae6f13a16a5cc021872d7efe0f444a203b5231c3c3d4dae4ade66d69449dd7966a60d175b712307a8840b827c146cf92a6af7a72e7de3146b748124ad09dfbf1af96651b182dbeb80b804be494dceaa55ab93f79f03a2f8f3cb99a13d3f23d1632faef3e14eb241c3b1a0e8a8c1dd30e36128fe2e3df6573b7053edcafcc02b6d4cc83d384014eee1efedeff5dca1eb7b6377002ea14ca3980e41723d04738e847d077a84ae1e9c663cdaaf3af6a85615ce7b1a9572c9ebe85473f275bdfd01b6f9cc7b1f36f07fb7e0cbc1ac47496ba9edd837f02e5f2ac3afe2ff0734fb9156cc85550e6c4fa16342c866606efce4374be85e1d3906b6d40590bee03e66a87000e0f85d2f89e4b211e01d9ab56e70460f336b0546badb63f9915201b82b030e5da3acd92dbcaa417aa3f89cc7e6f4305d2550669a7d9e973cc5572f33da8065bd16b6fc0de39540dfce72e4b9af828da23ab870a466f905c05176e6fb92632425a32dcaab7afc5064bec990b62908e8d0cb66fa4da02265d7f0e7b63c69cd68c6aee7cf0826e3bd7e8c7d0b833c44911e9be9b9b7e5535558604e47fa0a10e113144d257ec2a6f11588711e51635ca553069a86d5920c4bc5d147b0d047bf7096d98d1a75c3a1a9900b606b8732b3e8d2b88d9b58a32d5a3138e0664bb2b6e0910be6169c19dd1c4fc42398d96ab60837f273d654309399fd45d28d5e26c080c89b2ebc0b6c477e594b0a78f9087b8c3730ebe70d0c67ef102ffc9d40410d6f6f88fdf7a388e215156e561dd826890ffc7fbbf1730f63de72c19bdb1ea52f2d3fb5e946ca2efe918f5e7c47be70028dc56ceba78c67e53d5be33c588d9412ed454f5dc9509a3e6f6c2ea74902c028b4031044cb898eeb23cc95a4fa4dbfdd3c5b3556a768c297679b4f8dc7db0290096e53514e6678513115e0cad037f0729d7b16f2c2c6496686b1bdc49b9ba95b23a6b6d32cbc9de8bec56c31861e25fa065deb465feb41dfd1bcf1d393bba9682fafc75ad2d02254721b2d1e99d14e56a47504668c01546a52036d97d3f58553e88eb357f4e57f03502a20f048fdbc9a76eb54f85c7e284b2b5c47ec6e479b61474726f2c03018c29c785dbe3e154751d113599305cf3d06c76403045820eeddb58f7210f6585e5e5df08919c423dd0722c1fd60610c89c620bb7d2239f42b2ce271212805054224606e5e95f3a269231b343","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
