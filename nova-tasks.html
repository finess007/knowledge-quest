<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd0cbb0cd6cd82ffd974561d050074f2a1c25c94869fe67bf1345c9c53ed16c00b96044a05aca6c6609622dce707e59222ff7f0512fc6c7a708acb9d50a227ce4b58c5c5b6b85fa21f8a70c3e01a0710096ab74fc0b54532a7118e22e4e30a4c1eae631ffaec76c37fbef9e2f5f96b4393a7fa6b9b5c797fbf569b059d033ed7389a8b6930709498572f59734a22160abfb9491a91e362639b05752760a84e530521469436b4c4acd12d82210dda5dd6c3ad4262696584220db9a4d62031e042f95a9203ab3634784f3355d75fe34b40f43f3515b1a71909cfd4806e5da8caf4109fad1d4cadaf54ef0eb59479e29f54c8e1c86fc87bdf71c432530ceb92a965ac5243bf61e81461bf27b4f40b7065e2a755fe3d232923f7c3bd60f5c0e3e5db4d86865aafe0ef7edef4fae33bc722dc3421bf2fe9c74f7139a6d0a6a82d7f2ada1645a0f42825cdbe009d1e0b3ba8e713f962b60c34506cdb72fcee47614f716eff119d1c22e09c2f89d8f36ffe5ad239617b821050297b386a8eefd24fbc14047485e94b4df6fe40303ffe3b2539d8cf0e684825d1d676114fa291c1a173f2ddf5084cc9df42be895927015652137d4d3e9101993bfc701518d0e16c596bbe059641c71494b1dd01a701f9691af142a4172c3753e08fb60012aafcb3cb68634e0e2333620d5e6cb33b8edecb5ba2a6140a1170ee50cc590d04bd02114e9cdaa6269b5fac8a40c782855f340ff500b6057fcd58f027f4bddb64eb31e02b6a24762e5fe4ac662599b818030ba55fff37a2b354d0a93537d973cd4c4a4896078930c210bb6ee580834ca0629fd5727b09e606c3381ef79b57e55bc50bcc6e18c5315c3496adc88ab8d0265f0c9adb557bd482bb1d3ef7b5d16bdcc8955af12d0ef89e02ec4b1d7d6e66e578aeb16e2a245020d35b0ab393e8c51658f6ec6fb60b72cf3e25998879f41d61a4d01b3aa65865a26a747574d6ca2b916e04ab4eef84ba12ab88f59eacc0d8b55ef0086321a26b84dbe69f3b846b0fa5ae3359e234014fe583d735b6cdcacf1ade5d887331f0a4b65028e0084308f94f3c44e7eb8eac94f0dc05560b706e5ce250f35f7139677e023eb16156f19a9ee492da53950d5c1ece09ac501967ac9d9ba5664d8887fcffac2b7c161ff40ec988162bc8f763808ec1a7c4fc85dbc2ac31dd2272f0f23d832c2047d0574eb253209769b0323a7f1f7d7fea55c451154268f7ac3950c4a50300905c7eb96f3644393aa670b20f066355c540c7e52b6acbf8aa87a3413ae812b31d7423088f5626647308b3c4cac12b29224d601b390312ae9e413caa37092e47759ddb328a3601f3072cbdc8f8d116441b938a330defc7e4f3520bb0ca50dce218afd5752d6bd646ea12431aae1059b935b58c9f6356ea4af0e4898960c6bf6e45be8937c99199925d38e083eeff6b936f149d7ec1ba85b11f268a9b2880c999630bfb23ab68b36ed8b0fee7cde810c60fc29212bdfb369ef5718f634e78efc4d9e6970bebc34faec8e559d12b441adab33507738c2d81c5ef3fe2a1a5cb51d2bb3a5ff47508ed9ed65ef19b5934bf315cc3229950b72f5d31761775d34c7f43af6393929c8cfe779808c0897e1455c0adcf3640a3a3d0327b115bc36d566bff3fceb126f9fb683f7a0811758c3d973582bbba3f98fd77b71994116be2f6fc891ea2be0c6a2d5b4028db10ed69ef61a95e4ffd856a399a83e9dde0cf1d36aea3af31e828c97781bba5a7b3d44d3e91ea4ee43a3d4cb5cbe6dde2dc15772f93a0c717fafa329ae7eab20999433d0b632138ab23165174d0f06a31d3ac0ea3066fbd7a9f90eef9b75c889fa1c7ed06cb33d791a7990a38f614248777e696d6efb9e8a3993a49f4f210eb922a63781bf8908e87ddc7e11c0be2953822e71ff39168e88ffb14d12a655950311a3c14d70712e9cb427959de76d953e968c5489fac6559d2c666d34c8f4eee4e587af2fa21797406daeba97fa43efdb6b8e9dfe93f0eccb4c2e1f5a61740a4f3aca3f3ad4ffeed9dbe23b2a32948c49f49ec4e4e4645ee1ecf4590ae7b6b6c1e9e9d2b003aacc9db8b71ea64d20533cfe2efa52aa1595390cf5f116798bc8a44351e8befce0ba330b148fd92083f4dc12eedf4503a7f32ab7e130ae3fb1bbe8d4db214ed7e5c5b01e9295a5392ef252ced124a6f39648ebd93976ab8c0d28b0bf531769bf9f55262c3e92f89a5cf16598b9e6cb186859db385e4c76909157ccff95b38680b83efa35829a2802805adc63c4dfd1429a9d6ef804891640a7900605f273bfbef15bf79a210e0396d6082fc76210cddb70285156bead513d55056def607575a1e88518fdad887b2f4b4e3c353374dbc65e1f4031dc595edea8d47b453dd6003a1f36d9e8fbd3ce7b43bdb213d0d6120704a9c9800205ed2897130f8cecf638d029b84e7287ddd1bfc369562d5883682742524984020d110c304b682a2435e809928446b3de1f07bffaf674e2a937fdc03edf94aff3d7b274415aef9c8f27a52b83ec4823061fbdfa01cbe358baaa29602ffe0a8b676d80b88288b8578852aa6cce2882ff63acf4d3366bab246553eb10b2ba34c38818fa3bdd16fc09247fd92612484fb8788779af6927572da84ea70b17eab1ce6d578d7261c563f368be1b0190989e2842ae18a2209251e732fd98bf8e7336b59f33774f8668b5b52769f230ec743bc7485b473362b64b0ad094b2c2c3fbd04b4765541d5ea392c9e63459b21d04f4999eef13f0493b3264736a5b47f09c2bd8c94f243ee42819761c349c2d8cd1f448b73553fd79f5cf05f2e0abc13844b2455c912315dfa4184170e0cf8b4a5f6296baea8d21338aa3401a4cf75e031738cdb7c50d50ca8de579c0b4210dac2de5c2c20bc77e637807d149ae44811f8156a944102ede93fe18d6d210d05d61c1abcf6fd6267ae97bbda7d15805c299c210d1f20582d5cf3433c786fd060d1183f1bbd80697de32ae89f528edcab98fe112edd94bbd2bade92867d97f66242c7ad02b8b7fcbe2041fa63f23ca608ed7a9ff7fc71a4ebf5247f568b6896b7a5977ba6b65ead52b74070584cf23d7b1006f5a306110ae6615382243c51673488bad6e5cb0cea95d3772a04db4be49e8b3be66f506089cfa4827770024ebd37bfa482dd654deca05e7dacdc0fdead9e5f08cbda99af709e5c83a2245a1ab8b17bec3c3afa2c110608c26c45a7912b8ba6c5223e17933caf8ad38f1d487f25a28af9fb95f7808f1c68d986d4a99be284da06a00f2d3ff5702a72d330926bdb2fe427e5d84ac4c9dc081a11a274b643f472d5ba4e54f491dc370f0515368086f5557625f504858646f01b74ce51499de88feda81e93656d40d09e2f168f82d1933411048802155d12d317225d95f3b3b96b3e3acf33481f724c9252e27de6d511a1d159cbb66a0f9398e68af93054ee52cbd9f2035ccd13d8d23aedd89582d09ed2947ed546780398e16ee52e64a4c2078005b8df6c4da754bbb2bdc5eaeacefb97204f53c16fdb9a69811114d480787068982250f62c1e91c3710ab60a20a5805a3808281cf314c6b6e31eb7c82e1d17478fd9aa1a76477d2ec2d730badaec23f0e6b9e5911af79d2ea3dd98d76ad9cd4a9ca6f74efa078e0b761f6f7d915761f2278681f92427c8f3268467f43628c59e954c94b38064cba4cfddc75ddb5083e7883932ba7d0ae7ccba81cd217d480feaad8fe50756194ddb25f97ecb856d74c58af9da2ed21a04120ab22469ebe06a59c4b22db18a0ddaa644dec446002d201ff363fe29a4887060cc22a551be8f3ee611dabab4732d32d45753a45fe5057cf2aed38d2d330bddc82e63407e50d75784180555ebc9bece976cdbc9b76c955db2e79b03b406c797d11ed8da97a6049e3aa2c22abc746f2c4679a5fadd2873d527cde97419d4e26177f6e6b20bd570fcfe662bad9455967de8d5241feef9b670af415e9b8a3f39cfcbde0552332e92cf691fbda2b02d77b708ed80b364e6a3323518bc94630b66a1e5d57dc6998abe05957af372ff07efb4ad73c61d74d09ce415d053be23685194c3278587ccf8d74e61b8c253dc0113147ae232f7620e140aded049589aff9b6190bd082d1a68702abd3afa58d13a777b9017c5ceb3549e7bfabf2a0f12cacdf0542f0043ed59f214ec514f77a3aaefb3ab2b122ffc73de2ac2c67707d050f8dff8d415e87bf65584ef637a35b80d405e8bc3138ffab69d2e976d1b9378874cda814ba8ce7d5fb8113d58db5b824816b6bc210071a5178384d91df2947b8feba2d60a74e4c321c94e0df7e449066df3f00e977bfb944b60caa147fe0040375fbe55c7b2b11184d504f2e6954ac0f86b361ce4c7e6a8f3ac3a4d25dc515d062971fa467ecfcfde14b3293ffd32176b20709ee11f6feafac28a79caf65805c583d0b2fb4a8ff6ba6e653681e4b5db26db1df9896df3d4455bc4d0ff906d86a76d8c79629c33b2046dae9fe9d963a15c126bc9c1526b8afdfb0ecef50e65705a1bc38f93d6246e009cef25e2bee212c811540c31cb82782586a74f4b7fa2c469686accf04640942a8fa142a89bfdfe3e4a61666e2aad585a6ae8a39397cbfde95db4b6a84e51949b702860d2c9f8d71029c70320c4f6378eb38a5ba325ff119edfc5e4bf5b07f1e569a876ebee62ff80dc178605c29ae2015711a6287aa88bdcf93547b34aaec90c46966ce7341cb653600475ab4d696d695086dcbb7a8c5cb5dc7c67ee459b4d73842be845b77e67b9cf4469b47a8e50e793d027a2449aa0c826a20299d6838176c384e9d32badd25ecff4f446f1d572d0b7cb21661f1eda6014c344761fd846a5dbc991d866eccdb12917b0bc151d1392c047791b0c6489f0320766c9acf6524f0dac264183c0b8c3995c5269c197cdd95eb553a46ef427ce7925d1397f1fc8b0cf906b0397b551dad584e806bc1f55dab61f9a74b533fdd126f20e7bd4fb4286c563571f837231c06d3b360b21ecc7bc627449dc21bea2bd7a57de21d3bed9874ab4d887723b5c743e08f365d3d4d577df982ac22f20d54a4fd8f566e849912f9fd69717943ce9ce1f0cf394e39bba18ee102e1a1c9831d72c068dd7689d27697383a2dcf4a616b66071cb0f46de1cd0c6c59371bcd62e496577f41930b456bcec7619766cd22195dd3ca0c0cd174b9c060ab483bd67997e8568c28fe37c093f066175b2efdb35277efaf1f44740f55a5691d68e210b2964f6f52c41ed498e0f9a9455ec0b640d282b47971d533f899cd4dec754923e89856cbb8fd241036e325d47c075f61dd2f5d7dbaa02b3106e1b8af5c3d39c81fda9716b4e77fe8e2b8f7208dee474412cb22b248c85c20b6bec1cdc18ecf43cee40f04b91937c4667a25ba0ff2243bce4425aed2f2bc93c4c650262c422ff0f95792cd965ca4dd9a75ca6f97d9d1966c520e1f97634127336d2edc7ea6c5ca369e28804338c0e4ab323a6eee00d6699b2570785d249919f46b5335b539926fd3b0682a9359de32de4a30dbd5f2269295fef38152853daa42c168238f6f47398b06a346cb4aea53961b5d943ce162b35752b36b5e8baa212ae34ea23cc5237ab270e1c18ca49bc86ebfb1c38021902dd69b3d40af6acd8edcc1c530d855eaefdcac8ed783432f49af10f4becd1118f699a8d451078b1c6bed9cdcca6af3f21c37f71376947afb51c91ae90a972900631c7d40d51da7ffa7e4c7d34a12b483048c2777a467d851afb645e3beabaecd6491e285873062495a7ac7ae625fd315035e5c6caaf5b7e598e629053e2b645dd2bfda0816f0c99688ed0447b45283dc7788ff611712547d7d61343e66ad624be083ac29b0ed6b7f213c656a25b446f2d4c23ce56209209f2b9218106b2254db1def4409a17eeff3824725532c87e515d9d882ee259ed852cc767ec03c7b409a3c781597949efff468cf48df79825babe56770116caa53463181b82941bb8466bf807ce573f06e559719748663218dc12be87037d528ac8ba8e04d1d852187d6937bb33239ce5d9d9e14046a0d6e4a8dc52828f3cbb33fa4e99c90984ab5b49efefe1cfa415d5d0da9e66124a29bd92f5601785011aede234848dc57c737b1008d38d41d11acc13e18206ce49429bdea4f5ab0faca943e720e5fc8ced182b69269fe1fdf9648d778b070313ceb289a846599589cba3f1bc7872763b093dfe33e426d8574a4b7a71e2d7481dbb645d5fc8608ad01bb50f3e613217409382ba120d6ed5b832986451487b8c471bb9557b3224d333a360a6bceb7da2dbc9a61bee97e5f941ca1ac3bfbbe85d9071a0792ad1a36f1e6860d4f3f45b53ae14de32da28c113d5cc5e7560e6152652c3606c24b08d34705a6c77e2d96548cb58640ffaf84161c27b591c1040da0495a3116b97a7872dded73d01506f9ba066f3b2570fc7f59acf87a665990123d5bbce3f2c99c1e49591d3d3b50736359061896075c00b29f0688587344bcc359e3feaff5a52d9e7f02b94ecab6c1cccafff7f79d5f451561e201a266c90e297336df22797ae54391b421aa6b1f3f6b02bb554830514f8c8d8366e69bf759558f3df7cd08bc957f6930939412a216ce527be984dbb6ad5abe84f2cd5a31b31496a9771dc5619aa8e68036a07807f0dbefbc40ad23186eae039c83430368ac41ff8bfa35338e86183a9d05219682087a955c8e02f30249f43d56ff7795361759f77cea2e62473f17b3866e6dbe83d4c3ee887ffeeee426ed8f24384a26bd2ac6252dbecd5a91632d6a315730737c38a29129a19b9d09bfb4245054e9b17630eb5c014c9889462be3923d04dd4dee43a1a47cca3b85fa1f615b9f457f0b4c143ce70f75a4e81c05c6fad8434c147862f552545894d3f8a6e93b8ddae02d83fbe848cde83f87f7cf35892ed27916c1c8c5a4497b74908030dbeaac02aa04cba0fc7d1b3ed8c415dca8eb50c43a9ac76ecfbfd2f073e860c090a38ee8a4493f7620d2b9bfdfc49f985bcb31ba2329898b44cbbda679116af58d7f9226c459537e09600222680c5f287a32e5f91210c2224ca32fbbfcc7860bda665b65ef47bb792f87efaadb396c8921891f88609530f688bc0a4b87f437bf46657914d6691c4c625fc3214f645f74e0c74dd86748b906982e71eeb9c3f19ba3030da4c29bcb650cadd92ce0209bacdc4fe766e9f05800d982ce5844820807c222b8b115210dc89661e5ec2fe40027f1a5046dbc7ff185a91c6407c11b7f7b70afbfc240b1844ddb7b41ccb02b470b50cf2f0acda76b0494945845cd2b70a496eb1fe12d74223d69d0864647798bdb9cff025800926f13154c1768df037d8380421cf9e5ef8de3cead42048f0803ef605b57668e8892b52056f96627da7af1392aa0d4c8f13062da5a271497907f404ec265c8dee265e02ea2281b0b7e94257fd464d20acad9882688fe62c8989e3933b92a266b4044af6ab2549b0c81e3f696556d47c2ccea4a057ed661067343c4a779943586a886128692d4b3a75dcf7741417925fd401c00db0bc287148f45801a8f0996ae67598497b3c77d6dbf4feb9f9340d86c8ea7257dd8208c0f032851cf0c54255912832b5a10235f2ed2286a7c667fa1cc55c49253b0782005ba07cb88bde1a18527c8a94dffbb12808eee3701b21186de845de65038fd7c061db025cf4015eecea774521f3ec146fd0eeccfbf526400b3b1d851bf15bc9cc4415388cb35351bd2e57ca8683032756ac8abf2ba3d9ba84faaefdc68cc7546dac86e107d0db428b9c17ed5383c16ec7edc9886ef3e1e24ce2bfe042eed7d05df56cedeba7cb88b1a4e26eb7af415afc17ba30ade99e2e9fc2ff8a7569707c72c29ec0ed4c8b26e95b99938286f8569007833a0f793b91ef7b1d75b232a368fa8a03f4b459e6eb3e1f235546963dd2ec52a15d9106311049eeeadb267522a029ad3537cec70cfa9ce7c0d118e92a37eddf38478f7e41854179fb58bb38c9587aa72661158e3791ebcc1f7b56bc98f992c91b1739263de9a3f78099b99edcaf260275b1444f69e9e54db508a77fa6d1153b059910b72866d12bfe209e3bc74903686364da7c859e1a975f5bf762c5ed9c177c279954c0565ae192bd99ac2d4a1e703e1ebca3a67615c6cd68852e904ce7c68dbb5da374290bd3ed1f67ba39dd93587fc32976c44efa89d31f2e63e2b360ca1d213e1dd0d080ff4de5c0d769d83c96b5523dd654b517bc5936898d90e1a8fac7e02f4f193743c4103a056803d316827803bda822baafc0a1ff3decea57773b2da46e57421534c2e192bd4152552e6e1ed28017c17b9fca95c42794157791dede5e23b153d77c5c917b57008a703df6ddda3441ad0f2c4fc44062bb14cecc512fa7980e3e2dbb337b0fffb66a97d6977b11bea3c929d449ce270507787f93f066e3a62a98f1c17ac41fbc25af73771f2cf47c278f16cb175e3b9b9053067e4000f0ee13d5468d44ecdf90bed5e7858672ed57f7333b7e0563061125e5eb8dc5a2d8fc1e60c29ae15ad032357604464e029acd67d1a8b0f45e8c79a051dbeaf4ea89f8a77c9d8d3bc5d2119fa467779a8c62925ece3667b561dc2f979a529d00465ed4dd9dabcd0a4b27f3994496a7c6cf299c01576ec3b9c9f7d23d339b2a6e27105ead6e0af772b6f37f0476da1a9b57e5f4717b8c43b796da767fe944e47ab8be11e781359b3a1781b406afbae7b12027ade5c9e53264d0fba0e109efceee56961d2940852487f7373791151ba2a6a24ac8eb64907a27f7dc1dbf59b7e1e779553bc38fe6097367fe30875d08a2af1cb326fa4c5ff2f3436709eb032717700a1f036d8b370aad04cb1d2f66fdfb78b86a5bd7aaefb074ae6c15a47cf84253dab42525299e0ff6a6aa60e5848fff06f477f5a6defa79a47b5786595af3f6a7a9b7860d4f0631077b9e9cfe9f305fec5a14cba3ce9be05d756670f07f9c5d7d7164af13e5bf3d920068b1a9927d94aa37ff18bd7ef5dddf23dbe6d2eb4716117fc0e1f8b3bc0915ac845a4d16e33160c68655ce5e83d3eb14f64406c9eaf7e6101a76afb20299a5b8be406cbd67f795a2a95c16ce2933f7331249af98f030b8751e9c6b47865ec15a7bcb4d8ed3a5d9a889430bbe8097ad11c7256a864ec6371fbfeb9faf8806905e805334df7f302113e718331dc1105ff5e5191d0d25885993a24b68b2c0b2117908302bc550e8a5334f0a94744dad92f15d2a4b9c3e6365bd646d049b62ac00e80c2449ce0551f066cc7a2197809c712d737a5d7b10ed434576a9f0ebf3d098cbd5297ccb42d928f81ce8a4a964d5f79f58db9d76f4f8877fb84507bd6853a05fc23a409fa359651e0abc23b753143192984d286eff1141c1989ef1542263b4469b798e652d7370ba49009b7acb63b772029a1564e7752bc5f9e815f13ec8cb2fd902d4404d5d66b3b54820d412515129fcc5b228ddd695c9ab00a17a8680e0227d15415e415c16210cfe70a29cbbeae1bf7cea29224c278b6d6b9b0290ef6dd4c1771410064ddb7cfde2c70c88d8ab0d2fcf3ad864daeed160e4acf3a016185e6a90053fa89e7db2de97408ac8c305c11a94db876578196fd8abbbabc5e0e4da81f34d0c93ec3f5c39b9b8073213e3346217ed8f47aef27e9b829d08c7f54583e35feaa3d8bd904bf2bde1f84af89908994e6fa6888d7afa5f297a793031831e210463707678c9111d4ce67da923fe0060a1317ae9e48bd95f600e2b1022767f79585e3031f2e731dba8e7160b3091763064f4057a38d1afca0a31c8e20df4b75259de6b7d31017829de58e6e7812bbdc3c5301b05cbec9ca16a5e7dfcd0bcbc6463c2867f9e1050069b5ab81d728e00750a6e924540193277530311a60124493d31051afb4d3c0f4aad9123ee927357267689c7238e17e0abca5770167da047967c708e448707397754b694002a6ec9537a4cde19a1d6ec9d5faee3c4277036a70d37d123785d604df7afca5e1e3c24423c00c35f9f58de0886d0b7aba5fee094e1824ca6e207e6701518a96e374811d9b2bf15453557edee15bca7486d391b259f95fd69f7a5eec5c134ece3949f2b2dbf54d541c3afaab7fad196e7caf5b44c057774b834204082dec4115fac4f2e2b10eb189a10cb28b450705277259be0110474c5b294a52d33b24ea45eb9b4f591770dceb60a8f8ad0b7188e6a4dcf290bb566bf1b1bc7b1778e24a1acf5952d799acbd672fea25ba6025395de05e92886b75657c47d5fff1ca67ae28fb5cd55592d8b7f259482bb57c5edf1d0a3587ff90b7e35cefa428d7ef5a7b019f42ba8c21877c0004760714aa24d29fe0efd47807cdbeb7e73c16a9bd91a543efae07b03ba0582785e022111d9d5a2252ddb91dbd8a2d7e4c28cd4d23e09541bd4c22d840f1a5efe4ba9de46948dffc070420713c667c59a4e80940b7fa4bb4fd34834be3d8149f9dbdf1eb78186e420c18593dcbaa2c04cc53b46411430f0f4b53f22786e38ebdc2336fe9ce714e60aa6d448773f178b371d10ff5614515a380a05376751b485a3e9a6e92b6a39a3f6f0eb1e2889ea0ac72b92f55ffef72bc93faf24b89e2a1646f426caa169cc6ca839bfc7cf735e99a5280d8b7a87024441093f4519b2a241ea013b534f260739cd98dcc5d89b3c514d2b4e5ca37cd1c91d623c4f120548268b4971e8f0610ec5c12156a5890072d01252a846f193cedc5d2cd09a4f4c451685b8f8a79cde85c821164ab9202d9d33c017be31cc6c7c8fd6b960054326a0ab3f92b2a35da8c554a99bd04d94dab2062c7f7105d5a8604ea774397e535b9678cb0f5e048ef518a2166fbe20f54e4e0fe57178f29080c049b115108de1b738573a223caae9957bb62ed3b8b97c5bc92cc7642d8dcb8f518e93169075d200a6df167845f8a450e876640d00e7008602821be639d0e46f18723cac6e1f8f7920455fbbe54c2feddc0e60a50a84e5ad681ad2fcd26cf4b8f5d494290ea2d4bbbcf97881383a8d948c56cff7161b9a118c05fc3a6aad2bcffd8b25972e8d884daa2b547898f000a684a3f65bd4cab9e5558ecf3485acdf54d6077e30f49be3788f1e1fe6ae1d7fbb21579b7f2c3598e546f39ce8cab41ae0e6414fd54c7d84fe4ff07d4eddfbd506732bb88565022b87bde203b52464334f308719d5d3e555f8b1f0a1baa667c030618d9f8f408b6c3566e34038ad69db37c4e51727a950192f65fb4e8ca9fd5c2cf58b42a89ad6b738962c65da80d135f99f9df3fc640b714c7fd4689aa6610f609227a79797384f56c2f29f00c55715490074c28c70ee35eee23765c2b54c9ab3afed65375fafdd5ee9da208e7c6d08b944f568cede8ff78393932fdba982d40ec291d247b7ae6e96a1e93a1843838b2c4aec04264f39bbd30276534e3d70db63b5128153ccad5f38e8422054b6c86fd405d4f33b0cff8fc6fe7cd729f0208cae00c987c8ca1cc1c905060ed8db06fbed4889a091afbf7c513ef154631e7574f7a08d0eb609b83b8a96aa4359063a314766919a1bfa9d0a2f4e9d53052a2da28742ba7b7b6cb9b32618ae4dc80c83ad919a70d2101601a5a40f8ec5ea483c93f4dbf6cbfcd2fe35e07708deb8a48caab7dcef60e7c731e44e6dfda2b96c1d682ddc99805f204faccbdbb11486594ac2c05cd90f9bf8d99eb04ee65c2cefe6dde634ee5d38d5d819ad53a933520ec442c73b40fc751b4e1f6803b1c1d1474bae23041974fd53dd5107ba36a48b5c8b29feff5de00f688d388cf29f276910a9465e2cefd59f1b27b82678c915055dfb63d8e52a05ac9157654235589081a27193e5f8e2ea276c9c23fbb47aba9c27d31b7b4ce4d1ef1394226471ff50e2b188525176140577b047f6362bec1a9800aee33e87f691d22d5316b6884af007383873376453ad911391390fc0c8ad52e8609eb2507a0843af23504962875179df0a6145e4db41af856d5b836de5b71976c543f121b0609562c94247729922c5ec08d11e27e5d66f7ca7f584b6661b14ea8add3127631de9052a88b26b75d775cd6fa23cec0da7f1147f6c6f44d6477422c8043346d89960bbb5c00d6cd327c2c0ca9f936456f8beaa5a6031a7019cf06feb62f3d9f43f491ae8710f62da5293e81590948cb902a10071dcad76b5e2ddef61121cdd1ed84420d14ba3ee15717fb23c434ce63223a554581f65dd6daa6fc89a23fa6187e0714785a158e92c2621039b518d8d41525226a4f337f38f7da1ef36edffde8b63c59f8fec59cb6b4d459b44f376de8071fbe0c99a85e562e8686fc6b9f89f0ed2420606b967e951a5ecd9a2448962780637ecc6fe61a68d14fd35de79c15d0e531d9a21fd0c86a3638ee26cb2b1f71f24e84b62769991ebcbe97d0b70a59a0f6ed75669ccfa767d1516dfe289a3c6ed377b0cc160636f24980138ed48766971f4fa3dd0b53f2e5324d70830617ef3b2eb0f5c2c3399eb5b2831bb4b137a352a20172f638fecaeb6816a59646a471b378ea3033a4e9b654d75f7031e3fa4c75775fe0cd1f2cce65126a764aab80219a28b098dec1b0f8840658a3fb42cfe7933d55ca630145baa979eb8d6f387d00dcbf59e2a7652ce6b5b04c759ede2f2353bf14ce8078b558aefc9cb4d6495991cd5b6842280f112987ef22bb5f573bf1070089b9afa221bbe15c440d258574a7e938d2c5a148d971f214246dc628f8217bc9ce25e8b06630f33c3f964e68e0d7505bff302f5583cd55ec541265cd003a5f09e9dd27adeed6613163bb1ea4d5b7a06509f6609a256b4dd277713a941e6c8b189c2b9598954ece39968dbb5424fae214c1d7df39864af308c1c9ed6d84635128059a762106d6a0f0d6a72ce9013ca193070e1cab3b3123f7f619c9dd9ed9638c3fdb2bfcdafb6b6573d23ad2f2e989f30da182c1c2f058733ee00e4d13442939cf02601a9ba626c470c8881bbc600ef63ac4889cfcec3dc8cbac84fdd58dd84b47251e1a9b9828394a914c7ddab70a33b2e930c8e0e102f53ea8357adc11fbbbf0e59e3d3b836427bf28352b6c6fb0a96a4112914c5522736fc69e563494466c74057c41f7339b986d9afc6e734688643111f1412e6427e82867bf19b7a49f28b8ee2095331027324794f3facf7256ea788dd1d87bad4a84c8e6f36ba2c4788977180d8c1a581d23c795210e6317b5d10abfb590461d0bd238d231bda6768954a1a3154ba5fd7b29e4bb57617e120098899ef42ff75f60703b4be7a1f9f069c33722a1d52908dc7332e1fcaf5c1bd1abb633bb358afd87eb17ed2db4092b410049fd37c48fa8208da47c70266a9591ef37af267fbf8e441f2c6f2f62a27ff1935f906bc4c3eab6b0702b6dc614ca94b8b3e8a45cdfeb4e8d55f8f2c6347e131200d4064c248666d65d88ab7a5d84bf3fe1c506a8faccdb14c270fbd27339db89eaf935f2e36725415a2d1f852f13d4b804aee0a2bd558b2d76e5472a9ce149585fd4efab54fd346e63d240c4fa08097b0f3ed4db987552908f30c2d5c9f16062207a33728b5043883409f45ed5bb81c7689196447a9301bebde41f8d53c6de1e9408fdbe938def1d49f693488548a8eb5ff85ef63723ce114660320f3ba99bd885fe52ac8c2fb6e5f4e8f70062e97d5eab4953d729229174042bf6c505ad5bb9f46f9bbe58ad4b16d1466b3508a32f36fb0cdf729f98edd50e3d88301fd8b26584e3e094fa76e4b7f082f5803c2901e63bcd4f715829c0b6a88634f537410236e12544bd7bacffe93404383bb4cb25e652180a961c792006fd3970e5aa0ee4b36d96671579eede116f158a6d609005c7283284bbc3e776d46f6d0bca8754548eeff93d54d7104a487145fc3341fd708d3b95e6bc6bfe0a7a74a5b7b1a69ea62fe5955e311b0f2b615c02b6c5308b2dc5273bb55d6891028c9781b309b9d86cfb29ad3d00e8e8a03030ad824099aa991b0fdb9f60dca2858fd27873871c750fd93e6b60e54900a66627182213f2bacf5f8fb2c58ee45c07db3fc59d0c121d65f5a3061db9c8e4c62f4fd166b22605afef89f5b2e225310f9f19cfbd9ed491c7167cfa39cdfe9a464f42de19fa23d725d41722a227b87401afa314e931a80cc14980e290efcd39214fb1fb37ba95abd24d71fa6dea9d9888ce56042d7d8f45176e68c545d1c0a35d8aa69b348632ed98b0adcbb9e26443a008549b90c08e22243bd1ec5cc88d93ff56ba70eda1970d41f5a3df6d950ae287f94a5a5cc40a17811656cdba7efc379d47fd2cfcd32de12d03351390b5622344019d788997c481d761d126945541aba3be9f18eb6613b82b11bf6884c59e385e8fce367158f70d1e393a955b786aeed4aae8e2da8ffefab2d8c736b303feb556f1c58f89ceeb302489da36f8c2111f8aafaf47f2f9cecea0eed6dbe1aa8e021a16fdc16","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
