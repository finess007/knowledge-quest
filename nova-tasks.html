<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a88fafe5a4b139bfaba24c82ea3bbf4ad165c1f9bdecedb7729f29f38273c7f66d5b2c851f3480ed0d4924484bf626ce70367f874575d5df876d3780177ccd45b65a3c29750c5d0328268041f6568b3aa61ecb1792f4bb509b49ebce0eea0b373fbf6d12adf5aabbfe956c9e3682e18c8e806bf1be0afc647e824997129d1bc03826b18875df63fd6a6be19f22524aa33120a363fae198c9faee10324c84da8d200ee577ce00ca3d9b84a4adce4ab3219a90aae0b08a8b968ded80b36c9746b24f09390f25a65760b6e446f23556281842f7d9633ac999e94ca1fcdd6307b2958d9668cc2f62bdf5ba0760cb1b5590f399fa0598ab96438f4af2ed9bfccaf3860448b4029f2b4f25cfc0aa0ed75d03e52c6a1b947aea2c29f32246c007271a0707689ba53fd09d89a967c509935f365f04566e3219122bc8b257ee592de1a77293a343994fbc1c3945607364a56be3f08fa54844084d691d620289e765e72ef3ef97ead83adbf4636ab873d78a76e8fe7036feef783fbd71d44fb806fc1e13ff7e04f29f404708bc8d6eb6df072037280c852917fcbcfab8a899ed5af2de1d5989c3371b495b32c51399aa2d2aa969229eef74cf831d08c6bd2ede06331f007af386aabbbf4bbbeaf3352a1ac6ef5aadb134ca0145459621c7ebb839046830d3b2df635c2d29decce037909119736f5a7b8200d077f0a4d68f98eebfdf5ebc07a8ce7101029d33d92f2de856aba6e708e7939ec36d9612502000781198bdc8cc3b69b4bb60fc496a7b2682938014f773e5383e839bea826c8fa3dcebe81536e7092c407fd78422126c4786b30e5294a87c6fcf2cd9c028a8bee325457ca1212f154aa238d92491d478750b7431e96325002c3a5c75d896465c7477eb47509bcc8d35d206305bbecfc98882d3b197655460c0030c7385938e9fb9deb305cfcf512c3d239cdc67471bd263b68f974f399ec1cb83b81525d21f7024a09a99314ac26fa875a0e948d85d73fe49fba4424e4f986947ae54ec1f9e6eb6fb9deeef89784a7ba304d007f69083ea78201544b828b4c3e29d8c5694ab4769965b5a8f9f4910be7b5f60e1a019f799c1ba9395a67aa8cf477e0c1f664297dec9cfd4a894f0d978a1a5b60b1680f9d055952b9c9a8a94bc892a4ea9078b076cd0c7b0c3ef50c666baffeeb77b9f75f37de5d13ad382d4070de192d78e01d377e415497197fa989dae3ecfb87a429d2f16c104e8d505bd86d250228f7a9f7ea7c005f11c213ec78ba26a5a0576673c32c0fdd63952fc1ffda35733000d6a6a643f6b4298cd0fec5b3394dfd206522e0e6eda9bc35088f5396fd42c5b0fec9040b3076f75c17f6dde00db248f67ea1c44027e221be681941ac1504ab482a38ecdcf029a0a8fa8b7c9563f720eefc01745c2e998239a9a21926557dcd8b19bcaf888f90e2cd7a9f28b365a89266cff7207b8aea0b128b9d0da5b9ca192f43274a4b727ec869815dc36da12eba4d23d2d0e61847dd83a43842078fb208cfaa9d9adc9ebdee0c181c40a2425caa9855d4c7af477fc208360a10ede6bb1a63350a62621d69bb1c6252a51769c59bf6e2d94de1ee172b46b0da5539cc9e8d0e7f5726713c3fa7e1907774cf4b53133f6225523d8c0075926420e482a2ebae0c3eaeb245befaed4919a92bdb201f15881ae3e29af36278d52f01542493101dbe1cf0ab8dffa10bcdfa43e544116ca1a4f26c3324eb3d052ca08e61bdb28e0cdb3968512fbc2be9e79e7ce4e87572d42ad419542472fa200dd449fa193a083bb0baa5cde77a517dbfc4c72a8dc01b078f62aed34a92416bcf79566f2915142b7210f1dbd4282168e988e77e3469f0fd58c9be596bddf1a09eb1e0201ba9b7471019ea5d86e36190fa7490e442d6cac00e99b6a2cc61538b9483a918840f0ac5552413eed6b308eea2c6ac072ce4de6191695ef9590fdf17467d57bf87ed2edc9e98ec171dba0c35bcc15aadd71efba5374e12e27528cf369d4ffef0179bfb5ecbe6319d3269cb14379298abc65951b8b53e0a2c02a793c112a9c6b32e1ac5c211aea1f52a1c79352686563476999c3b28d672f8f8f2005871c09af021bed7c0507e2e577b99f81e5addc69f9393e5bfe2e8ea388d325145c1448f29407a37221e100eca5516cecf0c4a74f9e0f3c40553bdcc69c16c21e8b46eb668403f633e0e8b8983d44c59c3e4c6bb4441f9c3a5110283e55b1e39ea859b7ad2e5f20ba917d2fe7a2c0f21c6d46144d14578a751717f2b8e7ae2104c85bcb845a6dbcfff6ef7e1db02be605c5bfe695b3fbbfb781f416e6ab5554da7226a92fd342c12d23e5a69180be954898a13d9f9d1abe7bab72d0cb4cb4ee918e00e40029c88e3b45260b84dd5e22a9a1e44d72bc12c29200fcae2ae1f3a1745e82c6f16a406a08d2d302a52d059acf979f86929f7ce6e53a58280cc91c6406fe13c36fec234284eaeec954121134c20aa94ddd56960eae6655384a023635e3dc3967a5fd018172e51130b17d343899694fda16f33529976736c4ffe3447955bd9b92f310686a36aa6c938e925609a602d61073e3887febca7d20fa9355ed08fcc62e730a5ce66c59c14a4184c40316d72c83df7d69ca929a8d8f86c2fe8914dd68e94d8cf5e461285cf4cd0f179559543f7c54719dcd17f4a5adccb47fae1bc24811c4d2b64af65079a9f11512700d9081b4a268495c19696c4b21ce6b0374568cb320b3a53aaba0bca6eeffca1e2c0bcf824f542aca847b00cd62413b13cc374a227ecd8cb851f32dc2b284ea3274fb7ae84e6bf44bdcb225a612902a38b23584c5b62ccedb42da41d5b750b0e3e4a4b0eabb9d9c645bd07dd3cfd3cf95d56452135162619a253018b992ca7451d002cd7987b94657fa8aa50ba4b49015d3687b1447f0dccc845e62385f61d44453af8d52e716b5e7ade5f7d918439a341322a1508f3da558f3a3355ce55310d4d4f7102918c1790996ca52fb744c35be1431ba96e88419a2ab61a3dfbf89afd869ad1658430777d1d3c7d31947b2dafa0e9c8cbc026c46810410e2c7945987faf08f39eab233f2a8a4506ac8b264b9b99fd3e5414f89e0691f7e489fd1f38b662172fb906cc99e9193f334c1e1ff6e0361444f6c6163ba154e813a9d3f99db5625905ce636ff1509e2203d7be575924a0f82736a17dc847a0a9905a8b1981ce017b97de24c5fd74b50e1b0be546d5c84e28b80e5a5f555ed92d91fad575a2c105ee255083d96d0ec33af95d022b710a9c95fa991fc82c37d530a0da7162d245c25a7810fa0d933d20c8d03cad05cc49547723cf95d71122df4ecd66758bf6af715593f79646313bf20c990a3e2b6efeb5b9a5e2b43343dc5fbebc90a334005b86345bb9f4688e7bf7282ae15ec25899ccade59a6167c462bee1d80c570e89ee23c1836330f45bd21947024cc00a29d72638bfeab3659098f0517e91db0fc6c4b6598897982d3aff8e55ef774c276e6f502a839de26474b5d34871a0d9cbe1c7b87fc3ae1bcedca29e18ec1b4d62ba5a28cc11b4379f200ee2a391c2985540f20e1ee92daa5f8983afb0b31f4098ed46973f55f151ed5c39c552d6cf4951cac7e0230676e86a4eb6be94ab910f0ea13c150e2e3040b0ef60801ef83b6f13d2fec3b11d00ce69861e2e17b458f5fe836d67dfef738d45b7bfbf32cf085109b0afc95feb1a4df05e377d6a7a5d32b6820da5efe425888b3a9100259b936d4676b2946eb18c09dedf03e8103fdb65135a84da216350038b324d316e21ab74980be3fe5a9421964a5072a948b1d19b6d29c573fe376a4103f12a5f90cb4a3b000f40d4e146041e49b12902164fee4170d6468ae03b7492997fe9cfb9e6b6ca4cf5e1ca4ea3b1c30f86cb26360c761027dbc767f43c31485a4978bfbb20526852af93eb3af79b8c27c31c50bd7375a5d8a2e91d0988422e44cd570a7f4fb4fe2247089d332571172175a6c795d4838bdabc79ac0d064b953b3dccf441351097db7f74034e6778a23d94381634212d2f92ea74ec49fce16457a14057a9a55878cadc01b5c1428decef25d713d0281a83e67fc06c3c234a2106fdd48d3bf73e6457611cd709a09a9cb7c38e2e5fdb3f941ea28c889d7ccbe9678a76756aec41e0a57619d3fbb287cc9fed8a8f421e799bee9a9b3bcfebe49f7ccff980fc12ed5eb67762aab664c8915bbbbc6bda73163a7083995767a412168d916ba74725efee32aa065b0e31a1428e90d3ab0f1778b90ae36dc8cabf047ce2984e9b181810998571b632137774e6299cc1226a8a3b202327d8739dc5f66468c6e95f2fbc5dcb0608aea68dc1b76d3a111def431dbb66e5f53e1418fa56c16544b55b5e64a59317e55449461cf61e1d62513a59feedda75396adb1231b1b4d923bfecb4ed350ace60dbbf07e147ca1f489581205d50954ffeff52a580a47fdd5562a0822a4b1b90ba3eebe681aec5f5712c26a37d1d2b2c105adf5057d6f675582b3477e205cff1113981b03530273e14728a9d39edf2283d1c9b561c860ae7350eca075581d79c79ab5f0e685ff109d644283b4f0d59f336935a70277ff13ac34d731534d684d6f4c834b6ca756a41f24c7a6fe6c6458c9b55e77543b1fffa637b87e53de329f98aa0004aa155a3583e2abc3324288a5bdc10f362f4a3cafdda86f4424b615466bd97de2377f05250c96d174271fd15046f5606385edfa463a1629464b33dd311d22cf03d21215417c93c2387d1eb085b11d65e3701a014112f6ef2fa226a1dcb85b734567bd452400fb7d25950075f44bb6e06fd345d00da02d88a78a0e8ea1f89872b41231631851ed131b2628c0feeae889664f2a310307962b0487ce3018db36f9f3f1584161e9fd7b6f5661230f405bfa5b0c60ab6a0e28d959ba9b4572c41f948854cbc7b9b65ddf4f25eb8cd0c16d4c6242eec5e3fdba34abac2fb45605820087eba6b9b0e94fcb5197e8a8bf964d47096afa4edbbe20c6795324575961a5404e7f8c9054ce3854bb042b2ab81d825a5d5c8fdbef5265ce7d55221010c5a5e8c48aa5df4806e9cd7293f4faf7a050c1d898b70379feacc226f358f75399882a763dd9eb5f327d96d20510e741820fc9f1ed6b00049bdda8d68c0d7ebb2062ab475ecc0925a960a4547514afb45e7762391893289aa6283ce8970e41ab53ef351cd767c8d48ed159a8053a0e4b5ce7ec101f6b1f516ee26a239f2922d2bc627f0a79a8c5fdb1ce83f872c6ef9368994f317bb2f0dadc29ae5d606b68361e7088ee2aeaff4b90378d0f4ca7478f7effd51cf2f4a19640cd5e9524b4fdc605920d603155859bb7d0536c0e174bdffc4cf198a4ccd50f38800c93c88b73380101566acb1a6facca20de950d2981191f506a64ad739844b0f7b0609f812f253a10ff39fdfd072727c11a57ccba10eb21d4e1d0d41016521f9588a31a598ffd2de007ff3794a9360526d421989e0c888f8b2cb7a0a90455ecd102afd469686fca26814b3350a426b924ca8b2ddb5dfead96f7bc2b33db7b57da73930a84e795a8ef849e7a74d723c8632c248f9cff2c340048b1d80da64a93a3c2eb630e8680a7d649d52f428c90b64251c2c0ebabd73f29e20e12c8169ac216c42c8640bfee568d50c91c40e77a5c867b487f28b5be73415f25124ded7929eb97d65da579a3a82b86d1af1532306921a848bab25653251438a14bbf502549ff3f1665d158b74cc94cfb62ada73a33a9243d9761425806c201af7df459bee5d300a871a876badcffc2f8d2cfe11373a3b9aebf5fbdbc3b59e3dc6c04bcb92bb30f827c50f34ddb4785053ba3ce8495d87bc3b06b4139a2173238db6a0095586dcebe94fb48a51739601b86bf60084afc1f03b38cd2e3c0f0f81e8d65a6ddd6e654865f2d8d9086018e1c8a72ac09e1e4c376b3480bcc80fef51e27b6da03c04d2caa38e1a8c3225d0c1ca3ecb367088d025712c8bfdfd9666dda0723599be28530c1ba21813541b8d8d672997afd7e339b1eb2094bfdb6299a3c07663e4cefe7a2ab7cc8efc45bd6420763eb7d11f87b2a8959391a5c23b4cdb77ae9c51119c9e16bbd528f44eba16b2eb59c803d04cc11157c74700f0654752c098960f7a9da7f681b030d630a2cc17450de25f59f65c29e1a4646b1a3872cb581c7387ef1a7c81105b586fadf95baafa1b9d1dd82171610f2aceb00adbadc6c9c2ff45639d3823bc7a1594cbb0c12014951c106df38960a62ca6b0f30347adc31d7bb44ac779a4c3a48b4c93d01313e80d1e7209b18bb0354c5e54a9cd25171af719aa914138e7d0b905d1dd4e5eb7627812c81ada3bf411fc5f04e563d5de6f4a7029e702403fa119a034313b8e012f0b8b8e10427b929c001caca561015b7a3e1c13bc16c17fbd61bc0fa58d766ed64951875f6ba4fe4c2d8f5608f83690abf501714ac86fdef7235a5254205fc748d69dd870cac741d4a966eef094136c2f78f474b388de64b84843a7a53ab8f9228b9a97ec69f6a1534aa92e68a9187957aea071cf114bcc29cdf4dedf9092ffb61f0f6ac0c0a77ee1fd8479b806d1ff0e8eb73d45a12aa28bfb0957c48efc5874e11adc8954952b667b80dda05025689a0920e78955f5e82e80d401d803a3c5c551e4a0721b7c3f9466e70c3b3027993663dc4b9b87a4945d1eb4e0dbc758da4fade261701e3bdf46d334be0384b350f0c996789cc85865f453bb1ee465b3d2a3404bc163c02c8d7071cec92f1526d571023e4eca2549370ac1665924f3ea0112b246d6dcdd8d0f393d6a852e1cad269b58b9e7870c7605974e144899b8073ca9e8967c316b39808241a61fed1337b6e0440531cd7784d7596d33f418f4568dff00e36867d680e73d7af240b4f3bef57b7e905d3be7f70c67654af1806af18341df2ea9d855d23e5c7f149af0fea2c1e05202cd2eb99345763a2258550f5417f7ba77a84924fae408a091a9450aa57065e2b36e85acf959f22f0452ff8b298a7a6828f71e9ac1f8bcdf0a17daee7836f2811a761bf1ce3aafb3bc054b873c2c7c32d05230cfec4487bcec768ec24a6075c2dbe2fd9c63352287ce35ff1df26473ffe3f009c724e249deca00ced2f6a8ccdc346d5deecf0415cddb87d7edafea3a6b3acb227260df05c6543b5ce335f959f58cac857dd2412297567499812c4fc3422ea3d116e53b8e09db98b909c60e592c7f08c3771fcfdaaa950ee1c5caa1bddf0ee7249e1861b3ecbec3dafe45f3c4fe623ddfdb5efaef279faf9983af9a7251c54925ee0761f581d52ccc005524fc0232e02a53d3307099a763a19ac361d535e52aa0aef64109a53f284790e7947ce980f7cd4b15b1a4ba52eb654383bb9c9a8f780ad028642b0216ab6ef9e6b94dfa3ff8ed52ffab294b8fd0e585da0338e0233b3c4fba7789bafa13c06674eca7eadbf8684175f745e04756e2657e2e17fa1d8ba3ba1be3fab751830db2e50bdb9dcaf40a40c78f90d3002cb01e9d13e8d5299a2d18d1316370a8fb42eb24cb16337e34b0d13f4ae4060e1e5c818bde99e50c2472806434da64333daa34978cfc6714b1a1843d486d9ea81c1f7f43889da51a1a6492db1d23157146eed706857cba6a1b34260377024355df2a78d307b908afcf4c370ff6f1a6ad58c4a26aa746f1bb40eece6238deef9f0edc781e5edea3a057b0a1e993f2922afa997eb1e3d28a57c624fde29b0805ffe0aa3de6898751bccf70a4cd48b58205753a4b334b8079c36c3da4f00cc2152ef1f200a4d437985cd8aad3e75e23988233b64c76c7c02a6d37c10323c49437373bd3244aa40b12fb57f660c6c388917534b7e0d55a4a9a6a55b4d5102bc54b9ccf331d9afc1a116d62478cccbd7a1ea1cb5faf09f6f74dd99c285a87288db4a9ca5d9334f7aa1fd5cc567824e7b53a222461bc88d6315cbcb0609ac45e9f77c187334c451f0442663357715fcac82b791c8307355dbfe5741d8e617d5e69ed478d0bd56b64d1f6ee9d8bfc99a572d136a749fac21393e23d18621026291473c98b06269a7585a2013cd67c98cbdfb9ff8af9b7460e7b55649440dd8c7a5f577c80716b5732fe67e21c311d8999ae987e4640b86fbc399bc5b796816727691a88b19ab07b6b6063f8cff0dce6df64a4a6f2aa7e772a4a90603250fc398598746d8b32211b9c94a0de84cd2a38141e0bc782e5101754ef5b30c1a58fea0623f557f6e619b2951005134dd11a3f21eaf519f4f7b50bb4406de5ec6110b16dd9314700597b6e971d49304b3133e53cfd11ceb1c6fbaefee0e104a00f9e64eaf0e28bae26a103026c1dc0d4c22f6dd1cf1e3fca54c884a7bda641276eb7a45803d3b3bedbcf4d73861b4a97e1a08180af4226d8bb399bb0bc465c79436b629070b47617542590b5eea14110bdcd442e7e73c46ca0515b9b332b93f760a1088c1ea2f10a17e489bd1dbefaa1792a211990c6191b5bc4f39434c6c040dad90224fc70e73f86f4fa34761553cce9cfe16ffee8ae4a4acf3903862f538813f422a731e9e4606f62f5b6c3bb76a764c3e90a79b6b6fc59a84448c687d6297f983685bf8acf48c5d0da68466bcc7dd692d51c8e8ac685b39f2cb977ed9a703a374bd34021261e0c0a7b4404493399d3d5339b9341df014ee32e491a2b9404d942fb40577be889edffcc0249b9ad57c1668af9917c6d7e3d83f8866e963869b09cf9671140b6b6184276b62ce220a1e358baddd7da28fd591772a0cf175709c7fd044396fee12672c61b16e585de6aa76bf2965e342c65768f895954ec4ae5cdb4085880bc19b5c4dc57e6f8276113f2b0a4162e3cf80c8075f9456a354556f70e6e8af173084b266a1502b0473a038a9a8cdddf47687ffeed5fd4fb92a8c322ed15a8dae651dcc90c1adcbb13cb434aa8cc9a95def8d7220b2e0bf066befc366acbfce13dfa5b20c3c6c7129912a7f21111c20a1478becf779f8802a9364f13b1b5a573e3b8f99f3998b66256a19445f8de855b504a6a2cfe18f87b4e7baf7e74f175671a0336a699420b419095d222788aa60c5933eb98201c0ec8d409d5e32bb8c4ce4f1c2945645a69592c00b3a23ee3cb0e5968f1ce99a4e2ea8b1ec4cff15fce8307a79a90e7396737960441947f7052cafc99685135d739c00b7228e65f2f312a074fb878eb12106c8999a8bb4ea5d89e93613ba03170335636bcc86be88aecd85304de3fddf0f56225c58489574f6f6c6bd7b1bafb79f6547e5f364f60f12b3874b8fbf18c27f9414686c531ea2fe5b4fbfef471a6ce3fc7be02c6805429c81937cb8706f9bb08de8454cc743437932f582a34d2d9a1be0ebde331a3d4f49321d88780453172f3bfb68a25a1b22bb2c056b7813048a46563234b81ce7ca3855da1b44f372b787e35b3ccf1720d906eb6aee2495960df910396fa0c1f4856f167f629f153520307a896a1396770a3e05af4916817d05d51e73b9557547eac09d24b50fff99a7105378bacbc7d457269177fdcd4e5bc05ac185a18232b73adeaa3fe6fd0586a862dba1380bb8e7b8719e744400bb706528051df27e63e571d9cff54674d538f0b8fe1b8cddeb188175f8f94c6fcc68e79ce2d9f1b2808265f270b1b535d27e75571b88b8238fe15849f60a7feaa9e8d345734610fd9743a606d5763ee4a6e753bfe4420e3e78afdeed7e09912f722ee3093cd199eb88dc4cd98a574da08118ad61924af073c7c38f669fccc2ccce351bda02b09b977f30845aa9b291e72be6067998fc470936cf622f7a5397bef47358532a7c353ef1f20fada72402374f6c5870c34464b1ab055ceed177e9ad8d50daaea4e27315bfb8fa88c32a84dee2793b4ac2e13aaffc585c29ceec395efcd1007ea221d0573e193f5fe0e3a60aaddeed795a15bcb5b6d86a0cb793e20099150c87cc3b19439aa5bb1320198bf8c77547a77e948ca2efd1e4b3f2c798621f4981e795f4d27367c9d846be3233e6414ff4fa706eaf8d0a1fa14dc7826cae135bd6d6afedb45fdecc194f8fb87b748f2d73d3f6bb4848b86ff5d6fe50d45e23eced951737e18fdf7b34f1fe5e0c9579f1d5ef5b43753902fa741c7213b9e237e18e0b7194aeb634c3b15354ea8a94a5476dad8039bc48f7af9ebd358858e574ea7646cf76272354013f502c84d03fd7d4f50aa9382909242ecb0556c3ed35026624d42a108926c75015236dcc80e37af37baeefc7adee14e04b6e2b30e9a2e6525329c7847281ebf6e91559cc95f1fb22e182aae435c7fff458a0d2e4bacfef775f84df27144801df63d4b63775a92ca8e272331a20d117efd8600eafd25be100ece85d710b4676629a03a7fe1fc2e29153c63815d0e70f50d64f47844500e90945d8d347798ad2ced0a8ca6c4a914e977092940ea84ba4d7cd30ff513093d8f3613ac8c6a6f960936695ab81ea437fe453a8d252b381dfa3871bb9cf2163819efc5ae65fe22b737baf4775fd64c148c296f266b26903579e397e8232c7c65a817e950ee0fbd4b90f53140348206dc818b514a34ba454bb2dc89d82810129367f0f3ffa452315abc048215550fd83cec029ddfa979845d514afa4cefbb888a4907ba2e0e792f9b8b539f7de5b98ba5f5b976b44d4768ee68ba18005b9298d3ae73006a3e39c6a6975d9d8ade51770ebef1266a4d39fb9f34eff56d790590f1a5f3a384f4370b22eae9f95379ee93678d34a7826c5df639cb0cdf27c818babb6020f98e5da8618680c59e7049cce836dc8fe32ef9366f1a041fa927da858cfb5d47b432ba50ad85c77f158e18abcc635887663801a2f6c4c42c0199ebbcc6109d84b77d47aae61f178e0aa0f399cc483a0921ece84bf2c57b612254b48a65a497064daa63b5ca0e8efac0bb984ea56b7e73f2487a24925a158a4e926793c4e096df6a33ee24b5b228142ecdcb8f579e46f1977ab3cf6135ccac983a96f23448a52d797a052971cd0852168d8e09721ca7f77eae2d4bb7d22f6425751178f5090658faf7f24b0a7a2f524aa9baa3722edb40ecd536c95762798dd73d36a55bb1e9b0b7c8c30bc1c980cdd1d0358177be7832cd199af307a0f3f21f7b9691c95ed2253b0e0f1f1887d21ebafc027f810cf83cc241ff129474d9c2dbce6dfae9af064a3e8b513c1ae7d3cd0c030540361777e881b44e91746b0c2eab319ed40ba1b3e958c3d5c7098b1ccfe650101c49f427e49483f7f34f6f688aa77c53e414775c0af28679e08ad3214c8205c661b5512885fc55037eaab6ff7c13bc6348739a41850dfc51adbd46e0bc8b2a98aeb2d5840ee3c563dc55db5e0b334f531d4cedc8cfedcb11ad36d167a43dee7aea17ec4e538ae6b4c1605112916057e27d57c82e085689e1b0e11287129c361b06b959290d5ce73c3144bfef0d7a35e1c19ec5acde31285dfd5403161b1bf4be7fbf06423cac4221a06b290450e4961b94e69801c24c6f08c6af36984fe57f9ce0e7b0bed39d9d9ed5b780140537c4a640aff98c2daa15c111ce665c465bdc9dd90d1ba91a0b37a8b94274d5684d69ae0292a213717d40e2c20724b19a230b807909e3b984b4d0b65cc64fa0c88298ef8953935a8c71dab17e137b80f0d18f9a96704d9f08f0d105ddc6ad441bb30c4a5ed8ad0b89cef50f7165666961f63a2e8e3011d34508571fb23ae1a42420d241b5b779fba383f68c9d1008d15bde978f8f91379dfa36c06147e103c382828cf72374f166e9d7b16eecf23244edc66f3d141b976c9232ff97f8205756b27d537fd17fc17d15993d8e5e7936969b7826a9487b0f1ac8fe9bb7beb0fd31850d57b25a9fbac41208fce79fcb7181cbc868a9d1525b6e9cdc0280c25b523147a8f1431e9dcd27dd98540870b5afd1e75349889ffbafbe84b2a3824bfa410bda85adc6fa5a94229ddc0165b922b061e312a8e3406df7785cc52b3ef750805d8b14d80c2fe83824fe4d3736722e26a686f1fef1bcd433080298fbba91d78b6d21909d689ad27fe8a477a18b0b24094f428b0a93170d739cd4ec469bc3b76cfd63508ed6e814ec85ade75a3063c01c0ca11044d41a3760ffb247a3a5f34071dc777f82bf791e2bc3c124e85a16e404d4e31bc46a9f8a9972719166d92c7c7440b095c9b70045f47ff98e6270e4d57ef694f1e3df56c2aaa057faafe0507393b9e15db9a448c237943b39b54448129818e3ac606f186a8d22678176d01f26f553ff24ae7f4dd0835875385dec7d37dc72f07aae8db9b3c3141d59655d90ca278798413bd6d08d722afc58c8a9268569fd516de76a82b69864be0ae06904ef6e528a6ef8ca053471cbd5fb03f8cfaf42eb6dba6ce0c3f15cb28524b50f2858f92271f993e56b6ff290a04a4be25235cbba383502eacdb46e28b7bffea9a678b2157914404443bd8a7d3ee0811fe1bb19ebc79dd8e82e5bbf411d2c6450685244da2b2b5ee9e1ea8643d440564034549f701f8c60144e1f3ed867f733709cd9d85d8b2ef1bdfaaa92f7df37dc6bf0471eac418835789d2c014887c60db2e867665ce3aca83e3d03f9c24b86acdf3afabc08ae8f67ddc780b1b08bd5bb944009b8e8fa0f43ca305c300bae7fcd9e0a7b941c63a413a0a8f909e0892f640a9f1119c32ed5f4873ef19b1b3c0e7dcb8a0eb6f22f89ba7d4af8d3d2a104840884b3d96cc0ebff5cc146206216992c7989aadc39b4f43da64a7a58710e8aef08e59ce6ab1b2d8060a4229a930adbf93b5202f2315fbfd4432129f3b0887b0489c47f56d3708b2de5238beb1c73a8c132cceca24458fe711fdbb8899a31d3cfbb783ece85acf908063fba4c85c4c6c906c174e9b33dc8fe22d0a537719ee3d8dffda5ff345d9d2985b49a436c40de654ddbc23d951cc347b039b4f1ccfae2ea89465510a94cfb1984f7998469e5c64a12a4ec2614160649d2ea602338464665cc4619e5ad0643890c9287d1368a95944d21d1511312b7577f72fb478ee8e76ccea107b8154420db3cba624c8b8dfad8b57750f5f3165077f264deb508007de99a63350a09a9e53bafd33663c83d9768c6f96bdc67807b6eaea30d63efaacfee62e7510d7079de2455a4d2c1a98c5b3a169c9cb043a3c7d540bb09a212d3c846a61683ea369e5e9758185bd8058036e7f109639e455b214e68181242b387f4d40b2589b87321398d52faaeafb31c887bab8b5cd26bdb8b1f259dc21f19d21e5aca1c7fb9ef7a0bf13cb4422886777f234e9bca80cb554b6c00f0f609c90d014f9104c2ae5a6b9918b6c44bb6d56edae5a96409e5cd1947f58e120b723367c3ec9c78e51152d3dde087c9cd00b4efeb486d42abd841319724dcf26f3aead062408c8adb81cf480fd6f834728b78d93341b0dd16962f5b034bfd28f0c7ab8f74f4ef5800baf4d334e689991a78f7d464923642fdbe477d3aa7a3e66ecfbe13029ade45fd151ba641047e72cb73b0347460b45ff7d2ae2733be13cb8504d2d106114e1a174029ba5505ce1dffefbda7baa1ef603e8c0a6ee77607e39ebef72c1a92edefadd0763aa750fefba4c1f9be902bb297ef4fe4a4b355acd9e44e90fdaf4549877e56665691a676b69fd17e11b9ab49760fbdbab708167ac3a18985e01253cb093ccb59247dc9aee972d27a6c1c8497e39dacfca9e28bd292839f7f8cd16b7dda649968e5c717e649682086fc6bb8d851a153c2a8029b2790350bc9515ee4617e434fe7a9e66905d8884e8552878dd126375293f9b54042b99dff52ca47f75b8befebfdffb6f0ce3da5adbf27849b77b9cb4407cf741d25def9db6a20ffb841cad410603baf0d5058627b9f0050ea686e32e5a775bb0292ac30c9050965f611139615d0759bc880357451f442ff037d2a9c95f75d21b915eae3cfc7bbc9fb51f74b2e2bfc7aef93dacf3ce6bbed4021fb815bf70b62c0f39ebce6ba897eab5b8b29bb34c5be0e89ffaefa6a105a8b5ce2dfdd89b3a67fdb64526846e068e003f5c1232065c1ba8810cb3e61392e0af6bea4b85c0713ee0602dbdb0a1d81b324af1c03eb57e0c83162d5081f1cd4329434297f626437832bae2bba4afb9510918885aa572bb61c0e819f1f0e789766b997377349759c3d3b636162a7237abf7915adfafc9becb663b153cf760aabde04535c4226faa482c997a42b37ff8b506f3c2073e3d015fe1af256d85ded8377a7e497e9598f2e9452dab37a27d378568345199d483b48df724bfa99ae97e967db0d5580bec080794b85d0691408f3d13e6502f73c3d3acecd125807a05de487e4a9022c9ce5fe310e31117bce925bd703a8eb99b5fd2c38e918a0e7584222e4ffbc3bfb06fba57d44edbab3e4fc5ca0f17dc2bcfa2ba10686d68efea103aeb498b7384cb7bb39a67fa5ee0eb097aba7eba6f32fd327c63b60dad87483f0bcad480c190466be53feb32d6ab0a1aff7e719b81b0","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
