<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b00d353557147f12f1f95129f1b3c916df44860adc608d3348bf56f6876de03ff473ed16176aaf4ff8b8f1e28eb55fc1eeaeafbb8f44151f9f6a97e1d7b07ab661deada57544b05c328c4fce203a2b6bb36037a0b016004efd074a23ca396c110db4c23d6a435b2452055bd1223a2c03fa7c0b578d3ca4baa5b61266063a2a3b66e27a2805f71ee5983981473af6ca5b8f7d68529bf57ebdd82ba672b3a4444b90e0cff4939873aafad75102fb204417490a6dbc9afb64eebe04f7e9bed9c848d6a19616d7bcad03f9f09b6a74fe240172e30bd3e3ddc9538512a01720b0dc21913f2f282b1ccdb5454d6babbea375831016bed8c7ee708d319c9315b19aaa00f4e990701eb70697c7e3981b1ca33a7df539db4ce2f83010bff184e7a2e873deee717492935109bc162e341405d60cea3448ef793ef54d90e7b67345880dd9da7ee1ff68dd884a85d0a6ceaecba3d376f475fdee2db6de5c88547a70ce523987acbe9f3c9b894d8cd1b674d0d0ddd11d0ded8772b2634e405761b5f5c8a47c145e1e569e3acc4be1bdc27a4fbd1ac085e8e0ca0476294036cb1ae70c6a37641a8c30e287a00278d9bf3431d9320b9b248a1bfa812e61fa03ec17d5c3ed003d995bdacf27a527d531f5740611c99d45a266b52d4f9b0ebbaa7d3184cff22686007e0a1f37312e3953c2293c0ac932363f29b481090480ab1f00e5f8911ee811c554fb96bee59de9210a81cd2d9fba4cacc9950d8b9300d494cad7c27267a7bf6444b6c94723e363756dd7a7159494c275d1b14a2d587233ce1da4a97aa4b02e6ae47acd893ff372259dc4dd7f5e71d29a55bb0f6a8c19359517bca5ca7fe360ed30ef9f53de8e3c5ce9435a099708c55b17ac656e10c9fbb40e7be8ad3585d60a45b209afefd7759938f08330688c07ecb27855451b90aa6c9c8c6cf06098630d19f87f870cee449ff3d74b3a1e98779dd675ef9f8c603392650321a954ee243e52fa7e78081779ec66834cabf7246c0fd26f81ffc4de2dec03f9b482c488c7c3c59d1fdf355e3dc7fc7a7fc004f0509601230d705f37c2757e9935bbf1572b8b3847773a7e0428b1bd52ad5ec8770f1fb9893aeede892074673071119722cc6675ca1977b3e28e7d61c06a488f2b2f1f1edb8b261e58eb6863bb46c8742a23c126c2db27a093d8d1db11310c7dd3b479536afcb700f4c0783c32e98204a79cd06e86e8cca7087d51131db309ba5953b3a6575e66adfba092d891a22f5f0001648b6d74dbfb12e53bd532e0c74d2009612d693b9ceccc99086bf1f6a69d401281314d249a7e0e6b03b3f69a6a0c026abb4cc5a96fdd85c20be5916d431bb06e5b33c226d1de9276815946f288d4906672149f0f2c491fbc3aef75dc46572b1249012c21f4926d938a87d063426f3d2b92f7f520f60fee058f39ccf24c3b20287863361c24737f49c0e79f826ad9626731b39e7a7a9f38d2d9afac001a5bd79514d954ced7ac72176f8535076c87bb24158c8309d09b58f56ca92eea3d4625fa9801a5a29c583cee7b6386dde66f0efa0a39ff44ae0a80c2e0fb4b415ba8f3542bd6f2e9398c95fd97fb3aa5d24846b628d8af9d7c462f0f275cbe5e893cdda511921f2ae327a86dbd3b6249f5c434892e903e864ec96f5671a57465168972565538f929f2cce901dc3d380bdded7890048aaa173cd5e74a6256744350c5575e9b6fa06c41622911e8764af09449528debe99f81b41b4f90886471ba11cc8a89619d7f3e34b76abadb9af002c284721f87c4b3018e306b12188aeed241179ffa1985330116ed3503075cdbd1a8626435c5645d762af49912eb4efc32a8a6ed585f0c46cc32e4a1a2f77052d5e5d75d97a9f3eda8247bc207b67312db1e37552f6ddbb38e0384be3f81dad742fc2d18ba4af1ec71f91cfe6eceeebdc87615a070756ed1a804f6f7d596d6ef581dd9655edbc041c81e76a79534891231e84a02ebfe8cc43a6e4adf7f8a21f154a0c80a8ea1b5aed2a6d978a448acd11b31a9ae9faadb25bcfb887044bd29c0c4a27f13b39474fafc6108a44ff74da5972c8cda8f919820419e601d974430e12a8b05a79c87d4f1415acd70c330c5ab393c81cf21c3f63a5ceb8de0eca28c7a66c220208f626e996276c8094c167b293fd81b8bcb189210501fbc14662dbc55ac3b375d1fe9807a7ea6d72b6f02a59866854b2b1861f8287a1e607f98cacd06aee1cde41eeec7ff774d5ecd20054b1cdaf819c58fae9982c6123bb72253264078d3acd7a12fa0abf16deeb2424ad054635a7ce6e8e7fe8860502d9011cc0fb1a8cdc29662dc27bf57bf50180e506274c2fd4704b163dc8f9d7509729f0df05c09c6db5639fbc2014806f0ff8af923942001497c6988ea941c99e2ea63f59bfab8af47f44e1f110d6fe12cbf01a7e43594a28f31dba5793999a96c32a2a01f3b6994e788181e62ae487d507b492c0076ed1f96c54728c3e8ef8d69a9f3b62d72068e1f22984f2aa5b2d3c1c0c927c4284096347f354c181f387c8937a25a6dd74ebb94c6af2a7d3e21d89b7f58deb2cfa8e00221905ddd9b4baa47083b12e07eebf0ef4b7573828bc3039282664c1a1099437a069d4a71e6f6ec0d9eacdcba9b2e138cfc538d2985026098b35c2991ef3be26af03355c5a1099bac14425e09746e1f947126b5b82ad9b5d2f6cb7492053528f429ef486895c4dac049679569b0a8937bdf98210a4003dca9f90abd2703f3dec4d1130dc35854e0b0a44e65cd39f08ea4b82ebe801f522c998b89a32d7361f0c3becd420611b25d06d75f340736239e2c2d9a57420a0bc41435be4e8ed67517fa10f54a17d3c0a4903282ffb5f02c0638db41f5cf191489689b47a2a2ec3dbc74e3d12cdcf04cb83edebe144610bc4aa26a5d78598330a3217292c6de69bec683673df4aef77012e3402dbc284bd6ee489b88c73e4ade08d7dfa0f85ca9bba2ec1471a98daf1ef018802dcbd21687d4c4be3d66d2c7e06381971430790f176482e0d0a85fe376f931b7ba04c83c24864000eefdab63fbdd7d1a63ae42e2abf379c045f7a7eca3edd130ffa0317ebce9a2bb2818e9d52bdbfca061585074373c8ef7798b9cf046d43d1d0d63ce19cc9bacd1c45da45e7388470ca68db2330c4decb21a003ac12a7ec16d07bc695fc9997084bc163f8a01f9edd3e0542bf6377687f2c3cb32c8be6a4c8f1d5b70000fe34b0814be52e8898d76520d1b7cd6f6d46eaa02494976d5e507016bb88472b86367e61860ddada46faea6f2467e393328d113d45c9b7b65645f9ff5fac02c7e956228278e7efb1b51096bd762a0e3cb35c8bf7bf213542579c0750921e17373e99f51824f27c2a473602c221e22678533ed9db25e9328eff720e9aa41d5ca304dab6bb9c43d3176816bdd6c361435f7755a54191382d212dba3cb4e43ce726bfd9e291dd483eb693e6badf669d602bba0a51840df4e77176c51e83a460408f0a6b234ac369fffd037fb5b0f2e614b1ed832c476698cf2f563ff6a1101683da6d4cc63021fb0ed839f1fc6f960cce97b64364bd5f5b1882f1d1c39103d2bcad6e7603da29ab3c23cdb79f25e3125105e9f906ff07b740fca9fe58fa18d288fc7e8c706aaa398e91900c8a93651ebd4636d37fdf6e22160e39447ba0d81e6490ec46e3713df86df56865a66dceaf8bf2ade02ce4fcdd4ba07b84dad71af7c04d139b085ab30f0b15801b29adacc386e4d9a9f98ccaadde769d474a034a26b71e7a5a751137e098d96ba55e08bd465fa00565e3cf26fbcb859aebb6e05ccb0b517af0cc0f8e14a78e1dfe34e56ffe4e2d3db4234a9d6dea1040c27b3cff4872844829683f40dc7cdc3f1eb7db7cffde08482c16f2704a52d3e84d28399f65d2dbe1a336ab29d24c392d79e9d3d5145aa36b66d2dd708a67a014027358d1437ce895a1ded12fb67ca559fa8666a3f0a84f3400efecb417c07fe5bb4c7a330e48c45e0a0981530967b5c8dcea1d00daf4113e590c5e13ba03abb5cf346017e9576a553258258a03d97dc73db4ddd29e1244026762dd045203a064c4059b7f212dfd4484d2d885a4695ba9b099dd7e1b7e6d7f6bcdcd62f826707dbe8b6be2b3d767121311cef2ae9e26081159c0102da9273a52f6144dd76d87c93ff79a35de3c67c322ee5961c00f2599c86043c9fa6c53d1a3ac6f79d17cf177f6aeb82976279b1d72cbb1d2c3c1cfd5ff7350e035ca1fda06de9005fdbd7aa4dd1466176925806eb3a18cf07dae35a184268efdc07a4b250b3d15c1cbe22398efbf2da523efd8796b6fb2326a22633254a0ad4fe37f6c97c491f16cbb8cd0216ed3f26274619df22425771b2acb83611a11544226dbc3a638ac083431521e4efce18581d3a81d3328fb802f05ea71a8c232ba7f82251b3343a0c5b5f0436f63428bfc8d3f1979fda5165ab81b1e7d570b8e83cdad2ebbb64ca85cb687c1e385bd2554358e798851ee66cf93084c0be661878082a2f8871f8ce2fbf5870d0b099982c4f8800a5a88d17e2d8004f6f601eaee3ab43ce99ff7c073c242ded2e3160f6c133138115b31f098a1e8293504de86723911ad20a78c1293c343fce97667edf1fe0181a857ba65e2646bb2768274e5846585715c02eea2dc5cfe699679a09763a744bae9e5b0dabcfac29fba0d1db7179a234e3e6658af284aba866d9bfe21a68d84bb3dacb1ba8fd595d36cca9ba5e18929a230d30735020a8d0cf75f38773f5bf8b11a2af68644b9ebee5da65990a82c9f8bb78e4cf55304b351cd39de4cc7350261bbe6358edd8e01b01cf6480349c09aac8e4c080f8aa88726771ddeeb4efc9d68514de76120cc7a75ed17f7cf1de4f6fb115e76f50c65ecfa54b0eb48de28f7e4dad2672eddff7f29954732799907b9e1fe77319bfac6a29fb69cd3dbd86395c56a212d1741a7770ea8769f3c8a5f08d31c6f057b38ef66992ba1601ab6fb16077f101c2567032c9db537c3c57bd237f4745428b3aa28a789017b5043e8972ceea2217f9fc380a55c32b059de205706a315991c5bea7609c6db9fc8ca7adf0eb02711bddfb1d67dc3e250eacf2a332d77c921d9ca25acb89374af48907652bf1678a8b79594ba6c45cbe200c32ff9a05422fa165aa8b3223cd1a32be5374500542bfc05bdaec382b927882a5aa9d55ac82bd8768cadb32136e267bc2178d9b5caf424e5a89b588be7fca158ffad2e20ac53fa4d444dbd01ca115e8318bdfccddcd1b88dd8ca2d9030dbb57b3c1c150ab84b97f7f152e06d808648ee12bd731ec0ee477f2d0884b7bb1463d9c837d95f0f261b51ebeb6e070f16d16909aa2d45a26f7d7e928941c8102de495d143730ea1eba0f85b91647ca0a0c09ebb550bd692e0ff7affd7055bc7e1135d99d3c07c497ae04f6cc47faa39fc0ad951171ae7264f5710edc6d599c77452ebc995f45b4d9ca6977865249bc20bdef4ec5f1e71245f60f5cc530a286a53fa596e5fdbce5fc08e38dcd5e27a0ecfbee08884c2ad301fb28e675e74e97c51557c5eaff9629683e2e9f4cc27eea527095b68d3c8d65c5e2e35452b7b7e98f8ff62584f81909307efd4b800bbd60d4e1b1ba3456c7599e88bad08a6c2a7498389ee74f0a504610e3636b63892e588a3a623f0a52c537d0b6869f7d574878c4c6e25a915433f9c50dba27d48caa7860cc5defeeb93677d2fe682f05739f7c7820c4f4d3f18105b30558c4e62be21a96b746c8f6e8806ded93cd5cb327dbe8f9d77d361a15768c507581c0e41729850111c91d1a24d00f8fa6c40f934d2f89ab04d96f231072f94ad36a5533f8ad11a0b0fb1c20e2fd4ed46036fc6d6135a3964182c7c3b0cecdeacda85fa641aad60134fe4a20b8efbe424c14221559ea9c73ceb1a424e87f51654879094c0b388c4a5394fe8b10a23164b6d8670edf2211eb1e1f280e155b23cc085ad35765c91be7439a4b5ea6ad3bfc8011c44340d687e5909c1ba2a382a4f8f016d169b88ac84eb7d3126986608e7f2ac938a44505ba53593ddc9e49cd9e7564b4a3090c19ba67fe28745e32e86669220de45ec9e47e1fcb05df818bc26580ad53d97e6919f3dc74534e4bc9b30b815ee3f2bf39626041832ea056e23a3239891308e275c111e42f44f88d382e1862fb767942ac481ca88b78b26d402473634ece9c3d0ec7d2aec9087d14c4abd46c774ac55dfec957c8cc77b5e13d486ea3df5ea2f5f2e5bcf19c700722bd9c8a7fc8ee7ab236b4b31588fcd24c4cd2bee517cd270b24ab99045ce45e9da9446d5b455a1887f3302685529a928fe6c226e3fdfe965eaa491ac04c0bc865fcf8a7d4c0e9ff469f0a8e8aaa6e33059eb26259a0968ff676a4dc5f9233f4bd501138398d8aeb9e2e3ebe5de27fbfdf5bf4ffa868f4cb6d4967253da879263f0c1b5029de6192aeaaecd80de4493319e96125d4244be1f0330ddc9e556568f6e0010cb5505bfbe6cd4527f64b55678fd300bfa6450e2ea4ca312ec7979454d06f70b25fefa06b2428c1141a5d2b5a989fda01e8000c5f89e1bd8028d8ffcb2e0a57d36290654889be25870cbe9fb990ef3583d5be10cc39acd9d42b694405f72a62c2a2bec72114445efe4a8464161730cb07a2c65d4a7cca1f677ce39684296774ec828912e7fd2d99aa069452355d0d2fbf47528fe0c3926d7c2da59a0df2000b065847283ed4d7ff94a2ec26cb6a542dd483111fec2b41f0ae658561110bbba8951f20722bfa5577973288136ed27cd707afcbda7a0a379faf3561841bf83a9e3b75a8fb7b68ef0a6af47aa7043daff8ea295ea828fc489951d6e6712c9c8cef2a973cf077085bebd22598cbddf748997d0b2bebb78b4f6a05c39b3d52dcb7d4efe29c511d96ce4940a9c50614374eb74313e57354fb78f8c81b61e5b56002ce7530a107af2b1855912d55d69fd0c3458328dea9a86bbe24d58165dbaf5ad6d26604c650e4df5e74aa29a7eb98b2289d4266c1ae2228d004997ede030e5a2c843b0651b2c0cad0221d72894b20cc2ebb40b3e203aa07ab75021b69c300a7818210b07b879b52bdd316f8edf057b37c403aa9f937e8e42cdcde1f0f2b400b5146695dccff03a67d3c8398df13e70fc15a59e8784c365391212af9dbf96bc5c335964b30000b7f982d81cd3fd7b798c172180c98afc4ae780bd7cec961000052e4a9f1d787b3c398581de532edb5d783c16cb65949c27902cdc1ade1541ec8683a5acdfd5a8ccf6907a8f79704a466bb2870aceabe3d812045cbf7b234a07060e5e2fb082cf463f02bb0745fc18640f3c98c5f27e99e8fad48d156fad84985f5f2158da40550e86ab90175e09a64226ce0b5b28c3a25f2c6ee7c21b7f5c6f25542703c935d2f488aec4e98cd89a0bcfa0dc5a5f09ffc75f7c1e9d9ee9e38b40c29e88a8fbe3c1f21f5a12261e0cf7d277c3ff254ac1eca45632c018ea3b13a4677d122b783f767face84047989c5bd1110827c8ce72319405ee776b6e64dcb53709b3758def3db81eb63f7820ba2c84e73540842cfecc16ade1a04f54bc825dc7f9e094fc1a66025b15124854b05a54822916f9f19a82d69a549230d35b746f8ab8c77d7eede3a053d4edc0647db4c4f7bc248cfee5c2ca84e1144b7546ca19620ab217c37f77410d7bb2be47dcc195a3bdbc1555d18fcc0c74da639c3504115d70765545535fa00804b2b0ac1d4fcc1a1bf95e844eefa6995478920111193b8795d07c9585c45fbfd2303b8a3b506559d425d49ccd83139a806a605333405c1e37883fee2f7abaae1cd2ba9c6a7bd9d3bfd7e398a636cea5c6669c26c13a07bc00a2b51176289f9e767510be3d5a73a6b98ce826d9f7b14db2ec1cfbe8b3c388015a7a140056a5098c382f8f8afca052f34f680016c74560deec90854adfdcc6a1c1e1f170a7d80862b8c3053926e5a58fcc63394bb0c4bcae12ce1c7c6b53dbb0e8a2f866ae3741c668dd1718efac2dfd2e893e656d98abcfab2d6c7ea31aba8e76bbf8de463987a58d1a8d735c292cf7abe3ab49bef7ce561192482fcda1b1fffd6a401d89fe5a0d995027ecc736a78ab6412b53725f382e3aa8d68aa5f5bf1e87f69c7ecc75c0738dc1e2572213c29bba4457e1f8e55e6ffdfaeb57d7604528d12ef443a08d879291bc88024e4dac6a5ee3c20c1b066331c18e0a7adb0d02697b233787605d8536891b3bb59fd9614ae487e7bd700a3c143698fe7eb3097240cb2fef98c10eede5e7037705e703624172e80ddaea86d547de8962fcc173c4cb0b69500ec628f56607e5c19927830dd99b63fd41d57b0b8aa38d67efb7a8f53e288d5fa97755f53c68ce4c21593426c55c707ad7af603fac689dba0e6ec5969de4190ef21bb0302c89ca06b4461f1c8089d0a6b51d966e19e200d2290b5221d7b697ed69c824ebb5b6e5b0fbce476f5fd514f04bd0c253778db74c8d6d90c10be2475d4b9641c21f8521ce71b7d39397513c7f30f7432bc1dce83e09be1fec7fdefc37442f2a842685c75652c1486b57adf771a8999a190f6f3602c9f8768400ff84a43aaad32d852fc08f729e769ff3b18783c77a78f0836647fcd57aaebd733e8f1e9255b581689bc455a8c51d59d74c9beb0675e30cac27353a4b9349dde50442cad19c719d2b0af781cbcf0b257187afd2658204d3287b34695e6c27f5a4837aaadb95b292dd6e20ba0837a7a17bd940fe5e48a59c781b3e4fb24ff6fbe97cc7124359bb01b0653d881e8ba1395ea2f81d614a65e7683fad72dbc426dcd56f34220b0ec4c8817d38c6cfd1285ee3650122e538fbdda06a62449e41c8f3c5b22637bb12571173fbfad0cf37e18a8ba36d3c41e9d32fbd3575f1675111e295d2d2ee98fcefd39a1c2b4515b7fe7057a835b07cc1aa393518d028de765d66f626e0b8a2b27655f969ad38178dc639b32ba8b59fca3afa7306e4097e8dd6a6ac041f84b9e891b5aa10672d73d895bf97d55ccffa0e37f2be0f1cdbe4e6e1cef0fb152b933d150d050c834821bfdcf41e7c88d35d24353e9dfa29ea1f069d78502f0e7e8609d6d226b99ce7206305c4e5c84d29f6927f6a39e7530f23fe62abc9e99908746db61637745adf45ceacce311f674360e0bac8727f300856fc6f75f56701fd3381abce5370c2898aeddff098642166e2ab6f5c8115afdac82f7430b4008bb6ae84553ff1b5cf96e20f2522622d0ed198e65bd3dd0a9a0ce648f114149e2450ac4b6fb015cab2931383cbcb0e688f0ab3ee5d39e365d7872255ae4878b2c195c684d2bbf08feb6678bfec0871c1eba0c6e764756b99a51ebdd22c45a1ed98c50a91ffb36f47779c4ce1892d19cf494300d30accb032eaa9ebc66f704ebf3dc4ceedd9306a4b03525db67d0999de5d225a88c34fd384b2c5ce95c2ceea8623a7f1338d72118c4fecc42b0b65027507254b177263f82de425e243c5c8ef6b9713bdfdb7b64f39ea099db20e112be21ea292fddaf80b468690347ce7d60dfb46c379ce3a139bbffa8d4fe0cf8b2a1e9e2d9c1b1b992b1ecfea26f8919548f741477c46cdc1ec46d4ff7de4a4d93ba7b9fd3f35b9d84f9c34b926880e2edb2ba6df7bae93a8695fed6dd289eb820b864188549d5dce11948168f149c8740c3d5f0ec28f2f4523fc7e7f8a3f20ab5c7f226e1be762dec809fe10238933a9314826cb4b164f7dcec1334533643926db54078657087837de5f603b4eb00efc0fd1ffb0c677a363aa4781abd7b3fd7a291ec612a34c3137378d26e984eb6e9ac48fa8a127768da86b35a4b9bac62292df5065543108eac1a0a8409c299a7c0d32801d8fc61a2de3fd5bdbbd47e3f877ea37d5955400070a22ec19966075c733f01b922c0f13a8275f0c52edd6d19723e528bd36566ef0449f9e3d3f9ef16c2832c8bc1a65088b66109906e23437d6baac06324bc4dcedfc49b9b8a7ce2d8e298ac77e177af823ea35407b99a8c72d6b21d07a98d59bf315f48b5594219e569c2d9fcc04cd3764b270cc24a1b0238438774780f7405442f3ee7b33a321bb548d93cc7823ddfb20cc539fbb84dbfb87bd993ea5a1d3335fc43cb8c56c2c4ac3ad9c8de4f856279ca0ef941e527bae94ffb051422bdd7ebc55ebd6d9498d5bb7b6bd222d3fc097e18a944b39664158c5b26c014759f20101f5159fafe1b3ae960745d7a1d40d1d99eee2a727fa1cddbd96b74badc04f56caf80758b0100c00ccb4c74da91b8ae3b202ee687b8498d5157fcea2637ba72bb898815b3e9700fdd86a3a43d8f7434060d615d22b8c87c2811fd8ef908d0c95cf9202c91284bfa5c186456c60e28deb3b5669809b6f97cc4f7031320483e69866b8bb23519f448427313c847ab9254527a6d8710c23da9b42db5a1d5cb6aee70293c267f65c958da2068d5fd17ec006c689ba1a844a28a7efcdad2ec1a25c5a6fe791c9769497ec5d8119a1d53f2fe239af621c88e31ad719875f97ef070a32b217e8a9668dd5c5c63e7d84ce4f6e4aa9f3749017d795bbfac83a576b2bce1810d53103af3c63b9277a7fb8755c6e2919d156e6dd59f80053eb71f6c0f73d6245c8ab578994821c1538bf621257338a5b2b54e82142901f155b877c2477ae56ae2b2aa747a6268c81f2270de7c16e62497a2ff910de0110a23d4e530165f983e0aa8a3dc083e27e377eb9c3499b8036a42689de06e3d5389891c156180832388d776e6f1dc66597f9f218e6fd8185e20250495e4c83bbe63faa22116b7ed7678eccfd8f13ee60402e9657d5b74f401adf2dc04bf0ba08190a48d77c9ffd16af5e57a5944dbdb61b1dd84b270af6a50a3c4475ab4ed20bef405ae49d0c53cc856c733d8601ae1baec40e849f10b5bad59e3935a1676bfc9859b0aa54d124e021082d70fef44dbe78aace03fb1de5ab55d8d222bc82034710caa590f784f1ad657eefb676138a6fce571c5798d3c092aa691860f758b52ddaf223ef33f6c74fabafe6582b6554e04bd50fd6c9455d5bc05d423798e6bdb246c2b33c47d8f424d91f5020330fe1bebd7a1373672e4c106bda21c1b19abdde07f901fc4d712ba561525e71b5a2c1c2dcd36a2fd2d655e2071711feb836ef0c3176d00cdd2541c4227bd48a15778d3af20cdc128d512db330394b85dde23ed0054ef26b2cd827f3387ac5672de9ed2e4ccb574300506267578f73bc361af49076ebfa15236b91afe1eb6d2ddb59a9ebd04c68f2a0db3edd69d9e928fa5daf0c270a5f7dd25b3deb76669d367b5e89f25c9f16f191833fccf395f7581055a448425cf6ccb55d9c107491222587908037bd6ae6e3f7ea60be35e5f5a21cbd9b775c6b9ab3e893aeb094872cc6df74f59bc18e24219877382783c0694a445f64db08abc99c361a42a81f771f3519792a1986da861319cdf723b4e61fc0dc269a62f79446691cf1edf0b6fe61c8585a5dcf21838901e6e4a4ee298a61ae9394a355617cc8e3cbee6dc5fe2e4df9683adcbf70ffc721cca5a58d74a27f93cf23a2ed4780bb9bfab8be53326fd30739b0eb5cdb83c1a95088670aaa05da9011b056f72c008d76b25343296f40e15c2bdbaf483362a93e0e4e5d19648f821555ca3e52a9251ae4c3317bba84f528946f49c400b34dbe59e1851d29ed5c865f5a26346329fc7dbfa0e3e74938d824278dc55e6142f0c33cacf1860bc077dcc1bec1be7e2fd0836b17b3805ecfeb55a4029afbb07c1a396ff13c9f4ed00fc6925bc616d2193ecbc03eaaecb913c354ecc787c8dda1200f55d5601a34c3a59d8b281e45117d572eefd685e97d4860dfff8cc287ddc84547cffcd1786f7e0802085ff108df0f68e420c66aaec746d2aa5c69ae476ce6f545789d583df550db58215da16c684e082ed28b6b8c8a6136821bb381500d9979a42c93f3f0263972a8c42ef6e7d9136678185e8b57c0005e52608891ee3a7319e926b1bae25e0a7351ebe469e416c9368c878333ecf360aeae11168c636010632c027a55bf153ac1b66cc8bd50ab2bcfa215a64a2529aaa0ce0b4722a8bf6aea17daccfd88bdae71afcc8da9a4b775de8b673e374abc7e79aa47a9743ccb06c68b1fa5097bcf40a3aee6f4e6e4ae3d741fe8fe1486c58d97a5e52c939322ca3e11c390987075237602c1dca8bacb605b3b82610a96e6804f10e245a3a66036be3f3a4024f851fd162688ba6858647ffeedb3488d8ba2ab803fd0d9585ee3412629c2b32b84dd9bf413a336522d0f3485229a9a98963813fc975a60dc57b8c255d8f8b480968d563cb12dcbc8771c13044e4d7d55db32b8fab6ccdbea85cac478eed84a2779d674c18b807f4cbd3f47c2fe5468e845856839696874a932942af5a3649de5d6779c3bc7ed6863cd9fd1c212efdd81046e6a471991ecfd8963efe8ca2450c3585ccd1650bfd4e19fc06560489cdd55080bcbcaf2148c64bb1104bc807afa1ab832702da7eb16c085c676635f23d7791d34980079f3f5d2de7324bacdc5102248f3c68b21f5ceff29dbd033429407d0e4bd0f564e55d2c20cab5d0b17b0e148aa9d2bc9ae6e31cfdc07010bed870e6da01f096e15c923e665cdc5b6eaf59a8da3602986805dbed90b7b39e0908075b92794d7abdbb2b548c8e57f783f40c30ec4091a70b386bc002373bf51a38dcb37dbe1db8d517b24e4503d9499f7ccb89594023142f30e9b3534840d05c9bff1a9ae7a5696f4bb2f56bf0b04f7c1ea096d2eac8144f42414b0d2193bea4db96c31aedf2dd118b2b605aa76b7239119ece3dad0fda1910bd5973899161e5cecc039a86d908476d64d7792c108bf37fe2fba75e98398071cfabfc691107196987e34eec61a004864e4dfcf5b3363b85216148bfd5a1511ef2c5cf154e23b6844c4c4f116de406e66f48e7e14872417d2fce577d84ee25459076eb3617a7a56a07a681c5bad963c04a981f35b5cd9ddad8d9bc6392ea9824be8e800b8566527c422b6da08bce5f9c135e801c57055a703c23d758e94269d5561089396df2c21db25b553769bf71b24a08173ec685e2118b47a8158df8e27bc9c650ef1baa7d3dd2eede73e44884cb00aa7f2706d57b5fd632e459e4ec41064d2e74b495e28955bc502b050e96d0ab94453b055c888b9a2a82a409000d07447925142c228dcbdd3ecc79d35f81164123a806570ce2657b038cfb4a0b0098c151851ec6660ac69c22b4c30f2496152f3848635db58d716067aa4272bf6ddf1dedb03bde35588cb8e97de4c3a27c519cec4cf089e70c38a6c93278ddea87a872deabcc5d2d9351f20b5bda0a6c184a4493c3fea80b1ae7618f9eb96cf857c2febec3b111ec81f7bb6d828170d1820005d3a0e690cc1e30652ed37a2f4d38e8148c31ffefb58194253a27c148736e429ec1889f70a8987763adebb5bf6db8bd5dbdb47dd6b9b2fa34b8c9e0161008c67306022d0a1511694f13999c54b41d03309e534562575fc8b5d4f1e6ba6fd4921fae727f8d18d55e2920c63b1c600eb4ff3b29880cb8633f79eedcac7cceac02d1f2a71b40b7e0b6bf82c697079df1534396aa7719aa63656093f8d27fd90316d29efcd32f2a0734accde2e9bf153ffbb66b9db67e99842765f32e84e9b7c7e59c719628ee8084f096aaf865d167529b29426b138646eef7ba92a888888fe9e8a3b6260aa4fa24e46ae36c0a0d93c88afe80a763f4d826816586e29b2bb3ac4cfb84a7aeffdaaa2e3bd3a15d99889297a2fab19e1bf1d53055b6888276a3b2fe9037ce3c485ec7b7f97b42ed8a9da4810442ff87a70ee8e46ffc36cacf78c0ce33d32c24016d5a3b390e8a2f4f1fea35054c8e4179fc5a4c4d7454e9c5e81f4fa6172c75f10a27c5834ca29e4de656b34c8ad409071d3bf0f81093768b43bb3ee986c9ed0e6108769bbb54c7be5fad1b05fdded88a219b7ba0c0b77f9f7820479a70b02eb6b33a1b61674276029e5a57155a37cc881f476f69c062a79452d774638a4a7b609b5b9162241399d732568fe0f8d56174c7f78baf37d9cbc2bb828f9a323f51b649c607627b857949b25ee6546fd93ecb8c197f6f6cf6a1499279618f1ac2f5f098575d0d5f7192f70ad3103973f864162f5d49a4b86a7904f2fca8ea67dce2efe9cd6588dca38547e2a38d7ecf9baf95bf8ec1c2539d638efba32e8d869e4be7b0474b8dc66ddd63cf9aca58e04b280588acb42acf4c7eb25aae68afbb88ab9ae58034c1ecafa9eebca574efa243faf33103e90c6444e36caba91f7e1dedfa3989258fec02765790a79ba4de60e9cc9b59b0c781adc0c967321e3c2c44694d8573bbf839827e8c5ebb63c97a765a61c8851cd89eb505e067f4435bab44cd725943737bf8539b3a8da91fea1b4dc14f536faa3d47084741e5173ad73d301a06238d53e2f8b898d2fa0f929e9d5bb0c2dd84dcd2bf46738bd8244be4ec7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
