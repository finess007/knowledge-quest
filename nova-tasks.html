<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad602961cff53acc4c304cd4a4caa0eb68232259e65f7ebe2f47c4a48fa4ffc9254fce9b5d00c46c362e597796c15a0efc6dc1075fac9d8be5b5ca9781026cbaa3317a4ea006fe2298ce03ae4af309babb6bd59e21f88c33a7bd6e24f2651e831278d8cfa85977908659a1b9a5753c17e28785217378e4a2c92c205a2f71955f41285a2b7f9113dca5a7912c3edc53887640225777b1f4d504d69fb92140c87404dffb2b40402cdefd0fddce7f05f1856a542e198102c5f6558b702dda9e34ffa4866956bce4fd2db839c2e5f0a123fcde0c80d9ef13e75c5c9d7d58ed14c9bac86207e52186b096b6a76d5d0176fabf8f11ebd08bf6cbd853977803efaf4f1eb08d592d436aab2cec2ace1df9a90633cfbd5a7ac3392659b4d9b5ae874447dc1d35736d8ee22f9f165294cabdab3da2477557f3c35778a56d626b13f0ab1cd46cc1623023409934c9834fd65cc378e91b1b7ddf4cafd3151d7827982e86dca522d9b7b98e72cc7b7ac06617e182eeca0cff8b378af41a3ff80035c1d9022ab8657661aa18e63a25fdc3885bcbea901e38f717374ff0ca4f03ae94a4ebbc6394c9d8a8c50f78c9790d6db4d6dc249da9e40a1f2cf5ed32a5cca302a6dca81e7c47a282b75800b64a6fc23935caf01f52d1a41159a03f738b4a50f1be79b3ef69d53853944d3b317b995b33934ac51f4e6fd6014d38fd436f05d6a44574223069767b1690d7b047145aec178a1ab4063fbd06aecb011555e8fe8388e219f664fda7df08d2ab19e23208b0a3c57286f9326fa3ca232cf08a6de100610a7a7fb35993db3a6b8b2a7554c4f72a3ca1e7e41961889f5bdf34a6220c4eec0f79dfd20144c629f7f7a8db5eb68253974d52b5cf072d0f396d7272d0e28fa482eee6d68aa548f8d0f16552ba6050c924efaf5583586d549020008ff368cb907f6a1f43fe8e34887196d572660421b59a5699cc18496320f426dafc5633688429577232eb780e9403d357179c1905037106ba15c2e09b956bd074e61bbc2aca5d1a72b85de666ed83d424b9c114dce1a16be56969f39fc8bd5356f0dc6bd4948a605bf322f8cf0e6ab0c23a28eb8bf77cf8c1eace1aaf33223a70b8870ebf8aadbabab72170c88101fa1ccfca6ce2a01a24debca1e3dd5aa889fd856d715fb2e49b1b7b6e8dcd56ba01d4ecd2dd88efcdcddea10e4e8654d7759bc4f7ee9da791be5e111b1d943dc72d4f7aed82fec6a90a83ef0b4546f6bbff3ebb4827766d6bcc1ae092f4d2af3413018aca5c082f04d5645f34ad45683168b948a732a311c5cd0f69374e098e3e02d6fbf5760ed80d305752be4bd3d9d0d4c7c3ce3c8e29f67461b23d0f2531825b65321424cfb65ded0e6895e9f10630a414fe1f7dd59ae0408dd9b4d7728c9073e3506fc3ab79baf73905c6266352bc27df910435bcb0ae59200a0835235a29a1b29fa76d8609c3a7c2f05828a2fb9ffe5fe8a673d20df030b4ffa4954f493215d27cfcae001cab5804715df5fa0dad1e2be51dd0574e78af8249069d1fed87070f533bf0742a5a34398aa0214b45b0b4c24ba970abd9a0e98d48f0aca484a02aa657c1ddd41b447d9d3e257fac7bf6ff228c6e4e38f2d8f4fa5dd15203235e370fde72c2f6defed942900367daf6a30d7747bfd6534a3faf5991ff8707730d165d47d391bb30d0203acdf905d32cfc9e2ebc313b77f7d274d717698e7785c203053a5240d6540d00a73d96a4b8ab95c92bd72f54e21503250ffe4ca411a9e5319b118ffe2bf97b3a2e6d6138311ad71b4e298bda8f2af8eb862e7113139d03266f330cc2849b21e4d580f19af1d0fa8dcfd7beb49ec0960d0faa189799c1b9c6e0b418f1c3310896901fa6918bccde081a06fafed1814f5fca8654eb265dc12de522df664a0f44953616d7d537572e4f8f6c230b5e708d09e62bcd1f3d6c070fa2c7efbb7da5d6f9266fd5654bb84ffd16c3df42e42902fac1b84e215a46d033b4bfa68bba802c48fe021858704a80e527e4e434ee38fe7ffd97047f6c414c492692e7176a304f795ddaf91143644f4edfa0d025a375e5bbd95d860335a96a42c691319979114badcfd66c24dfe28846ee0e1b256b60018816a23984058711f4b9e9d2af21fada4c0046db0350c689a66d932be3b2d7b8d2694f7255f338e1cc0131b15f83f7fc85337422e701221d71023a194919f821ee3b5fea3b425410104ae3831bed7df13e40356f675d00e5a11edf3e49c808026dbfa6ac76a5d4279c202eecf3a21f820943ad536655d53d0133dfb58d88c3e277e998183c21d2588a53cfc8323a6f65c98eceba3222a7f11ef8b4b121af0aa529cee9ed41eed04c5684e735b6cf23807109648987bb83e07c94a36313f76d02eab736bae12b4949ec05d3863aa42150672ed2f2463a7c554e2a3863f37895f9e4075ca912148ca0601339f532e0c46ee69e97164b44dbe4e30794cbbd86794b30d2c57f6f8fae7476b0968fd255ffd0d18765e4528efcf84a1da4726581341ea1eb7c314683414dfae77eac4b4287f8cf4da12969008dac9966ab20bfb75e19850819b0848572f98896ab27fa6844097c3639f7711c54f6ef5d72c5081a5df366dd334ce1335dea48d899d554e7fdb7e596ec52d626d3a7dfc5d9782c65a82f17f9d825236ac9f003aad5776eb81ee040b6564ec7dc0f71b7126e6326ba9d8efddc3d2cd8b7cc8b7f30d7955c6a386e6df5472392c4ac04cfd345a887c58d1ddbf3a2ded4909032efed7c3a10ad17c65986018668ab16f014013a632ecf19bbcf4914dd03d80f3ec7fc16cadaa15a38d0d1d3ba36c61db25ddce5c0a6b523e379ee64512c2ff67b552cca96eee6bedc6d96a9cada6f8c200cadfa9d4d777cbfb52d7a628f7bc4fd58ef7105877646e8e30b1259cd6b923565300c9492532939d94a16dde099413f1cd02c0aaaa66540f345967b92a50c2b8bc78b3c453f634ab1435003bd78432fe61ca353d2ed1b2bdb43d2619ba5a9708cf26b386c044fdf4e6bdb28ea0e0192e414c28bdfca881b3a63b6e2077f9e40e515cb34c8b463ce4bed8910b6ea59c80720b7ea220ce0d33da1b9599acce3a62c056d28918d769c9c620ff16ee280a96aef2f20983e783a222ab163dd4ed758d76d5f61982bf3f409c6de6936e08824cd38e6a7674b102a459a4c07693a54a9223d8b99c5918f2d8044ecce8a9fcc3a574658e11c34beadd2ccf5c3c688a70f9a2579cc1fbde7ccc791e00f1c52d65b9b1b8f93539cf1d39479bf01f65fd26390c8aa5c9fa41dd5bdd7335f682f819abca82b096acb56b0d560b7bd29de8313d51c3228f47884d166295a88fa7b7dcfb02fbe8b5077d03ec9639b3e4de56869cc1b6ebb74c43db0312b3ddee989b4006795f61267e14d08cd872d2bab2fb7b902f244f0dc11c8a687afba9438d13785c60f152a6cf2a7f869c68b306acd1a43279c255823eb601ebc99f3dc8e01bf0c7c910c5db1dc05b232a470489c607624667d631a12b98f391e80e769a146005b36ec14fe6b1df9e53aee2ecdeedff7c3dc94f932329d92b9409ae48abfaaa04a4145afa072180de8c55b128ce5dc4dfcf002fcbf4d7e004af3b757248ceb08e3ab9d1fb54488b25ccd6c3576b1d540deb21e85758943e1866c06961c8291d5bdc83ae53de014852ef71d4a67222603d11f2ed932f067bb5f7efd6b3a32c9273437d7dbebc62e81449b1859df5920140e0880368ff9f22fe4c621ea6d05de03c70ba84aa701d1b19e1c45dc8fb05aef8d1ce9485a4fd22e854692107c0ace02711b288a4c89fa511239c26ad3fcfef03b4c63dd77e3ce9cf9f91f19d37021a863af6f35b09899d2db8870ef5ce3a5d68a1bcb3e4e6ae685ec143dbf19de32c1f82e34a9fbfbb3968ba4221fe4b1a36b7f11ad7abc47d0977555b851940d33f7a2424d17eca1f0917aafd1991c93bdf417378c49c4474bd77ed42b8a4fdca0a46b4844b50a309479d3617146c11d61d31f15a58f8a1d040c0a4c0c93fc8eaa9f92f590d3abc59aa8a53d151c33babaf8fcb55bce2afc849d21cef2fa97d9a2566caa684136acd53ebc39e3afb1d9e7b1c654955c84f0dd21975f4d756a44072e2622d3d8997ff628379b8645caf6aea12d0b62429b3356c16f44333e16132d32df2c6c2560ce1cbe8c72c06cbfbb606bdb4f88f817b8c042715317801a1e43d541b2fd60cf0ce4fa4fc2ad1a60385c395f6d329d1b5374dd83c56e0479736003ff88a7b7bf5f597e64b588cc66d54c546b88befb7f18bc1257fd78303238f1d53f3acab14e454d966a24472e433b6b8d44399857b68b905199993e834b9d7a11037c35cb5338c099fe01fbedba5d2214904a09505404b8ab4db228e9e65937e7f4b5350c06a6c28cd46e1f140537a5c81495ad270cf4674f9fb999b067cae18cf00af3d3528039913f2e491b21941504f11909c0b2f85494f9f09bf683368433d4e0f0b37ac02ffaa02c2185862abe40beaa6f83b81943b59604539d2edce65ed7bf8a4c543a82d507f61792e6a75cbe266fb2175ec5c4e3e9bd4155d835ec190ff7463a403fa827ae5e2f1496516eb0dca9e46f28b68f9f261ec4139a7290cc59e06d61121a2dc45c573f097e2541c00a636140f3ea23a11e55284b61beb9b84430194db3d3705709ff899d8fcc2a356c3115fbc9a035bb28e6307fe96823b4e3363e215428632ee0f220328a648d19585c942c8d9a7b66dbfc7c02211fe3499be48290fd62626b8097cdd76401eae039ba5a25e7aee57d05f16518ef88eebd0f52c1b6342103fe8acd61cffc82fa53f65ff37df20f86c2ae2d9cb0d32d8d0a3711c30e8896697abac88cf69f1511cde7cc15ede3c537b81fde7937515d68186e2b566ccacbb0579204eeccb064e06fc1d119b3f3f9b937f29c5d284de7e0d49787146aad4bb6d925986fe98240e41b0352668b138572af502ce5a84184a8754a97592c4db9f1fa917d1334aad9ab2ed9b6840d7bdae9c897259c892605ceaff4eaa42cb4653864dd6e7fa2b9f969dadc526e3782c1022e4efd646598c79331dd125684433aeefee11b88167246b05e248a7457621ef99d047b30324182a3c79956cbae985aea1e24005b77bf19dd2f84f8c5fa2f9e17c8d324ce66339186031a053c1ef4e14473ebd9b7fe92aa16ba639c8771276b93508f433c3fba8d1769853771a88b9218fcbc786d214f1a8076c2c72fb51bc8ca8eb3c1f3c1bdc2d739b859b93c9377cab7bb6aa9fac298851d56305429e99c10925a503af8486d1c4f53c251d120d5e96e5fb694f53c7f8b65261f2ecd2d0bb5443c5c8752087fd53b9e921cb433c88f085ab8299cf276bbfa77962c869a97f8fd2a67ff6d612240025ea1c544ccffc2af41085392d1418764db813a5d24d48fabcca89178a14af25a382817395137d9e4505a053524d72db4e5dcd0a94a3a3cd3fee7b9cffe5c3852f7698cde26f1ac177c1e02d951a6b9f02b6a9ed7ce61d0127086f6d6da0abb705a067125640785027d7f6c937691eb7ddec05dcc8b189948362a562e8cb24bbfbdb214f1b33ee9b7306ff59dca77260823ce57745c9308a03634d93a1ace40abe4d0d8d4a870c1534de54030305d20756ccfd8905f408e17e20fad065b41fa9b9cf0278e84982626553d213d4bb8c4bc1fd1053a4c88bc1d694e0fde0f6a5faa4c0d51347b28a94be0a03e52af61386b578cf43cbd2ce699ac5622b5bd1f3b57c37863e37e063a52e231d6563373ed9e0b333dfc5b6d2d3cadb727e178047187a22c11374e8c6c2be8b405226309b73a6f0d32690aa615b38ab681c20c059500a8a389aeb210204779d14201725797b573dc706c5e3da94a1e86cd832d66bf91288017f63ad1515ef77bb6287aa70e9546e16431604547b9fbdc51af5217a6bc176b93161d806eb4765da9854000b8e27200e6c63a9af04dd790eb42cd5f3dae055b16182e5ce1666882e6f60882467a1af276e50e6c153e359260728d16595340bfd16f47909011a3a5c4bf1706080ada2889e1e63223d158a7d78cd5626ce50bda74af310bb5d5b61bb98de5e2ad6b757be132eb8064a0ab62177342caf8cae07609a7043e13b4dd008bdba116a5a54b61cdcff85f116b01e9af753d3dee729f7f079e72e8d5dedf7941ae53fc78459b5c374f3feda989f7fb97d13910516788f370be680047904cc8b83aefa27990ab6d24f98a32f4692c7981a498a5aa84b4a9653a9272ad6993645f44a614de59c13f23c5662c86ff765f50f71ca5d8ea5f202fd2434b8f91bef2b2f254e9f348a4dfd099c5fb2461f781eff7dd42207849813d0dee52bc5b356e20f26f6103f0e8fae51c542c4440805fc657e9fb536d773856b70428719a91a8fb33389500a1c7b66ac37e5474ed39dab5c84941a803c01a76fcb85e24f8427339811f92542b5258ea15749b7fa939806e6934b995e7de0095aee10129eeb90d85abaf5dcca5855fa70632f12b9efd2edd640ffd9f986add6e21fd5391cc78712981db8bd747dbcc4d3bff6031609750a6bbc2925cb7b6062f5a22723c4999c1d0d5273aa6f672ba624b65b7a1817bc29a893eb446360684e2d0e6032383e922a7cff5a4fa057a239e84cc46b2f596b64cba607c7ab602da3d3b96784eb73b272b4dec77cd445fed06284c843d10526da6dd2d5c194a05f8623331abb043c7182e00e3319274dfbf46cea677456337d851a70075ee09237a76007d314e4d4552c4df212b7068b8d73111a53dbd276e56419691a20dd09c77d52c1d223c3157661018286afc0101f9cd475eb7f6bfd160cd11749b1239ee213e908d5b54d7c4d28bfb9b9c78495841f805bfb9eb2fc9278d7b4cf18bc2845f020b0b41d5c70fd036cbdccf66770305e72c0b673787a5ba0055cf27dfba5f0d4b367be357ff725ccbaee535a6fab9faf1cd16b0fb7bb5acb9d0f267e5f6b713806cea2db73e0176c38e3a3440cc08d6c1f09a7be1d6f5904379150c9f84c28e15bb5134f18d2186b5491ab36614641f1fcb9b11a16e24b26268aeccce808a7811e0ef3e68371dfbb70cc5f4b180635b5225b266bc1c9857ba03b9be635c0e38c7b17ed8585f7780ee0c82fd0656c2a93ed629a66e8db0334f64d2bfe6b6bf2875539c9253f38f4a6096b1c3fee474aa7f6e768b5cbb651abfbf8fb056090221b1b6d8b47734707a3da485770e40a62934d3f6a92607cd321371cfffff63e31a39fb8b449e44435a174e96be7a2fced8dddc7997759889a98dfcf94d4ec8a6095b004b6168497a38c10c9e23c213047896ed5ff2420ca3147ed074539158d27e485d586cd1ff07d83ab02878575157d8bcdaeaa8f0bbf70b21060c1ade60b0ffc87b292046d1f7e9b161d0779cbe7ad3f18f2ec783645e8638c0020a3ad2608fcd67d5df572ab3c207abb545881463b3cfdffd7cf57c9a069365cd4e7ed0a29eab6fbb73809319a101d3bcd6cde1102e69e23677e9ee465b6ecfa361ea79ed85972a79fbcb8b1052fede03a62054697d06f098e352b0cbbf2adba696bdf1ade068c15a948ffe53378eea4f200c29154eaf8d05b32ad79e1a956e51f91ac12e6385267c635f225b0a3abbba790fd2ebb2cdb1d784b8689b46fb85679b345f9f1e3c7da00e95a2fe2b56ccdcf8d2fc35e3ab149a47bffac14e2a0b06929b3e8b44e088f25f7adfb6a78b6211b5516e52825d75da29b9a2ee244fda488826e593c6a0ba064595aebdeb0dc30ee10c93814d0deedbeb0ed55ce0670a63ad7441d5c483130e45992020e905e2d63f5a02febb5e4fad6e9125ce7778fee496c84060597cab75f99ef1e5b63dcd2310fc992b55e67584c9b7c27ea0e40ce36399f360ed20b8443863066b3c6f5c8aaea3b7295e2d672eb3b68c181daa395d1251893a57434aaf340557e160a928e4cf50e694578200cf7b9ef3c7f7d5a4dc4df205419bbc6a93de4a1548b5a8344ec9d2232842345c9cf2f9c2e50c24ddc94e20e764edbcda3854f32a6507e83be5d2e9e08c536396e35cc47e11796f6546f4090ee24b6b4fcbc4bd86c61c27e69f8a8782458285c5fc62def61dac771985a2fc2ed7bc6938633bf20d6cde3a8f75f07cacfd5cc0d6edea7e9069fcc93b8e0474ce9efa71f34dc24863626668d72ac5c65993925a4a9a745da68e777aa0982122531434f8f5342036895c648f7a050a5b5729529143784379b9d1aa738d972758af03f7462c4e7a12505ce7baa191b3771c8acb37441be6a0f64849066d6068faad8e08766eda1844b9821a72c81475b884f87b6ca684469b74ae52a816570b7f8f63de7d0bcb054b0e91470d9bb04e74725cb2ccf411062c23c39cc6d31bc2914911ae61dd0d6541fd8453216ee8b85e3c2f783de117791b7b80b96ea67134d1309922fea4b156b0504b9fe66eeef634a91686dbced9988ca6cffa3be52d42f8a64b3477a5144e019f11c93e83d5f6bbda3f902d3654a328ae2cb771b28e709b590e0330e007a0c7d5d6165a2b93a40614283a61a34c8bbefafdd3baee2a68d27ebcd88632c59704cc5a835f906dc350424adc9b1c19cb82a417ef6eb1a5996e3c2eea17f5ce542d01d3fb9b0eb6776bec4fe7e423bf5674c4727937a60cc1ba3ea604ca8db57511c7761c65b6b9ebcb89d7d1635b28d9cee3a57febebc02d30506b648e2263c12f8ffd0ce42dd9b57725931b9b1bdfdd86fed1c944a41503c46aa8c13413a3cb79e3f1fab9130876e460d0ce636576c024e9ddbd7d3ae3a8f25ce853bb93d85f42268e6e42643e8961a6f1b5e910f6c379fd6e2919774371a98832825bd820a3725e882e369cc2336b386a0d54e66bac7faaae02eb356afc57cea931e80799ae17064700624f1310291a404191e9c6e46e1b394d2abc685320933eb2ca7ee3ff6670d665b7e0e3623cd49605159fe3872bc60641c666038c7ede35a394d95cb3e987592189601ef98ffd61527042952e3f9d9775634893142fe8b75ece8b18853de9449213317371e858a566df0a27ce4190e85a82446322852f57e48d9568db77879f37d2f4ac9211fd190f2361f4e29792af75e052741c4c6c7a7f8856b7f5fa99bd3e298ceacb1b3ec74c09a48466b14cb9936f5f192c394bb7337744b1275884fb31571d7bedd16dad325a47f9df7443949cfed53bce27416780e848b6550e9240399137570b64652df76ca3008a1aca52744e108d51df5f188fa0b1db5ba38fc020341503a56a9425672ee2aa95450d7ace48ee2bf332a01246decd53057150f84f158b14c512c3d96923840d32f021b362268b8bcbcd81d539c9d318ce4e633a8517ec2a6239181f78e6ffb69eeea586f0c13c0122babca38dae0a343ef8fbabe8242d640900b9ca3f7a36e636110d66e56bd3951014d09e8277261e11bfa235418af7c1646a4c4986ef9445e87b52d35e01e450f6894e4c74cb4212026c44040a18dae3349f2b124396182e67a36ef339f345717a6f4057eb9d8866283dd01d11ad637435760e3ea1412f586f2fc2668890de98d8321d44af4ace8f981486b9eee6f31f2520d4d4ddddc996db22d2890f34e76ee64ad98750f89c6603dd96c08004bda573a2f862115df76eb4210a5846f66c4b44fcf15ec2e6ef05bb837e746f50f148ca4741a9486b8adfd161595dc2188bf8376d6daae061fe67cc30100877ec02b33911fca270c5a318db1ed814bcee2707a0f84628d4251d04bfe25c3cc9bdba93a407866f90c001a3434d68e342f2ad783c36323afe6fa28cf978a32a692e4c71b82304344ee7e955c890ae74f7732f97d5e886c52bb939fa28e5b7097f59e66e27432cbc3a5246211b92df074e4112c4510217e163be0223d76f531ad916146656c24c0b018890cabcaeea0f96fc35eb0387729879a8b9a61a1ef1b4649b8f1ea26bad39b6f286c18dd562a69bdd8f9b4c189d7ab27bea12596b4be47722c37c9b8026297c8f3e7c329c9c92a6c2bd1149dc1fbcfa092b332aff13f52a4ebff9c78ac1cad5d6419886f9cda994828d8ca9af6b8bea4747ca66b85bd580f5fb0a9f4ac5bb96c823a7361e62efa11828c6ead2c17a5adad9f25ae6ef17549d7484a9a949a69ecd7cbcd1018c6c26f93fe6b4f0639a877a2b84a04119dc7ac7a177c719885726ffff4c0b082183c2fed0c692a1cf450d96d733d285dc44d5a4f8ab13d009631c7c3cdc3b0fd1c8e26c27b54a8aa503c32e3c7f2e7fc1c16256de6c2099bc24f0c7901e74516622674213fb3eea66a9a75241bf4c22d7d0c275e08728d2b6852490e80e93f5ba0ecd83d11c47a544bb717653773181278358fde04f410ae6f64d72169c0f049b79605ab819c604d5a20654bfe443bfc88ba94e77dcff7b36730635b135653b0a94a5d877655e64fe6191bb25b3409a8b214a2dba2057e7aab7f3e5d84e9131f919785a91ca873af11eeb90891e2fa86bee0ebf2bd45f5d15daf245af16073a7481955166b472a8b2c359408f698f3fafa1047476d5674066af91f48ca883bbc525fd2b1f464db4514e0ab9eadac289dda9724da524cb9acdcc2a5c8bafc8cc19851906de84536597ad333de0101c9156d2632b8409ea8380e7dfbcaef826703fa90d876279aaa10a94410798cf5a30390e4cba0673dbd27445f9c18816dd9e7f6e4b7006b3a49b9df06a5887a6f27451270c644c8cb336d0d2cabdd20210921e565179c338f6e7dc8434cd5584d298848b56ad1c464e4eb17b71eabbf7b909940a3e6049663ec5cf3817a7b2516b62afad3897fd4d2b8263ef29387c1624953e2562b86f4afb2ee63dc3ef4ca947c78174af820a3bb51674183b37c3f55c4353a0479d3ef46a6ce71e67ac487c8fdb1092df4fc1325937044528edaed12d4bc22b1d5537fc4f1905e80534d4821266b29524628dbf43e1fc95aaa2e8c293c61b41e33037e6c807caa3cd9c7af5109193c23fc9620c96fd2a66f778586d728387c1e98b6ddc73f8a27171dc0ce140428e3f367d6819a13424eadf008a1b0d1539912d6432a66d2f5cf2df0fc4e7ae903b3e70c12e2739e7f8e7216caff0a55ff78c78cbfb5e91c5710027c45098b9c0f45f99b01180da531bc5d233a88e1a962eec34aeaaef5e192220be7184e113c7af18f1a3b3a946ca579755e54f143c383354a70d6c5666e524e5c6fb38b64cf7a314fd35cdedd7a3bf1352bcfb004b308cfac68d8ed6e31071a1a32cec114b90bdd837b51f5b3662c162de2b0149ff373e3b10ef540d7d11cb1c351ec7f6ba4961c90a0a5f2d45fedcd883dea3af5b343495e2e29d26bb15049d2cd874217abb7dfa1580baf0e6f070e06156fcfd9c517a06d56030f87e5e2be6cd12570872dfd713b73aa8ac47aa7989a7dbf9f5c9510570b3721c00235ae3ec5615f975737178f8c30a3222516d9f21508f8e0d881485e86a4131843261585fb5867d860b6cb2bb1e60e772b02c022d0ed4b84ac720b1aff88d443e1d6cfb891623f8ceca5278cf895439ba990002ded48efd51423e16de7f4ccd6603a187af84e2a8a099c770b3ce7305d8b7e8a9a1844832b5074db054b8d3756f4f79dd81b07b3497724f08093064e8ac477bb52cc02b62d8c08e32252fb37ec443a9ec44abd92567968f82e1497de4cb36de5051192ecb0049d28aea975115bcc9b5bec36f38577c0ce94644aff0c3ed8ce6ed2ee44840109a613fb4f4c60476edb1cdf367b98cf590bb0bf38852d16b078b0ea27ac209887abbe29488df3b924e10014054e35ae07eed8a10fea365d1e683166468a8bc6c07d239865b5a7da241b7e2c3952d4ef1ace5889ed0aa0559f827ba80138f6a6f409ed4a367738a7f260358cbccc37df08e45fc3614222d6fc1e78494ecb1f1e1b1009d9470eb60102a018d0a8ced5af68a1b27d0ad5cbced72e85057ff7ca3383ceb445358c25a66547981dd6ef9db754a27857b8a4be2f1ee27eb43b33a6bb91b9275b3b716cb74a5cdf9ddd0b947807d25381da17083e1e938f8aca920c0b355bbfdb9af832c0f87e6f95f6577fb2ed13e5cbcf43e7ab6b3fffa668fc87c868bb76403747797b2e0e093ed1351c36921c24daba5196011a5dc1579bb8fb904a52fad795a4eb54e9de8191e6d3725d0baa4639ac46343df30591d73f3e0f3652eb66d4a3d285d6913908263df78fa3e0b425082f9d962a3e48d6c9fe0b0e5775b96acc579a9bb10df4ab75e3548ffacfc5bfdc97f778256c62d17ca8d25079dfe454acd1299e947723a2482a569a6e5a3ab89a6f1700a639bdc6ee0939f456b80eddd1d0f5af3336249d9b67b54cf30eaa35b7789cc2636b9a3b5ce178b1309b5f1253d96cc0d77036b0d2ec1d99d0d0d683e387446fa1c88dda1692200f24d317de6c730186c82322507ac405013e8d8b6034cb509060c431b229f45599626c8c7c47e3df3ed80445ea4af9bf744bb5173a6ff9c09eda492910a5e68e9aa16613ab77946c40d43fa88bc895a477b6c8b9a96ec74d3ad190bde22fb86fa6a388d83c183e18b66a60fbeec5d0a97e77dd89f4835186a7c66c2a755a6da0f02f12256095a61941b444017e7395ea130dddb9af7070c72faafbf05c5e7f516cd8b917476e0b51a326096c804c8773d1cc587563af6345a21ddb11fe164a8d12e8d140c7a4a5e5b9a02ab12ce7fdfdece9849c1b5ab81568fe06038a97650ad18b53e9aaa04da27c717b792c38b65a7d1e020a0041c3d57ae75944caede835e3bc37343220b5fc55267748b4de9bc4af8e3a7e98f2ca35287546f02b1e0aaaeccb459eb109fed27a5fa00256635df09188f416766f0ae3eceb48819eaf19afa875006cf02d28cddb140fcf55ad8d4c0635d6e9501a0d5dfe1a3ac3336ff331ddeb076b39f17bddffce83d0834c67e9943cf5d373169569d0092e4bc7b6816f150a64e6879635daff261eeda0fb98c5adf6e0340e30f2b09434e23b3d87bbc6b94b9bb5781e2530494fbca3e0618c15565cb6960e869386dfe62dc460eaa844b277c5ef4e98dcb6f6a6252803eda70cb9e934f956ba969c81189bf7a72a90a77a93e0886846d05dff55795eb1716c0895bd51850bdce5d4aaba1325e7352a2c3bf5cae8df37f7c536b8a6c704c55a1688fb8efdbc4b7928f50313b269d62b4003251784447b29232c788964c7e073aa4de9a54d75bd3f36a1d6254aa5a83ae2aa21597544fb54c4b4a1deb86953d27dc852954b79b5839f2d6783bf0ec1ef08ad713b21f1edecedfa7e92df2ef5f0776ada5d9436a6f9844fc90f6db10617924b797351ede038f866e3f3ebdd9c9cf19e2699ed74296ed8be3cf9ef1db344bb1f3a915ff022b8e44abdb9bed85fd0a48b12363c4a5a6a7959a0a486c05ae1b5656a795b53df03eb7263455768fe75750213f8560fc1fbc7a3afe1ddcbf372133a9d54b312d532e721fbbdf93f2f0172db88e2c924ca97a9689afcadec1baa90bda02f62c9db0a28a678be6ccb995ee71bae48269cf9d77ab5b6d281fdfa4cd4fea9ff2b989f718bee3601c6197e9ec17f2389829021e95206c2c0263326752d7b9f2c1a9677b952c23ae177cfa164bf2fad419545dfbf02f100a65f24ad0932d99100976f1864c419e94e8b14f612d59716948029b09c4244b7ac33259731c4f27bb6abc5f053d912deae3faa5c8751e3c8f606bad853086002fc80b9f8d671abb8f119dc3764681e11de4a88ae4fdd62d57e4775dd6a902a971ea459ad39ae575dec9816a9de156b335cd14781e1dd01682afd9818985939e64f88059b17cd595d5084fd9121333cea99531ec12ea01d84c993d1c0e72fe712ede9776b8f6306c4b778ada9961b488bfa52ff833254d3b190576e9476197590354d0d9662e74787201ded5fdfb59d8a8d2d2136943a2b6e4fbe51625f47e0984d1fd919f68b38cf4ac4aaa04895d586a0d5b14e6bc19d9767392b4e9d9911e629594bf89b9b2ba37275083335ad90a57b942f329f29cd0e9bde1115a33803f1a47c53f6f2a57e058f30304bd7a9fbe87b0a85d1e9867d357c3106b38f6a6a692a90224da09e050b37c5efb1180f5010464ddc00e52b4f7c412d0bb0263849a205b5d067df32ab77e1dba681b2a7d23ccc22a192a0822e4955899c677ded00ff7b33a5931ac1b142ab5581e84679067b6f3d8ebd29fd60bed680d259518dfb5a51d2cb111b1d27cef9e1c967d610813271496af945c4e6319f64108095aeade79859ade06f648b0d0eb28e0fd5832e80f2a7fbf5d4065f6b75710bf1931fd2323ffb0891413138a7e8f558a157247144b1fbc278abdae1595d8148a3d9cafdf2a1db8b9f2753a3a3df5de0420504edd5cc2cadcf0b4023083ddb29fe776b67c86d546e7c5fbbb78adf1a25ba192d61e0eae2a04f525b747ca8b825fd30ad232b39c1edb296087a7cf15218c701c95e0a2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
