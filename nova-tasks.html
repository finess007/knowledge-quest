<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ce8e6528e8b796b02d4f22c81ec106e83749ad758c4d18893f56d36fe114e43cb5b20349dec2a076a75d73ca3ff992640fbe49b8ef3779a59e25b288aa1ba8807f8ace3856c9f6dd1e42620a41f528a071396fcdc3ea9e4bb20d4de3f2778f2dfcc78aaf5839ef4982f69068da79ce593667f32c91d8fa28d738de106ab6f2d36deb1135bae42bd31dd45feb68641d725e85e68f1a5815b7c1d7562684519f2919736985997823bb7bf484cd0254ae4d1424b9d4e331ae680f7ce86bd67c620e4a93f38d3828d12d80e43d84faca71002be13fb9b1340a695d65130373270037fd3c2ca1ed71c672e850cce49a24cc70e37c07aa7f22beeab664587701fa0a3a32594cb606fc7473fab98344313ba0746ac51f7cd3c89e6df9d80f70e39268bc9d794c207c634e8f9f589c1975117dc582166abbf7dcc8ad3b5ea78c18802392196adf2229e0f465be07bfb736db7ad935e8bc3a0c6983d72be9b5ca9bbf6fdf34cea12bf5723e49ea060d2aa5b3ad63e9a756e7c1f38c84393440e230203b4159f56bcd8a46f10e1dd21dae9e4e96d0480b4e0b5584078641e17fb64336db923428346853c62808172de06a1d9f6e5daee12114047bd22c059f4b0168a0d53b9164bb426f7b6dcb55550c2006559f59f2819e18857cd07600c99e9fc2d6baea7f0c11e3bcf70eac9cea1094666e8a640f59f41696aecd0870e90664968b15d93c0a578b3de95acfccded357e884edbb85f28318e10dbc3ef5c7dbbdbf3c98e9dd299f0cb4936fba3a0287c830ec5fa1d3a31211edb344aa937c373f0fd6fb52b2fc218d8573a239340643a71de791d88a4471165944e32242edc7443429616f93b6236cd3c57f6b6c55e1aa86cc649baffaa1ed337fde23a698f4debc8807f3c3d39b6a22a44f90940243cd0a75d17c07d96878e7452d6831654906f26d11e05e1c2e9f691c5f26a5e9d2b398d63ce63e100f6ca5dea25a8a3277306bae0a937a9191db807a6fc245965af9d58fe4e7350049fcb964aa4d1aeca5017c32dd0dc5e8595f92bb7989f2b53a8db09059e3d6e86396221651cda857c474c96cd67d0d38189fffab06af489a4de31e933b4dbdbd1bd24ce4a13f806835d23de486a3944f4debb5045634479d3b8076e335b2f293118a83c5c1460299db594bcb878bd79448cbd50aadb6a4cb34fbbe1880ef21e0f60a5935081bdb0df7f032e27162b76800980d97d9c1f9b8bc26a046c66727de008735196875b3324ee89da44f654a61b0fd51845af08fe7a2f954962687b4df2ae648bb48ce1ce782a66da82cc9440a1a5975685b98f59d35ba53cddd309908e9adbd693dcf3aee8ab8896ff1c9c33bbf3986eda6db8b6175f2ad310fcbef73a80b8c877d8ace71580e0c18d23807e54a2f9d3e81fcaa56d9cbd847722c2c9923c54c48351d5596b852c878c6b399e6d1beb6a28eb9fd8d15b170ea7f2d9741685e8621c10c1d49a0a2660966b054910e90984d7dd44f6e84c2b27ba2bc8438b1d6541bf794fae899d2532f8335f3ade52c164f1f70983ff1d6536c77a440fda40f0697231347afd1d76a969c1ff209e4d4ac26c358ffd028e922cad74cf20f5a118c0aeffa6a3d6d09e4d57937bc8f945c3287f490e0d990859bb86e13a14e09b411093088556005205ad74e9ece563607b3a10165084205a04d8afa165368faefef1dc99fef2aab2999a044771db69e68a29916d065cb8a694323627b300529bfbec66d44a9039ca31d10839bca94b3bdf2e4f3b2d23483476ec6f3e8e8501b77cd958d9cba9f0601c98dea256029b38da2e921bb4a345637823448936e8c5895e000f849cd414deeed9943cee36ad3628308b3df22c716ea3fefe74b6604aa314a20fc21028bb9816502159107d5d95504e1b992cd663549694ef2b98e632d20683fa7ff8865f9acc12d0fa2c8aea2e490f19ff057a5c5180db88e1fd1e17a40bd695fd087ebd1d030eb391b4f1ce9b343aab903a5b6af325656425ca273e7ef6f58a42199cce4b778814d80bc0aae24861c373131a6fa2db52ec0ccd5e6e38c87fa7becfb98da00868e9fe532809215704bb9932f15380d9a7e3d529a856a4f33a111d4f46b38113ef2cff10c8850c72e22c2e1cb9e5373f73d4e55597f40c39949eb8a5a5c3b4a22b917e741b89776ccd1818a921d04a58ef93eaf4c9aff3e0a0e3d9812ad2dd34352b8b2aabe22413016039154c14ba3a82e2a9a0973ebc3a9453d7ecde23de36469d3b26923494c15ca805152b7dc4eb7e01a8a0b1353bbb82af75e6168a4b9465d8bea5cbb876638302d948b55bf7a93668b7e567ad5137df8703c0e21ee1ce625251fdff43184912849b012a03d4517c7416489e5602472549dfa2a907928522c34dba39f01381702989e15a893d179493f79b1dd67e0c44be69b03c8c084a172e6e69d5f8061c9c9aa7e0d5df88bd3043dc22a4e9d3fac15bd072805444a80c5aad95dd7e12f7f4ff5be664763023e71708d7745cd0e8a61750fc3285783f977a3de4fde55a5d22b96d414fc439d5a319762db70d5d18516a435e9132ad8335d1772ff4d545ce4fa5a8ff26d6d93b89a390c1f5d10897965056231d1fe7cbd6c0de5c4b5ddf3ccb158f9949f17b52e1a51c2025d3d8279f7804eb61ab1c19683ac45d86295720bb990b6b838f960974b069c843c3abfe294daf001ed641a926a6adbaafc19f3c3eff53ed5a41bd3dc7c57aba90e085f0fe0094e702cda27ef4ef0a5b2e69fff3e6c5964abd027eafe1edf841ee31b71076e5b4cf8e296041182a369ebc28db2d3cfeb2728dd3823b683a5a3bf2c61551e4dc5f56dbd14163f813f268d5344bd71184c60c6624a69f4de6c229be3c618aedcefba2eb85eeaa1f952a57274c2f5d5f019d7e306731fc82091cc9d07685b9030ed93df92773a9bdbf9505aadd55e50b035984d710094d1c4161cdc2b8bb290bf832cc071e7fb202c54270a1596349a5be9b359dbd03fbc480a892bfa01fa10dd680882c97646f3d2fa59cf3050d380c77118d9ffe67126e90d6874cf781e2c62c04ecf20083617ed07c60f8c73229e1ce975cf63a1a2672b65d26c732633d58f11b0105aa7e8e257b70ce354bde468b6e776fd90feb4d90a03bf954ac3b93f858763d4211e843c62c279d82c4e17151064b74c7a9f147a6e4f489a30defd0d82cfc17012e411f4c307a079344a29b2af7bfdea6aca9869e5eb48a38b0d2e906be60fe0ba34e51c11f9a2ee1e46696ef31f648e250792f1021add901d13fe9383d814bebe45bf69956a7d40814d4d68a2fbe66a6d11b5e6c36debfe57261f8ad8c24c68a24622ff1ab01c52b88525800f43e5268dc386bb19b819c81484dd75b5968c9ca7ab5568ea6d5d5b3f8b8ba97fdd755736f124c5fc2ff16411f9f4e42009c5d9e37e9119e2f7789ee787abcd9304defcbcb6366e3f613b26bd7f2a0a3ea35a676f8904b14e27fd77e44b9816105f252e290ef8ac3391979e39f1b1faa276619cbb7685353d51d42ecb1d2f474e6c3dfdc559c2dfd7b7630662720ccc6b78acf9674f594a7988fb18b7a08abff1fcb2dc21ff804d524556e5da6760f5e78eaf45a0da28799ae382865c4cb4e3427d24ba0c0bb42dadd8238cbe1feb2fdc99345cd9df36ce67c556af986c7412f40fa50e2df251b851d219c90ebb68e0eddd7453dd6c91d10495d8196416b312a2c99a1555215a4bfeb8113540e7abe24471f5c52f0cb1537a3a2d0838c50f623df5797d1d2a829e90b46bedde9c7e251a96306084f5e37eb0c2d3af15978bee105f6c14cace270ff9c0189103c0d2f410c47bd2687d7f552e9730dcc6be68b65d82d62e7c39c58b62cf59f72c3e595074970f2bfe10624ffaecb2d9649174e2c930faae2584f1b34f8315480c110034888624593e47613712e9150f205610647502894ec8eebf55934c47d3492d2d4c7d95c518a36c57a23b81344966e5f7252791d66e14e093b472cc3509c3619098f104a2a747c124ac5ca4f0da5e048c67fec112e0e0335fdae8141f892aa5fb5bf3a4c37fafc151309e8e07f5f8a5a4bd5ea6e649ecfa466c27d95342ca04c98febaca2a6ec0feb2f6a8b2396de77dc13595957e35c4ee85f9c5539fe38a71d931aa1557ecc948653b715401a0a8ee31c7efcc495582080fadf1841cbc387538b68778e6aa3ed13bcc236d67f1540ed753aa5f1b5a6aff805db8fd6d692382a68cc26fd2f3790f3c52e02d2b76a8e2dab1bf376330c8f34db6d36534c2b8c603295f3d5a87620b862cf6b889f7797bbe09e69ca3d6ff6b0160bb8dd0cdf415d4f96d55c0260aff6c175785a7f831006004bb34a1b05aa33d790020f83cefc4674af01956efa418c9203a061ee5f762f2a5a0f983ce1d75ce7af659dbcdb742d8b4ba213faa3242b37c60d1f5995d15721ba6b01263d5adde719530e2830657c519f7afb1a00ddfe43088a41f4a4579df2f5cb7ddfacae22e99fb0b4eedddfbe8646ee9b48b039a52e018f86078d345b6ef3b2570dd621dbda5b7415c74980075f73706f088112cfd705cbfdb22dd814328b2a7ff4f394c53f579ca70e69e6b3c4623b7d45c37dcdfbd42400304d91ed5e921984d7cd99200377f68c1e9259602d20a90965620d47f2eae1eafb68d4cd1cdf4445c63919a7538bfbbf5df5bb1fb9e0a7b0e014309460b7c94cbdd85296824cefa2c03438d857d0ffba1c6486ecfbe0ae622495eee89f3226a90f75fa36fce9b34d8820702a0eed60d5061c2fd4b300dbf5d4f0fdf084548e0f4edbd6dc7afb3e7d01263cad7db0705cf3ed936dfee9f28eb8097ea81bed9f5712eb07662d549b50783d8246b660bb51d70ba540db57c7e248a577fc16f43186f71b6a1a537568f0e4c45dd28e4758b605483c6e8bbdd8210fb2d8abb994cd60982d6d81f00c15280d0e9198ee341045c50da47ee13baf46d593b5d0fbee761831b4b68d68898948eb40dad4ce2ef0362f7c0a719d182b9a0e23dc6ee3fba414f7cff14cad33cc77ea3142ce8a50b1ff04a60140cabb5b0718a198aa52ac0081b9d6f1c8636cf269d73dc47f75625524bf862ba4b20178696c9156af06048190302232d29d0f00d53e3afd8e187b5de94d209be130a15d569b7f90a2878d1653deb5dc5f934823e8a92de0c6a266241877009a8a286a1cff429b99c97e377856ce88b974e93a970b3f25b67a233e0d7a1f258134d89d28f890463c6f59abe6a7a62a0e74e9d3fa09cb64136e9010b23e8b2c7c5b9713d121682696acf81ecc770eac3b5d16076371b30da386182fa40a1cc353ca3308a0ac0babf5680a90b9a19b7c7754ee6073fa2e43e33b82e6d0d0905d288ba76ed11706dd0619b5278dcb80b3ca7c86b9ee14c1c336d69ced719e05be29737e67c92c3f8596f90c9592ff5278be6a10874a8404a831dc946237ba43e955731c21df6dec928fde265dadfeadaad38e1aeab1acac278fb4cf5d49976fdc9ec9b40499a84ddea748c3cebf31ca87f081301936469f24c8378feb6d63707a05472ac86325b0fab3a188d096409d701dc754b7b95a4f1f5efdbf269670e5e903c87f0539d9c44fcb47d91d4b5af79969b36a2738fc63d18d237dc22adf9aae2d971b337e0fc9c0ef95373a40ba58b0d720819ff7ba7dc4d695df3c4d6541d5e471fe64ca2cc4b2ece833377a63854f2874b9fb222f681164906694ea2f9c74e6db540a218c6529f64a1509b702e05144ebe3c04cf16c5a738ba57b43c66bc8c27b9c0d31b4d000103311c667089dab0a26b15ad299323608898c0e71c931b047ce651d9aa55087121c92bcd82939251a062efb80a945a73d404cb9f1d591f018f498c3ff4b803aa4e8b87c133d88185983e735db618c03352d3c00b744f1fda1ddb09e7f963d395875e91a95c8e53f1aac4168b0ed162b8fffa0908449948945559b75792bc460f663a204ed529ab90faffa26dd5ca858b7b3b6122a89d20bac08d2ad17ac26e94ed43e823cdfe574d60a906936c0f8f10a3671de405dec385913c26a29eb22a305a6caa79406c74dba3dc69b68e1fa65222f48da3b1737190de3d2ef041c93a915b1b8ccccf8d14b1482c9ae646443fd10a204bc0180ebd3485f5f467767abeee6a25cdb40dc450cbaf14f144d2463420aee5215cc570f4d0a3a940c9f000e72a0abc1db1182eb3bc4579941149144d620c15a811d7c30b88f59f68a12d2981cc60573aa35360f480dff4d909b0cdb9473a2166f6da39b46fe7e9b8117134bf13abc8d5d2f8c1f7855437038d6682a7d6c76a1b5345d54b5e06bc558ef0d9e28f9709349c345fb3303746ee283a7ce88e328b5090409f46fa5d8a9673575359f0462f6ea87cd08ab8b2b42336fe654b4d9980b74ebd9f43e23da48f5f93a4fb84378d4fb1633278ecf931f999f4e8fa87c3f95ea58dca59a729740710cc072c2b9f743772bfc504e7ccb16ce48979c92511be33f5591447eedf4ae72aa6acb81b98553e56155a24e9bb334e89a17a2a1d36c57b7a6d201d3e1fb8c34c791721a44b223b2ae29b539a631ae7dcfaa8d2593b3682a18132a578818d54f8296cad852318804e81780e88deded86606dc5c194da27c1fef24dbade1fe13cb9d3a69fb512d92b0a1b8f8486dab401c3d3532e283e515f8b3c380e1ac43619de666f891aa4ba12141236e6f1b61cc8b6cad6ef3eb27b4865ce62ba124058ad5af8acf5bfc7ad9b47284f5f34625539c37543dbea6f2c8e0559f1ebee47c2fda61ee04c78d5f5bc28cad8fc20606a90f5a231cb036169e4e7b0f8c1cf2d879a7ae3917549fa1175976dec48a8afb24f8f6c9c93e31b98ee5b6cb559f0217e4890a042112472c41b6506f777f256ace2dd4980a53900f4ca23999bd88aaf0b7c2531c9f47c20fa49faef3819f5d594dbd503d319de84078629910ae6a21201303b57b76eef0922444aeb24da7f57e3abc91ae8cfc0892ec7979b5004fa3064a8654edd5c9b612a740c5a752517d48e53e17981cf64c485bc6e55950805146e8858dac9312c98363da1b2c116bb6162188e2d1c834a8e6e4c839a8cb957f46b695d708ee1406af9db618c7dca4d30a2f7b3a61f70294e7b0b3ade30e6130480b317021aa918fd0582285b76047f8c50febc9c403f8d70c128b57dcf296054c9cfc162c5c43648bf9a018957c5f29eaec98ba40c0953270f647a75a97586ebc17d3175d8514f81b9d8766dc100cb9c64ee15c45b918f00227f18572eae4ad611638389f41ec53c0d27922f755fa32f78f18bb6ecbd5d9e8d653b8d41bcbdb88d918ffa2feaddbc6ce4b8d453fa0a58ad58ec8dc49a25cb08ec71bcb485a5737e3d350bbe0e85f23124a3ac629ec46786892a8a899465e52f85a990b33f8d81567f8eb3ca8d11b47229c530392a5f186b350acfb53b900e62d7537dc2098f4570c9605c3ecdbeb029adb5749bb7d944cfc4c6e8eab7ed5ab775ea7906deba03be0d4f6b2396f2dae99ca994935acc74e8d180640f3750fcb54186833695f764ba18c21ac36571dedd61604f3a3c3336676df7db68cdc36c98baa0325aaf3937ad70c1c1507ce339cf949ed09d8614b5273b7457348bcac145a7f9ffced200faa5fd30ea617f3bf7c379d5af545e0a3c95aa5d7b303714606faa945a42855d2c2811cd9dc90de0c36a3338beeca9c19c917ff8aee248925591198c36f3f831a3717750b7d0ad65ab3e66d13c417e103cfb19e73c63e45d4bf05065263819a5841c1168d6ad8f88921414e249fe533369720ba9ac13fa25de46a1a3ac0360a6ffd739ecbb6cc18d0861138c6c67e081ea20d57e3ae586d13a5f3befa1a362661db566d278607592be5ec258df39b2f9b07eff819528395a28f5aba832f93ea4398551af7963d3d30ab6e6973e2501df4235202671638ae27402d01d24e3e6725c53aad7d55c77ca8f1f30a5c670efac425e05e8ed50bf07bcb17fb2685aab001c80270b84415c72a7170d536997a371e21846e8c6bb9a18cbd294207d256d5ad121982da18aa90b6b128beb19e15b09adf8d78ea8d1df3ff4bb949b823713557775c9618f1ddcfb0efa5948b2a5ef79b97d9c8a3c385266f829792ed46b0fe0c55066653989ba17c1ac392d554e2132b7e9fc1ba666ec536c9c78c755e6603aa4f72b012f867cbbdea330da0af33ca8c0253df51359c949bf47b6363966f0f2a50cecc6f86d96374d0e58ea2d4a447ff3e0a9dbc5d666e66a9f51db0736e6110e3714fa7a195ebc7b7a9a1b965cf17440df7f2c2a7579d5b2895fa5f700a1667aa41f84dfaff3d18e35e546039b1ecb1d57c0233a2d51aaa5b6ee96ce96c7be175dded2747b29306c48fe816dde17db79a94f4935383bab10eae58e80ca77c491c8692277a8c7518dc53974b05e70c163214fb299a9a1b3e212153c191445ccfb8dbe13cc390c82900b3dadce8a432e7a900af9455236fc8038115d439f2b8256c7a2c6e2d172b45f01013df01054161d1593987d2b927c5d7f295394fdcbd7483fe0c81610cf34d527ac45b5dd53fccb30945058004988043f7da73318d59c8c6afe985a4a39fee819d466eca8cd978a6ecf382f3d37ad0d9385f1a530a0acfe9fb506fdf86f079630016f69be7bdf8a68ab45a2993394e0d8816769b0bcbcee11d23c5cc88111fe0b269858abf193469373dffbfd7b7323f1492e8ca02d42ba2f39554be9559590ddb3197a3886c2ca6533ef05fd78715b01b367e2e2564a1b73816e8ba5fc7b27f8d6ed91b3efc7a0bb5ed015bd84f87e1feca74b67d1b87e9bd4ed085e19b91ad0287113956ca00242500ad877de4fe0e1ff9a572b63e68d304c7c2e2fa7ffa9506bc9e0252d878f9c5d5959ba43121db74b6ec5fd53c8c20b60f7b3a3935e26d95a391173944dc0e0437143f75409b8a2c598305241b96575df0bf38f74aa2ca43b4240a3d44e7661d331a133be3acdb52f6414c08f47d6f4dfe3790c5ae322f277097ea20de9eb9c2e115388596b18f68b43d236123c7f40c38ac75d527a7718bd8f4fb4ccfff8c512683cff7d1807c91812aae47393b8f11b57d1728536f0aff8a0de3908b3bcc845b445ec00063ed555025e7dbd36f3fb62d93fb97b1a890573ce5dfb6a0639cb823c3845cbf661b7213c90f108b0a984e8e546f7eae67460fd3fd24bd3d907e9f3d84e74491ec5bafca23b1df5e1caac84c71d5a051f4471901ff65111c6551ae69635bb0cce009e5be13b2c9b2406695d5be835471a79a81cb01c50adf42f4cbb91180f3909d41cd348bbc9464ae63f080ff6a9e766ae892f988710c4c9dc2e9bdb5eadccd09b8be3a6bf391c9d4b0ebd17f08d6a5626bf17b3806675ed9ed87f4a4754cee0977b8f157de24d0abe881dac73550f77ced66d1f434a7141db1341dbf8d607ddf98e53ec9e28305c5715df5ad8ba522e45e1417f3d813594f7d61bb30ab320f516f9bc8739683b38d8f73e3cfed37b13b8a106d8ae5ac7fced790cc4b8e2118bdbaf7c81597592ffbc3b6af9b4a5abca12090eb073243a51b7f0b9e92d1b7b1325ec898e57b8ea6da67f9ed0eebf21c3015f89db4db9ab3f6e9bc45135313dc88db1d9b8dfc823863a051ed91c0195981015ed5d2e131785e9969d8628a35398035c753caf21ae55d78b0d6187537ba7160332822c842b813f76fb99a5af7a58b86195e8ee8b1dc1cd1d428a5a1c7a90d6098123f1df15ecdeff1668f660577a686e0a18227021950a2bf2e527efa3e8bdfdee8763e49701429d6ae7a9cf5ee7e0385e376df30ad89fbef3a8956689167b24f8e53030b078d20ddf942f7ad3e46f97027b7cf72133d4ebe73fbc83b4c4ea1fd03b96381b68c066243d061b96c06b798a9021bff41088b7aaf5bfdd7b07e354f4fa6a283514508f4551abfeb6679011a439401329dfe860fc48382e45c50bb5941c7d66126cad13ed18075020c1562c920288dfba8d23dfe434a046ed605f44ad3149310963661efe7e9419344a11531d1790d431100b065b75ef9c853b8f181a7dc418ed47b674a195a99ed1576060c9e917daa7b02a2cbfad11fbce9c02fa7916bebc6ed44ee6530fda8ca0f7a862668b6ac992e5ba02828deee02629010ac0c074094ef7ede093c6b1b5c2eaa51612cfeeb9af3f21ef16be5b6dfe9ed8c567add4553515895d718589457294dff931dfb92d49d53e96f8773c263091f14bf4cfb53ceb7928e6cf573258ba8ae7f0ba7dc2eb86643a120541dfd842a1fc0c3ffb5cc67a9e8133cfc33208ce32eedb0bc473c4bb3aa010ab5105b889ddb93c4eae1052fadf9298738847d83c5d63367339c966428aed1c3dbcd2a6689981c4a10c24cea7cfc889130e6cf263f6bb498db27b7ddf33c0177b5fda689e0f5f0c1750c8abdf8205a2f7be9d10d1c18ca8bcfc0224d0145a742fbb3db3f31382d09a156de9385d09defe6b8cf176702182935c3a4d88c4ccc8123af3cc9c266656047a0975ed78ce6596422240bfcaa0b435c0c0097d283d69f9211a85b28092c1e8ef0ad5e23eabf8b3b1ea5f6acb78c85ee3d5956e3a2dce9699a19ce8e449ce358d534d95749286e2cc55bda7814644e08a57784676982d21e231185b0a039af8fa70bdb305b68cbbe6e87ef1f16f02b5a3aa347f6a74a9deb07f93839c67c59646f4b868f5535a033e92b04f1a2bfc0c66a367d37fc3b1f0a019c9506188fa9b1c1e027693fbe5cc99fead3653f0ffef885940b687272deb8f579a989a6b44087346292b369f4cea9f7a993180187ba5c9a73cf562b0f8fd5e76b39c9c5dfcb5a4a2173841abe417d3a98b295252f866f7b4f5ffab26eb372841fc4895c6e499dc77b4e45a0039a3d030609ca84baaba0b7830a27a2660c0eed1284f4ae4de64a8f48f2d8517ed08c3e9718bb8da199fe4b5747460078b0fe18fdacc5f30469f9a3610e4042c91c4c25ebef3b5b0b0fdae730a4b56eafa818f66c3d3520acde916bcd2b795abb2b1cd5a54c8bc6468e384c5de72fb17acd5a88eb1676d9b5e6c2486c096c39363ce108cbeda837c0371e66d6cb5bd68c1c212f7ce1ab4def1119f6d87b3a4306929aa1d07661feec2cb56108ccf84d0db88f61755c5d409c0e6496ff1af4c3050c6e41380720bd5b1a4a94bb3f25e655969da8db43d16c531a03c44019a1e114f85ee9b5e138ba4c58976b5ff2a316f15e4c7f88ae211be0d64360acfd9b6e6d47f77f4b809d6092c7eef02efdda5d1e1ec46cea1b8fc07377bfe7bb9bf2f5aafcae3e7cafc50960f67286039f95b5e5775ac22ebf6332fa6f74acd0e89a632090df5ac1b8acf51650dccf40eb2822ef214362f62e7e47ef4ed564bf473b81f1d7c09a4a47e29df84549a14610b354ed06bbf4d1ada7b106785fe7f3f875c4b8579430b295ed564ab33f2e029e4243801dfed870871a9e882ca2dfcaa8c0b6ea088fb33e4326d635f13a4e17f01cbe01043c79ec37e648b988db0f886822b0a15a59ec5d250e5047e6fe36d7611cf2219e657abf4a0cedbbd83edbb3e7b4e00f7c927c523c8aacb817c8c891bd5fc8ac4d83ee68c206e8dd4cdbcb58253416c4f3d9211db637dba006e386cd8f363d51f6728bcb5f09b4ef96904899d7fe090401e973d630d412b02fe8bf3ac5dad46cebce49fd40871abdb58b491c714f5644595ccbf7fcac425be23b6c0a16c94e763c4ececd1c54ac43692a77cc9ed716d03cffacb887039ed688112a074df5cb088abe58f6d5f6957b629f07ea3044bd98b0c3bedeba1306e5d6adb2d4962bf6474281e91c18737b7d6f1952ab1dace6547ebbb18f1a7cf926716e054a183b35933578239d70f74c49cc888f58c9b94ad4561ec6a96194add4ab82fe96f3a4bb0218e5801830b2730fbbe41b2fc9c49fdd86f9b23b0218d835e459fa4036ed5453ba7f3c2b0075af9bad4c6b284d193faa645135cd8a97407e4a3353b5cf1d9080e7cbd3bcbf4186393f3be9c8b83434dd21788e45067b58f137efe02996b294193052f1f0d0f8b39e9b9bc93e84e7bdd06ba03e999e4fa535172183c0481bcf12dda84826b277aa2a416dfbc6b6e2fa3be2da9927452d99b55965920a864e21f88dd47d90d9ec723c850cb1e7482f39693cad4c43e571b3da64888df3ccc85d5bf492a9e6a5e644a9466ba2f1a93bd476781c8f210ae046fbe68bdb69fd2faf35133cb081cc21f9a50b3d2b8a0640272fef809f9b0028397ddbf7343ec91a5301783c52aacb0bcdd4136c43b920fef0621cc842f85c58832af491f41f362ddb187c67786b95dc9a78f4563d18f1e4a2bb9e17d3b4a92730410210a8cd53c28d1f226d9bb80cec8c497feb288106fbc6be0683b97d147a2cbe5542400b194195fa033dd4a4af29e3fc10a0e3a5ac167414c4356298d440c1728309a4b6b09257e7e4354d555583c18f63af5d7ab5515d4dd856aab4fa8f8a8a846266bd1adb95ba178eef0a4992a96be106a640c47196417ca88adae433fc81021bdb83517c1f7533def93e40a268a29a210a2deacbd5b1f813647516579807e26cf3f4481d90851de3243cf0e0ec0b0cd5afbcb6bacdb19763cda2ae96ee69f661de3960ee08a84a1191d44a8a9a05f6ecdfbf5da8afb38f5fcec3c5da15ff0562c23ab20c49f77eb2fc9b15fdc471323bc603b7d566eb3567e9630dc80ce4333fee721e9c48967700ffd29ca2a7946a512b24b92b1762408e179cd63992651ef8ae89c3fe64b4b78f676182497754f7d926d1ce5a4220185ef5db7d51cf18827825dfcb830382538fa6a68d0d886824698211ac177378bfb3e8f442dbccc8a08eee250c39efedd0fad87ca565256aad6507e75179e8b4c56d4b85dcd70bb97d306955539eed30ff6247ed8527dca6160cc95bd4592747be253bc3a237b3e6529b4aac95467e8d01c75339d0272062d587bd7b652006550e317c3856b93a12eee2271d2b4fef5ccb0af19c85ddc89739c0db88171e21be6b8dd60dc66f567391dcd68bfeabe6620c8182c571e1086160a7e48cc3f1f8e982735643836c227d1d9e66a031625af04505a5d8933d22d6cf905543286913e9c53a2d6a54006e336978c7a0cfe8958cf684a8e19916f3fabe0740f24653378e3cb8cd8fb6338fde420e9253dcf8da023e7ab7ecd45c89eb7d5620f33d240ba524168248da8548d05b47674ad3546923abf8cdff852a6504de0b56c4f65e600b5a8bb0506ba23bf980cb129933cf9429c3d2acb8343b9bce2438b6781d249eac10022b217a6aeb46ee27140d901718277582eda0789544cbd4ef894aed81603897c7adef2161ce5c9ba81f7dc1edc62b976ebf1e05319f3fd773175f671de22c57f328608bcfa838130c78c05befd1b6f8f577e4c4ce0596d2adf81ca443591711335e15d515dbb5916123357e9e49cc8bee3bdd6786113621efa4342c65b2b4525f8c6a6f39d75568cd513736a25090d9166237000132093d6b06952f66d1434059f4bb872bc7de5e4d6e43d8f659f05e4c6ed3567bb4fce43c2e5f51c1b2430f441e0a107e6ce2b051deb2a099bf233c1e68ef4153435d5c6cb6cb4b533672687582825152d7a90d839d6ac5376b7192c8417baab961a921180549b4730d82a16fbc2b76fb3e58cb1eeb2434fe6031a7f50d463f7603546b2bb71a2f4a9c234a8d060db2b26998b074bb2d2c65e92f01d4f82ea05c1012bd28c98a2bdaeb301da33c0b4b880ba4b2e53fc390f1109167d79c993220bfb21901009e0545a214042e34457204e71cc866839372aa9ebc2cfbc6e70e6b9e5c53ecf6f12a1a3f1d43ae55b14585738c526b680c977ca46a337f68116a22aef7db03ed22402d0bdb2d9ab7344fd769ca2a44bc65995481621b47c0d3f50c32c4f0e29777ec52fc888454fafb845b1b744d34d50c315f8995b96810655034806bc1b7bf614cd16d9c2d16472c78a1acd8b743124a2a453363e488a7985d6e8aaf8180c9f2e2b5ce8c6ef73f92d1feaef1aad8c7cdfd5bd5ce42968beecb13a5a278f65e03496fc22eb3faac9cef07465a6d0b22d4e3b46603354b1d355c9e11f21d153c1a513e6030cf600bdaa8ee0d7eb0d35d495171b6839eb5dba098256d376f07ee11db4dd37c0e89ac52edf7e245d24248","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
