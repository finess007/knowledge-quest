<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"129557e5ab02ee4db6526dd838eac178c752006e65b60e472d78937ab0e46b9f837ba8931bb8f230ec43a3f55335557f356747d79ad338c465cd68f1d965db3ec11538babb7ab18092b09b37cab580e0c6a53c999b45b5086b8e09d2738b57e0eb153f1d0b6aca90281cf9c8e7f5665a4b5911cbac408600f22cf3f1d60ee69c8fb7dbb9a6b1f4dc21a78864506450ca7f2871e1a3e40e45c6c7e442dbfe23691705602a68b3ce277ce15cb8fa350fc910abe6ade8c06eb97a8f5c1cde12a4247139b91995c4c6845bee7341333d9d0a0caf2e1e77a8139e82531145fff1d1a418e365f06dcf10a2516319fed0d911effaea1bd4d7410494f00c3f59431c1bb7cb83df81647f8939fb6b78007fa997f58be3a8bc7b904f00095ab4e4695c116efedc4030c858353c51f3553a38bfdb05e1f0ca85e9baa9a9bcff0223259e1dbe749bf968fe854438502863c3e4f3fb6485a0c2da5dc1a4d231908992640758041f7271d22c1f8c97c03be6db1e105f66094cdfc3b1308b2ed1eeef97c0c77e6de8a76298615497b5f8ab8cb383fa77a6b2d5b599799a444c3837e63f45da587eed5f2506f37a1a034196286cd1d2787e7144eae474d76dc856033f37852aca1f0851a48e02dddbcf562677fd49a5c8de82bfefdc57a50f399b4c4cd0625695fb5307474f9a43d2fc2deddc9351eee6832ef981ad44c6b5eb6cefd233cca01de20b08d30fcadd9839730a11b4b1e0fa41b7c04f0700f91a68c5d67f6c6ae3f2b320e2ee1eddfb18b08a0334d1524c56c52f5d682426bf223e0d9f2337b6f9050ffe57ccc949908f2960df613999a1bd0651e09b487f885665987788075518b7c9879432b4c5f71c35be9b12156fb00a281bc16d1d8f6c63dbb3f01abf9aa2f29bd9ce2dbd3a0a353865b5140686e0ab118f9514ae8d2d3781d21d82fa8ab58825856f15dbddd5c9ad4df9e0d0055d05577c700e7e0ef2898f06d6c776fe9c39d43708a5c2d0cf2d1a5dff53eece034eb9bc75619bd0ad832fa0db87ec0f31c4b506800e6aa6f0e62bbb68480f9af487c46d3283c040876741b6de57984d7f853baf4a6ce6bace5c11c74acebeb012c735dc71f69673494e548de3edae158097f01fef228a23ae65d4b1790de2b0dd2da16f0490f9bfaeb057f48aef4e2a66d306742bfde0df3182dc5efe02f6f2c182e5b1f4bcb409afad0cbbffea6ffd1b725e42135bcec809927d7d8cf5d4139070db6aec33c3225b11da396cc6937609ede890b04af430b83514e0778865ed4924c12bc74eb7bb0930362a1456deae48c019d5b1ffbf3c53f29822e72883521442a359dc8d9c9ccfbfdca15e02dca5cee8fa81183b13841e78c3436bbacb147db6cc5a75482ceb855eb2efe7af7385af63501b3f4bfcaeb931e670bf465e0c511c6ebcf1e7039297b5c07a6ffc21bbcc84bd149d80f3f980ffc79b9ed386641b8b4ef0e5a393ec69b46a607bd59b4f7482f79fb2ebc3d7a497a152fd8e66f3c5902a39df67426ac86ed491b02e1bf4546e90d5120e07773f6dd4c1666dea1680e045b85861ab7614f41df9a78ad9b472b0ee4a582d47c9c41e6ea72b915bbb35fd27afe332f68332f5b235911835615a7b89ee30cd964a277ca3fcd53a06ee69b5e695a5f08a0d31f92725d3600b472bbca1c3c95bb8942f7e60ae793e684593226225665a5d6e2cdc8ec9d9f586ac520072db67786233f04d8c8cd232bc59de840deb7aab3593b206bfd7d5ae61f584bd448947dd5e31154b563c897aa93f0926ac67a129e7c5e06ed0aecad0050c3e166993a797cf01687907541b0e097626a33e53e7607ee6e030d5d9534a46ab5eebc12e4bda93ba5039624626d900139a99cfd0287cb71eef99f98af7ffcc3709d76d153cd8c2cc7100e4f4a9df712669a42eb765c1d201a0862fe5382c5359bdb67cd1cf94490fcc64a9157cc465cf97c2b277d613fad797aa5ada421834737c50113c4c56a4c2bef3504a6257772f461c8ae6e38ffc12e6a49eff472aa333ccef7688c72153da3e946451073391e7ce22a43cbd56e86216c81902d39c2ad3a42f6c972864ce80b99ae35ca8fd8dec18c6586cbee921aa27f60a7a2e1e649ced115bf6c7a9e8aaefd0fe8a963385cac21d6b92ce01c7e2f23cae971cb69a7ac2dc75e269881ded91ccd6733c859337d32cd6a364e13fc37f675af8665d4e0ae9fa7fadd792af9e3005d180edc42ad3a1fbcc95aa0e12ce88f2ab100f743959fc56a70f598c3bdde27284c559bcd7e43a423ff03c1527acfe467243a9a8f78a4a90d2ba29a713f36c21c7cd2fa110b8043f10c73c40bb781d605dfd021da1768f7b4a4a2e2e32cc0904f7423ad7546a88e92193f0ffc981c4fa5edf3c80cc0bd35e8d47ff744f3fb8af827a6707f856f1160eab037b4b047cc0ce568842cd39203c46d1a322557892da50448d3cf30aa84c2b54ec64f791b67e1d38a25c65a73b93401a28b42d2c166e80ccc6fc291ea819d26979350b48e8555652d9e678f2aff494f3e6fdb09c33a2aaa59296733ed84fba883d510f8770971e56844824f24019f5ac49bf701a82a05219f08e95a8a15813342fa4e8dc6af92c9c656b8e26237ac106c4b10e137529e0da3a5ec7548e82d42be4df139731b66a2453e3e321b12c363e82947909e6906443bd7401ab08b7c8e482c2f2bcf6aca8002bbbe3127290f33c86e8f4a83c52883332ce3a4229249f5b15fe7101831a201388296c9ea20d3dfbd58bd6d1492199df47046871bf194ca954aa6f31ec6c742185da15c905b07bc325765f26a6092cd0ccb86ecc2d22fc997767a768de7866499f4d29eaa10ada35e06a7a3dd604edec43e6d707aa869657abd1f729f4c8ddf19fa9905bee2aab338f24e4fb31196ba0d0627e4b85f32c4e98c8dc4f8e7d62d5729fc502648c74933ba223f61c1ef306f30aac60ee37b65aa499ddbbaa65c1677095b80d478cecb74cc28e636f53509dfa94a9a0eb2fbd12e9f41bd5ce175f19e9a83ee58f22115c61b5e4378ae050d17ea3bbf1da8dc5dd7c84c73b810c9f7446ac314d3eb8546687c79f8111ce429fb723d5b36300b6f1db52b8986bc89a483cc5d25cd1b19c0093c5b46085715dada22752c6f85c48196bd3d0c8d57ea879194bfbaed2195baed6ae66206850715e52c8ef90862247c54a29ec03e181502773f59b9db73fba4849d7061111395be28a6b2c547197b2aa526ac7446133074d446ba441f48dbe5620c45596046c5832cb6000c60c06a422970dca2a7739fd232a58ca6a1319b195e7c93ec1e6b1ae3378198696b3ae6ac9ef7740640ef51efe18bab2d31241bc97de6d7e82e93d443106646dfedb36e43226f34d3e72c1d9e2dd67fd77d37dad4015ee915851d23f394ca4a8f0989aa86adddbf6b6e2c6e422343b7484dea7ac2f461121b053dae120461a06be33ce5f781ecfdb8898704ac06ecffab2ce55eefb2ffda3ce79644a2ef753c645397ccc7c917eb2eb9d1f98fabbaa37472100addab0eda1531b1425b9d3b8c8d9e3e36c58ad50a38073f24444ebda58466a13b7cb31484bdafd14ccf1b71abafdd4c0d79be5b7ea8d5ff1c6a099e6cb401f7bf6da01400c61f9a5a6e497e1ae3901a96c7ef534c8a0fcca1fd39422f576093a69abb64a3a19561c29472ec930a50c77cb3e0b7ec15da59f93ea224b6cfa1c3fdb1c24cdca1fe0324d08b3715fa7c782859b4a052dae33c1ab0b2f96f506e5b5e8f2ec7746f69ab3ea51cb1b93192cc6463b85aab642da0395d9b2e07be07d0fb5ddc781bf9a8613dc47cb1c579cdc137d93ba686947db6eb671bbe29474f40f90272e71621099b2ceaa660df586cf2b8f4fc3734836316f6875d55b23eaffdd7806130c4077cb749c62011e4ebf307e4f338a04f6d3ecc702b90c940dbec809605b8a6a6ba8f1d01af762712008f0edc12656fb6c646cf3a64f1dc7a4b37fda432d7706662bab88034879612788e5ab9da3b6cf9f83789f3eceb1ed8ee4e0addaea20c7a0d640768da8e710870c427247e7f0917094ac288050b6daf27122e992e8575348f90b95dbc697ef51de23225d148f58cad869b1fe13b761ec047e632c8ecf46238efa4cb57c5bc0b47fcb63ae4a9bb2a658561c842c2c4bbc963cd0b994baa82f20174e848ec5580a7e7d0370e3abd0950e0762e3ece3106615b311e11315430e287fc0151cabbb7a0359784fe7b30187ece83413769827c2fee68bba9dd2ebf608cf5e3a251c1b77097e87a958637e2c0acbd5d5f4dcee09b731704d2ba34f88632ecd05ba58cad4e5d08a0299cdbcfbedf7be4267808ba665a7dafbbf18d0e53fcfdc82794798e194587fd766125607eb956943d7e9bb2164d009972191937c7c52fa47b8f44c47a2f25ae58ae700f895b56893c731e874119531f5b70009a0f61a043c3f8b70b308c5b0032575e8f5d49587961f0bc3b005fdafcc0bc465f662d80c40380dbd0799a74bc81dfddf04986cf55b479a1ca63de947447af2229d060d2dd6c33d2d3d10d7e259af9c5bf25c84d7e91dcc154fc97101b44f55e5d4ae38266ebfcb46ab0e098b7ffc35860dbc83e555f9098d7eceac5770f7033e0969edc7abe39179e1a4087b539b8443c4879a478218240fc53d8cecbfd752d9025e84b2dd614fa38024d9896854ed101957bfca651ef7d5b9a9d0239547c8c4cf8bd172e6e829b499c439d2b2b5130fbead083a9434660046da693340e2b4ac7a37478786c8eeb5958cbe9c75cc8e28cac118d348c77f438ce0f509efe0e3c9900e32b1d7128c78c3db2cf4ac1ca030da6e91b0d92ee83f463db30884a1c518525baf0c151f2f9bbb6069d60b8c545186d517c10b84a4c64d7ad340b2c7e6f15b0dee3eaee05401e165c5cb796a7c9295b4cee6a1c189fd7b3247a4a8f7f2f0dab4266439b41dee55526a46277b6ff419ce5e50fe932ced2b09d0ffd56d7b3d37a7a4920949209c9a9753713153fcd4196b70a66d33438cc32f6fdf8da667453da41882e21fea5ef45e29320c23ede1a366696b4b07a619bacc5671e633ea94840c5686a3f77c9e78ba177dd7d523b80012f257573c54cd70a2cfed82118624938dac27d9fb6699fc7f4122a2f1af4d51a999440cf8fac62e648ae50462a14aa51537b321563a19b9310f0876e6a72d0743a32422f6d569a1f7a54a1de86f984d29975c383dcda3eb0e3e2dcd184a711f2544405a8ef578575c6245f8d91834bbeba5ca2ae8464e105fa0b3316f144fdafa4a1ea9b64de6945c454bd5b67a75d19382cd5afce0a8733cd527069dc48958b35d63f5b321fd59f3446651782ddf5062ea295544a42ae1d0b02c9a320615ac1d1541a6482ff67e76656ab536a20812e3afabb73c776e6fb56a1067b1f1119d225326a22faa830fddf0bd98be90a79c146db36b519d8e35dc3dde71e5caddc0b5d6addf6a47e42363b9b7c8c7afdee4e3b58e519eaf93a3f5d48a6d04b4b296e886f32d3b66a97f90766198aacc319fb6c31343b71ce70d5bdc1ca006b16574f158decb274d4c8d35acf01b9b317ab9cf73854ba6a76fcc926e2bdbc05c778f0155d136f036a5b783e051095be0cc4c87aa93ec6dc6addf39316238ce80852afa848c2acb71c1c01c957f00e7a1d5285325191e504d1c9f7b372f102c8ffec09a7f2dabe38978dc6cc49fe6efc0560cf72e9b6d7bec7a6b1b64a3e2fbf41488e37aa68d6b87fb6650ee5168638c77e6adf826b0ef4ff10ac728cd12dca973351b22d90f8000959266f67c74acc9f44996d703540b29eedb1ab27be6630687910a074628a1701bd401ad39ea306872b4f7e98d1a722529b0978a5b78bd8e0a91ff3393d00e13ef5253a6780f9dd93e1e5b81d29f337c36a472d148bde4c040070ec50f0bddaed029a03f6e3f1e47479f9eb72ca9efa0448d76707432d56993a7c2a7baacfb62a5304563508ffa2bfe21adaa545c03b3f35c15c1bb0f4c350ade1345cb3f2da704d46cb7f1be376b661abef5fa3d348d5bff0d2f597b6b948953b60437e6a756a8b114ea33f4f289ec841a6c869ec2e68bcc62c4f21d07ee364fbfc95ad6aeaef0ab73657be3dd079849a68d94bef367a320d63e185d0461b6a93f4bc842aa70bf6984e7cc125eb311f8adf08deea5e9ab90ba4f05336c165fd40376a82237322114d36cd5027adbb7dfb7cc176e5c3b1f04387d31314090ac428104efcb12ae494ddcd7214c861b702cc15d5636182b8d7dc82b20b0abff97f71be0807aa814b9365b8e752ae86c858718cec41e25a90efaf3b87a2415a7cac36236edaf6a328157f97d948f5e1fb796a90f6b99f2fca446dc3292d6605fdab681081e0075c8b0548df8d58ce867d8f3bf6e8e55b6ca802a35323b3b66d591869f3b6592141ed600ff47750a55c663344282fe492980e40a168046790dab6223f83ee5a2026f6a5097a5fc7f2cd7ffd6c8e44807c0f25854ca6c14e2b19614922a0f3c0e42609b0d4e2fb09be1827af0e318405c2f77a7b4925689630b47173cc3350363233b0c7ba32e8ea67af3e768c740f394dcebde2ed9fe9e9c7a9cbbb70176220f56ac211f4369d4a8ee8b3b8a808780f05be609f90b261878d8bce1ce454c653770e0e87b1f65f76518d31f837acae91d35520fe2515767b4c48b841543e839ccdabe4adf450aa02e837b296ac40bec98a489901921dd809958bf69dd2c7005127c4c97405117b16a7704b3ea97b0b17db0c77ca35a5aab723a3c8ccfa685fa3473386460d7c7b525e4251e7845aacb44c26d04b459414ed3b8d0c10156f81edbb9e90618aa2b1357f60fc2b3c5af4bcdb38f3a90838dad6f51413d52c29aaf38b5bcc4567a9c2717ced1fd92fc4ef04ce42144d8a561710bbd85ebf8087d4b2af02c7ad3590443394a59ac635a62aa1ff89a28709286dbc4d3d3f7d8c13ffef03a1390bdfc635afd3a396fb3f7cda2629f66af6a68d83a12d1348df3057896e5d186656e321382b2954eb7d0120eab173d04d873e7e0ba5bbda551d7e95a83193109acab8c596e00d50bdc410dad639b23b2d10f519f217c8e322dfc771a79cbe59365e6e25d8abc28990554fa3d99ac1d444d3b6db5b5661767d489ab4cf6657777fd387ebeadc38f5f5a700686cbaf12a66d112ce0ce4d1061bf2d8e751a92cf4a93ba5f4415bbf3628f72fdb125b38a38cdaf92ef805044049d98c5335d349b2ce2c9623dbf9ca351ba69c6ca1f02357534181e7e720faeae28dd60a8af49b4c7a51a201db6d4a69f1afd37d02af1106aaf4403740bb574b288f3604bba21949822e9be5c107cc290a5e716e619160fd7fbcbc20d5cd9d250492b3245b1be0327d69d349ae04d86bbb979a0db34ec064d9f1977d29bf14091d147fc9a416331b074bf80b19ec64589cad7f5b4c998b95c766534adeb46af86f3201034f89e3faacc9038b38b4ac457916489527d5db9fd96ac203b48427dbaf4ec5167e936956af4ed977c9caf715d2b160376fdd4bf766dc696421994e0ccb167bd322111b4478355c3683ee0ad2dc3b1d38744533640de65718017a8cdd79f6ff68e3a7c38b65742b623f9c1532391704c18d4c2273300c1615a7d97c8cffd515771eb339243fb5fffeb0fc6db73a9a9e5f26d7fdec4eb79ec184c15abc6e3683a911aa44fd36885e8c7d9011a407fcf662372577d412ad6a5f564d6495b9b298638b0c1d6ef1972c9968683d985730361ab9b8afe287238aedc8c70dd1f0ff4bc84abd811fe1aa2d4cb31d99062fa30c8f2eaa927ab87f5a095b084eaa959e2ef1ece2c5d13c47ee09aa5ed2a77e690f2c3c5af984af741d7e0e4070e14ab49c83bfa1a273926e2c288e6b05ec646813551b01c042974559ff249530c95264b3385ab3db0acf6ca4ea17be140ec83ad0bd148ee2e18d90f3e4c5882533e55abdba5d7ab539b1914a9b72da06af8228b7ef896701eb5b20ed1fddd24463c406ff31a228b28ff18b4ec1dbd71d47505f5dca558ed460e0e1b8a8e931897b022fbbcf00efee39b8d96265aba9252e3ada3022f0a5d975d2cd9be87497394ee278ec63d6406f08f642a236ae08e9fe6ad9712f0298aab723e36dadf4e1f354f4d9d0b67bdd19d2a64df0b3dd6f41d87a21e9521bb66ca9727e74f947e3ebfa6fc21f4c7877fc9761f17b339a0cc09e32617fa606e07cff89b3f17562874a31e9bb35ea5f770c880f42a884bd0a4c074a71c3d58b995b3f3a3f8abd6e74630641be7281c1b589095ee98779dd888048c0f431b9926da81fb391f4310522e1ac4dce6ca7e130043bdf76eb91391f5d8f428b5bfb11b60780e296a0eafcc8f3d64ce8ab93fcc0643f0c6a4365ccc0b936a64bb4b194cca001861985cad785ac54de6367d12d3f39ae07bceae744f47b85b7db66c6bd0136477a7352b9fb23dee3d3e64a4bbe652fe13d52c96dcd41595cfe529b765b36ba825f5747925cc3107602242375bb3c681bbef87280e5161cea68e08a2912525c2684002b4abf1246a4e7dcdfe09b76a2b73b9fa326b225ad86fab8a7ce4eb7e2807181e399646c32e1cc48128b3b1014b2ce3d20b100a8db880bb03424dcc2edb2536aa98ea0c911a16b47bcc58251573a5284641d9db0181f6fa7aef6e533e6a8fce46a04804078d4b3522e7a60bd977fd10aa1cd22d7b39e8dab511644af271d93bd1379ae4060189c17c2be40a1179cb3e14ac1423fb300c5921aca0f0457ab840afd45e4a935feacfe1777d40d03a2b6b5739b9588702ffba10c4ef9a64964cbfa1986e6e87e91620e764f3d2df813b0c50e9f2400a34aca4075d7617f537bdc2cab376ea415bc6410adde0c2448213492cb35e53bfbc7291dcde28b47f368cb82813b170e04ecc0f8e3bf12b7c6d295d783b67e87a08d266e416d738d37202a101f8f1eb5a083b02443a61305bfcb67be504f19f37f617efd74b87bea3a6c7d2d235885b481ac18c1f2f8f08ab13faeb18efdc27cc349e83488f9d9334e5bb113abc77ce1b9c685a1826b3e525b851c78ba154356f4ca468ec42f580d9028b47be5eb0d570456b1f9c16663cb11f1085eaae1f23ab9c4b0964a48880db48e41f66c09925047564cf7783f37961f7daadea1169bb45bf91d67edd513850de539bcf88cc4d18a601ec02cb3908a469a39ba57b139e1082f12c62bd9b7605c66ad732e142ea20c3d7277ea50a67f90c21e3bc2ab37bc83a9cfcf4bb0ba095a4aed355fb95d33ec159ad12b19e0d72bdc2a8b2e48c2257bc79e44981e736f72d7d46ac6d1d7b05172098845c750928f02b0915dc5a149a30faeb62cbc218448dcdcc750cdebc82986cef1b66488e8e87134007301bf497664352c8ab3605c72b7cad3947995d11e1e73595cf2077b25bf9c954bc05aeac6aad15ccb4bf583b9dd20beca900d3ae61bdd72b2184c1b4ad3d92720f2e7fccc3d051c5c89e2a4fda275b73e7e8344348afa3417ea4ca8fb8f57dfff21ffe262313942c64ba2a6843171f0a5294c7de5ecb12eb361d68d485fcece601f464a219cd143ce0274025bdcc7552ab536b3e9809e975c56bc6aee7f252fb16c691a814f62aa6cb1a1fe86703e77e845b823eba4e115f24a2b530e7ddd868e44c20cfe75e3d71de2b87c7a6749e7f15c2b8ceb6e8fe61b1bb7bdf2979acd325e4baa43c210cc3e29074e1f299da80a3a873b1002cf32e7a2df6c1cca8046fc22a3748fb87b0773e1d68c8a61e4f6aee5446f896fe9b1115d4f8f4aa8a29411c9bf6c82fbe0e34595e0abca064be3d4e9b4562b4a7d6eb191e8dd57922a5781710d1ab78d6be5d4ff3e19c77785a3f8bb30093a7df822241a0ac8e7645cd99835c9e49d707fc9fda2cb440ef4acedb600d57be8ffbcf423d177e5da068ca3833f9422f8acc4175224941e1fa6c4f6b6773827c13eb2194e35cd3250e882dd0b03bf29a1a3f0797826af20f249e973a03bc396bb2c7915ebd8df1d7e8fe5e9372d1716d2eee4a754f6ddfa4b0675d73f218d2178045ed9c2f17ae6e29600fbea83f9a009f97a5ddeee268094fc5d4e5023b227881b9683d152dc9a586c2c6758feb3e8e917686c000fd0f95dac6bb70dbc0c1a6f9faf48e9debfc67ed6ad43b5f8ab6ea87e491495dca014d7b73eb6256b60640ee55ec3c24e64887141094c4e1248e72788d7a647b0af7c9f50fb3954021537d6b0c2a78bc1638fc75eb42682c2d0b95feabd9702689ad1203947f5c1b174a761b697331d35f962d190692af20a34b00f28e41ae066295ab7a1449145be03db28eeac6b5e9b95a7c1510c122775f05e391cbb68e384e7eb4428ed9eaa06e73820ac220cb6ab2e1babedcc645cd8c696c2510a3058de13148975586b727cf8840fac7775d3ac4e1c5ec0d70310c285f3ac327e866d8cab68cdc1b68e4e47ea644e9cb57bc8f8012aaa3cd3d80f6cc3609287a8da956428bbd9867e0dc28c5c88c8684b4aa0be0d3d81cb987b408baefbab6e53eaeb70cff553f7c897825e558255ceccf137891077809f524367ffbf8fb41ea19f538ff08f9206a54d0fabd465398497c6b2695ca1983a04b8eb709b552c5051f401b8340ac53569ea084a9fad0f6999d7061f138254480c87d43ae54f6c60bffcdebb5375e41880ab4025213cb43ffc2e5a60273ef3b69ec0ccbd8a3ec6defaa9c9e31ffb181011a843505cdf0feb6bcd578e786263d822e2a2d6824e92457e5e6e65600749b500bb20bc579561dfa874b6b2c7010236eb9c700cadb9695646196f29a69664556103725eb7acdd92229fb1da48cc4e07c39933242ff74e079544bee056b45d21e2a1469786d862f3c5d90e89299c3abd96d478a87fc0da3c1758d85c287cc61f35a29f6b5de3ecaeb0b26be0f01eda15410d9590146ed513cc30b4280df608e15dd274f01c79755a96ea3a7bb8b7445bbdc7c75c52528f1cf906cd82b5a18fdde8279c0b1da04d1cde1be6bd14e531de2f853503ca2d7e168df0819cabb7ca94d5821cf5f007dc1b1319149428d0e51d7081c7d057bad356b43d5566e4cc825be6639d35f0b2047f7f0ece9c600123b091c77bb67990dd9c7cddc5027bb324ad2a68da8d1d97a4e5b55fcd0e79ea8b0415d1ca830714272dfef7387c709d8945930e7f5621018233e2cf39d21dd314f2a96a2ce2c0df2a97d4c5da81a3ce7850f1944b1d5ce5c0e19bf66835d7518291c718be2737f32af3708f3e54edb137613521d0a1a42930e57759c93fd4e91f7d9998213f227d93038cee00be882b8b3c7776389f3aa2db43c6e860334342626e4d71e527e0cd005f195312f540e2962025ce7bf1cd4ce3c1156588c1402e2f55741f753849a48dae84757916d0b5dca2dafc87201aef2ed79ad08085b086fc4b9a12fac0670d104426f3e6ff949740b0f902698de11ed8f3f9a17860dd8536eb9d57c7918c64a7ca9c7e2f64c7c0ed89f184c785854e27dac27809318a8c440140ae62e4316e3ef16cc783ae52f3fd3111d672bddfa619b0bba47ce2a79055fafce1d4d2c881331125c25f3216be4f3ad2787655ef5621bc901954813b03355481fa49811be9729a2ab33d29f1a1cc52714fac98064e0839847944feaed923cd1dc8e5563bb2dcb92306eec19c9250d9e172243d8236204c9408d6f380d38f5af7a272944d2ed8e33f7431c3a5e18627a889f1e01185d9a95f80123e2f8062b791f856d3ca90aff81535f0aa70326b7e3abaea19ee93aa704e75f146e8214bd17037593faba0cfd54ecc97113da49da358eeb08bd34491ce134c9cf4c1c0ec292234c3a1007c9a4a0f03eac9504c0212993e67c4007a4be6b3581acf1a49c071628e2bf61ffe4dc55b1de5e65e4cfa8767b503a0fca151acc114679d91ef4c99da8946a3ad8760da34d019270fc57551f0e34ba666eaa833ca0b62ba04da5c373822edd698b82ebcdf00f664be47e50c67f41cc610524e38975f222948a7f4ff818df17d2bd0a17814f4d6aa5e59731bf4760bdbafc0f64076641be548e50cefe9aa80ad6b6cb7e73a7035390f2f9ce0ea0b2da3cffed04ae3941cea2b109b7a708cb271fd94eeab39726c673e758e7278ac255b8f90adae52726ad6d47e3fe06176c8c6acffa1333adaa4842a6ce5b7ead7fb0ece0bb515d53c72b3cc78f53bb15e2fd7d4b78f8732c7b1e02e46940a7613a5bb0c248a93f665a663ba7325206c776a31518412fa3c85621078135cd42b371d75232dd3ae6c5ed3ccaf57f1546fab789d058d302c49bb4dc5a3ac41659a603bdaf9f6cf2236ae5a86c8634de467d44707657ec8631eb8fa91a4883a88e3d911f212b069f33c64c0d7a414939472b8e45bb7d2357c9e0ea59c303ca790374b6d61e0607ebb5821c3be15151399be435be9d32d629c0105345d81d9845d0231de12434fd1edacaeaa773230ba8e585939bdfc4eb6194fae4ceb03e96c92fb53d1a1f639f68bc0b45e52cb321980036bb4edc842622bb1a6fe1c4348be1791132d98f376bd29eae465752edfc9048d3f8a82fa022193081da7b6456bbc6680babb95a89d4162a0270eb625449b3421a4c2022fe6dfd2cb61edbd6b8d791c615b62dd4b9f24ab87e73e0a9a0162807663676afba267fc7f655ae3e50e09370395b38c8d097b775dd4d1ad7731891688faa12cb09a1794d0cc7f60f8105a3a467ff066b95c7bfdba6829c55b48e4c952438ab359909e5b27e90cff70ffb8bad509c49d2f5c2be73da1c456a1fa2b88032dd4dbee6d8b2fc8697adc16b75cc1051a0b495d40952ae33d600271a6581d4aba185a0b7ffe5212ace75eec782d74a94c0d967651d55e434d9f7b3aa5dc1a5099e4082f0400914a4097fcfc620d97bb517140e4b1e765cf71245daa9428e8de6dc9e1a94ab5dd2d2b8c634b71cadabe5c7390dc84c25c8ea14673b6e7494c6335eb9864b0ed69ff9803025021af718fb4dd74db5b459ae9ea6e79b08d0be50c3729263b610316bb8fe2c1cd9e9cd5746d9ddeebca65b5dfcf4c608fb0d556ef396a326f626ff90dcd48a56b9caa6f0cc992849c70e1954edf020ba4804756da4d9308f2e0ad9e2a63d92b3a4b99564b4400f21f7e6549a4fddd2c760740a6fdf8de2b5849881e550819fae011e09f39c8982f46b4510ba6f24d39e6b6945673952cab6719178ecd078043e7e54cfec18f93ca87801e87fc2ff61335dbf81c948eaea71fc0d4892ff832e60bd7e83158ad8314269c25bab770b847fe2a27ada6548fd06058ee36fbac63ae8c34f9e9e9b5fb5260a3bad09b053f04d378de909808b7b58687940bb15fc48357b1e6939b447d4a6d36a54fd989e9c5d1a47ae2551d8886f40ff7abedf29d2e4e8e26c3a3919480cb71417642cf45491c7e1749bd1d939253f5d0a878d681433402ba3ed1f3f3941876b94d1780a82a4ea317c6e32db30c6caeeb58695ce73eae8ba76373e41d09d1abd7a69090c9ff87b1e9dfc2fa1a4bcc929e0906fb613c4ebbcc758c22066f025db6398ad494e0522fc6e798bd88f1aa908fd99d528ccc00dc4240cddc900ecc1c5e2e3e77c37b9196385db92a5287f80b4a3afa7219d7f3b5cfe121ef9cc7fdcc86498ffc96e4d0437ea6075b88ffe518203875ba0359daf627488801ed0e3e19f75494e9a35fa49a230f2de49e0a1fb3592367f9b0ccf9ca0b4ae542a7d154fe14647a13d738e1052bd89a7dd45dfb113d63b44158161b3b0de298702e10e5d9ee9a96d16f4d94ce8e700de020ffabb25de50606eb05bba3c01f33bf11988e9730556e25fbc057fab5d59a72659feb74d66cc2a2c3acfbaf35c0112d53778550bad150bd78c54d7887593e816255299cfd91fe3ace61d93f83694ec5caf131be0f234126483113ceb810a3cd5d595a94e7da2c233900180ad1934b2a7cc3e09fa72808340d39eba303c6fc434138defd04266eda7ed6c30e7d3c54301458cea33d46bedbd7e67b76d32ec9c897dc270969bbabb8f2b06435f67e949a295eaf64cdc5fa33a7920bbbff6844ff6099217b5d7e61c599e215ceb137598343f590e5f7aadea0d393220b4893a889513bb8c1d50db47d0d73379d7388a40fd3e0feaf06229912a1c1f30fbb5455559db34b97843518f7f766ce4c547ba69deb56c3fdf4785f9505837a5712b06b394c242d9e64e463b9df90008fbc8d9b5968ae1491e6c967b6216e1a08ca087689e92ea89ab2f0d2de11be4bd1a3027f6dbfa9b77b680e3f3052b7bb338347eed5df86e5d4b6a584f62026c86691a9e7bf428a1a1f731bd12b1934311688c4155dd980d771bbc287fa50253885175ef73e0e274073a9d39e4ce354de0c5b0be1266e807d0739b3d0379284738799766df3e2221abf6b241ad18272ff2c4d4236f531956f4db6135dbf89e6ed2af5fad121f5f4a313a4e5251ee8685f0f345521d97aa13adaa","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
