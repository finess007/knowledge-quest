<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f154df28e384c5ffb9aa18e39464896ed35c78c61ef523c69debd86345b893e16a799c4b8ef77cbdbeca7d3bb74d3f969fb7f2662c629d8c8e5c865dcfdb1a797f4f105928ce87291d6cd6af7930fd90564667b98f064caee22623374a98765cb0db34b977b94dd1480ae0b1e67b2a89ee01b1b4367bf29d49da746e3505950cfbc008caf19ab3f4ac4007af584586df7ac1b2034314efb2c29f0a86ca800b408ecb018dd4a7aebb45180bd347a1b1e17f6e707e3205767cba8995078b37e0aded03f5139e933d3dbeabfab5373ed376c1ebe109a47169e048877bbe28b7370e54382eee23af29a976ce53a74164ace804e5d688a944529b9e654698d36632284951599a73cf29cab6acf7bbc3c7ec8ca5eed871f4986ebc78b56cbbee917e1a3bfc272e4368162c91dcf5c7065064c62b028189b21caee6325ce47ff6abc4c62bf97345dd5dbaa7c2a6f3c35ce9b0760e156524dad80004bfb261c17119943c284be5db3802a3dfd3c3d5d3e82e04f8e8f73783d7aa233022dc7e5f686f5acca1160afb6a7b47c7fb81567e0e8a1b6aad1b047c7f794ee0a960dd26860ed2a38d541c34cb3625a1637559ea0a49dc35b59d41ca767f016693b22417bc79736142597ee641efff180c415cb6363bb51afbbd7e06feaba04708e389d9f830839760bb4b27fe5f24132566959ce7584fe765e399b03343ae59c81cd3cce8b493877aa899a711899035776787b3aa2221bfd79abfc648028cd5fe916435b69ae6620085efba850e448537647e0459d725dd8e9ffef91f9c7b2bec445a5c8f1a3d5a4425d78c3f6e00b4dece30b7930322f7363b28425ad6c512efb3e652c8c3dd8a01240d3027b14956143fa407866b37fdd6b461406122db3ae49bb9c9f41ac72849e71c7b9737cdc2bce1299e495194353fe7cbc01f1c74ece35f41a47410ac98328167bfa7e7055bb8bb0960dd7b6c601f878b56c765adf94401522be74c5053af63ae9b6f750b72be6a5ef3464827233dc160b7290c3c437cec0ff9a3a8da3900bb5a391c32f848225e415ba59d832b8353a906884482649d8494e97a8dc21263480da636fb128ed448b70870ffaf291f0b5eb08fb75b19cd4fec9fd9a372aee3c67d1aff251e285abf58026d131b0af6428990f71d1366a9c3d1ffdb48c40ebc39ed7810f4cf0ef75a824b7533635d9107951053cdf9c6ece75b7ceb9facf8d480023d0990e2e42c2ff64ce41ada7a723878ca43a753fdea4cac6e05dd275d14eb066c29891a8ed0041d821b96f3fcbce7cc0654105dd2bfcf577f3853099d8f28a88924c6ec5405e4d405b1ef6c2662189d68c6b2424905900deede71930865119116d378fdbe1f33f0051e35c0a664701dba3060e1afbbe0b810037317032287a9b19455afeab18685e19538ffb5f96b5a11385605a24b468eb1e73f1f8573d9ed7a23a8ab81e71b103d016ec8a5968b6c0e8036a692dbab6e2263c9071009f3bafb8a7f7b3ce1cfb8aed1149ebe54ac031693d4a438c0f4fd4341bdab04e9dbd6dba91c886448410119a6a4878dde36b6207c93c649e37de82846d83db4b395bf65f26b5228b48b989f32c267634cccbc1daee582d01b796d4b2c059074f3dd7d8e65cf0a2e285e91e1affe688ba23857600f1abe4e9f4d09d3d1e54422f92c220e619e3293326d2c3625ba6abed4e289d6ebf5d0c7b1857fdeb9e104cbccb34e1634f63cf43d5dfee9d20c4625b14a06426fce9b44483bfb60aaff505206cf6cb889518302885cc0bb9714303591b3c064ea84e0ea4b5bd870b3992327fd58dcc8b1b336f7261fdfc49b931ac9fbee7466d449affcefce79f938bff24d22cb1d1b2e8af82daaee1deee874f1dbe675e5eae3b0197287f5b8e1b3be593dbf371f5f109074ac9fa9e43fc29e6efd7a01c399e485d73e16adaa1c779083b89f91d5c821de2374f94f1defdfa1a826550ea49685349acc6811b6e03b0ba1f82b0f8ce7e197bbfb72ac533abe4b53ac0bf5f6056924a3843b480c7bcb64a5be4e6eb2b348a3320ba7953412ac628888537981f9e637f75d27a6762113c9c30424f66e566db8165c35e32f9fdeabe4e60127869fda9bf793347cb8277e59d534415562c772c436f1048d9b2275ac48f9677f364f0d1e0a42cfe6eee88d24ea5d1a9e631443c56b620e3ceb3cb54865b6a3112771ec45b663ab4cd95c10d647812c56fcc9a2224bc20ec47647ea15e0a5b74ae430648e10a0b12b0276b3a9867fbe6cf5170247c4e13741209eb7d3f3989f9e6c751a17f822bb57e1ddea6fcb44fbba690fde9a1290e28c643eb22986cf62f4887fe00d3d33648b7e84dcba39852aa8839d2f0f5d570b3f85f0c74c87fb074067d93ea0d2b0420dd0edeea46dcbdfdc7af2558636d19ef275b5ce1b115153721b618cfc666460faa0052b12cf0dcb15d14f1e9b77132e51880fba76463cec761ffb765bfa210b685b4f7eacd07dd3c8b035661068682e52abea2fc931af2b9bc70c4eb358bb806a05479df077b3cd927a3006d0ac6f041b4311561338a64b7b3e14057eed312832257a9d19fd51b21ee8e4dbe1ffee769aa033f91b418d9b4adf2e939513757c37a2746fa0b527d2f6c06730eccfa03da0411d19b9963bc34f23b242e1e2b5ad6c1c5d8bcf3c315d3e2e9acbc81af7b0805ab6af56b559aa08e3bae5be77b95080402a23dec4445c8b36684e0e09461b169f9bd38e0ec1c64009f0fa3a3bb5dffee641123395aeb4f2e4c7ae21a38621d1ada440b59cfd6b04e0f0d51dc5f74823fe66d1f049ba7f7f9b57736bb9d3bbc35f038b09ea57ed9b2d1bf4d06c54bd81f6ea829364e0f7a997c71e84e6c263f40cb754a9de94832fc277b79556375688096049a34ce071203bb543ecb5ebfbd1a13704db9ab2180eb44e43dcefa23fdd6cb2942ec2b2d7bdacfa27967261d2f2275431c458c7ea364e6e2aa3ed8a9c7259f7c5b2052964b8b7e509b60949d4b2d8c0bb3b42e326c22e37c7defe6ae75d83368035f9b1f1bba07122b27c1d892fb7e42e843c7cc6a7ac38398a05c89d8bd7abbaffc78c96c4727b5ba57ca9a822a37794c794f4c5f3ea7d524d66d403e46658d74c08ee92c77df61c79467c50432206349afe3bbee6c05c3578bd68d60e363f2356980a51d9ce3400bbed81e35d067a85455871088ff46ac546fbe8dc63cf71083151165bb542ff43bcec01fca039f941c1d12a49f0da26d6eef47ec9284eb0f206cc4b19229b4c9562e6c41f7d4434e2892932f4d26796c37eaad13860eee898878693bd335457fe4379b55aa80801c71e20e0682cbf37b86b8bd395d499d96d73b07bd65699c057a1eebbac3397d33463263863875460be45597d217a4b528627bca52a535279fb6d71caa0122048d5eda426bb2573e6c4a8f752c15b72107cf14355f38e7c33cce003afe799ce834f678af54e0f5d17a94273be1a315baf31a70e1bef6dd70cecb2e87036bdd38d306c23cc088fe63e5b645f369427a0e7c54716811ae1ebb97b0842361aadee388a9c4a65ffe47c1c6dc2014a272f82b9c774995c4f9dfa9424ff8181bfc45ddc7515757704ad99efe903140db92dc4a5c4b7a62b89944d8b83047432728e3472c4ac3d9ef0fb243e21ca3929bbbf3ba2bec8e4838d3904acc5981186e507566d47beb06c708514c32069be8a6b96368007974cb36384ee31d74b92b5b142d9675ddcb1f0e7230e00503060f3a724dc07fb58b2e76da18611f716ff871884ed1b723f1b558fee5a3d0678d99abb11d5553b4e6d6793ac57fd0042037c088bf32a4ecc2b3f1c773b0b5a31a595db8650f65f31adb00ed05fe74acb3a6294f2de2d7d0c63172ea416305c6a09c47e3db9b4207ea506516de6488ee6d7fa8dfa92b39e512bd0caaa0082e60fe3a25e91b779c52ea6f85f811ebc3105f513e054e4b40443db544cf1f2fa53cd13c3d1e40c1ec368c3ccd7b781dcd1282a19d2c4967950328e705d0f37427d0ca2f902952f37b3aa18323e336913815bd1396f9c77ad14f4574c463e6a3d3d5df3787a64d464f1e6e4a24c9efba57edc25950004ea97eba2582a1d9aa4ffc04bd69e6d124af4cfd51daee586a0549c46b9cbfc1b2bd513423497be4ea8c35b7b06730868bbf08af43ea5225be0df02feabfe38bd5c9aa6890f0d117a4de7fba66ef5a33f7b34636e948f568851c2baf375dcb49d0b591d9466e89f2590c605a1a4348bf27afbd3bb257319146fe175e9d2a8173ed2f29b23b48f2050b24a5746a22c0b6f129b56caefef5fbe18ef4726b9003650f88589da1a0eaeeb8b28736bb13532bd116822a485ba993e3d8952049e1564386da21279d21630615b3c10435ff59145da6d0bdabce8afdc80553285025344c3140f4b1a639ae995ce32cf26bd4de4215ffc6e0c6dfd19cd515c74b3f46b92f75e09d46f685ac2deb617e9921911a1a9f946a4941ef6d082c680cef2687073bfb98460e9b718195939fce191c11df3ec3c02b21eac576c82e87d433c6e73102f35c523522541b51bf296af1b22a66a5f4dff83d2a168672aec4a2ebfa09fe326b2792dc930ebaded757a5ecaeb56873c0c2376f75819642a8486e0d912f5a1cfba570ed06b5ac94729e5def060d27706946ebd189e6b2515e0c95b6b7acec305c75c1173258db11628508977dab7cfbb886d6d8b39f0b6f85242e93f83320b8e24cd53c410fec3a5c330d2b2abf3cca448ece35a8f4c285e74e9dddd5077a6ba059a3a4b6650908958d8f58a75a1db3a1dab0e5af9136202ffa8bf4af17d1dae8486fd95b8b805090b898b1c2385e34e8fdab1d8f4a78ef5666aca52237468162934e20c708862522459835e8fcc05ef8a5467ad6336dd91724ab85fe1a36eba44da80ed857fbb97a2fa837b4d32b072cfb46ec0760016fb876d0433a49f4b23ac93f5f28e16236e3497a6d1982f0bdd426e5712bb5a7d091c1401e15aca6705a003dae80c21c0a846358ad960467289917efe8372ac0104a1d44ac9bbb4373a2b540b6e3d7792c32ad1177789723e4f9e1f087f2140a2efab548dc99b535d2f873f81b4849fc301ee3abc3d37419f569887d0df2c4b1431c159328e2d7af5f47d598ab82252965eaf21415c30e7e973fc9a16dded62649ce99f376b4c3bd4f5845ad7865940f853c85eaede9b7eb00714c0c0fc0137a90530d6a88c1006cf8628818d295b8f1b7b761f61f3127c93288375c93ab4011e4cf6215d08d1861bbc587a3f707ed47fbe5bbbdeb304ac12c54d96ac3a1b740fc091234999ba9ac7bcdc182603f99305e3c54b1f4aad1de6ca89338547a5563d6ae884eb310d8cab48d019a58c8c52335577c21ce450ba21542bac74b9ff8d547330a410a6718b0341a29fe13ee915da9d64daa40605caf9d7f5150071bab4a2650991c7fc1d740c9a61e314d9b346f365e852245aeea23226c85d5ba910bf6367076498cc8415270e71794fb81310d725cef6247885580e813ac3477494ed00246b6f5086814779a29edeb8fd7551f4ea34ad8a0d97411728edb6d5ea3a9ccc8d527dbcf2235c813043a7c2c0a93b8c70d008791e70ee271aef0cd486ecf18a743c1d7424e4303dfe1d32627e49c8d5cc7c9e743149b70bf69fc7875210e559426ddd21a478d0d38a107951eb97661408c14f3f00d9f377e63707903a012ef8455e7cd83d8967f0ac9f3a3af109cb3a0619308886cee128411bca9b5c2ff0ace1fde2b79e55f7b7b20e44498c5012b4d47d8492d987034b4b0b4b4968ea483def01668125990e5c56e7f878c1c3a88189c86d755767577f6437c7af73ef57d0dee5572181d80d5e2c09ff3af8455e22c24d2db5fbe6fb488394326516bb06b1e1f68780f22024a87ae7d1412668d5a5ae7db0ae24e72271be09769c428c1427eb554fa63d26078692b0db8b0c8bf44ccfbd5569efed3f882f0f96da6420323d7746a15d1b1edd34aad8e4fb9cef08f3556808c5017a16713ef008507a19ab3b47a2b16406f8bfe9669299d8234c041c5f091630c49ff576a0079b195b5714f92146e6bdbcb677740f1bf4b3b7fe1106b4e82edcd18ae9666056dfeb4013467067af6b89504345741f729518acffd7fef32c6797a3f5d802a0eeafea6642f3f39d79c8dcad37741a269217f32f084b9085f51da60483747c59f744264556af8a90cbf4f637997de7ed174af137335f3cbeb9c9800be5dcc5c4eb775890abc1bac9fc4a81d6c83f754d3554375d736148f795fc126118282961aa09f75ca6ae9209bd98dc7bc34fe1ff6f6bdedfd356b5e14129198403dd2e97c1a71800237a934ef298fb01a14cdef13f93c5e7b73d5011e76d7ba1c76a1a89c9de3d8f97aa5aeacf8b905c35addf84d936664981ba37c5b8d3b429e0f0b92f43653aa45651e2066a18452ce14bf3c8aaa8a1d65eac6fed5d23702bef34bf9d6dddcc8974cdc0438db861e423da611328631f9a749d265c3d418bf2b976cc1c1aa4ad8a0df62d3448d0127c580832b3152277967f2ed6a7728bd98b1c80285af9b0ed9e899c4de9c0da2267b9ba6b3db5689b766e897a83fb1cdc8bf03aac55b9d832a149de6c3084be44db082701a42a976a4c69be6748e9093a23935258700f637fa045cd0c53b2c33ea4a226bcceaca63dfe4313a6f44a961459417fa633c57d7ac906ba2f40fadc960c1987b1ab91bc3891ad4f665a9ab7b93a57b4692413ec820b5989b3c7f1d07df11c126b607b5c6d63c436e3ed71ec4efaa1a9edc8fa4f12f261c83cf564b1353a4a9ca419ab349a22e7f2ca3a01428d61ba8b37ba1cb593b04e1468810f486428ed6542c131ae3bf4a5dc55391fd265e231883cec47d6855a54a41a4e82e67dedde48fba760defff4bd308f818026fd56db9cebaa6d12e97dc2c27e0e483590b01a724f3c3be5ad404f450386489dff7f15c744adc07e74bf37e44822fc42147700f4a1d5269436e7053259ce796478bee28dae92a7c7300a2b03d80b33250270e94f81fc6eec74593e7faa0882f4dac170024498815be9dc9bd9816d2e50917bc6db34547b83e1e053ffe90581d3befa627dcc1d9ee8e8b180e3228e2a7a6875ea3ba71f49f97bfae80c18ccd5d03e61a65b2dda5ddcaea0667beafbcbe7ce7a98439e8bce03e3ff948ff5136c8b137d9046c3c9a05a00aba577f3b3b17a50db2fbfb9695d06adb1f9805be3735ed9641236033e263ad2043dc0050f8483b7e216aed6f39802617ba46dca49eaa77f003c01fd32b7608752c024abad4998b4366a92d1daac4095c959d992657ae234981fdefef4c5aceec0316b8ff7985234de14d16cd6ba02171b0b870c26ab201496d58a79b7a8a267fd02f7a3efc7682d50d4852b1e0f0b8ca02795999214b6e237ef26b5f5ea0e2bf80ce65500a4dae3cc65e75ff35115ea2ba14b38d1663cd69c231e343201c770e67ed97d5c83373e363153e2588959735e8e9934d7036b33565056519843cfc272dec9607be0bf05712dbfcab67281af17d092f6e2bee79333c4f4e1084026a866f5bb82504c96b141515029a56a1f3f3d173f8fb8bfa25243a99639dc40e8cbd890027fa435090a29bb57a6b71854c39af41b819d39a54807729ac6e0558f7a6f5a4c909b33590017b151c9e6be0a432568308c6be2afb816296c13e26ee23760b7236327666e6e2bcdeeefc15f07cc20a9e75daccc8017695b4b7e9e84257bf4a16e4dca491f3be29e6e4d363ecfb8a903a53f2d0e220fe7463328d7eaedbe231a2e110e53c16f0ad2b35c01c224755df0286f949c668be7a2bec1c2776bc33e76cc181874d213e7fb055a5cef1e61bcb4a79a011f62e725f147c550ce96f6433130d351e0308ff6b12fa1c3c8200daa97aed1ff658c2143dcc8ca45f7990e62ddb09ca35cfacfd3bb3d20b703658cf075d25c411816641dbd7e0b9c5cc00f804f2d951da0538fcd6cc96d97280880e78cb5c6c1f16794dafed381fb84c31a995d132605ccc6fdfb3d6ed4acab09bf48935f70f003c1abc6539f65fea9362c37d515025385881243858de6490a07c22d4aa8ae231fc5ef337860fce8c9401a9365561daadf9b27da4865c89d6878a8a28277d246c18ea602d5ed17a8b09a2c87bc5b30e820cfdcf94971accea1e57af58e338b4ebd797828441f252682e6ca0e172f3c39d681b9b48e0e799c57869f932f59913a49e21e00730a1081e82f329a3328af1cb3a786e8ec71cff028bfc1edfe82fbe6f01045ed0293570fc3a2d97bdbb2517e85e9a9922d1f81f0bb5b9aa967c50808e5b6b1807037e4379edd81db2591e016d25970e616172a78492340b5cc5c86c1997910e83115e53e6fd864aaa0398c9e8666b8f7aa8e76341c6d2f854b0971093431c395745c5da833ef1ba6024872edfc2c3857b5ac2126da10f62e62af028d1849d73e7f691f46131e6c0fb5eb2f4e2f7a1382dcad6a149067f460ff9c56f382221e125e417fc5d29e30f133485a93dc31995078c878c36152ca7921822d444f552dfa2ee68ec22bf2e8b14309ed22f4ad1a59e62ea93035e4c32afda265e258ccf1593a7f26b396a1aa716b71c950b9d467a2092da471f9d94d625e0a69f27a787162e7383b19b11a4aa498a100ff32e604ba5c390022cd194dc35ce19fd526bdf828351b75f9e0cf0bfce4e46ff15473cfa2f438196e94a49b628ec7b6193648a95f5afbca5389c60551fe9dd3ef6010a4bbec0dd3a3bff7ae275627710359cabd9c02a5b2bce48553c21297f358d0b614156d90b0218f5992dc4e3e457edeae084f90b454fb9bfbe66b9eca3ae2466979d1c84a11054db9a59ff2233f6f8a98323222f127cfa726293703b0a2cdaed65ba67ad4ae0db9a55b2d9598947253fc436e2e2ffbf05f641da8d7091e1e7873ae5b53fcd82df054d8a74f61efbae6c9dd7aafd43ba748af691e6e524a5d2d9cae3531eb04869c632bd37c83b78819733ead7aa635dd8fb64da33a6f329d4d2fa22bb3d8ef3e97f206b08b358bb6a35c6cb020500cdd6a6dbfad8dca959e3bba9fde512b83d855c9db03dec4ca18533cd9fe1f2d62e3d92a455a47751d54cf2a2ab46965d43ae0340269201c522700c2f58ffc134b979245f8a44c6233e939c109c9dfe92be3c48ae324dee2dec6e393fd277595aa33bca9d177154ddefe255e7f8b684b81d818f3b09ddc281a55f13a35869ee109c9974bf1779d0f505982e2ea2263d2883f4e4717920be69b22265056fa90e45f0c02fb93726c0716b755e832d9a6f5676b1fd7d6513795aab3bd7f129f2766ac3627a761cfb64f9c558b2f805995935792329a8228debc89f0f498af7f197eea0785d702ad50d7e0a271ccfa98e8a7b2f29491b3e88b5405479a6b74a22315928f0d226c74ec4de271f090f88be01681ee8ee00d30236194cb70d689ba2a2487ca3f279cfbe2d40d4a16db7e30ccadaa2c846798f44ba8462904aaf18cdfb104a1fe83f0133175d0de72c2b760351016baa33da6f00334864c6f40e75e0ee2f92e6aef1e23a8f295319309c96974047a0806e0e2830e987b894d096ba06d858c87bbb1c10eb1caf4596db794385f44c8f9d8ad6b188f54b2ad2cdc38b3757c145ec1125bd6ef8d54fe1167f2852364fde379b4310ba22728b3a43a81f9c01a8232949553c99b2a39f1a62c5543aee7e94d629964b7b755f6a9dbda6c2b3652fe1bb9f04d95c846b615c8e1cf2abba0faa83b49cf2aef2d4f5a69c690008ed0307443e2fd9056dbb632c21441c6b27241acbfb0fa64ecf86412991279d4a22b8455f3c5e26b681bf9fc12ee5eaff2c7ebfdb8e5a1fca82e5ce0cc0be1ab74e8f94c9679958ec42185fedc0ac80df6ee689e41e08d4d2ad9906965a39c588fe3f3119df6b131cc0eade4aad67f5154eb4995a3c3680d7210e18af3d4519cd97338c5dfa7245f5552094a39c6c5c82d1681dc30906b062219855a926c43f01e298f1fb0ee7080720a7d20d489915683ac3fb29bba253cefd6bdf80d7522f31d66ac0e139acb8af7af9e8882791a7a48fc20108980cf57debcc75c0e1a1534762ee83c68e307b7c68812530625504bd00ffc082716977df84f75efdddcdecb8fe191cdcedcf23d71ca75bb0860e72f93c1a69280fc053e4b06510f6a4f415046d8624cd9786c8dd5314d43ab7e9b146cee4aae2c3e1f8a52a8fd847fc38211640003791e8ccd8bd8175178ddfe15a458973b7bdb14882ccdf35af079532f7fac71233ac44a3a62eb6c00feff75f2598f8e6fbbce2207a785974733e4676aca50f700277ef43a2ebaeabeec8e74e9704a8fd4a2df75020a7295fc56b505ef19561f7d8c7a89c76303d3bb562b6eb702d893660f6b1a0799124ddb9f158a55f321e701d83eb53f7c30ec91ca3ece517731b6fa09daeec6d8c8d03848183bf4dabadf0b295f5ecaf49621ecf2a3fdde0cfcb57caaa82bf04063cff6236ae94be94e1cbccb534389c98e3ea5e384b46cb36ef1c25b0d3c0e5f55364a34a8742f8428c0c34f3402d796e9db8ee2d09dacdaf07d960511f0d3b7372ac826ff7b0308119e1a686576dc0de87548c8af0b8ac355ebc3b8d61f4180e4b330fec956c6976ec57a0965a59014a5c37c6b4268cf1eabd2f99287caf4dcaeca6ead1e583844f9529c0988b5a18e2cc7d2bd6043555e5aac91533e9c2f75a0dd823ce51ad19f7460c428c14bfd6d9ba64b06200e992b0023e61ec52fe0bf8d94da61847fb5b535202c0fc314c3375401210ab726a6f850e9884aba51efeb980c8d2d7b1d2629e2a89b0d683f37af379de1bf80b43deda74e6238d039d938711b46ac0e3a216d2165507929f6ab873cf011d58453850150411a8feee46f1f2da44da821acd582f141616ce4a8b6afc0491f05ed24b6f50e6649d2c5152b0370462a7b46a00b249628e990c902f8a3dfcab108ee308f4e5c63706c4d8201b9b36b559a8f706062e1a7303b4da0955299f44dd78750395af056f3d0d851810ebf84f67b5897961ec84f69b2522af61cfccf50297e3fc832c4a248c6b6ab14e983fbfe3d5ee75e0fd51fda93fe0114f114b94cb68e42ad33cb85ff73da3b00094f689b040deab7493399492f3c99f1124009bc5625d810c39b2735b9dd1ec937990f617877f46f0426999ca6c133bd7abef985ea95e43c7aca971821034c6433dce21c29fe138a670b4cb2e3ca857d49d81d2b26beb8c77552d128b5d370da631b260293780145bdb0ba0accf3ae1e19b2b66e993c042c42e15b65e18a8857f72ec0c4a9269a75f051e6c2ce818dd955102de89e7b6a89f9555b8f7a1a3b21d5fc8234733f5e1c9ec96e9df3966e8f9d1e42b2617f193a176d48059725d991f4e17b735f4ae991abf4bfb51019ffa0867b0a7cdccb3cace889a8c2dc67ee3fc7d90e530944471eadb0ecde8192aa362c1669fc01199ba4d76eee89e87b75f268c0790c699db478545053e3c4c8d09cdc858f02a19fba4c9db668b63af299efe3c838cba570a9980c6f58e89c2ccd1f15d439005df20d2ef62007514d41f93b9909227d1f07dca66640dbcdf5e83704cc2743904b24c19eb014eed2276d31e2d5b1842d766ea407e2520b47e23659f486510240049b43efea82e301688b4a84739b6f8ccd7e8e470abe0351d1ba13973f898ac802e42011d6ddbdf506449696a33520de0c30b3f07c710b33fbad7635a1b22140f014fb8d1784efcb1f0531838f25157424f63ba2fe53ca5c9b0dde76c366511ffe55f936387469a14093dde7efb2a70e1908da9e53e03bd28671b935e08282931e04f6323cf7e54b0bd9d688a2001ffaef97eb18be755edc39bcfa103414d456a3ce0d64317545be8ad8fc2466fe12bc6a199d2d3ff37e8edae6a8a5df8faa580a778724002ccd1282aec146647aef7044ea180bf229a25f0d7555482acec56f71251963762e7dea5caf1dacd9d7206ea3a0e1aacd31dd94155ae08ca3dcf4854f2ec5f3591bc18a79b6d25275291b9972d378e68d587078c6af74d0905cfc34edfc734004f9c70859067f6cb61d4e02f54fa5318e378e77c9fc15e4a55ce1106bf18b76619e372dd915fa18bf00fa51676f4b0da51783a2bedcd0aee591b09825b9b2ec248c0e823359b54d8a49558e4cbbdd38c34f18585acd7a4937ae6a47c964f97376a01b9028de205a4f0d11ffdce794d50ef42b7d2563a75ff6876f4155e285b0e33acdfc6e2b87038eb4cf70b5e063b76c8d995e02e57b1d8c1bed731fb22bc7dc4e6d8bbdf7a480a805477709aac6d6c6acfd7be8fb08c16e31f3f462cd235947862202093e89d1498cabf30f2856c06a2e887586b7683f45eb7aaf4bfade6659c6c1591cbcb92fcc5431b23b1c6b2b9f272617adbd192f91e4bac69cff7307578921f6eca5ed1220aa9158758c2eeea3db9572f22cf608a4a7b3be50d31b39f67741104d1f42b122ac429f89264c211e630b622e95ad7783015a0cf095cdbe847de5a5499c8925a77c4edece8c0c3427f9f0c03c67fa81ff917e842a40171e9bc333afc28f060d9f1b5914616772cafbcc11864a8863c780ba2542610416b8dd310a2b84302b6ba2917397f3fe2439d6eb3fef4d44cd6518170b9030398b7f743486e2b79f298ad0a1865adbb608a1596c9c0d712ff3b385e68fd49865e40e13688fa841880a916b170aa6606ca04876878b5d8f66ac74bb649f335a213df7bf69cd01dd13e1b36ea0683f067c3b727c9a09f0245c5b8af6aebdb3eba8b99869b0a626aab8368321132f9c87feb8683a7b9f31a566e5736eb69f6cc4fe597b8de8c7ed572eb303a769b89113bb6b417ee07424cd7d3c160fcc0224a7388466f7e25c1e8e9d61f68dc1d4642496a5e1061f3470027c348d1d52c9d29d9bca33efc1b86cb8640040ea1c2a9b811154ceaeb35adec39917f436904dd9d5bc5488cdf19b3230565e8645d2e9b37eeb940b59c436005ebdb51c78309443ab8d36595d272011ecf06a44408edb1936f70cd2e6e9b91bba6fbdb53196aff981a2eb1fdc7f5270273f956029634b8af2fb488af7353dcec138ab483071ecfaa8a671a4623fab4cf329966e3335bea141c7c2c7f3ea6566478e3deea84aa6d2b6ae984930c97312514401c686860fb03e13d1833dc9939dca2b108412d3d333d5723c3c2e73e9c922c109082d2ae0c822bd6074fb0337a71e76490d06ebf3a89cb60223854a12b2f111d2f9e198fbb51cd1fd5e5da238e379418e06737ec4ee803488e20331dbfecb8826dd8b06185ef08f92b273d142aa7215e9e910e4083a115284861163bd0b6cbdcca3f346c7fa44a7bebf91eeac11d7759de3e65ce6d28810a97a7e4597e0228c0eb2820f07a4690eabbebd0344853ffdd18bd180a8a0588177b6897a5d2fb1e2c1c9f2ce5bba977b4cea00272b78816343512c24e3f1f3d7658d18b885a5226b300ae04269119fafd2a17ae3068a853de8d4eaca4187d7986f823c46dc27c26c3f15f2e6c28174e401bee4a61840ebb4c04d4d6651c682b518399dbe093a113fad40fc3bbc4eaf21da71720fa59128febe9b4ee39fbc8e3d66b04c3122c598fde6467f55bb05758114e4987c32e96bba69f3b438c53cc96686dfcf3ae4120eb6d413dae5138bd17b4ad1797d31a3635dd44485180f070053daa18463b2f0f28aef3623fedd1a8638f4a5ec183a8b5707d1a3da5b63a464744e3ff54741a7b6dfdc1d3a83e71f7014f282ceeed930a7d0d025ce701c1aae9c7938fe949ad88294d88dc9ed91281c0c5daa9a7bdd6cdafb497f987a2322cdf903bf5d2dd3a84a2ae308b380ac6f124bb4511c460a1bf92d0b604a4e05b354c437ec07b21a063f684af2e38f1b733a63969faf89525248c5c530af11b7dd0621f0cbd517cac90c59ed7d6a0fe64619d7ac7bf7a0426f015520ee34588e23bbd07aa840821184760951ccc74a81e3a4789d350d9c57fe79649f10da3bf35e7639d2071f108cf6b24f55048955ed9e7df941ddcbb8f22c0d1884187eb086f18dbc5d96a3bba0dc06250b39365aff02c7245df2d408c65d56171306c7cbec2198f12fa8c85ff3d5acf779ede6943c211840b76b42fc9091bdef3e7bd32beb55b819981463f017ea09b340458887a8801dacf2500d99dd33f2495be39cb511d2c2cc443443962b8a077827aafd11c492cf46825b17095aa7c60d703676c717c177a51530f811119157e415785c85451f024dd58bcb06760d6507f376359c92f2d15510ee69e9d048b4db0a2219166b2cb901661398b2a48ddabff5c2421ca48e409d88dda20eb1ea6e493cca1c6adf1a1d7b571d6cfb6b62e8d650ba50664fd11cc04c9ff5d91c80a79128e0ef5a8f1fbe9564dabbccbc7127d2eaecb2c7f6bdff359302a0e2c34b4140ec0bd6551dc0f4471a627b078390295319c43400f2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
