<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9edc9a851b015ba22391f74ecff9fd21f7d7a700b23a0a39d01db5140e40be2f5f78e6c4bd9733ba9e9b122862bdc9d8ed22cdd5428d6f4221c8641368b45610d9ca5a8719026dfa73b2ab3cf291c7ea0dcae6bee8530f7490e9d1937abc0acf47bb511ad5786784a378fd04c27f92c26a53dae7a23cf3e3dff5c5cb9c040f9660d9b6b6c9afd1bb1a3b8c5d3b384a1b0e288eab41bbaa3225ea2524b3fd6ad625f473e5394f64a3c06d97521979847c2beb90be95500368276efa0b577224dd5bf0a9d866f13bb83ec11c626f7727b7242f3668a261507e1593e8e940f6416c349f69954f9228cf3c485711f3b7c764714e4ac48d973446d206ebe45df5024e10d64ee1fdb8a1f10cc47137fd6b488811167a4a367bbda87c9160b481a76b156901bf97d3ad01904899dcb235d67f71eb252b25cda1692a361651e0b45ce4175b9760f7799596045a2bffb4119f87651043dda8a394fac96390ccf26a282ba7d4825d066a1a303e44de4307f9eac330d6bedee21cb5b60aeb8752fda65da38ddcd87d99d089b435825548bd214e36ddec1d2c4a62a98a7a9bc15e63e611332555adb03d63af00f8da33ad84fd2a3851e87273442cfc2067305fdec110db00903d5005f7dc55e0100e314e85e299d055f4857daa66d951541562d6e9793805c9d4cdbf80f3742d10f80cb6d47b24f600ea2041ed821eb29197216a5bbf54e08ae4703ac19272cbbd8fee8aa04a64bc93fdab58e0ae0f9e4cfc688390eb72ae1f42c2f41ef629b1e107868ccd17329389cb70dd59e6108a2bc598271a8b1c8dc64a73247313c55a852cefd8ef8cc0a9061f694d6528fad0f1299b6ea9058df3733874ac935a06e1045cc336c575d08ff992f7a66413365b9a984c1341380aec593e36ada8a01c60505368cd4de1c4beb070cfbd8a6b1847f6823c4a1c47a104b7712dc9a13fda096b2f135d8de65b5f0b27aff9497e8a6cac98b3b2458ebaa449b1141aa30d725dd58fdd7ea4537764ea3a07658cf02bbf689f3ee70ddc5b3b073b3f106ca6e6f41b069af61b1447b34fd2f4702bff2c63219e87efa8386b30427703859eb79208065a66316d5fc9f4acf66b5908f30c31cc10b9e8e1c343a782e66b40024fa8762579da3915390fa3aaea29c7b541980e3e22ae6c7fc1f41d03bbd8fb062e4cbed69a151de5a6233ec0b9b6f2100de8070cff7a127e960966c375e731c85579a28970ac103f0a162a8d9dea0c3125bff7db137f176576b47d06da77d9c99393d5852d0a58ce5c5befdce5d91c9d7c1fb79959c646cec28280494d84176cad85a14bcc0668c7c8286b6f0cd65df65bd74a5eef4c6330269c9b75a2a60a780e8a0c203a86693387096868345e4d8e05be6354788abf4a7fd1195684abbd362c95380696c43dfb8505dd047abddba3ce91fc3a1962989b83eeb67126e73ef4ef451c1a421bd4a4aa9773d1a8cb76cd7abfa369a26d97b8f0de5400d624b090b22efd1186612b5bc1c2fedb6893f80f7dc8ea7d0912819464399320be18cb7d285831922848fd7134ce92033f0f85ec04a20aa11fb82c41abed7f34afe9bf71aa905a589e13da4c26657e267db7b1a206fe5f7bfd08d037a4e138ce83b5fe165253df4fbe6706eb4965bd090be1fda1888d4450de34e674e5defa7df4793cdc8468971adac071ec11177ac155b926bd8afc9aab966aa6e08d1382ccfe6d5d22408f6d367ca6dfe59bbd89637021aee78482c1fb18116b074d9f21a4ba43585a8d30e5bbe0aaf6f04cf2f051c345fff4174b43a4069ce0cc2c729d5ad83c5ec0fa5688ffbd398d58e25088eb7178268de2f6d2535963f0f25b96a9671f15c863836c79e4173a9e1812f2c7e87c30f5de0946414cb9b56c682a18e95a31346113767f62d4cd9630fb996eeb43eb21b83c177b642f27484bc1f7d3cdb44738f27671714926d7701609f46830ea0e65a78cbfffb1f9360c98405078822f3a8def4a0c79d606bbf6e550c261a8aeedfd73e929e44dd79516c33afb9afda744e2c3fa8b23024a22284e6a1d565441cbd63096476ad1a417fd9111dc7a871061dc45a4da6f9af62a37768bd248814d1f10cb48a0b03265974fbb3cae888548cc8b3901c82d72f04410e4c1bb6ea279aea70382fecc9b702f859ff0c25f6dccd5fc494248e038ab363dc559c94d9e57639629bb0fbbc5706a53b7fc3ad536120948b00e1756413fc4ee7c2da14a9a1c0d99387cf20b54c1c560a27b070466f19421ca4c0da08002307dcf75b59e40ce5bd30eaf0ffd9124316c352737798f9fb2769157cc06f44de5c10a857048d2f5becc34ef59beb208ba82308e282ccee9d9de2b1769bc311417614b84449f8fd5812b28e13ceadd2717d7a516572f572e0f1ff83bc2a1ff375d78816fb43909c4f9904ec4d7953d28871b4b91868314ddc76e8a9b112056291b2bca81f5c5b794752117f587b640b7d9f0ff71a78fc9c11ad3ad6768ec183ecf5baccb3ce1bca92e14f22b06c3e5e3db72b088b66685b2cec076dc9dc07dda5ca14ba3cc161ced4b551dc705db42c748869e9157a5c0de7e7821487b145cd4bb540a2c9e31ec6be63639876c07c24e346bd18b0decdf7d358720b00cc331a934bfdadf88e2003cdfbecd1eaf2b245da7ca2cf8f53cb20624bde7c1e7aedf9eb4e1fd9d904b1ceced78e49aaf689f052f16ab09b7ff2592a2a0ae3c00c310f151c8916d35c81c0ade6560d70cde68fc99f2a75d01eb113feb29984f14a645d5694295fb4dc45ac2052e2a05a19c72935904e1f4ca9678101055f4d295aed1f69c45d48db44b41e4334897680c415d094022eb5150b3d5513ec11140e4827dbfc4cc9d6fa14d9d00dca7824bde8b60a3282dd4d922dc931b57164aeecc108c622490afddd7bf7d0ad05715b2bc36dcc3a0aa9657222d35f702b47f592ffe321a66843167f0fc1cfdde3b09220541c54a13a01e96f8d12306e99723940931073ab04ee418487a6ff8ecd86edf1b8aa930e39396930ea786b8c915e62fe88b335aea765e7b3e94f96f3f9922d1827405d8edac2d87a7a02cfb1bb2db3423454ed621ada63a04d481b67290f8847f2532804b7d6f5d80519b1335031cd001104453d58865dc90d1cfec0944a36a7ed1609062438721c2c3c9ad32797152761a902ada41244ed7d003f8f72e30fe1c4bf55c2b06af705669185f05511fd53a3361d5e1b36b519aaae16eab8f751c99cb95b2a90049c2ae81a557cc4bfde94dacff844565f32cf0bdf6e6bb78b8aea067847bb3093578bcfede9c42a5a2e4c25eae094f0086eb4adcdb83da7131105bd9f16bcffe75d268fea30ee92f2a157a893282865a29439b309251a3eec4892a1f5bbc641c40577be6d79996b4cdeb4e8f6ea0d6a645c7a2cf1a36a6566c4775f07abddd785e778e8fba085a672f92a051937f43529f0be5836e3065589c33d228a46b98dba6f46c8b5fe4be59451664fa2a00a9edeaa9e520ad7fac9b4912bc3e172619a7386370497b92eb2c8a170c1c51e59bb4136addc9f327ad86fd46afe19bcc72e9dbf5dcdead2674d9e07e2703a9e5b88dab03a628a166acaf419e48d5db18698aa0d12d0b91eb0e175d00b76a8300951e1d180a55de658430a1cff33c59cfeb016456066673cf9672c3b3d340ea6ca0f08b8019ae73f34b19c577afdf28c9e9003997d1107e25f299756e41bb296b603d46dbfd9041b3dbd5badb6ddf890a0e898c573283ea07494fba74d5d7fcdc65c665f5d7f35d48b2f583a8604e521cb32ac7ef72aea9cb5f7c87aaa7474686a383212d2d1a25407b15ea6a7ed57ce2ad6e0a3f5c2e0714814b9f83d50aaaf855863f0434b70791cc36acbf53481f618f223cb6f21e03e04c86c8dc66af383e02a9fc5dc767249a659e636e9aa09727e95d98bf6b8bc80e9ea115fd9ca97e742ee377201dcc446bc4b3568042aa4a29027189c2a723da95075c907ebe9d9457d46e434b8c5e6a71b6e08ae80c9528bede7f470f3e2b02ddb1077ef94c78bfd8137a20497dd594b04e69566e17f6b6cb14d220e259c00af1792e7d820673e548269d57e6ec001d59ff0286241989dd08f5846e65a68527a77ab71a79be1c6550016ead77de8188803892e3b39cfd5f29f0b8dc50931778b34bdd6934925b29aa34e3a525735e6ecdaa7a1a0751101548a145258815732f47029a4905a540248e6731de2352444f785d6e688a420ef75b3a26a3401e33e5580819de9fde802018e835e69d8f9258af6ab6bf169428dc22a2f681d93552ff0b3f0a499dc6ac096de3941b84eb9a56662d8489b2fd49b1c3a7b556c8402f2bb22e32ef2d84ed2fbcbd4d92f2f2422c3559805f259f8ac62bef9459512705dc95522e40c96d8efd75612bcdd0802e991cdf9ba6dd028ac1d643d96bd654e2a678aed7e1531152f9070330f9b1f96a9ed262512c1b6674f58bf79567c30bffed15fbb43494616ea41c9b923fcf368d0521b0b8a2a09f96d798c6d0310e492d06f7031e7ace7b4706a5ca895cb5cf031fffd2a43863d067607ea67120d14f84f62d396e11d5088b68f849ec2d51679f56b4993477fab77a1dbba6859ed33eaea0674ef9e9bef29fb7662e37a8136516a1e420a7926463e02534b4ec10bd8d8b30e137554418f9d2108916f0d34853f4a9efcd7231f5155efd8aad1ef2df5d3e9bf140b0469d59e356c44ac9e661d9ab017fe0aad7d9f8da1aa83890549b8450fe49f0322a09db1258b1a530f779592846f47e2b70e4ed621a94c4c35781ded1ec9427f92df358e3986247eee3b7ba1040986ceb653484c7feb5a5f159bbd07ca0eaa67bba3ccadf3366a4db8486a7e4e27f32806892e9f7ee1406d437f15ef870b1e89cf64789130b2f278802367f813fcc3b60035d56aef25124aa55bfa4f859e6265317b9ab796f745e19bf3e81b1fa9a1943ebcb7e830a848e4efa778f5a4e0a8b38756e8485271e675acc1857695de25b4b76ebddaff5485e367f4f7bde74a73f98a13840052dfec474665894fd0a14f1cde79d429d2cfb46cc57e1e6971c47c66e6ef2010274059e859dc84ee24f1ec5f538c254ba1baa435b336858137ac4e84f165efe84eae7b95a8d2eecc3bfc9a0d867599dcff0f00a67261a2806f28363b50569acafadefbcb8b1a05bd0d95a5523465807a911b2f6e7cbe0c1559c73c3196f86bc006c629e1fb162ccf40c5b6bcd45b82feb60fa5a672a9fc672638a5561d4c65136e4f8d8f289578ca8ff2d271c76f15d5264bdaa521d9d480bcba20cd6847b381a58ae38fa35b2aa692d3e592417912e7bf48cc8c44ba9a49494097c753711453c59263cf7669c022283670af06624216fe40bbb3f3288c9f2a16912638eddf44b969c31127d0a27624a8ecc7334255d7e10d73b64e6be62b4ef7bbb9f7affb1bc339781f879866177d194f7f15b566899f8ec3c1b738eaa2a3993b1df1b0a1ed87ba1868b4787a821705a38015cea1fde6e1a7d84eaaac1c60fe7ef7d047106c603025182ed96c99a9d8967e7fa37ba08ace52d557f04c4c1a4d2b4a6f4fe7219611e71b9a5dd2112341ce1c4f4372a248b288bd6bc37f1c8d8c2cec2a0fc88655c6a432328cc259fd47542365c0abb4616faa1c3836bfb55a15b4052019766d9f6c9bc605d9cd1626ad27434a64519f8020bfc4a5b6ce5ff2f362ba5c6588011a66181d955bfb00ab86c0e28eaf68a9c2d86fce09950aec90052337b2e7fc5564f4cc5d52fbd2854d20a04a0f5d752c2cba88cc292321113ddbf10168f95f7029c69c91dfa523abc93621a33ca73895be6e8f43de3b74bc81f5f3938b6b7f37b7d48a04b49cd1ac9473f1b7018b238f836af6949c76712c485b70ce63e9d3dedfcd9869cc5c19dde24b7aedc60a0c3676fb4f62ca60b0f6f92b813f7951cba2d6ff109f6807705e2a8228af926d2f355973428d55e128ece9c3444db3cbf1f97211c6f3f71c1776492d48e50369be978a4f9c95f02d1b3ac280052a6f19eb8da164a9b1e49322b63d4b67c7a4a0ed73d4da53b8e763ea89d77ef21e2d8bff60575472b5ad961cef956c8203b7ad75b5f7bc8be7ff53aaa13dff776cb566377d79fdbb83ce2ec38165e42a2852f7cfb267aa67e7af25597b595adf4ce6148c9a52d9669c3fc196351d052544a4c9a62206d60acc690bbf2f972791398d9f1709443f0732db0b585c9758e361f905ab2284e6367824db894c96205a46fd2c8a5697a7e513c16ffe09c2dd2c213865c0846a201fc2d17103b7add0a5bc3257a503e76daa0ed194e631b9afacb382c438a91307110a46d02b2838aa5816361f3a097b911b14d779e2227204e1ab21e68ca77c2b2b7f588e0aa03977aedac0713eb88c9d80136af6fa23349a8a3b07ab5c377e4070dbfea70c3466d05386e3aa8f81a07a5e80636f8101ee8e9208050edf77836c842a9217ed600b17a7cb166d24432dde76bd847e995a53cedfe832fda33e14f362b745ed6e643dd88fa8d675f4acedcbd0442b79cef5a4c3302a72899e453d0e03945a7e8135b1d73808fce9110cea1027dfc55f09cfdb80f7adac69ba78e713639b34b8582a94ff98b8665439d61372cd171eccf6a1f46da60282ef179020b51c5459e91d2d7ff4e3d72eb849015cb40b280fbb734f199bc58df5fb7ffae595b512d8c8be693efd6f246c89ab571f2147445deed1d3c69ade48c514cd36d64c27603a19fa4c22759233906f58bb238ab05abcad991825554bafa98c1d5629e729cd66b39e1723f836a3f92ae5e63e4c79f24604795772f5db9dfbd5e8f588967615c0d302a5b80e65d2a28e6cdfa6460d1699839de2cdaf336efd6e3b63c9344741cd448e8abd0289bb583c5054b689bdb799abc887f47b2ce9572bdfe3376bb2ecf877ded69a93ef514f573a98bc10c48534cf1c1590c8182f9194efa7c795777a28a2cb358f9629d1cbfc8eb8d52fa1b06354f1b9b4d3ee6a1088b0ec405a8ff4b914533e661b6b4b1def05a29aab7533d28214e162cf40cb3e089191d07ee98a53f89da8723c5a0e0b7bcf5fcf6db4e7b64e350bc33a4ccdbbb8a77022243333416934e87571cf204f3b095bd3553e4d459e3532fd30b3c599204b439ecfd85543984d914ccaddbbda0abc38d7e67437d725ae4b1c14e4c891d3ed82736ceb11abf418e42b88ad5ffe1a084c1c0951100cbf1a583e00ba764a3e5ec6c3736fbec0ade47c966baab92e9c8f2c569268e965e292c7f41911ef3a6d52b43a885fafdbd14eb24c98a85f5d79bbed4817188f200608bee62db7bd1825d2418cd24aa54903f6298f1013df8fa2c05d4c7786ba12b97cca1cee853a05ea5f235e0db4ed305390c5973b47549faa8c6551b0b02ac94fb5870c8af03b3b1fe2665a26045e7ec76b2002d6a9dca915c737b024ca92417882b4b6b516e452f0156a49ff647a586600669ebc44c06b4d75365b430a567fc4498fc0498c77c407ed2eee0947a97b50831db2776e177f4f064a593ec14b629367326bbf8456a4e5129036c52b5ab17a9ddbe396d31187e3fa2aa3ee804ffe16f0a7fdb3c55897234ffcf85bc4611b25c10c0e71ad42ed75908fcb82cc4b91331aa807373aeaf8d3d2f21fea96fbd7378ab5bb47a0c4c0da794d84850bb546fddce2eceda69b10fbc9dbcd8f05bb42f6355069a2ccb8f2d58f8c8c369a1b3cf88d1964774f55153ae93422e92aa7d65c30f3929203439aff44f7ec6b277a28e456184c74959b0600526587bea171dee37f2a5269e9bd844ac29c397f95d1930e78ea49aa5fe0e52901555f636dabb6271dfcc9bac3e1f618b718d8912704af3f5c98f7243530c2514eae6a8b045e54359d3d8e5ffd027fa67e05f50be55f5cc9fe6d7974b16a81b4f46ab4d4ed366e52063bf5032f7b494cfec5a1012227793a15f7781a31abbf92e046c4429e560bcee159bce89b06dc99da6731a1008a8182be4a81dfb6e12dd10407e01c580b59767af399345bf97b20108ea657cb740dd19b91e4115ed95dabd04321bcc7ce1afc990b11376ae010081a36b7435bbe6bef0c8088febbecc77d28c339cf477747261ae32cc320daf5d5640d4406e2318771396b4aa0d17b3790f1e4a9731837e0b9855c4d01124f9c841dcecc10ca0edeaf1a9630267ec9df70a0ecfb1093dc83141ba733bc31f7f55ad7196c526cd5c991844f1c64cf7214387e316e461bbf3540d811564f9b932c5efbf395d123c9f93ee1fe068ca65628ebdea700ba0d9707af2ccc10bd947384f23b25271d2ddcc8763470fb53b06ffc3021c4b60a719edc1614e2f393ffcb4cab345011cc5af45d817046937bd2791ce5639ee0b6ab5eae8d34688e238273c0390f8cdd386f75deddbcc7237f9de3a7b09510090f10284181d0d2aee5aab1fa7e47c343806df20c3445e52424b76eff86b97cead2e06cfae9250ffc9ce9523ab694e468a84c4c39e7df2d246bde67e0e46a3d4063cc2e776f64eb05570f363cc5ed418b516990a8aef7ee9ab71842452e9ca2b23b1176a465a647fddbb6fc7d3589040b0282ce3e6d9c6c1ce8e134216f55256181e559c715891dc9cccc2cdef0ced26a9faa07f8b20adcebbb0ca39da2d40bd7567f0f0355f5d1e562e62354c7a6380871c36c6bc9b8cdf264da69488f3a5d9caec822710b678b12891de2b7834b747aaa1d94b6a36ed817b0bd9ed0337b7e18a28c9efebf0ebcf11274dcdce3f5f201514a6b207c67995318fc24d1dc93016965905aa6b952b3babd3f4763405775a1837f38285156b7275a8bef9bfb9bc35c1a6df4df6b738b6eea95b11af2b70e859981c742ed77700639df5514b95e6253b11fcd90c720e989c360bc501c6ae2b05db2dcd67e6370b3836808874794a94050a89ac2b42fba0d1c193b63a610c9d087f585751bf122c07b2d06057a0fc68e8e9fa2728cf1e3170985e399fbfcb5e0c7bc36ccdd52610788d456d99122fed433acd0ca5dc2d51e4757457dd3eee1631aecc0e20ca16c4d900258018876a813978c7a3b689c79fdcced9b7e6e1d3eee62661c106f8834e035f8bc7e9518f47b700ce36e854b3a86db9bd2b9cc32bde6d1a903a688c163f61dd5d3afe3eaf8c1ce121de93744364998dff941fd83a9df6d601a1372bed5e79a7bdb752d1e2b0d2c83f57e829eb83993cefd741afe73abdd81474c4b9bc7ca45a502a7e8f9beb0100c1dc7cf1d6d2e05a327ced2829e4a7c4d592ec3b1370f3333405c0f9edffb25b899524293fb713a64437ef28911c1bf3c8e6ba7c1d56a8f887f6217fdbbc8d46d612ba45f2a541fcbbb8d4aa105b4dbb86f5baf2a6caa9f57027ebb88dfcc139bc3aad8222a01352e021845c34040991cd4b2772ef5e2269a04a7ae48eae38af1a26106b5f7ca41064b0b74300f60ff5d00d2cd37fc060d367523ceaa375ba91c99c443256bf01d4cf77e2ba55a4af3fe12fcfc74f03f8e173e76332342eda6a038d6f955ce7a1b5aadaf5feecc193fafedaafd9482253c8f61ce2fd44da7d4af30982714e143b44a1ab687ecc63bbe7b5eb41e6e9daa7d717f9cd8a262924f0a0cdf1cbbbf5182fff167b59223b84db8b6db9897ebbc288203f9887bdd34d4370b904695c89acccfba179b43c2812f646fe651036c4f9828e92c949a15a4041d6e22c44c01c9b7b5ee3866343771f9e0a57523c4c87eeb29aa9264b674c112ef8f524736618e3c8181bef0dac6e6483ce07c50ae960e5dc19b00447364af1b7cff81a393d75892f8ff9ce446a9dd715dee1a2c5831322c869860f104f1bf04c07dd95eda0c525f1cb1399a187434a08e8dcf35ccd48ea9f84d218d9a31acb70839b9fed647d5fd8c2b2f9fb5b1e729131208e6f3be925bd20cd381e1af4942b78991f57cb155f0087925f9abfd13a77c636ba1219e4fc55467f5b2ac24fc3f2a0835cc12642172b2b23640062d8828ab0ef8c4af79879eba8aae6b72f67d15e7a114d3d3718d4f1889597a1731e705b5a6339db9b35abf2b703b957aa363a56a09707652188ecb9a3b080ffa7f6299c663fd69286a81ac396e33755c47c546b2e617967a84b39bbabb6c6a82448c78a9c1fb8c5e1c1ed4783426e558ea8c5b20eab0cbbf47351c7b6b9bdf866a621dbb645f7b6961bea83b4534c063505aaf94b04bc4136ff646f2e629b748f6a18d1f8d3efb227b2a2f9406ea1571d04604c826ff3551b3dea6c54a4b9f8c43c12c3b8d33f625e53a94d400b081bfc555e06cbaea539cb6cf6df5d8e9b0ddb2ae57c3f1669154cc6041aa4b7a6b6d232dce332683e5486f1f80e698b90ac569b0ecbc5abb0cb105e8817a538786f63e481153228dc8e2381d1ffbc3674e7219f25daafe73abcbce974a1042082dc6394904475ca01d5e4b6aff539312f8c40c65fcf8d0605503a2b38930fb63ecc553ef3bcb897c5369314753bbc95b6be4dacce1800354940a5137e1876b2be12a6c2373cb1c882d26a6eb3901374b260d0925fdc955a46ecd4f8c4f02e32f119e70868dc15ba29f1fe14d6f73db6bd0e55afad09159aece62bd91fccbb70f68ab0050db5a7a4fc56eb31d7017691fac790ab12245f0e35ab15e50e45f446ffad40b5a25d5401598972f5d74f6a730b51ca38311371c6166b79b1997c2ac7d9cb325bb6cf60d9026b5e6e6f3deef4d8b6425ff4b402d63236ab0b3d2700646d9b72f18b962bb8893d19d5ae67e0729179e106129bdcbf676d0516968d24563b902f3c82801194633d5075030664bbb0178fca27af4459cf3ccc9ea01272add011c1bda34b0add3e6a2c23e2041583c6bdc3fcf4862d27a1fb2c09104f9a43e11d0d83c75753572f2ac87d2daa9c0eb04e911cfbbe8d7ad5f1b75eafc54f7996159366c3685b045ead221424bb86e3cce4a6a5f9abd096a9b41442b2ceaf9501f22d2a92f194f102da97b32941cdde41b33fe3545887fec24cb8529021024b35daaa91b1cfb72f942041dd1c5d97c8d8a98e45145c2875dc77f26a5620e1ba666d65bfa35430aa6f0ee78bcaac05243b0cb7d5d9b512ae46a846733b75579ae116fc76c2e83896c69f2caefe0f59d2aede5d7687c15b448326838bd4a8863404f9495645639fd4eed45e9ca03dcb29e032ffd99431f5e967ef50f668f4a481d6cecdedf47511d94a9eeca6028dc01c5ae6899d708a0f03c4827628dcadf30c6d46835125f6893f4bf5d53d9bd218f7b54304b11bdfd55fe12895ed354ca1c9475f442dcefa39284840a3db6bab708f2e3a237dd6c6b8a343a2aa85d53912ab564209ac00a2c969c489c3837690613ae6e30d19c686a8789302390dc90972862c283b4f12cf68c63c287beb8bc58d0ea28483d2694f47871a0fe7bb0a1f7ece2dc40e1bbd2992cb221b6a46bb1455e28c032135de4c2999a14e7a5ed8f50460445a4dd9bc748b75e7a7008d0105cb920c0339f777ba54d09e997088321f7a0aaadcc77e269e81dae42fadb0367fbf47eafc8cd75db6264908980c29cb372ae878a664f907dc747ff1e7b2209105293faab26b44d6089669d791779fe056ac95a3d11b9701e099f473382b36e2d0960cfddcfc99e52f186d1211c827bcfc411d0bffb74f0f756792d416158dfded1632e32b16fba24606a4dd3c801953a1a28ad616eb7248ba3d6f7cff8a6468a43259c1ee714ed06cab45feaa5b990f23308818bb2930ea5628e2b65795170cc4eb68594916c68805a4289946c0ce763113b55182e19f1e49889377fc397e43f597358c041c8ba335c3abdaa44cb2bb10c38fe0a0d9823b5a5d1142302598af10b26da1e97905812f90e237835b1f50091ebd2ec1bb7fe8016bd69f5af9b00d0c5363e4cd2373270c43e72dcd8ac92397c7287d15d2b0441c856a84c883d7facac6c87c73a291d32cf4b3e1b9224158f120276fac179bc4815643e4d024a54cecabcd8470ccc8efd11eca875b470c230d30bb2ee87e8214e3a986a49aaa460113da83cbb2471664066263269a275c1095c5e780cfe2c5f02ceedaf14e1a270baaa9c77048e568d68ee891462a640566cc073c6d74f41d22a3f34e5231a2c5975a4f6b49c4caeb82da2f76db4d08d4503c11cafc277da64455a99623d41157cdfd28912c91322e4c30f8360282562f50ae56658515ec0bab7b07eb88474c4acc6dd7484dcc0ba417e1162e2be93bd1126d3f41e840593d28a1f639326b83946d94fda08ceedf46a63e1aacb96c8c4e7d6a39134f5c0f9bd34eb86787278d04dbaa2c59e389e0310dd0e1d668695c035404784cf9324c845327f03c9f0ad69bce512adf41cd8b11eeb48eaa11b2f94047052cf283b6e4e53a3292f2fa223b066d95a8f108f888bd23d17c66bf56f7012e9e710c212705cead63ec7def799b9392d16ed2a2d5a788a281742c9ddc85e663b95fa807e657e241ce6ce35a93503697a72b31079b9df5287859b7511d507829e509558f4283744ab56657c2393a2e9a4057566cb30f0e1d3826f42952499c7b33a5124442e8c91a01d01d31cde6dd51597e7f6e1b5a27c587aa65ad07da4837586fcb60c6fde5742d325aea632f365cc33f0fa6919ac10bd6eb5602babb92addb75529a3db43ec6ea4f685c9ca867896b27bf69a8adf0d0e55f1d83ec9d40b1dd69002c1e64a9ff82810bb54f61c70fd7d979d7ac6b4104378875ea5dbe1ef5b835bf13da0fb9b1a82287625140e97fba23ccd892926eaf663e68e8d056f098c1306ab2d8ce993ea4bd0f1daa606b91409575581cbee7a000a875817f7c939d7e4ce2aca0acf7885c0dfbd2686e5ac16832bd740808e53601835a8f6ef6307194b830381dca49814f9eaa78ec49992ef297868e726eef4e0b630edaf2e62af3f695689034b57418548b9b549971da2dba98b3c59854f80684f869db5369f169159cba83468c343ae13867bf497bd89206fcc2e5f01396a840b3fd67646eb16b6a0edca35914282b3f63e495ca1be3051882f8839727c3c50faba5e86d817c319d5e711b4208f328f515340d033788ade172f5e6a47e70fe770b793c254b9fe6fa3d3001481829ee39f217ef7871f058e731b473ac599f6b7738ecf00759fc41ee498e998397605a27b2549d3d95a6c46a79456767f7b027b54e458b8de9c9f0f6d84bf1181385d86aa0b42efeaa1c5f0f56a93b5994642ec18148a558b82fb76ba490ea6a0fedefb074e54d7927f4687926b071508faea9d2f48eef2d3dd5ba10e563c90dcb59e5266be6f99d286f34c1a63375c22b9da82700effff5fb7461154ebd226dad8b15d391945725ba5c4cad075db5ca804c3482093e0c2c9105328423c66aee556c9f843fdf942bccc5ab629a86ef3c935a4dfd48280231dc7a893d3b0d5365ae24ded464d4ebb0726637164b7cf03ff04b180c37ba28956222b62bd7b8d8ffabb52e74eccbe716b7efbdd37f0730a020dd0fa0633597029aa8e4b44f01aad048fa8516176bdcfdf162e71103149696d4d064bf0b200795df55fa92026229f47a247169535d33fb37e10d45ae47010836854ea150dc89f96d9f75add98bbf403753618993602fb189059de163b38166918d3a008bf2d1d18a26e754e74c10c534aea6fbd3340e9426519eb0bc459125e501a0864bb41a7ea389280c326be6179ed7150fa0d5e42cdac61887db43fa720e4afc7ce0199e83a12c044ac767cb6132c0a46b8bc8884abaa110b42a14efd12d0e7b9cde36bc805e47bd51781420fe0bae3eadb5aa3bef01be8610ae04c3fc7c90c47104baf572bb4817f74225ddad49a0641a937e44a14b72e8d0f9ad78cb6db85b0d8082349ccf904bab09b6e031c7fe1c55b168cb5d8de8826519b93dc5cb8c7606bdc7c7ca7da343ebe809380690fce3a3907c95eedc4b571062205f13e0f75c773a663f4ea5d6d623add35916f85d2dba4028a132cfbaa3fdfd3323e714a8eefb5d4ab8a19d07ac14b21748c43bf1bdcbc8e01a53c18e0cb8b5a7eb7caa6d8df056101f2fdff779cc86ba7e7cd6edba2d4f15213603f21ac22cf4aa499828f628e7e56c2abb62edbf8ab2f3eca65acdf7d2cc44c2129c711f4b5f5a639aa8b68f9b404f941745688362854a844de23a647367969abcb94848165f530f011ab06b1015e8ca4fea53d4","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
