<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"48e5846addbbe6c3bc792740e4c4ade6a244273c88f37105e83f57b96981660d2df8c1065687a3aa8406f6d4fa4437e326b68f4e9647742102145c8b7d19103fb6ad9603b71d4e80ed4e9923ce34d5665ff05b095a1074cce69d88b244138fb049134c5dda28a95183510bb83d01880e3e297e433e00eb2c2e3b034e04f653d7f1902bdf93d863ef3e34c845874c0ea33fbb972f4b20d78bf5e3f86e82412c3cb3feaa195608c1b243a0d9931d19231e11c58a4c4cfee4ed1144706fe168fb18fb10f6c33b5f9ff5f7fe9ccd3cdd6fb9eb598cab730850a163668a969fb193954b6082b7b92c61a3b150338b72be5f26aba108c28c5d2a3650d2178611803bac2364fa4b24eff48a16c223ebfcd13885e37850dc57da293c591c50f55e6871137bb2152e3386d97d58bf20e884f89a41af5b792d6381e5fe5d5cbedf9b5431341dbb4afe30f037068d611de42a08fa30644a224e2349348c7316bb47e46166fb10d301ce976df04819d4d2668bcefb93ce062ef42eb8daf68564e98a55e4ae60c9eda4c61404abbae22966f88d1fad7f706b6fa23d377e639ddee30cea82712dce9492253a5e04d7e4624cc1d483616625ca2b7e78b4ca12d14ff45e4d07db9267f1ed75a79089d97991a06f03321ec566b7d68543a5e566bfe99227f321a8b56fb0a0ef0b8aeaaabc08292c3b73f63115b276df74058de87e451374038fe971bd00d9987c8aec60b538babf53b2e1460996fcfff91ab38b02a289fee2c088abc5ffaa292a916f010ae474e9e41cf662afb7b8a94a318074b9f7ab20517bcf24bc64a41896a02a2aab28d4db1e3bff7a707279a10f346d033e74bc0e6af766a0f15b7a1e70bfe1c58fefb38fcccd37296baced1bdde6a51f46661b97274be3cdaf632e451ead92bd82ea4616cb6f75b2e5a96c758fdc9ca5cfe04ede13040bf5b7ee594add99de57fda693e58ef9175da8f2c0b8fce01e29087c332a5e79d9a4aa321c8addf8f4e387a1ebe9775051aca41d25a8c66367599b4eeb8f7de37e51fcb4994353a61e79d73b62dc73206c6dd34ce76136c49978e464d247c9fc36f69e22242ce237c5d7abb24837eecf74120ae6e8957bd72d2894064de1e450df243be4cfe28adba6d84b5fb8bfba935cb5c17e2222971151e0863344862c09eea8297859ac9cb91fd007653fc61d5337a657b004de1248ca5dd5f4e0f0ae330d7ead4a5dbc14b6010221f922474594e6f23ed396d3ab79fe9899682e7fa78748151227d0b9da958d78617dbe456ceee424cc77702b7d3e03ca4f25bc28fbc790260e2d675ce7ae6108bb36a7d9ec3ab3a8c1c421beb6e8df1015fd4dd89b6dbe5206a22efbc0969897d0d17ee2647202dce6f6cd08532c2e2178a5eb100e1ccd867f2ddb32d733ab41774300f31bbc972d5b725875b1a92b2ecd307781e45538ccb7aa3732a7073105147b8c268b5ccbc22544a5b796f11c59a7cb33f212ffeaea0eaf3d302cc4e1a65af78713c5a9da7ee76505533d3ab7d75df2145c409a7abcca08852ac67b2a4b2d4d3f65dcd9e7e6c4287864cf53b71f8380aea95a1267563b97055bd707691c71b606a7512b6da6e5862170b6b922ce6422237f375eda471ec63572d2f41ec97a6c66efa4ae2ed4a0f8bec165bcd60bbc62044f67e0857246158238c6e137db9a211123c8ee44b05c457e002d41c81186757340327ccacc592d26dbc25930d4cf907568869663bb3f8f9064eb70692b8280260fb3278789b23626b3e83694aab6b83087d80625d139be8c88e4c4e323bb9ba4d054b3c2ca4dc58dd0f4857bd14f16f898828e0b075cec4b89e2e2c80d01a1281acbfeb49e5cabec0bd9329071ca60f3ad63e393636f7a9d0bb09169c17b85f7f5d6e8bf23ebdf75fe6ff67a118f70a7260439f0bc2757c293768ce359800d0225d8315dbf3d20e2222e569cd49ad762d528a055b84dfba3cac8341fd2d1f5949856d9787948fa13b518343f4defa185967a3013cff24273dc573a8178ae1ee10f23974a3dbcbed2bc03dd7a32280279372631d1a2abfd70d7e3272a4dbd968e3f64d53da2a96cd80f638845e7c0f5ec12b80dd9505433282bea2b77243f9fe3765338d0b2413e712e5809ae022f6316c5db5c8a8a33662d529ae4be8e5f92b02edfbe34699da4cec609bfbee14278d94d1311eb0d56c0cafcf04ef5ed8aa02f45ece185572ee14e74982c974956938c95362097eb340258e1b3f3ec555f12821470b540f81ba60b9f28be7986d5697d2941beb7151cbf8452ce0040af6384a33cf6ab09ab34d055000ee2bfbc58b636bf1d393907ce5314fce3a0d9749656f200c823e39ad9bfe7400246e1735fefae257a64b35e638345b098c0fdb5e56aeeb157dfe7c616ad79948301c9f7491b74a8a2f2a4b4613eb59ea888a729887eda47b4bf147409e9a1ccc11ac040fe6eaad9b8a721ee32a04ab19ddada808f6b4279b54674b5d384092f8189fd30a3d686036d75bf7bbfeb97a944a75beb2e3fb1dddfaaa9bff28a1713356cf3abd5dc3a1de7eba2c75204da606ee4f1e8fe84dad9fb48f8540efba1ff55c4202896e528a7e6199815e97b11693275cc7e0953270208040e54ade6b352ff2c3e9eaa937a19a4c4aecf584c547c4956a4e65f3b97bdc19e2675fa5d75b4d26b23ba55bd9d23580c25287f800d3d89aaf23142b8e28418a4662926357a0067f24ff537fd91c88b0b38a210cb3b76159811a33e71bb6ad88057e0f0b1cb3bc7ffff470ce660112bf244b64ca447b087b56864cc0786eefd588963364d426c24ae342c896274209ed8cb30d1784e8927812cfaa83dbe6e651fa1016d7ab1c127d211006d12f599df9900e20d8222cdc380ed1757c16b1cff15677dff593ec101ecdebc0159398d56994fbee02d0a27f31f949b996d45f76383881225fc3a1567ccdb08419cee67f784b6f2539d374357ea6a52152c4e140a817f38b5280825cf0737eaeca48c7607d264186883b8347782d17a5c1805b52324e34c430887d9b8280c877608a7c098cdf13d45fa615551efa1d261650d1cc4e4f2e8c7a128c5cec129b04815bb224b8d38052270dcf0e0b03669a1e3d54098b1d1c8fc629303cf6739187fa1e41be6da76e12f2fe49659788ec5310ea8d4ea0a88c5b4eca78c3e87b926a8d8ac2517252b097c9997867af637764af7def427b127b9d73a621a36b04e26e2bfa979c1f1020377110e41ba2f4b2b61c965a6dafdbd54024ebfbba643101ffdb646b7d895f62c41ce1533117429805d0bc714c716e04c90a05191533e838750375120766bfd3d9059f92b0dcb6b35aa6162e2c826b4126358b00416544c649767e46e69fa045be04bf5bc6cecf8ed55ff9c94e1417b5edfcf333a614029237bb467209b530b0e0a7847c59c46bcd7e6976af95164d96a4561913bec9fd16b7530fc7466c68dd472290a3ecf6489eb1711ec28125a12ad597a90326ed011dbb5a5abe874bf3f90ec7dd4d7cabe49661b72db55bae2de468c4deeed0b953ae6a3199d4be0d68ae4d94d74aad1e7dd8a17b304c616bda9fbba9b4ddd574ffde84be4f03a278cb8b9140d770574010123275ef7c884b70d6596f278afce69ffeea26654b66a2ebbb65174d32d18e32ac66253922107f1f1e0d1475d4044059329812ba3dbfdba6361e3b366cd04fff1dc1ccf8ffd7e231e26a62a11fce660f08b60a999f8f53b588dc7c577ffaf0c0131a5c4baad0716a03239d88ca2e4031cc85f2c9d2f8513580c85b080930750afabe6dd5b2b66bffc3be61349d7f009edbcf8241e8aeae1003acaba8833850b3ea683e4e8e2e1d0dbda103e78c949276f7d0e4f126f7967a90b590c1d4ec9ae6996db24bf6d689c6b6b63d06d13ecc80a45d9017c8bf2c803e2db6c5f5bbf8544b9acc699d257e2e03cf995c015999cc6844a937fc3cc321a08f7f9e57a5f64077db08d21c3247f0965531e26cc05e6d7052c46df01119ad1c3d944f5060e4034541d2403b46c0261b0c441cf387ee35db5f43eaeccf8930d7ab9907c5d9b59e7a73320b9cfddb5f149a89fa60efc2281203e06db887b108ced2cebca3a71a74b999f45520be615793f539face558c6db941155c4267b11a4679faf1c84ccc1608836c0e599ec7ff52f445ae6f7d84aba7ab108689781abb450efdb409a24e49ee9b01397e5e1dd88dd194800f7ef90ca96bde05dc9c9494aeac9a68b460ee85f39b60ce40dfab1a9f45b9bfbacace3c0d9b6d47633897adef3e16873b6901904c17335d254ce48936b83fcf6780969c39a2d61e912b6a03447f45cee3f8f3345d9d1cf6db5f75fbff2531707a3b8e4b4b9812ecb5bb1bfd2d63f652c6a899a6655722d8f04293be6b49a01576a1cca7064b4b3537f383a26c60aecf513379c96fe17e778af636098d3c248a21f51bc5d4cc331b963104bf7c893fbe0ad47d10843d6d7c9c20262136e337377d784e63745c80ec5dcbe8c9d7346161562eda0a39696def0cdb2ef1a19dbcdf7810b7e021b7ca85709b337a3d3e336bd2ef7fb6df3ea10bcd70df7cc218c1fb039b928cb5fb3573f35acf1f6e389dc2137199d0e9c8f0b9044183b17e8e40a1d7ad7b49436c84e70b286008a0c1c4475bea9697471b960d76b07467364f2eef78bf1223ae698bf54a5807532ff97f68b218554beb9947bad1c5222d0c9f3ce4d6a67abb473823b98901fafec0f73b4138c3b9b84c685f7d87c1b8fa526c0cbf9072d1b329bdc14d9d2c81f49d71e9e8137d678c14de3603f4bc9d96f02e3a10d11bba8178f8e772bb6173d767feb7c5043873e6265d434dcf384521df4d2538b012ab06c18aee36f1f696f9ea6a23230755a94734437648eb23d9c9badb0640bfdd82f41a26d65176a903cbb40db8f46f6c4dca5ed3867d71c691c13089b6e89dc90953a093fbf2c23cba3267ea337228ebc9589db9c565b006a6bfbd219292f37c6bfa22b4382c414efd5ca8f7c303014767837366334de0fa5ed2f2a901506ad3fe0aed8d8517ffadb9a50dd4ef56dca9c02f2c5e1f5b9a6eb8af9549e6dbc899526d705fbffa2a3a44a43da5b30b618f0ba8a1092b8d999efde61bd912237a48867b0431be40d9ea0c7ca730548ad47f2a6196dcd883f8eb90f448462e30e7f19ea779adeb3053af083a26a73add36e1a264e7dea6f41c5bcd8eb6aca9cbe23ced923a1a0b5177065f536902550163b38623527c86acff8c8bc008ae58dc923db71f295399bed2c2f221a6023090a7e8596a567e1e3721a16ed200529b89e573174bcd584aaf50532cf9f182388f347235686641b1b7b4ecbee26b4f1891bdfed45b7183ff2b0557592ab14668df7a8d20f73463a68b5f62600941230c3c5e75dca3791469939886115e2a3c63096cfe633eb7d09e618c9c225c793732eb18b965badbee3f0eb45102a0c39ce0acaeb9960a923f1b3bca490d71f6bff34e8d9bc8bb323304bba562884e27f6799f2691a18dd6666b6ae098edada3a76e5d5cada0e34f292e70631e1459639b0074577245881ec6b7b2e128bdacd72d4ed0e273954ef3676ee65e0957b067fbc2a77fb11e72eab4b09bef50450891773cb3e8658687f9fe71a191094675697b8b730cacd81a0cb9b81e41792f02a55675bc68c6845c9a088bd0b0a301f8bbb5cacedea3117670cbfc6f69a83672cb4a96cd237bcb3c40feaa77d615588e35e48617cad590cec06fb96d9be5a93312e098fa7f3162a579abaf35ea71b100875052935ce3b7474f92ff2b687b32c0158a481913a866c92c630c643372ad0fbcda467fee4d2357e1fed093f733685d9cf719ee70ec2468ed7581234e14aa02fe945071a211bf49cb4dd18f44592f6f03af02843a7dcdf10bf15091a3f9890416c4fdaa6870612f070431e460cf9dc7e42f2967cae04744f86a8ef13cce44c8dc5e6312496fbce56e6a31d7c2ae5e77e8cdfbe1ba57466a1011cd90779a15e84e5dfc065bb1c4c8a4b1adb24a73212cc72d94b3a99a625c125df613ca4d43393d6afcf0e6aae4fd8a86de7ad78df269643c0de038ad2409d3911bb8b2cb44c85dad3013352e5ae0394eff1fce12f03796b5b64f7fcae9c761bb0411e6015ef4dde5901ad6a6355fd5a6471820d5c2c6795b03b786b1a28a8f84a9d7956a90d296ad51855dbcce33ef31141fa208b7fd50a125e100f77747f5179aac48c6a9404b3f386f6506c7e4344577cc239d6894b80c5c2baa796f542c4b55365b745db75ad8d9beb9d5756644ad92c5d8128bfdf73eeadaaaa976060c0e027e33f0688228d416fc98be06323a92962a9a8386997debaf4a35e1aea2717b6e3442e1a89b64e4d6b386aefb65e8b84f0e800f557aaf508fefc25d1de508dffdf4aebb78783888b2504adea82208c60f5a9ecbcb2298ff0ce0494a7ddad14278ea63f1bc07fc83aff3d775d7efe21ad72bafed39a505c954a6d92ae03685a3d67c3a90957a5cf0764d6b17e023430e530d7c9819512fbce3519e39991c29a22f6a537c4ab11139036114b5b2f4eadcad962162d793d4b361ed858138b30adae68bf7ede12a6a29a36cf77ee735e124c729972fdc0ddee4e03e3b1aedf07e732bc76aa5ab330566896448629244c9b868beac9ac89c143c69f20641de0663addad9dab863b5da1168fd418a4ea317c8e83a6a93c23338b46ecdd8c1aa4314f3a0add214ab380ce3e391ca7e965e342be857dd831418c5c184874d83f0d74372c826bd197dc755f0179a23f9b114df7b3655fc088369cec097ebf484da540dc79e8c278f81e1c14a95fd5e1195780c563609a164e0a9a06c526d6b6310e4260ccccb60bf83ca950faaa30281645bd3ad6424e843dbd1c001a0f83f2928e1f4dbce722e95feaa4fd8e0b0b0a0309a588c089f1ec502358252e44960f02f1140d1005a1c57e595cf8ab83b9592bfa65df865d4f35e0491e8d954eb73592312b0f449bfd04fe8b9258fac82199736b6e00f4d7053458f451747d1cbede809e16f31410d03d83e2aad78a65dd7f475c3c1c77d43157760799aa2449ffc26b64074115a00e6f6b80d9d3b95ceae3b76b40431d9ae24ef7ef178cc3c8de2bb4a895b485e07da2e854d2102d67227d46dc49b7c35c97645d4d4610521df039dea10b379b473dadc31ff971eaeb0f2795d2995f9960a3b878ccad82975efd851dc99d39a4daa8063876af316330df627623b29a55a7166d254f8bcf41d84612ad584c04c9c9e93c97eabd01080a28ea9fd058d3ffcd300db85e9bf2304be7851fa42b6e8de3bed2c568832c7a24c3c60d90570a13494ef229db3bbf5fec7675c4cf1121271aa2a9ab461069367733e83b6449fa81608571bfa3b286d60bb9ef893621339dadbaeacd566c66b5aef9e302489e5826d0183154a145f9a931a1161e728e82c8a08861d833cc2b3619a518c0efa8bf4f05147db1c889e8650422ec9b26cc67897afb0b1d92174bf8c462c1257c23d9ef05b97afd2d4f514fafd31dd4c91ce31cb8eaccd327d84c94f06867323629d57c7447b27d11b9dc0a9652524d873e330901af9652c27684cbab101a4eb828f2e322bd07a55e14e9b0e2207e2c850e6296cecfb3a67ce0021604b4ff2057a4d4871d00738e9a0bddc51736cc5d5f275bf3583026fa6fe0c5676f852b4863c36195161519cbadb9bd58e18233c29a3c28ad213019229c07f9933a47278d86917a9ff7d975211aa84e6419e2439a2810dec3cf5895c7fcc58c74532bda6c7955997d98e50987f453002a965f73c07e9beb4e9bc059ead3ad110722982273e21f4eb5b6fe208bb5f3216aeb059ab31b8401d494f6da501e12b4207ed69f18e8e2b6a4801e90dbd23df2135a83971adacbd3a1a7ccfaee9fd0708e19f1052c82dd44c8d7ab0d73635ac2428d48587cc7228c4bab20c79e1da54e325bef8a837fc08f745412434e01e9f9cbf4efdb59aa7e9d51544e29c729c8e6765ad4d36feee5c55eca7861345ba0da3e34d8ca312b67446a51e94cf667d538e19ac2785231923a20f3f17dac5da64ef3e55500bcbc9461e6c4e2af2b2cc842b90984a8ca69c36f9da6582403bb5812e52e3e3ed6270e66c9ecf484c0c367757cf92bf2066085bbbc2e7679e1135aea7a2947247fa46bdfdbddd0ad05f89e616be8e4006a297891d14e7352866e4b6950955de7d565245f868fa8847d2993e2969c2d0686491e3db827ccf53821c72eda675c793ceb3ee7dd2c74fcbdc6288bacc85fe900c7f1596ddf36a924647389c856eb47d57c3ec194c97311507640b7f12454c57c91aaf5f21eb39b6c57682b1071df906e3ecf27d3394241e152e34414544b23855c7495215fdaa251adde794a7b99b1d69f2c3710fa496d0c6786e20635eb1c7fe1d64dcce6c119dcdca01082bd82720f28374c5928cf4570346ef74e3c7f72c0ed0f49e68d64e742eaa04299fc8116f27ee973c62f26ed5e5c4107302916f5fbdd80757946cf811fa8bceea205fe39f5dc19de3a32ce74a57769a13002b4f24af4d054da300f6cc2b2f18e3b048318d56fc70c64b1919abd132344f84f8798b0de923b07ce27423a923921fec8a946468d7834e5934099cc07036df1bae3ea6b857502d9fc973a5bf6646e68b15a1ac35a3cf8de5401a0f522859b4ffa050c931f3c8bee04b22644d665a5fa1ac743e2917ef0c85af8395ca36486816341b322c9567f4d675017e739432996ef29808a119adfaf01c32807ef08b66a2a19c4143788ba6fdb0b68502c707ea20a3902ac7b41981fd6a18a04f4c1e5383b0deb9c3cba20d0e47b5305d4d47ee6beb8f783e644113f24acb780a06101daeb2caa2fe20b9ea9257961a24e19f1ac3f1df3baef080f92f75805a94b5eecc9a0cafcf5287d10ac495ab8aa73f26b7ec9529a7fd8e0e7c3cb280320cfc79bc94821c3cbb16d9f77d9ba529859cebbeff747cc760fc9221c0746689d29e9867e6ab15e6efaaff80ab148a3122713682a40af151a979c2a7b309863ecbd5d0b8d2e8dc1141fd90241327317e62c10318b7686fefcd90197bb3be8bbbef43d82a79b658af0000fc2a7401b76fb92c36d27229dc07d472e76a7c554937c34de758e990b78b4a3c7d6dcefa37084ac6dad98b2572b8800691925edc7d3ce0cb80a10800da01c5c486cfdefce8d2e859cdd0c0da0ade8022d03079100cd118758180238b42151cc9f05def57e422c13d59ecf7afb29b8d06437e42f03f46c708722fffcb701ca5e1baaecdc3fdf3a3f7078c3aab4bf76a157983d186ba9210c103c58eed834dbfec7c4e9534978a71bd410f00953c055be34453b703b70b539155bf3aef65624f3577a8794626f07266ddcdffd8ce0e1fdfbfda8c53f4e9c882c94162e617d580b6d0eba54f814f433129ceae76b7a9239cb59350594a3b7cc5c9986aedc9b890260105b020cc80be2c181338401a6c6811eeee839cd337ebc0cb9a2eb3e9ad7d93549f247b52e893941c9f213f9ca79f344cc8cacf1352cf967019bab963a4965177beff34920bc78fde64ad81c5618850579d3f98e8060ced95b0c05da17c752a401482a6149b85bc6007361bd2e219f2bd7426ad44349cfb13773bde9e8355f44926a64202d8ba03805226cad6afc0e352ceeade3a27e3a468207eddfafbbca5c1b8763caf4d203bbef236caac63ca2d6234083cd0effeb38880a17fbb0ed29b13c4a223e1b65c23913608e6646c33688b6e8eaca0f577f5cb6c83a20d23eebe38a2d54151352829ee5aa4eef8303bd22faa4edfbbef1811a824d42faa4dfcc59ed0f987ab671089e7aa2831cf058d236b09b4273c16c2c891601ae1c452ff8cd8eafc0fb7a40c6f666378de4623c0c41654bebf9994859a6a3f9d7297a2d043a54629fce0cbd6fde54383d1ddb4b8077f6fa0677e11ec56e714f8170a3164a318c38947fb1f0d843595b769f99d31043f385225c61d7d937b11d8a7de163530cf7d25cc2f55ea531e8618efdc0a0ab372539a9dc23cebf0cf9dcbe3a354e7a77670ddcf6853d0d021a31464c5a0ffa7a0f673ec7b931cbd6d805f33d220a60dc48084dfcf9aa7e6efc7602b59bd3df8ef3f710bc8bffa8930e4b3dedaf3d89663a38f4c547cdf9b52e48598b71a0bfdd66a76988a0f66eba76700b1759c6659a5e1f87b1b48a4fa382b9b67becd323629fbff9caae3e9bea1b075e6d10b7f5f10c2e4f7da0f61f6ed3e310e40dda5fdff0dd0bd0b8ae20045ecfbd6c5e1153177cf681bbe656c0efeb3a3e34371040282f9d86a93d58cf0db259d87624e00e3381d11a018b36bfe9e9607462cdba078254c446e4b2c2fdf991df7629894175f8c7b6be0652644cf962eed5432c022805ae689511639d70c37434a2f7452855ce8ee1e58ea8c321ec1fbbf0c77eda5170c65220ba36035eb13744e86acbd5bb90a82166d4240d09d1257297d0c9c4f7e0cdaf5eebab6ac940cb4c602dab44e86e9ac380c9339d37220d0663dadda85e55291306a308fa7094a05ae0e1f38fc2d81fcb62f1e9aa312f2c72e30cd703c81f95304527278f6064c800232dd962701238e282c3bea5ec453ec1cc05139d324555c048457a7747aa3581c3e65bc7f216f5c892bddf74fd84daef0e6fe8799677636e96698899c7d6f3ff6741171824fbdde794676e3a700661d50c0826612b4aa12a07c2bb514473b7ea57abad85bad5764f07d722bcaec968dcb96ad1ee131a5c8ae6642b54fe7e1228e39236a8303fd7d8fa935ff7be305001039e732b70cf767b33ba3362886bad59d83c5d341895150659431e013088f292d73a0f449f5ce35ad25d66a5b16ac6c307aa7964c06d09503d90c1a7b5c8b0fbc980882c46a1fc9f224fcff049008a9ef2b153392a9ea564532067bbdc46510bb6dd3376750eed54d53d9cc82a99c1c443e9cd7b6050127a73109f9003454bc49fd5bb3055247c53848db2b940ce4f626d8da6add84316ceff0515fe2805663574c38e71861624cc9a0790cc75c9a8c340b27e90725cc5d2d663861c25aadf07a48a6d894ad5e50dbfa5cc001aa1cc14b0241857ec2e6802ca3f9ed5b2476cbd3497842b158770ca11daf899ed1150cf9bb8c93d23726eb9244341c78e3c37976f79274879858501f2f322fc395873411f702fe36f8b3147e0ffd84434121a575eb6b92befc5a1724e7b8ffd47dd89f035ee83c8d633525cf5df957f208a87a9375b18ee5e2019285cfa8c183aa5f972bcfb26b93f643408aa8f4ed4a45396b6f8cb6a240152761a10b3194722cb00a80dce72fb3523dffabd41696b77b022fa295426aff15bfeeb85543ea1769aa7f603f39c74cc45d9cccaf72fefe04d826917166eca2421497cdf8ebab8ced3aa91536770fe7f7f5d2a4020167aa52dec6613882854c4e8afaa72622a7155d5c238d17cdb7254f09b7fd56f1ea962f4e9de72285e503ba21e87f50ba8ea08245ef25012b2726d0dc5aedc2b435164bab3c947aafcfb135246e6d555992d5079d003178d637130d3445f329484d00a7518a6912b8681180fcfd2a0f871da48176eff2f858f5889fe1a45a0a4bfca18411d4cdd3fdaaf7409a60ba3feaef7a621332dae588606c1a120a32a50f8ff7d6ee0cd31aacab49c1a1a12cd8ff055585c7fc2ed126788cb30f48f84167496c2563fb504c98e46e60cdcb7c00434cbbd79b3eb3b46866be6d8c5c1188f0d22eec5a19e5d2cbdb838b329167b082a774759cdd94c18a06c6b5b326cec2dbf099c344178b539e1639a765b6f1d724e10d6aa1dbb815f9dbb81ce6d02ca4fa2878a4406081be21f2a0e9eefe5a7e78845bf0b3aea38e432a00da62a0635878ee3b11241108e3f610b14a9def642fd3854fd480926ba80001bb8a31d5a48574d9b220ba188d31097324361ea5ac9c7fc9aa9ea061c16acd4bf421eb7c28895b67395c3e697bb634a0bf777a43018fcb2104c48660241c97c757f8896e695e5cbdc352007a7058866d5efd260a5ea4587fef25b89ff8cc1076ee4d2055999684449ab3c3848c6bd7baf0b6af735fdc9d49ec3946e7a5800e870a92eb26f3150b4dadfb8a106b0beeab2c3d6512fa158ad520a0d7f3d1cb7ed6f9320a5f73fbb2b312abfd12d7e9447143aff0d5f1043b37df32de8490fa39f509c867db8cef52ad974454bd932a60bde0d1e000ff26fea095b75e16980e2fd38a0a235a678a9750fcc77e9a4f7648707ebe143296a1a5bba346389d28f66262777cf3bf4a0ed0c80f6ec21e51a3a994606eee31670bb2acdcb1c44aa398f4202dfccb445cb25e71f1fe1aacdfdd64cbcb20a9a1d62143f170a37447d7ba322274603619a24c039c2e7072df1ad932b0c97c48c9c92bd121117a022247626f0ad804bfbe98946b9b94aa21f43cbdf77b519aa492629bba2b539141f8a2cfc798bee450bd0a563c6980b749fac335934fca56d7ec0a8cf6270edd9134386129df628f2ae348066921a59b6fef251332195386115582af9d2566ec6557cdbd16ce44f1db4fe516b9fa664087223bc1f1efaae8496d01b758ba87289576925b7d4ca36145b76f6f5d01b2c22191c6b0d4ffdad0734622d1b92e76b05c9cc62863509627dc3dba58bef3d791bd3f391e881ce08da3434baa31bdc8e106869041bd69036580928223440493b3aa7314d224a1f9f16f457418e97ad3541d15ef5a8b122916195b484ce3fdaac546038e80cfe4390ba9aa621acebdfe416bb2a4fd0b8dc7c30fa67e53ff71dd5d2f0fed80e597cf8a0b765c594208b5aee02026e2687c6bb831a7378f776160faf88e82f46bbe0ce4a2d8d5e74360b7249b0d89592d58b887e56610e321f99e977e1275e6fedefdea45923ac8e4daefb6e2f5e51c2a709f1eecec74ebffc9d0fedf2f9f8a46b51717be8e3a194112bcae0306869606099b9dda5784a9f9fde1e9d64b7c86877f208c410c32ff6ed125c670b57e3d8b771015d95d2a22113b7b70e02b6a47ba0d0649e4e2ce2931ad81d5a7f49a5784197928e7215bc3912794c8b4d6369ffbe2e21dd1773fcce07dc4407469ed3bdfb59e950f9ea8afe10cfa38ce917f516b42474e819d865c47b6484381cdf1f377b1c80a4c1b103a2fd6e4997004081a1c378216e840f46e33213a7d9fa73d54d441049822601297938664dee86fbc2856f7f3acb04519bc16d9077d4b65fc43d009ebed8ef1f6008c740fb609fab1761322aa5e01f65d5924302f29b55fc74df87b76776a5c0f95398df6d8e406c4e33efd852bffcfc386c4dbbfdcb0d3a8cb38c22c21997d8c43df9bc87237bbd039a4e03aa9b302854538f81f3e15c0bc352a9e6b1bc39cd4b35ffe7e10f7f02f4bf818f64e90ddad370ff3373255634c85432b8e45ed6f039440e88a5e7d5b290a3372f4dd6d892e1e76d46436168362c0dde6f650d4906ee54b204e51fd64ac99f6689b2ec4a58604697e67fd10ff3d3a97c6b3a7aade3d81fa7db1eb3ddaa351c5c87d7fe430ff1e54069c3b27147119d22c71599076f0209df681c914087c316d9442402426f0f15357d906d0ff7c4c8ac220dd11467da129f75e1e4a69d65ec4cb9e1afd81bbc4557c5f7bbdd67d0274d98fa1009c85047d5bce25a60904de37ce1867cba2793816758da707998f7d80639ffbfd4ab687d53bbcbd47e94ceb7c8c44e5f4482bab2f2486bf29608e6568dd05bc879b5b6e0cda99b12e6a7ce13da7d71091d591f054843e7b6d258939f818806b3909409fd66797871cb36c1c2f9e08c36c64e520d573f37d36f7df37540486b8d9bf202522959acf45d0c81fc14db40d6bdc90f222d0b4f505e62e51a293bfe13950d5c742b80ccd16faa3d237cf72085e5313202fa31ce5e8876bd6aba950474d7524dc769f33e6f8fcf88bb1851f0452b919ad58b22b472cde40d65bf72a9f8f50e082beb70aa51ee222b328ea3a7a683eb6805fb99983dc0336282eef356bd8f7fdc1044b14463e1939eb9484c9ae9bf5d55efab92b315e90d14dd62a37fdb43aefa433357a933d5764fdd39151a2539ffa2331c0466297a1062f8e3aa9babdcfef1f5f51894b669305c97da694bc0a0136195f2dc26ef095146bd8f25eeb754ff6a02c8cf4dde4a8a911d1656a433abe7eaf8d9b44c7efc321adf0e77fe101147167ed9b071a2ed2f3799aaef763d12126e2f607caa352a62e11d17d969f0d21a23d3a0e7f72b5982feaf845cce7ec08334d48b2e27c03a2e06da823805b59374ddf6952b883a4e20c72b9188e17a50da5c06c8c1989e432057701fdc0cdb363839cf2c15ad655aacbe46272b05043047fde111fd1c3328b07dfef691789f282a4a9d81d6742bde5565c3537347e4254f9fad9fa6d2697a7719d30aabe43abd8ced38760f8474665f64012076571656c1af7fa9f944735e27d98e1bc8d8f156e9ec44370f737243","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
