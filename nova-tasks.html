<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"55be1cf944551988d179b6380bc5eb76aaf91343939b86da645f0b8f310a18ff43d9b89930747e43cb731cad0954f845c7ff2a1bda8e9d12a6c73f5d0c8400c3df87111cac831d5e5a85342e6b7af55e8f20ac7ce4350bcc9842f422fc2aaf52c5bcb0e5ede50cf839c9c670e431e2dac915ffb1dc5edfecd36f60e85eb0ca8d50166eebdd679b5140e0f5ce0ee03942c2c883fc995c6214dd7437860dd0a2c93173bed1316dfffbe9bc7ccaa6e3689999894c93242c07a5048c7da84eb7ae54f8a5475a8f58fcc0aca806ea206fc3d54dfe6a4ff784f7664246b4638b05d9716dd6e4e2abf5d4ea1108fc2579a76af307dae5cf0c60fc1e524d28e6c1beca7ad3d1a5a06616afb1cf6472dbc416f71b3f5d251c58f7132e83f9e57b362a1fd80c9d90adefbb0fed97a54b680cedf2656a21daf710352644a8b1581e39d4effc7483e9f4cf9b6ae3ab3494bab06e0fcc46866d25bebf135f65396bf59c823470b07bfe37b4861a885fac985e38ef79301b88208bd2a513cb0d91350601cd558305c627f6d74cbd0be0ce4f615f69536b1fb45a6e60a4326c2663b026b93ea0b422f8ce6e6b1615297c9615e7dd421ae5349abd0dd899dcbb8bf2bc879c51667e5e2d553da1aa0c476d82130c9685e4672e969c0ada9a65b9aaaaf706fb1c2bcbe570b4d36b9ddb5662e7cf54be220a539ca76f8ad8bc91d4b0b2b41ba7c4ea50df9eba03e476c19f872036d89d51af9418e192fea91fd42d56e31c74eff1aca6865537eb36f0eba33eb7a81c72a3d4a06ca358a08a693deb6babd949683b8769b698905c6424984a1e50b20491c3430e06dcaab04ba6dd51b12b238f57caebf9cbc67241e0ca02c337ca9631debd54637efbd8e865b65a42e5fbf6f39d8df3366f8d21f024f5ae463bb2ed2e209e351ae8ffb7c671487d54b5d1a61ae01b4178ee134300723cc9de6574046eb26eeabe9b05fa0b0f5de11083fc3cccf7de19afadb4115b5ae4bce22ab1d964d6f20416c41d0b5407161145d603f4f429ead413092de99b4f69a17730d00344bc3b72429a2f19be3203a651f92c1aa49add1add58bc3d308484597b3301c91e3db3ada4cf1f18f0f791ccb5cd8dfc49fee08d4624484b5ee2ddd68c823ee6fde9137cdb8e27eeec061f9c1397b90500cf5668de33e3e74a44f809ab7e2f877f72bdbfa67206e2f085363df004aeb0585d78f6c8ca885ba0164e53f628db02512b01f4c81125d4ee0d3e4e6911da7f5cd115b1764087429bb76372ba6b9bbd5264c71298c9cf748783f301d297f17f10ad762f463c31367c362c7811b6b733f9690ae441f998ef19923836d3314fd4ecbb1acbc685061c086153e628e5b0376c413cef85465399eedbb8ec14d609839e7b2cc4d7b644f023846c678d2a65b94c89771350687496143ecfc85af9f848a130b061f06550e1cee76feeee153bd81eb2eefbd938945e62a205d681ad7b0448d04dc87b4d0d4b9b6a2db6c2786af3405b7179794e333296b5e123f8ca2e3d6ff2c7e551aa5fc52add5116ce76bf07fbf04a0d6b43bb66d63216ce96efbb593a4d88f4e2021c3b2085ad0955de686fb6338643b91ffc52de072e0f9ad6fcbe2d5a7e0ad281ce2032a9f650a72e3811a4bc0b0647a1ea8af4048255bd3543b0d18714898613cc08996b530072192af3da428a71395b0cfd08e08edccd95c4fad53f5c9b6f6562cabf105633208772ca28a542463944de0a731f4b0d22fb9b401405a1c1f2c84c5631c19bfc80470718b37579d178018c01c7c6a0633b5787649cba515cae61410397a6481a467a65b09ad496a41d1c8c473ba1ff3770755aa106cd3c1e322fe6000cc749184032b8331fcb04358bf4a24c32fbc50281162f1bde3220b43bda00c3b9e8f706a2ba1fa9aec4b1b7cc3a5d1e8f0f608ce2a46e2c626ac843838f997a15359b93736b36603aa20a520e41ead7cb710099db501c6f6de62b055520151af06677f9273d0e68ced2c5df5555f3967fde61d0a1fc496b7bba1537bb7bed3115d1b81455e9ff4e02ee57cb70118960abcb48ddece94b2b9edd8b8762f79805379bd1ef88cb95ea394a3b73e0f90c4831ade7b4e2f86fe5b38c7041a86f61ac6af8bfd94f02db63c98e017260a58bf3f480f4d95ea52ebea8512e99eab25d4e3118fcd3e05f85614449365b7630541f5a3c7f828fb399d6e9c8b8b87e7add6cb2e7fbb43369d7cb6c61dd96c9b43ec0dc22c2e92959349c643a9334f84212d4f973c7c46e0bb654b6e6007a91d5b8a0ff372cf253c77af7937da99aa627333f618a59ae78442f6d19baaa1fb535b18bcdea0ab3435c1f0782b79b2d12c8cb97acc3aab8c46f7ab51f7c80b634ebf5941f4a40de48cf8fb0f603f5af4462889d154760183932db8bf57440d1e00c09ced3bc365f97c0ba3daeb1b2460d1fe15f9730e636ba47662849277fde74e91eba258c241a13e33caf36545b8fd9bdbb55d1b7148ba20c185744db7b6644ab4b43dae71ceab17c5cfe6c362304cdc1bd2f3381574facfcb9a5808ecf24eceb46405948e3eccf99632142771e531b5a9207991122f94d25d4e898c76992dc6a63d8aa5f4d2e3b6e3530c913750eed4ad58135c9d927038fdfb13211378eea5762c3d3797046c09cda6e38bd2653f01e41e37842241c766932308029aa5cb62dbc3c5c96f4e0712d076148098f8adfd4e6af29cfb42fb44884dbba73f2b7227fe5b00a7c8c6d9581e96bb32a890f0696c0b1f112863208378d05f078d5b5cb83c4b79dc52f0a697b39545f1932f2c41f472e5b5af5606a0b40c89431743391c9505df744110b2f8d89c22ea928fdce20430ca7806854c8edb597f867836c1690fdef1241e730e0e4def7885d38b3914774fbea7ef3173d1c485f0c0425aa0867afed40ea380dd73a3ae0cf04765bbabb374b0f58933c1447c5ff7ccc9cf891a2e9339a99688abc8eaf5686f2787ea9b5c54867d1b1ff1a16092a546821d72e0ac37d8f251911ef53ee59e090259a9c6e19a012a9fa596da376cac62890db4b8b80d702446b6d91c8d2c0f4983ab8a262373a4fe12e1058bc3d5817d556754459d9375e4e4b2f40f34c34d149ee63d0c6517e5b9c059f6e2d481bdeafc58ce6df8f5ad73468ec71c6bf8380968ce3326ef7137078653fc2ba535398b5c6086a52a8f28cbc68a23e7f49054ba6c5010eaae65ae47e88fb9d97221ab2c56fd1c219d693104f5adfb4f4551358bda102b6415db73e392c83eca5c603adf70f2c407ae4905dd3de7846a0b2f231508ba9882d96d18dae481e298a776238f3434c0f32e50d3244b4b418ada4847507dd0466ef1614b6ea32efee1c14e3b5de805f952e231fdac9623611f3283d1c5aa4b6ddd7cd2a8b5fde0430403742f01279ef0527926bfa8e7aecc080f1b11f977787141e65f26306bee4b43e93c958fb943fb553e205f5050f6cb7aa5e44f8faa649377d2bdbbf97a49d8130cda634033b6ce3fcfceb20c6b7a9562e5bef39c359e40cc8d13114dbdf6b0d8f3ebdcdc51c8d902b6a3d2d891b3f2593faddcc061bc019ec6bb525eab36cf87308e7c2ca9925df40bef6aacce4b4f14f72b8c2a7bcd34b347f5546540f4c8f9c0f3e5841a6c23615d101e70c73fa57dcc496a40dfd35cb837f182fed7b5d53ed51118d7f1774d85ce17d788bbf4084724f61e2383d732b2cddb9f228812ecee6b7d55730ce605c6b008227502af87d57d7e63a451bef451a3220bf1b87c0f41fb01913a9d07fb0e7dbb781cc541e7a86c58152dcaba0e69817b365b0cc051a2ae0993429319f6fa82774e59d8c5a164cc6397aef9a49b00b98f641c9e99eeaa7edc9c150ac002ec61b2a2d41df69ba0fd209a1d1dfe2b7880846cc9fe57abe65b48e3cb611487c1c6b35ca8a136cfacd59637869f6f4d43b35debf8bad318a574febe874c83915f04d6e4ec29c6ce1726a14fdc2b40c0d14a9112a39b2f56fcb3debe60edce1ce1d22f9ffaa79e33ecb721124eb6fb6a795cfbf35e1658e302db1d6d5b43de1e670294704009dabab677b6348055cfbdd02ca9f436d762cf0c36bd0125d09a3aa1dd1a880db84341bd18179575f129fd736962f7226b8a83d595953fbb9b569c9038d018cc52e22588376a85e84ee41a4742d0040e7ed007c51566eb3872a1d84a95d990ad8a97d92592360acb8fedf93d37fd8425e3308f76652e0fe7a95b85db6ffcbba85f8d0bd2d0a843e814ceb061167d3ed92622ec7db2df92caa14ea59dcead50a64b2bc9ccc24e97126d3e74e4d3c771e9830bb133d439148b1d6662f9b05778af15cc6a120bb4432e5091f8326f3557485a12f97db4e7fe13a659157237963f7ff371dbf036c76790e118d6f95e26a4d3c58b9def1efdaf46954c18fd200b5c00b162ac912edcb9e9dabbdd9929a494bb6d90e264d1644f29936b0bf2fbb7f486662a4e81d30913ed6f5e6405a3022ad71e5aa59a75a5334e8c93a6c3c00e3b0fbc1dbcaa682ba8e250ac4faf31b15aa05eeb77c8a2e7d105119c0c11da36587ad79bc5235640ba3f8d63000cb4ae1930cb6c217725eaef6414fadd219a80d229badfe5f25316c7f5abacc1020b18796b1d66602d29b17ab30ae32be30fd2f5719a090e874553669f22130dcfb1fbc32ad43cae3fb8dbf571433748a4e3a266492fbc0a7e086cd8f2a6dc63a0afe37cbdccdc6ddbcb11c82bc83e758ec24892ffa7b1872b052bb9b765918d32722e2088907323d8857eadbf56174857b4a6d58f507331aef52f92b5b73bf63f5cd3f1499896f755d4b8093b722ef4ed4e12bfe8ee08558f9fcd9cf7f493cfa3db308014e66f8149b1d76a19ba5060e73e9d6b3089967d1e45f92f2db1309355768bcee11c59e56bc34b464b3fde3f9ef79a99ede6f55dec4d44cbe362afa601305e16009934d358d8b6fb6ac1b7fbaaa8948176b606536d5f6f22ab711979f316bc087a2226425fb99bb373025d07b74e0618f4f0c2df4d36e452ca7d617aa0777c13648008e641880accef623cef0049012e4084cc9094ea486ab9686c894b0184f291ac692055cfb29f3107176df241faa4e035250463d491731b8671b009a82e4a9e6eb0b60c3dc7050e659121418c5446ff095d440b91e02a062edf710dba749fc5c09ec8122a5fb69a9e187b5bf9d766e6612fddfbfe51e8a66778a5a24fbb9f1257412c01b51fc184eb6a3cd90fb526a261ebc244b46f280913ecedd0155ee9c607387d274e542a0d8eabf734840607ba259fd3ce0a298acdf2e2b200e7ca36774a756abca1ea9e91e576965cf4035e1835569601d3e32e7cdc92745223770acd23f709a91ec196c0ef1f118f97d7038fd7f1e48a8e3ac133009f9e936df4c769a303c8b2f07836c5ec6dee4082c88c4936335d24dc908eda801dd7e6fdeec1cef938ec89b68f759745f0727095883f17c65219e2b96ce3ed193c7797160c559880ab043a8b768595153d8d910ab33c781e25210f3e2112cbf5e67f1be938d55ea907885dd465c9c2dc178c92e12700f52f7043db2e931d380afa28167c7e6d6ee46dddce43436ae091a906800ab25760fd054cdb3feb50e8fb6e37e7ed7a3bf761fda5f86de1ecf0a38fdcbab07d11ee9dbea78a5292e94dc17fb941a9fb8155302e3bef077c028c1c4a2873d4f3131df367353dab8c457593607259f3de66d728576c9fc3c8181b694d5a02d5ad42aa4f082bbc49f42cc5963d720f9c15abfc42c00d48f4aad8c483f998a3aa77980352637e3f50aae3504c708a3d43776f72530014689aa8578d9f9c70927ff4684898721f2ec63fa5860ecc4842791bb9084cc29653f9075449c1306586d08180f7cfbe4cfa7c287c4b94784e74be5348ad9d8708ff0ae0293ba6296181d7b4291035df0b17cc8e434ca2585e83c562a85a7bde9237883d7ac50d9da33655f4f7702d66c3ca4cdb386e715167145a68ddd514b53eebf60c34537fb19489649559b04938c0938bccac2f08095297380580ea363e7277378bac49c3fab91144a433b4d4f4fa61e3fcc6916bd7d8e6ef0abbc20928e7d7d0fe6a973539a8b5d4b83d532d11ed73f8b02b756cfc8cd81a6ff5f21f557f1861b05e396c837be2d7633cf4786e52bf7525af9d5954bcab7dd6122b1b7f4d761cca0f2d60aac2d655a536c100218d153bf7892546e32f2d3c05e3e998bc3921c14f4a18b9a48c174642ace1290e6c3320654a44abb81cfb03e60a89f3ca7a7617858c69477a7e18597669a1b982c9209902e6fcd14d6720470866f99a43b2b99de2abab255f5324a07b6379e02aedc9c3669b2ff475558e1f73569f7d05cbac5177e9fbf5b617a2d54e1eb80e48a4259385a47ba76bb3ae75a6ab7ba6daab09714df47e1c31cf9bcb6368ad8a49c34d2ecc35ff3c5631408b781bb5d07c5680c9e0b8a21a4ae6631e304eae11f2e7ddfe40d27c6d624d23f61ef638b5684a630bc1afae31661f23efeba90a018db1b5d1a222fa2e0e146394ad47820367845b9b25b3aa3147696e395754afc6601c8d706a6322e9286393584d88d5f08f25dab5e6eeb2ffe255b17b54e509459bb5fee61136b6d98993f704ed87dc90eb1fc59c7d6e372791c351ad3c0468dd362e02cbafe5944016656d715a33cdd99750b468daec22e0f09f7d5e985a811bca1c58a9bb7bc32eabfa0962ea46436f0ca77419348c46a5a2034c9593fbf0898fc8af35d64836b747b66619d0d7da72d2a9e9b0cde57cc56f3db4040a469f777cbde7469379c2e71c29ad2d43f83544d9403d718441d2de6e2642e65a02f09c271ccd4d2112a1e1c05a48d532ea706e0901afa8a1a2f55d271acd173438194f711103cb261621355765a92799e77b170277ecbb9e97f82e34e28194ab2da54c505c7daf486f84dd3609741f6fa3d8b51ec51b191d81f9527f14272adf1464a561d7ffe25caa0e085fb7818bcf6e5fad8fc373cb8527aac32f0994b84b27ccbe19b22076ba586a282d1e4c8e132124d332453784e0affe7670bcfd9d86865f7e96ffda4f6fb7e6e268123faa460bac071ffad28ab6b2f748e98716b2b4d6570641cf56ec40d84ec4d760b8da503f7f821fb03798324efaf9c726d28fcf953c0b4c5970de5ac1ee4a7b2ea79ad3581b7edc09de28a681f3a6db1909efce3dee9162bc0b4a054182633ac91c48768feb81b2ce2e7d3f71806eaa6080a38338b2e5d6c3159adf5c6e3c9a56584cee964a60cac0f9ad49790ca220229974a6e5405e3150dfc645a5405d9cec006c0092ad83ac31a8a3a915d8523ef91248998ad043261f3aff98a20cf2520db7091f2bcb50ce9dcbc3e8668173f60e1de4f12288fcbe2ed6cf8be308339f198796a9ba7c83ddd7e105f7938b8f3c1eb9cd105df5fbc0d75e487e6e08822b646ac37c00ba170e706fe359b16c63bc3c9f64130958240df1f0b010902ce26c0bd11ff99ed0fe00c64f6542e6c009c1ff340b00fcde7d5aa73123e9dc4e26d9ec8860099e52fdd2dbbde61fe177a0c8eb0e670945a8b7a14e30647bf8d6166d7dfd925131f7c02b53184267730d53f1152f96e9b9b3922ec16e10878282bc5f68906d272e351463cb7a16c7560b02f344d21eedf66affc3b19af53afa8a8b1a752ab3f76f893eaa848c394cbde82e6264bcf0b98eebd8f7bfe4ef125e74bed243e8abf9fa1a965ca193cd02489fab05ed524b6c883f81d6b49c4462f5893896b86879e5de198d336558739b9cea01f7b069ba9a2b079b848bea31b3c23865a2bcc67b79172c25778e9fa9822f2c4806fc8039effd3c4cbddde7b69f28d4a10840e4c7e683935b92e57ad34f7d7304c85ab7c351e85f8c038e53e360a4d3cf6bac131ccb17efb36ff57464abab7a669293b575195f5c3bef27a1dbd161fbfad2246d40934d0622e352d34c2c643b06558d03b561ddddcf0cad4911fac3e556d55b21f3067d1b1d3800683b7fe4db7b2eab002fedabcf1d1284ca774534fc4d7ca93c0e0e9cc4b097bf3ce54f288a076dc4d62137a6853d3dd5d48063931ddcbcf10cad04fab0f934fbf3de527e38dbcf200daebd405bf59d5ff0d390102bae0b230286372763800a1f2b6d82d8f3493bf371b6141140ced5a915cda548ea49944963b1d0a39abb22ae33520fd2d6f2700f865258e5677f220eaa860145caf162c8d6616d85b473e6ea92d877034981cddd3e4d78b7fb99c590d396bbe362bd41d79006e91c4c2d62b585b8a0da057fd3ee35c0946e5bcb43c6a7f73f021fa1dd478e6515eb06157f75c5aaa7b6192e40457e1dec5258b60aa2e092489142d80af4342c8b1ffe930b161f80784b5e249317f62c32be819729f9847f27ec98e6a49c09e9c31c23fb32a65e544a6e3139b41501d21ed1ffe9d80c395ca8146a17ddb999d4a2500443115ffd9283f47bcb1732db7840ab936a148c778c57fb62732a40c6a427bc171976722d1b1d1241b9e51c39e635d464dac575e06b56914a17ada52896220e895aced6e64cacd4458ca0b63088d6faee91c733147bdd8244ef7a26b204dba3c849fc379c2c2a2a1209f327c6187c21fd9e6318381f3110940e96b89654277c51fc374b6bf41035576e2f130d7d3d7de0953ee0dae36d8022b9cb701ca4107006e26e7ba76763739b5d3cfa0a8c965dc8e5dc9fd50231f80b8068a7b0a42943d9a20b996d1527b3477c9aff3e7acb96f396ade71ff78c6432de088515e8c9693cc23077fcc0400f3ed1789977a8f7cca0bdc37f6801b8abb55d3c2663afd84e8dc02d72c4777a104f4d533730555ffa5c26555143a3a91edddb50af1e3552fefb83bfa9a500b39ddc819bdad1106dc228f6c81995fd18d58d9ef992497e4f0f63b4695564f54febc8b2e5175716ab75b6623c3cd1276faab4cd8d5ea65d5c045b8775709dd80c553f1611ddff583b7b89c5a1cbe941c9ad7e5be3b80f880e2f4fa11e7e70bb8c19d26c653f5c45f7658a5d859f4ec572fc4064a26af7a10d6c91fa613c4626367e9da6e750e500bba683384dda241260a0ba3e4f198b77c2ab4b400454ecb0fdded6b41308557961259789161a13ed8958bcb5ea3d06111a573052b1adad663cae993a22484cbf549f392257835588053e77fa030a91154a1ca375c75d5ca9a86e411b27db1b94c74817c0af927809db840b47deedd2e344a9d7960916c283b2a4a2fb0f824c6dc1487a2bd50845a4b54a896460c8ba09616103fa20a69f98e90e61c8dc24153ac48c3440ebeb5efd1df18f09e86dd44c408fabe0d9211314171be26cbe8482f38ab3c263241dd23b895d40bb4a7822e17b608d15559f7d5e441a9fb8dbeb2a421982f718710467bc5b0cc7ed6981344c2c4802969b468a7e836f37b618647eaeff0dd0f1df9e99a3dcb34202b629224eeae6af048dd171e2e578a987cddd13eb4eb401540dc414f492420362c158ead27a5fdc598c9778dfd9b992beb04bf6036c41ea66dc3ccedd8456088cfb02e6d3da4f0945a8fa508244ac3ac2c8a5bc2a85b29a4afeee6e96a29d524ce2f6a9c28a1a6824345ce8e00188e71a65b090696454fcb570c75548ff971478cff7323763ce3f2167fa9fcb95ec1ed67a34d5def395742a5a4d5cbacf34b22249d46a1f29691666d0ad1584d8966aa982d98c9d5b81847facc16e8ee76e67953192586abf8442f78dea5a61bd292fd824e462eb1a1ed10492d3b3a331598ecb575fc19f88874f6ca282e0632cd94842c355d0f32870c29494b10aafff775b5d2f846eb97356cca854fc622abfa4235b125d9dcb41ae6da7f970706caae2036cc9c333331b4a4a65803d7c008176b7169172f679e9b137196309eca3f393e264dad15a6fe6440f10496864cb28fb97086e7ece58c6e22d14b69f86b021527a3d32b740018d01beb946c58caa16e360ff9b29a02583aa11fddfc62b75a9ed8a144d820e4a1decdc0597d6c2a7a3c700dbac5045a6377f035d9b4b48f0b6659bf7c66ac0bcece392531e238e46f16392ad5591aa0495d08d1aa08617ac2a70785f0a0eb28e83d5cc2e5be0a7837029d1e8a3b7c66c8962a8a2494fb621da657d8172972cb60e1cd6b03081ffc6a25590b1a93985ea2df1c904c8efa67ffe75c2ce25043ee057f0d1938624f06896b35b33a3e8f6583693061192ffe6517e8370e6238180a5131bbd9d7e5b1b9033071b059c7ca77535fe3523705c9f237b7798e1c41de366177447ee68dd8e1edb19b3e7ae65d24ebb52471d5582d9b8b0c760e6d9fb5a656b13e3524a74b566c4c6ec83d5af250dab5f898556e9eeab870946ce3cfccc3a94773129ee9d876356aff4fd1d914bf1208dda32c9e463d816457c5eb539ce30fd927991c01cfe435fece522ccde2782a6338233997af2f111c0685ae05b389277f772baee63b779ac5a1edc972d86b0d7abc245c318d04229ab9b10511902f361830561392b89715e3c1e8da83c358f28ac2148d019655500ed91a110813bcdb7c40e9d4929f45f78fd40adfe60937f827688096a4bbe32fec5c99b959398deff4fcabcdcd7bf3e172c12b2296843bd20841bcbd3123f58e6da5e3adbc4527a2ac3b94215b3c3847a27be5b79076c663ecabff654155c163693c7a3938385c1e9893dc589a21d5574d33fc84cc492d198f090fa8a543300c7d973c2b3d91b0f898fe5bc1ce316d755b1447c03ece2c52aa84a5e4cf691f84aa160d6b8299a579fbd811ccef409702bda2e78006192e587f6154511557b083afb53e23f9b35f841d4b921ab50f95f3c405f413c2c47be1dc7d1a394a7b3ad4e8d4b1f443d5911152e183678dcccbc69c5454cf840bfa64810d8e6ab82981331808ff5722c88f354455e44e98586c00130efc6b0ca3382952e501bf8f4834d51538a77810aae2d7eaba2a1abd99db7e0a32098d04609dd8c4d20f880289f9ae9c03695154316d965b0ded43fe8bcc5c4fc8a4abf3c10ab6666f3ebbdd57bf1cfa6e943c244006682ebed3bffd1aa799f126e2ec698e3d3ac95c2cd6008602ff0d86790d3c00693dcb0da735904d85cb9342e0668c26ff9be3ec465b77826d82ecc188bcb14815b373a1f477f98c2a38ed64b8da404bd0652e7600030efa899c576a1f3325e0d4b6bd5b54c49cc08c59f7cd068bb851edac437d19e4e8c7637ea0729c458b927fc20c9d791de78d1b6c9ebb332db0c3a616919618da72f6ecfd6cef8b97668e6ce80c1a34cc83eb6e335bca239aa4353a8d1ff360d255a884b488972f287f00b72c250f450c96ed0b99012e27a1b5bf1453ead49f1b2844605e39fec4b974cab16561ee63ccf5788ca798b49510c84a88f391a98b6f78d477a327f65397c18f94db8f044986dc866ca9baa83d61a8534b8438106dcb97da030ee0f0c24f656def002cc27535ab13aa7f9d62a69a6b31e54b89fc8883c8ef8bdb88c5778b75a0509e68c2febfb2426768f88769d8307649b7eaf9e2dad72090938f5c116e4d8af1056612dddb784c6971c16c1fc1e304d244b6d1ed10faa53b26426c96c860238d712a49c20a85591cdec3ce67930525fc83b8ae1903d79af683c2125892be2eee204845ac79f6b0f186b537369a65e88ef4705241ec53b5913b3afe73dd9c1597083fd1381041f3e9c14aa44f17ceee0af0e152c6366c47057345822c55dcd823b9272e84a9b0106f92168e3476bd57a5fec51436d7714e33a5c0ee842eea10aceaa79b6ed410736cef4611f7230784d6eb9318476a2d390e736e6139e46b855d8e41882a0a418da0595d2f97eda7228cd0e326aee66f1b78c8bf4bfe384ca9c7fb9c899c4f3659541920d2ba38a61eb6c4bb69f31479c3fe17db49fe45a6f4e9f447faadd866ee37839777e9815b00bd85949e01d606384067b3cb6021313cb19ba8772f8769b63ce6d307c376821e1abbb23d073737ca61c1149e97980c3458662acfc9b81cc3ce1eb92c0cfc8d63283df8dced379013e94820da486c3b1402e626a68f2398c2702926ac7bb144a0c64af04900f33c9c6038e52366fd1adbc42ef14636a380fb975206402ab3915b5ccbb58621a0c8626ade01b4ce0f883d8773dae72247dd278ac558a65e3a625a30dcab8fc67396756c54a22e41683529e7664315724f4c09729d2bfaece8acdc5aeb895bbcd8034bb8e261cc8ce0ac88abe40017ace7c5f0853eba24e5548ced69252a858ddfa3e5e7a12c69d3a80c56211e57c82d297f240edfbb3e32747cccf85efdb6d86ff52e974b3a3f99dcf56a24fb5983a9dad425a882e1e573c8f2e7c711a10d14e67f5a87e4c0c0e66bc4f1e9b81e77801a7b9f72144e19094dfb882b2d8ee278fa6b72f731fb72577a2f379268dae0e4ba95bdfe964ef30b72b6732f0454d99b623bd1bda31ecdde7c28e46944abe90f46b4688adbe38fb797d3f40ddafeea1e40ea482758c81313f492ce2ea90861739d818c316f096176caf61fe08741dce3f95537e201bafe017317c974132bc5dff4b5e3780ece1702f49e5a32ff70d245da24abef1141428a6b2f37985651c2dde345d1dfe2e4b08a613abcd7ae4910bcacd143f9d2dd5109aa400979c67f07d0d0f467c01e39680735a0269da0e39b9046771919bd336c21cc31081ff323e8ba5f58c9965326fc213905a7cd2509cb0c0bbce5b1242bc718aa51b932389a47f83d0804ac2b1cfc1160abd030fb2df29f00970dd02d30463280611e1372e17ea1a8755383bf2e41b128c10598b52b64b6bf0c772318beab7b2200336cb1f9a7d4df5f4ff96b48550c7f0790e91b280ce8f90c396bc13f9d7389fab772d59b220ab71dd3d89e4b87d257c926eea01c239a4bd2ad865e6a63ae306652e703dd72435599ecd34544556276b16680a8c23054be778a9399a6878e720c1b5e3364660b24f4e3ad124e9bb16645dd29add3a06b7ef41daa9d0350f39552a12c939edf497bf162c70314888c968eee9b5b1cb77220f7f0377589610db80cee234a0cb3fbd4496997e40c58bcf1d5a37428d2a847ac73e0fc731c696f570aaf72de86bdbe74a56c8400eb37bec576ba429cfedb289b73752c96ffbe671d22e063611801b9dd271651cd4dcfd167f44364f21ddaed86451708507d3979b26bfa21199fb1e4ea4a428d216e32b0a86e9a851577175c7c818c183edb60d9300fa427a2ce2cd1694253fbe5fc4da25ec7c362282abe235a20c3ffe625b24dcfff3d6a6067bf40a3dc212417b949a403e32176fd29cdafbed648c19c9bd3462d13f208d0adb240ceb32a6898dc8ea258b628f0be7a8321612f13c993dd82264e5b3daacd8ff3ec4cd3d445fd7e2d2f27cc862dd9d95e1b1b9524dd521ef080c3144c65f27daa4b2c701e12836629ac80b4e16b54df5e0d7c4c8765972b45ac8c93b2ecdf29566ce48450d46d54a2bb19746c17078e45122ebcb6bd73470fc680002733e7138efe0c044929f71d4f0033ad2808e412188807374fbc4580b9f2a3d1617119bb65142135d1c57619f074b64670b7d9d78fffc76bd570794fef26b6c1b86f6096356a6a115667b563de2366c21ce193caae34d9d993afa8153a311413529d645b994e5dcf6bf35df6fd9a66c0f4fee88cd96ed29d145a7325ec703b834b0f6e6bab93ac5ad21b7d71bf2ef855a3d938450d44c93d8efa9196f8bd3ddccd404033da3cb952e478cddfb218d0a59250cdd4f0bbf48d62d735aadaa9d4b9408f40cb08e25fe92f33bd99b94b06c82b653574d3e318e70e6dcf7e3d39219a6e72030e584aa5a23f1d1c1b55f212f2fb3ea9ae8e759940f765179f2791f1315f0091c45b8f99f331b711b88be1304d9d1024fefd545acfc9ee783d37883d9c771c88a7017d21c44fae57378d3cf9149b5f751e7bede2def3bf5633729433f8f577c84e37a9aad7df990ad36c305697d6f6abdc88d93559e50a65264887e6c298143ff1a5cbb0348f0a4ae8d17bc936404de10166c64851d7ff3bfcb72fc2dce60fc1e133232854ff013c7d3381e5466e950533f84e630d68ce7266727ff3eef13b48133f888d3009702b096f3cea71ccc4d5bc7f1b064496224c0e2a1670cb26d92ecc48a23432475a8fe0c2c112981a83ab3b5d704fb070e5250e2d729ff55f1ecab8c99423902513bff37bf791213ac2ed3abe0884658012e3af2f0f607dc6699d730bf1e4eab4fc27b6c18750b8de77382ff46f8d337f72a3a387a308991daee45b451e70247421153364ee8308041adda66e4fd60cad95b420fd88d0d2158326e3ccee283177dcb2116fbf069228dc7d259ebe95bf41c88e2017c5c4ca7e279d9482e0cd63527409b7e50a82f272fd09b2073481c681b633354cadb07c959f3c69cb10785c1167293de239c7f76c9a28beb3086c9025f4f7409767eeef7bfc38b62612d6dc28194f765da33d2f8119942e98d429d6732e7cb5fd6892cf2d","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
