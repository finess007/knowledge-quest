<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ae052d07a3565ea6effd9b8bb2742c35212387930453951bc095d3ec04d9ef6da854fbfa919bf6115f70444438fd9a7b29f9e4d93a82c84e979a9eef6ed8654d0088e7b5a5f9b8bffe579475cc450b0216da65645230c09499ab4cd2bf76a9f005efb673385ad9fe982cfe308a2a67bb0ff2a9ae0c762d0d8a576d56b521b054c59eeab447dc5922f6112038c4d9af43161a8a9f6fc0c83bbf2f70f204ea17e10f20f598f9f474bc28f78564235032ab5b145b49d75d818bad810fc0f5f445a03ae82ac716a7b86f8d9cf1f26070b37e0856ce65aa035398013ad387d7deb0057dc72f247b9dc9646de4ca393610290d53463412190d3fbe90b415833ff4662773b589973064e78e73c52725f4d0616a94ce38b2969a97bffd3f16186e7e3bb5204c55d2317e4e8a6aa6a6d08a94416e88e8c68776549636b0dc874ad8dc8f37c21fd2de8281e10969e612f17f53d95117855fc561b3d67e3d8d3e2837986960763dd532d680ac26d220ba2eeb81f3a5b0f16ed2537a585c86fc12970503761c371a7321727b18984a919d5974784f2bc91361dfd867c65e296f6932ed4a8e61c082b19b7c5e1aa9ddbd36d6641fb01f225b4d348132e3f8c065e7d0f009ae77ed7f83e71350460fc59cca47bd2b632e1821104ac50fcae231531fde216764695b68198416eca48dceae3856349eccceed77d15fb7d9109375f58bf325a3a7a3015a095efff795b22ac31657d4fb986a633969bd173ef27fd04780dadb6e4774134187c81e76cb8d35c717cf0c4ec8585578b16ae2fca44a8878f51e5eb2aec0b620e2782bbc508134efe91759a46c3377fe2e41d9749d14ec7512ff067424c9f53aa4006d0b7cde047e2aefeb9435f0506a202b9869a5d932aa6512782c78b9f800f23e0e6907980e1c8a9da389bb739ef31f1bd959bec13f9a3fcae6bd79acddf0583713c5a8ded0e858aacb46409389d6bcbd4101e8415b55ca0bedff97645c15c82ac8763cc03c23d72fcdf4bac086eccd9145a450f4867c277d34a2a25b4db82f7ff0106d28ab12bd1e30cf275378825e24d22bdc9c6ad0c929e1ef7f4e8afbc65e5a625d8893fae55af438f02c0946be36c480da17d6d97c60f623deb2d4e6f5e71db0d9c859f83c3fcbf0b531b65559dbac3ea1d7f2ea93aa5eb8284c0c2715a798f6d0b20f49773fdc9bb4561f2a2de6249ee396f0ae01c99def04766e410cb6080ada10e2cd869f9fff502c0105024ffc1feeb90ca954d972d53dbd256d2d1fef5849112f2625cf3812587de02946363fda8cd48fcc30e815abae53040458c722eb7ccb6d118b4d4a7058acd19fe384a9c0ae55e864c1d8395e2e6614ca958952930313ad021d3115b9eed6169589b477122b7cdc514d81d45943dd903ce2d21db5bb60bc4ff06f9a7c045fff28d7538adac8637d9d98ff7e4b9707e08e29db3026314716f3802c22c963199a08e447ad161af8d2738b0adfc00a0db916dd905159dbf70dd0bd6e4dc743022a4faf993ce6c8efd05a65d7cc871d4306bf3df2d9a02abc4acc2a98655510cacb6e693449ec7f2269aafcfe1f753f2a7d39432a9461405e98e879600b4a9e107ee876ef1dc3e5cb41331544f2e682071c9cf5937e5d971a3d90a23cb3fc50ca6347265940d3cf9c31f1eb028a5e00651442256dc51d11e1e0a0e7f2631fb69394caedbadb077f342f6abd64696134164b5500340545051248d23b82226cce91d6f77bbbeae15fe86c03fc7ba8e3720fa37bd1ca33551c8072931801d94f9f6d26a0b4daa3a532377c2eee0e0be07f3b905aa3cb34578e0f60328faa66d5be2560e9261defaa9a7657414c1bb66882a891f7bdd9de5d4f48f6b977578d114fbd998b200b7c7f084457e10a96092dfe5d6430497283967476f79dd601686eb93addd6c254790eb17aaf1d763c5b15338caaea67e76230ac1fe602d7d518dd13b9c42ca6bfd11aa91627568ff7a3d01009ab70afafd58b4b1f1e6024bd1c99742ff9effd306c1902cf645f34212d3d7ed463ed7ded66e3ff6575174cd6fe10588710d72d153c8eaed95700053aa5eee155d86f71c82305d84ae9c9821d75677f597a49c04acf82ff8ba74d32e39f6736bf0cdfeddcaab21c5be5f62b8e3b5862fd019ba367383f6d3250deb9b0b162da33a7c36425f2025d7aa95a1ea20dc6a634fa7c6bbfca4797b76c5534faee3307be14489005f3a73390bc3258837f4bdf40781236dc6ef876e3298c87f6fc419d1c85e842c88decdc3723ad03178875ca3577a985fc95b3ad3b2c9ac3dd46a7a8cbb4dc35f7589f1a163f3086f67911cdee277d89aa743aeec2f437f02737e148c3e0af98e8b336babb6366c9d4089cdbd55a49511c28d83594ad318f63f5de08ceb4763667f3248ea37b8f4a671af3c97e337082efc6bdeb343bcc41724ac0b18494d4a5d95a6bacb7589f0c51f3fbc8e2b477342301a55af14d736c949f1d631cb15d095ce1cd7c922f44755d4aa163d8422aabd2d4783f46710d885eb9b4812fb1fe5b696a6aa2226f76627d0ae14fb6b4ddab38643cbefd0a6a9758a143c9429a53d4f99857eea4b1021bc9d4bcbbf51c2339c5250cedb228ae0402cf3f25b66b9bbb580efc05739f46b79ba0db5eef835a85261275ab91d0a704ff87606bfa406e9119a0402f572c49880f339937848040b4f1295d10249eea04bb39c0d038141fd4de1848fddc15b5e1c3adc6a7a92c2da5cc6f1af268a4f23982cb73ce442859343ccfbc5baa4d01aeb8fd00fb1a0fea34496e4afcb48e1b55718507687689d9b8e32ab5b52d844eb8d4cb94d1241121134562db73ec08bfdf61cd96af599040eb43b4c96d236af592e8c1303244c11de1f98d8c9da0b5ecb3a983e35f80be58fd030804c6fcd95af58d809712dac2b8cc0bf79cc17e9c4c7da07f7548de3f4a98e44ee14766db2eb2ec5c920f345dac38624c9f39a2e641da11be677a069dd91a8cbffa40953ac5e8d15cf2e29924d2848c9e1c883a9ca69dfa87da82d9dfe5e8a6ac80b8e6f122342306136a1b2fccde24fbf89d4676f6ade0863a6e99e3a27e6879b116f93f5269d954c7fbd7b256b344021c116fab6771a283948946a382995e432801030c85fc8e04c160f3e976742ba41b1e4d3a8c7fcbc7218d53e337fb6e1081444fec0e6f66e65c21441caadb907f1fdd94286cc7fd0dd0fcae5d3d83bf868ab460195a80078e8d272d3cfb137b84209ef1dd5b6af82c47d473ba72d319abad668f037546be74faa3be1ff843b02101bea761587e000db0560cefe756b5166de7b2568d768f4c0315b46448e15f08cc4a87fd9a86700327d676c0210fb00da865df0e57b2beedc4f99fc6a5c4b33cb187897cf7f62d24a46be5fd294156471b326304e2b822b7f4c5a20fa936e8c0d2c69916753a9f95aa71754f9f2c64cdddf9c566b4d88606a43594cfda1c70923842e73867454ca0bafb3a13b2d775d23c063fd456935a5058bcf3a252fe669f0fed7668f1949323ab8d1c79184172b91c413dab42a315ea01fa61484f75e970c449c5edaf6cf01ceb6ec6f54f6fb4f6175fb60877d00d2637d63e56742ef89791ff89ffb3f158722cf27601b0933d6068695b11347a9bd6cfaed5be54faa590cd0b0fcdd4553e166c79c8c2af215a5c588d64e5c2cc34edfce969b6f08e2defa0425845a064d4e222dfdfe73870bb245491bfa1dde9d217258fb0e486b94252009779270b47988d717b6965818574a701d09ee7b2e457f7f4b0843c7fb8a6864a01aadb9c74c6090dddfcada9661794d3962fe782c6381ec9cf34323050a2f7670f635970697a3788b06d990594035d74156239bcf630448a8d61e8ea36d8f338801bdc8d9a8b9b70e285369872755aa221953b8c3d992772c79a4153e8303c526ed9886d3993d06bfe93eb9d089508d2687987c26ab8679482e30c9c7176469018b49bf8cfde836482471e129d15e4dcfb1db6af544e283d114d94f06d3c0ab0214b7a2ee5dd72524afd611354b74023e47409670a78ac8d0d045cad71f37745f17b945142bf3fc56c366466db96e7576f9994a68f48e8b038b86648141fea95357da11d3fa797ecea58d9ffdb28fa54d0adb4a3a2645933af71ec0f7bc76b543391f555632bb1ed88d535bfc58410861d8e32b83ab7b55c5dbd5c17a4995f63e92a3e59f1d8d49a643aaf3875cb75eb24638459f27c53bd0f032a10b0415d874f08a65161fc6e382defa5f06fceeb9a20aa77667fac8614816276041c02d6596f40ae10edc558b8cde7cfbd907a949e1d8a8a01176f9fcd259347bfd6a4c0d7c690209f003e704dcf695488b3ad703407bcbc1f39d5b18efaddde399404608ad6378e8a24a0e6ca000918796ba3ddaec64a46128f9507a6b87fd1872b356624ef75fe46c53f5e41a48a2aa48194826d66f3416a70cf2522786d4670fee9e49661a7ba335147a1c58f8dd84e56ff70daf4bcf484435e964942a1f323b7b96296ed9b44a8e5b84819af1b9af6f4d3e585215ddb3d4c64fbc98162f70837d26e364183ed3420a71f580e3efab4e52d2b4877f7c7d6aa171e45a011597a4c5819bdcdae2c46c205ccbcb372dbc7cfca20d3354ed478273083305c7688c886b571f17bd3ff57e4725416ab73cc85a8ae956d4d44a8b83a29f6435d7a32bf34e4fab368d270494d70506cf25eb67d307569f0e03517e10bc3cd10f97a2f09cf6c9b936bf6287237a8c18cb93a29472507d876c99bb4d2c93b18c5d850a9b67c114f7f3386cb062c6eb5b427739796be89d32595461101a1eebfc6395592782acb6ef28bd5788d0e9b7edfe9e7ba1173dc82a2f0d43af0184341fb1d85f4d5133fd0e0c95145a50d20a60f7eae05824c5c249f38d3ca26106689518b2dd1664f45f787853aa926493113ed0070be5403ae7edaeee3bc31ef66490c1bbe2db4c6869851c60dad40084a70b808d932e66064c4b6417105ddb783a887a05e00981ddd34c3baaeb8bf83d003f117b0a93fa146214ca56f883616a1a5409623f82e7db6d16193eda7052f61c055438667fd7121abc18f2774ae7b2017b11566d5546b00d9cc3767ff5b6a766389803e063e213974cdb12056f5b1e3cc6abff36f00100c9dbfe4e91afb85f1afd7090be766cfdbfe8a13599fb28726ec4dfe530ecf4815a5186029b9d2e9636210f20f53ca07b4a6c28a7e0d230e0c0ff36038b7f818743f0717c3aa61eb3be9e41cb9d8a107a315079b42064df6c519a456cf3e81fcbdae1d1bd0a0d6e15426ea46afd56fe57a2ab05b510dca290a93c957e359827002cfa20c969d46f5f22f9e9b1347d760f66694ef136b1b32d43db3e2eb190cb390ad80e2cc955be7fed0ab140f8e9f9c3731413658cde77d77fa6c2d201662e7a88c6b588cf4a175a07a53f3998a03b13d1b488e9d467d777c6be67b319f8c431a4847bb82398720c721a409bc0661ac988c616e93c1498950e9b80479b241af5fc0264d04484d8c76ddf4354cec953a3cea37936a9d1222a00866dc6616528ff8c9b8191f740847faec1be329b577951e5c7eec81a13bccaf344858482dcd715cb6620fb117406e26aa3745d93210e31e3cd5b02013f09ec0cabacba1d54f8c0e34155cbfec93cc749a675a4e81beea12a9edf9cafb6f516f045f56dc0ac0f67124e29f4b5e890ceb4c58e522ec398060717d1e5969d6555010efa4087933b6306f7a3aca3b29ebebaa9ed8ae0b5bb2e92e58db9aa46e659f692a543ce23fa8d91edf350b1dc6929eaf4d1540393c23b7c012e8dd5c14eb95895e202d8a5f22d83d5d5a6e4cbc58313ebda14719404493e908743a2e18640d70fd987c2b82188c5c498fbd10491347eefdb1652a8b5e9d6fb4d01ec66d51e46c1e440f3ae2a9f04c37947646139ac9c3ba5576bb95b704014df60172fdc87a89d24f911445109bba0de13966a5aa7086c6cd24369ec9add99f14cafcfe9e50362028d6f9a23ca4c963b422648297887bacb4bdeeacdb182ff0c639eced639c0223fa057b7675268340cf3abb2ef492847338cb41e318e582bb9b1dca50b7eeb7ed305f00981c3afc861894334e63180b71f2317bd276ba31b72523ef01e3bb474950fac612364b1d845b1856f191112f8c0dc6b0406d98b41e2b213a14b9b6f20dcba929ebbd2706275a2d330c74e1ab13fb3529edcca4f53bc4822f7b50f10b21f3a9659eaeac5ac8fc293efe00652796641616b0dd1df2fa782ae35a91e42f3be4e764233b7c1905cec1f7d1b841dc25166026435c06fc1b2c45db1f2803b1409288798c1da5b63e9b8560b22e3e5722ca92611e0338df08a95300b999c9e46f48d1c7f6b47e2579e89ae23b1d5bd2f0a62bf6083feb011b96114ba6a1128c6f4db1420ead6c0c07705e370e3a1005a2c2232c188fa3205a57342e400d43ca876ac8a56988231439baea5606429057aec82f72c0c8896f3ce4e6d77dbc2c96e605dc280e3aba0e4c472359edea2ad4766fb8a7b7b2e97b22810058ad92966d2f5f9c4a4a7fa50e783dfff3cbf370bce5c6a01f197b5bf5e59ed4a816c282a325d55822a8528a357c4211341e38a1490d407ae901e4e1e5a863a2ddcfdf592d7ab6319675cc8b1d076a127001e66ae9c047f37f276d2d731e0522583edf70710545d82e18b78b6e928b19bf7502d1ed457ec55724196bd0c71d5cb974fde1eed67628ed7e6fa326c06dac39515f6f43445bd1be2d462df81baade6472c4aa39ccfe62a6fe51a5679da8a0b090e299bf072c260c811170e91ae13289a2eef60f4af66c1b03cc781d526446fba037b88bc3b4e902179c9955f546ea3b915027cd39decc14ed2837280e006aa043ff849fbd74ca8399b7f092880be5330b8c891db7eea6548bdc30f7d77dccedb6906d193c127baf0283ee64bde64d83a790858bc726c171de9945468dbad3e0754c24b26b8d81a5271c50a5899ad616366257d48200de6662f4f0cb41471b090da72ae4e22abfcfb26972d42d78af3c99e253eeb7a396b5e38133a9ddcd46d8826042fafe9ed15cbe669e96e64b2fe5c467772ebcd0aabf68c2e5c8c1ce42a076b25859e79ea3e9b1ff4e19551203a2a54645e9faef59bd9adb6d9347841786cee7b58b16dfe0acf11348630d4a70a538f0341d36f1ff1c96370ca36264d6c8433b692cde72426e445d697e67aed391b9d68771b48615ddfe62163a8ee8b2b8027cb095eea92bf86389c635c6254d64ca86e5ccb976074a0c5756184de84edcbc3d14e9af9262fbe528dbb9b1eab369309d192f014941d069945a7452784525680732c88094d05223517095e7e5e671539d85d329878cc530a78d3ad4b0a65a8858b64f93e7ecc897f0bcd090c7b5be6082e60c3340539024a0c8d76a1161db67065cfe28cd36dba1431992579e84d1f9ae8522909794f934abc1af72ff75273fe64ec98f8a91e572d98812272714dc0fa1db4f90c7788782eed2f061b684a0202a6cca37d12cc16523ea77074545182cab34b024c86c208a4d40b94c94d96581e9007316b41937bf17174f584dd0fe728fa58bf213ec2cb0117af48517bd079c620f0c5b6232ee41018bf748c6f56f43a8c3159f7d556570d56ff28dff507ee5df675b5da01f968437161edfa1a121c1a08da7254d08d8034d8bc08a77a7365335a5cab4c9d3e82d5af55b4a4b9a85025c6bf410940bfb5c89fc54a11810ec2031f6aab9be0aa622cb12b215d36f85747a9f409ea7bfe786656d87cfd9e4e907f2ea048eeb897e9e026d46e083bf48c63d73a9a81b025b10a5d0de8747d5d335ce22a37721d30e9518aa9c20841bd57c9df491adabfc40817cd312c7bb18d8dbedc2a3d65e0b2964170494af33bc6d12ed639c5f9e21b6141c28c459c6ce7ef998843805a3f1ba7eea9c030a75ac40c39389ad11fa6274919fbaec05e37d323d0f2504bfe9fbf629ed7ad55bd4bc39c709fb6cd4e499f588585a570bed876ecc57ee0c7fa53ba0c32d2c8b9874742fdfe8e03dcadef726b99274c6bff42b2e90243e1077b4fd17896b3c34d056ecf40ce52b601e65c00e03131ac12861fed520f4dc49f1089b0cde4f231d9b0994515977757af02cfd77b4dd68607999f69e0553c8d3d8823ba9deafa5cb7aecd4a4fc63720080457edca8d171517061098f757d1c98eb5d427106374b33e4e5951eff28767f6a353035776ffb1309f925ca286078318f3863cfb9526f5e4312d8884447155a5e2eeb2393c0ce98a37940e075154d8060411a6767c55224c158bb3b933e8bbff4239b12b7ef465ca88eb6ab00d6791ce810f19d492337dd00485bc15fa70b69383f1f6bd74d3a72104c802f6a63a561593aa6a519855b9d6321eca23cd3975badfa84ebeae44b9188d65c0683f878e44b9b51e116bfad8a8494abaee13670b6d0e5c3b22ce2abd9222b0557798710e1de122c287a4ae2607c6a741979e5654fbf06e9cb0568305ba51e6d1958aab2ba6459193a5ad9b6b82e9189cce3aebdc35ae19eb30b69c52c23951f22d3c24d6c582bfb1cbca0f887e0fa71d17a43cc5be6242b1ba2e259f8a52f3067cca320edfae43e465315b19d0deedf061fad7e34203d338c8f05a82004cc03a0feefa449278ed1ae9ef7c6e2e85091112114ee498ff85f616f0135568b68e20b12b20a69ec869f412f4d455c92c736acd3c6b5044137b1784ae7aca64be0d9cd0a4f4dc9f3f6a057ee216fd5d185096bcd797e08394574f5dc6a34e72551af998bc90a29202f9568f6a8261e0e35929bbca7e62c186e047f1d36d097a9446505bb1ba6a9ed356856c15981e6b51a4aad3745e6d4d7dddbbd3b2d72dabe06ac83feaab8897e2b6e085f5ba04828eadda444113cc09a542bdcb4af8a8d6ffd6c876c5a28e7eb65ca3bd1726dd97041bdd139abe250f97b5a0a276f61e8dc16628e642cb5094609d41598d9a362d99c6e6f4071d75885261875dbd083c0da5b40de0c2a4a2064c39824d5b708aa9a42696a3de49cf73ef1ff426f34e3371d179a30bff28b67c6ce6d6b910f41da97940c87399547df9764490b6f7d315c790a3ad30b5ba2a98dd6ecd6847686c4db63cb8e9e7fbc8b954b4cd0c2cb4cc6afdf3d5bc3a9c573152f8747791aca14d480bc897342866af7d3336197f9687b1d66c1c2ebacc4f416ebae611b3215395469c082913ef84e60ff5f5137394c9a121db0b0b7fc3cf4964be42720a1d87afb652760f2f8b324eebc32c7bee6abd970090c3cbc71a39fca7d2f0396382dfd2c4736dadeedaab5f12411d35c137d7607ab8fa6a431f2afcb15379eeb282abde78c44ddbd494676b050ca48c8fa9daa0b1d886c518a6ae884bf3ad6f1eb3ce64b62a41b4ce4fbe4e583b2c4717b41d5944e5c87c4d3999893161b3cb527c77bb719e8cf8c278a7382eaf4d360f2cb5694aedc1038ea3f884ecf99ae136695d21dd2581e04a877e7cf60b171ae6ac3c164c7a78c63d1f41c27d7789a2a430bd38011dccc4da2cb3cfb21968c9f0ddaa8d456d3b3064d47a3b13a802217c62a0fd2e52025c97ffe0a012ae8260c6a64ac694f5b7af8d71bf440f94ce669cd3629351e3084ddeeb9bb2ad05c5a326ab26c87701a2809613656c9b14b94b6ce34f23b2b3a6928614401c9e359fac0ce816a89151ae4fc9d1bcc0330b5c9a1c2a95dd40308622a5100f0b7e064a29f3ae8c33508fc6cca1c27b832df02bf2360c11f94e8d67cc7c8e47e5733ac5fe2c05ec8be2d45b1a1d8506708c59c64753e2de8a0ff2e672339709e619ea3b2ee0d239ab58e0e8d15ebde60a177f53ac836b75ed6e376d44587d1cbad9f9c756f5f8f3824e2f9875925840ec0527cd95d55f7ed27aea1ed1522ddae145816cf71af4986360a767e41d16e3c5395f749d3073b1097cac1d67b8f8bc736b2dba262e7721f53e95b482c4525debc062512d48dd70a3e1dfeec1acf8afa4cd50022dccadb0d31333097232941e55b45a8c708ba35d5601d083ba77c7e1ae0a5243304a907c9a5e07db21064873d3162fb09915ad9e8d2291fb460a5c99dcc17ecb06521b4148a45684fd1ce135bf021bf401fdca179d2a97eadb31b6e70978809f9cacf531009a7e7695e24fa73fdf6145b1be5cc8bd64828767bb763c8ba470e5a43789ed7ffb4789fe4c34ab73d047531b57a62929df74c4a803d1993fcf8d1f0d2b453e12e690a34633f13b0b2ce26731697e185ddcba756fdc8c10e22dde4b6bea24d8153336beaee69d4c69dd1d6c4e5105a773de2446127d394bd651f9f8e9124c1af02d3dab3b329e81f4a53ae17c4ce5a221c57786ebd651bfba96a3e69e859135142ee7f38154753e35e9766b6929ecb9779ad4da0a9967221d8a6c52c7dff8d30a67f8831e6ec6ee7f06096025bca7875b891934773622458ddc08de752826683fe74300f66b08871e804b89af5d3313e69da559071bf861d6e20dfed4b6b79c305363ae4553f06011e91ad6fa721b4eabb8f9089d007031ce195d5cfabdb625c3ba7a53e0c05f33f595c12feac61d0a235ad37b01b27113ce8c4024cb290a1fe6f210f373c6419412127eb117eb4b86bdcc2c243d86fc334b5ed7b165d85d3ef01697ad83dff932ff84631578bb142ba2dbb947c13a6698711908f6301a5128fbe948f04cad4bd5b14c192ac4113c8dd7b18b03b923ab4b70735b3ad6196a21b5a09ee072f459e37bfb3a3ca3ebbb1a6ef3e57e314ef849d2198c74a64fe992a3b1978b21085628ced9fc7b9e0bbf70590e50b59ba82fcbde34b7725a7036fbfa0c08ed61be719fa2c28ed4b8101d9d564c64bbe8a203c9d9c40b03b5951cc1629939844ed293091dccd6941e9e9b2d62fb0ac0144f52685ad7233aadf1c970fc29ea3048238f34b4d31ca1016b8d438d1b11eb61fbff7f24cf4d9684dabdff21dddf4e26193c85688319b5bdd9d7c899fe835d9c77175296f5ac8c12ff43cd618da0d358d2526a7b9eb26e22cd05d81edd051336d8a8a807b58f83aa814c117f570cb12541ee8309f08c26e15877d974226a9654158368a472bca4f25f7fb9084bcb42984cf60fc26cb21be9691270ed7b32378c28c2be42a6385076a171891ebb131e09eca1feed64c0ee3c5dbf5616a5ad75863db69d50f7bd1fd736a13ac5a93e9fad276f88b8fea614f915e1ca15a33632e4830a184f6aa115388aff3c01bf245ef7a6c18d1a6379f68aabceb9839ff36a56ffc16ecfa51fe13b1f366259e582b54aa8b29e27675867d2edf621c3deec733c865d72e0d2102de2f7cbad0d8e83b9ebb60d642646591a52cc791f2b4cf35ecd10b72c629fce7b2d190ef5c4ff8c51462f8496e9c0ff1e386fd2f52f93816544221b52e6d18def1cd4571b7575ae5b9166f72c847b1b463493b25e073b9669f4358c8d72448f9018cdb1e439773c02369e10a7a5f18adbc9bb981cec60b2a5714a96774565b7fc9ff72f181746b9ef8d76d958654e615c8855501436a2129ac9e5cca183c3b57296f18fd021565ee2d9eaec3ef1f4f40bf503024c9c0a35f3b1b451b8ce6aa9bffe36ba4959faa270634302cc0a1a64511e92d22c89972b5789f7333be9d5dc435e8741544fb3a15824a6c865008b94c85d923ce9027b21dfe1a5e02a2e6e88828850a24910810fedb466f384a0f4edd0488a1ed4ceca46912f7407f2ef489b80003eb1732398cd0a15501a0e8cb9c86d4f55f3e089ebc492ec257cc507d6ca53cb15563650cc13fd2e0dd67956b576a6c473a81418a5f4b968104e1ebc78c0a34bbb9ece1342bade35e865750b2ed987017f34d07e10f954645e75d3826d3f5f71f3686bd9cf6659e765057bd9791afad1ee9a99409244b28ca082c4588efcb641808c856bce2b43a92b1fdf1458e9fd6b074052a8ac8fd896b6c801216f084130c8c2e8337b5ea8cab7855fac1b780b5a9b3313252177d761f47240c2132787bcbd2acf0e3689d2414b4ddad4793d196e2750603b948f9659d0b56160dbb449db75aa5b2c5aab72461388b87bb5df41d1ba22e930069a737feb4568510d16465878e58f56db7a68f4f6210fbb486963cb8eba1dd155a96dcdb42e24eea8894ba23942f32dffe02b180215100f7867cac8d65e00dcb6a6061c695377d89f657f72ac3c2c039eddab9ab946454dd6160a26a2c1513ddff2cf38f98add9399bca188f2e618c10f3ecc773ce96e3f3bf91204163adb921248b44d73693740e05d1e711001defd1ccefe9093d83bdede1aed1b03d349982e0effe64ffe4afa3044a119bd57e5db134498a021b50c0c4c2c34202b75fb6d40d5b9061fb149d8fda5794fe3ecc493516462812690b490d87f2565e1d768d64770028bac350b54263972c49bff04dbfdb1e4c08520c45db76854a1c0448512bd0d7f8be4055afe22b0f2bf660ab26e4a977c5a4c6401f8107cfb455dba86bdce98172b8a13ee848bab3df8552daf1e2879d412486d484f0077941abc4a4ac984e0ef5ed682637112a52040d016809c9d85a0cbcfb7fc894d30b3a83628c6828d40f3ec741c255f7722751ed11eb2d3a41ba272c8dfcd3698ab28081af68effa84264101a3d75359c0b61aa3eaa0ced40ba51793b4b26b73cb2f7a3f0aca233ac9686b61b4cc41e4e082a1b422785015b737c1dd15d46f54ac596722dd2c8d8a8e8a0c6575147aee2ac77b3d9bf2a7651e52b5ab2e3dcc222b4bc201c5221964233c603113b7b2e789b70199491ebba8123151fb0fcb4c4a5b92943c129175a40bbea901adccac2fcdd9f5e04a5998670a12bc5059029dda8b089ae6668010f3891056cc6241f9e7acdef679b26f48e26cd1760bfd1978af4587e62ef77370c3a865bb9d41a0863679d07ecfe3ee9fa997075d8a3bf6b860e974807bcc50ef20451ebde8a7fd5dbb7e5e1f03179cb74abeb8c58eeaa77e22bc5f89e27c158f05ccfcaa554f5bb617756515d8731c2cc8b0a49f51d64fbbcc74dfe2414b4a2f32c3ea7bd9095806277b8b1da964c7d7dde680d46bb60b3dbea5785266b499ee30ef9b3bcc4a7179e767f3060df7e0c496e829912b9555af664c2087571df1659323e12d346c1c85cabf823f34c81238d34345773ca09f2b06a168551f2f37bf07deead42e626108f19ae7d0cd036f84c3230e96d1a22e725204723a93529c6234caba3eb931475a99af7a89576520c74c9606d1667b8e1f7eebe65e19deab21e5dd9530bd7a744e4de93eaca1ad02c7d13db49637bbb41e83509d41b45d8a66fb70b36db9cdf1c708d7d4c90852afe71a466e47fece7b70dc00fbfbd92399a27453f5eace780fe57791130dc55bccc0724cf758990f4217f460e9f7d63a37bc0596716972a3e96554223e40875911d33c51b20c59155a510c6b07ab321b9ef952777aa634c32d50178b473e5123d0e9ec63d41307ab6f2c16b7bcb6023c0dce325035f97a63b5b25d444616591bf2d1fc941ced8f715b5eab74cd291db9e8a768d3b0b0ef3e6c2060f80a691f218dd76e5cd796360f42a8a60f86e2628cc4fec78dd22554fd2077fb8491abc7b9abaafe06abf7f51812d1870c6cfcad3f9986562ca811f84ac39cd6d57ca71d421d3f95effcec789e0d5a458a6c7c3a67d2a9aa42b218d42f603e6fb33994b302967fc651e60fd31ebc40fd6eac62fcfdbe5ad57b8bd5dceeedea6ae5989be4220ddcbfe4b2e732d0f7ca40b2786846155f1b016de3ef58ea04734ac588a88e46aeefb4777cee6ceb227399b1da5a31aa72f0cffeed34087ac09091869f7432c5729320ae30ea048c03b5d92d9403c033ef8c43bf20fdf8693a5fafa060688576a728e93f1416fa5be68b58f932ff9bfff00d4e5b5ad24b10e8fdde5795b38eec04a63c7d0bfb0d0a9144a0b56161f2e1e0970a00ad10819e55d1f58ee901b6e37444a682368e46d53c4e321d61712a1b10651ac452ed37f8c5db644ef061b0337a65fdb782951d37842c42c779a985789a68949e524f708193a702600ee950fe48f524a3c388b0850c98c02d8be4f74265b727d2dec68bfb66053e7c93c463b06173c30da520f048075c0b92d8bf5f5bb8f86ba0ccf63c3e6f9d2473358b708da1f2abbd08dec91f3fb96930edab990299d6e76b8dc225b52e744d43d3","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
