<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e2e030e921158b0f2e35ed6e6d4c18a64040ef673fd5a5c0c33e3c67615262f2ce6012ca108dc083cbd5a29138e1bdf2c032506f7b32f28df844ea2c684e03becbf677749a1b5c8a15ac7dd612ba2257e221d1ccefb031e1e26a2388dbf3785bc0e97342e477bc53faa4d8966f2260f4c2e31025d580bfa9328b6c765b98e50de5654311d93af1366a6c6d67859b4cc167e0e4e0150ba14fa4cbf73148acc21fbf57b9091bd895ecd630a39fce84079910b4bf8745fecddb4b2338158a3a9a5aec26f33fb617eeee0388b3358a836bd91659679b9297f6fbd63dcd3c8b937339a36d2ee4d9f972c7c1e4d821480d63984c88e882e4d05d5bed08ccff69df25bb37ec4c91ec99df80d5c24458448ddb07fa17ff7da9a10a50041c7b656c235a4255fab8e35918dea84ecebf334fdcea6ec440fbc177e9131f4dca2f72469e20593aa260c4ae264617ed819278d2f591f9425448b452e053bb59d0867524c8459c882c81737e4070c772e0f0dcf378e08760e25e16f6a41f80900d9ffc6cc21069e4d264386ad1e132cb4ac137d97e9bed3281243db312c44471805ba1d4e6c785c501012858685d3acfc8fe339e19160b374dbb99c2fe2a992ba98ba6a436be0612b5cf17e517871a56aeb0bd8d876a6320c457d4599d655e3753917db816f1e3b9da864f5d835231a3ad56d5351cbd7a6ddc8d979f1fbce6addc82f3981f21f02376fce52bbaf23f20df88c9d8921d7d31b535e101bc9cb3ea67ce8a9355358ef1bb5ed46206b9148dd917e2bbcf549c89b7a836448e753022c4939d4e67deabc59140da97e86d857dc1566938183190d68d40d54ac1d43d93b60158419cb9777cc8b699f58e0b8f4620ef76ea16f5169f55a070a05d740cf13b1102822cd8ec8c6becf4159a258038094f055b9a3980e86ac36076b288ac2b0f3dee22411dea9d76055399376159ab9792a3a7633c041c11e624047547e7345a3cdb0f776b924621ed8edb67c1a829100d886a455fbfda974ce704f9ed419bd0c61675908f644120c61e50a534df98d4ed21dbbc9f0c2efdde26ffa67e6eb82dd66f664e9a359c7e0a73793eb1afa70847331d42195768af9be36a17e99f118b61cfb5113dfa2de371bc06712c6c3494e1ae3c696edb7cc264a1c0962d910f04b2424609ac91fb015d980938deaee5662a023c40c73aea63c67756d16eb1183d3abfbf9ad7b112080f9370b3c0e27d45fe9ceb2fb5f05aa4d7d7243911bb8d31d8eeec5644720c513f631ff0382652cb4cb3fb3282c3225886a69f29f13f07607cc5d4371062fabb93f85fc69d92fd9485a70393ecd9b4e4a86c8a38ac0c9a000fcde646838a62708ad4f69032817b62906332571dcae7b489ddf0e956c3edfa4ad65ad9e181e8f2f1e7de62a5b8c7a894971e92bc34b375b98e4d517559cbff919ef86e14692d60a7ce5cc1d6caf5cae736e7c94aecc381501de591266bd2247f4f898a8da0b92dcb34d99e674c9759f242208910820447b4b2a147354749b44009cc51867961cbcfc3f635fed65c99fb3ac9880cad26534f9fc9dd98924b875197fe46a7bd39be731b7399e03e17369b8937922d1a179fdcbb13ab63c2b6a9d2bbd8042a80398ec7e2187de551a0d199775ac677649d45ab967d4079a15e9c36ed243f62e4a5525797b34feb40f9ebf027a582017016c36c98d53032ba6bff8f9ffad341e02a23119bdf7e25a98c372cc70300503e2f6485ca34250d91fa7f3b13d3f3a00f27ce1bac006fca999e3594b2eaff411dd579bc9b283e2fdfe1742ffa864f43a746ef1ad4014168455b0aa1441a24a67fa385af45f47b145fd034a5484f74bdcba5ff66fdec512caec7499d5d72c71a164398fab2ad52f9b5516dfa4b926c052e214bbd680c4e42c3e7be6d222253e7c41089fefd407e09cc2081008ddd60a8ccf7cef2a712b07f246ea47f46c6208660f6fba54c3305643dee47cdda60990b1716a5c6fd0522d099a5bf7444f2f1670838aff551c18da149b68c36e93242a53c9130d880c3ed8641961c9a5befbd279e67061253b554285126729df3cc3239983ca142d42a9d5ea4cb5e78c803894a6a691dd4c2967122f6d2ab19a9ddec09b6d6dc0438628c39ed645b8fee2f81bc3055e1e1632e358e87d0a93cb9dce21db870718efc0857f8ed9e3ad925e46f80a05f9b13e541ce6dbac080adea0598e59514336c9e9249eca49fc7bfb0de07a21c365d6bcd308a6cb714f870f56f278b9cb42174d62e91a5fb404c49879e445c419f807d37da64e9ea92993df0cd412f46455f252f5ad329a65ad67bc9b42de9acf5867885fd9c956b6d778b944807070528309a5e2b19b64bb6bf63543703780afc5ac570cdd899e684d421fbc9d55e12cedd64c100212d83840055d37c3d8b4357cea73606f2f0e7faaf40fbc6dd77353ea75e4f04f272af7b3e1e1250bd30b7258fee40311a4dc482f7d5d6c22a857ba065d2b3bd626dc37906c6e88a4dcdef5eff878d1a56c6dc4b8622477ace977ca8e4646ef6ff89b9ff6a8b659d1335b5dcc297863a538fb8994c1ac2a7a31fea7bd00d31e6ba5fe3e8de64ff21b75947adbbaef3e4810f4c0f41bddf3ffc934d94333187347fb0c5bed5b0531749b7e24779013c47a9199a3d24bc3f9842ff302d83b241c29a96114c5073a21a2cc46fd8f915efe3ebe3521e00dacf8bd5acebb9d89aa4f76fa3908235ac1bebf54041e3f8de4b23a7b0ad379a8ed3aada432a255c64187fec3e561be7c594afef5d7205d18f9b2936725a6ee25000a4173af29e2637d8e0b5534a45e0e8cd013b76e9035e116fa61418b76405aae24262a20eb62a0b352943183489b2e42da8d479da3196005b0d9486ba6de9ea254c438f0525b501fc6032e734d697f0599c903624c48a0c1c604889e15b7013b0d4659a2881c86ab659f90b44f0dc3007f6b91941a4b49d5e7062085dad61e93bdb37f929d8421d8b2c03cc3f9562f055949df38b60b120f4d197ebeb2dd04b13e4277f9aa2e6263444b6ffad308dead5accf664b2a96dec9e0a9c53e91ff8debc56b343c4f91169c11846db464ba08a6416350785b72e63f2af6808b8dea21387af4f07f2cfd26b2ff103c8e20f65039596ec2419a60d1b4d368f6c81f49684ced078641542c568e87da01147e0aee34a0d2ae2b68c0cdd9b9c8f9acd487ba2e555c2f29329d35cdb5673a8e758dc69ad6c1f529f76fb6dfde2f4f5892329208decdd4539a91ce55f189abae9bb0933f27820df924512a7e884107fa5a975c3aa982cda7e0a002cbb1c725cb788f4ad9ef95d505facf38b23ecae1990945a0431bd9b03097afdc7cca3ab8daa044d449842b5d986f8052855385ef13730cc52b3efba5ce27970753abb06b3122548cc859ffbec4aae166c15f724050ef12439f448d3e116493634a2df0b1224b170dbae9b0a84db82801973d051943247dfa0e9517ff67d1267123b82497dda28f80c2035a293a78b84a7080d02103dc5e961140c049b3401c81948abbbbd71aad1fa1e45f1591ca2d188f34bf05b7f23a8d39ff1f5cb2e69c3c7db396e5fdc36e7658b8d8e79341dfce3779f7c9720d98261fe95799f09cd11f72ac67301d5ea4f1201eec642fe826caefb6c8751a6a546e15a4018abc13961686c259c5b0be88de251b7e2415e0f1068dd2adb9230089529e1c92a0ad18d130f5ba3c4df204c2e368d1f0f0b18911d25fc58254679e6bd09a6c9d3288b017a5a8abdee53547456dc198cea398e2b4e31610532d400b2a6677d94e5d842690be422acfe1dbdc98178b648641c5018f3ba568d793ca7b1b51ed1f361d1ee92e232a832cbd830d22ea3bbdc8e9ea0bc105421f59214bb67f6d8472bd5cea4a128d813a51ee2046ea8347cb438a556e8a1c9983a82a89f75a986dbc38d68e13badbe7c7d0a25a553c11584bda6454a503e871590ea04c19e00f4f9712e59534f37bcc14f413d3bfef4b25a5339be166d55362542f0be5c1b0fb47a76ff12b1fc8144ecdbb8860f2ff2433525b4462be8b7ecbac409180de3aeec566d007d6d627b82b1e39e68d9fb1952491ff437ca0b0044e744e8e1beade541c25bc0c591eb78f41f1b0eff009a9a46ce675aa1f391c4b381395410b17a352ac24903daeaadcb3cb37b527785281274f42afd78f32b34eea84bf5e165019e2aaff86d13ff916d366aeb934ec7d1c5d79a63d38821d8fd8d53ae60c27e1d362558dbdb9dd332447147b420257d75c2352fc557e7c5d008123f5a977d76a4f2397a79a15b024788a7ee197fcbe4c68e0e7c85dedf7e7633f8c1c7f9968001d2a3d0e7ca9a6d3d5e16ab80ea0c44d227a1edcf003300881d9759a1ab9ef686b47cb247d21e5b8be7478d1ed170dc1f997ff6f4358fd4cf5412eaffd44b48b51751fc1cc33fbdabbd1fa2b9fa84b68f0ea430ccd5d86d6f0b9ae60910e61064a2a4e7008fbdf48e60574f50de88543150cd543957d850173df8551252ac0491b197833646c0035d7a499386ef13912a988ded321d3b2a8de0a664bdcfceb27c5d031957eccc670e4fce325f8d18a4da201c40e2ce2d519790ab0194d608a17599d9c5eb9f218a30e775e2352ba9fbb0272f12e7d196cdbf11371c5d354c03dac0378102e8ce53588f10332e554c8c73aab91e19e8168faf5a43a4716417854af052aee3d50aeddab9a19e664e083e8b878057c1f05b751fd9d88fbec617de885f22e2538672b785eac0b2fcb13644897a5c99bfc24fc5b50b83c72459d496e4d1a3f5d2dfd83520f7ac2636c293bbbb7f83aa65d8d984d15d1c82ab9484afa67b22fb3079baf9e7740da02e9c06f3168173df19263fe1a3b751de528d26ba85eabb99b4d8809a63f9b7d997aaeb25939ceaa451a030ddbe6c9f4da8f09131856d7a6627419e24154ca631fd9435921bc5c32c420b67b840cab8f95c7d761a7f79688eccb74d3d063702ebfa85e9472cf28670f77a476c5fe2875896e98bf3d2feab3afc37d5fa33e4a18aa967d92c9885220224517def9f2bca4388d8a67e192603f20ebf24c636a6af400989eaefafb9eec440a84624ef196057129a582572a10cf774dd0ae4765c9c4aac8fe215f3ff6b7929e641e88686a4b836ed503adb7a4ee73942e57a00bedb09bc5a24570e7030e9a896ad6639b970f661e697623722a8ceefe0f6160f6ece93f79cba528507fe293439ea137f52bb3cfb02cb00ac32f25b22ae6dd8920373fbf6a52f7b6983d99d969a9689060dae6e10153a8b1707ef42179f81eaf16dd1dd80fbf36e737e40a5c9e33b2fffe7a0668183c207b17ad5c8baf2df4f6ffad60340515d04ae507585c36f91ee5219c539e375a8a87f285f733ae1d07686b3682f2ff45b7ed8a0728fbef4639946fda946e5c7b5cdb8f4c5f51ce23fb1cfe38ac4278d1a7b792959787e9e05376d9c0026228e8583f13fcbda98bf9f57445db521d64cc4093e6436cf08d4106779ecc74a75eb47a1682528714f915947b4191a6a6aa5e15195adedbfd32e30b4805060615933a1c3226176bb92a84b04558ba2843de466d14ab82af902be550f1042b4faed3c8368ce57f5f11842ebccde6fa71569c753d0ee8be1d70735095c55d4cafdf3f251a4fd3658ce8a1d157fb179f2b2c88ead665843a00f1f90e6592e6aa74c1d2e58cb513b5812b44c0b36815a400948c7d5aeb89fbf2a5afedadfee057beb5f6d3b267dd164ec6427fd89c190e488efd0305c85ccd1fae6d0563091f92f7915d332feee34817ab40b0876bcea58dd310e22d123f3ddcc2c209c3c9f5bb8fa9b81d4b855d73bcbc225ec04ac46497e1517095aa5d553229930cbf8bd9011dbe4ba75814134f3f265a27d8ca148900f647201bbeb4d2966981259cf6710d9d2a4cebcccb4ee0273216b9437af8c55fc9d8dd2e4c0ec9cb33373dabf06ae3102ece84583000a6f40af28ad55d6c29daf9dfcc7e75d35858dc1cdadf3bf551d9bc94d447c324acae0e5045638730c4f94fc02300a9d13d944b23f4c692f2a3f9f19470c5800e418967b0131bff42a4a23186944e91adc036b1187f2dd4b97436a31eb6c5a57eeabc2d0c49618cf84ce5272aefb457b33df7645d5f69cd80f9c2168337c74622c5a2b4e884101aca06fa8545c8fe418531fbd0a108d1a6480b916fd433f0eeebe4b5ff1f58724b3713f2e7e9973dd3b8ed267e6a062285e66487b8fe28f4cef85707783d289dc4737d271b7ea145d895aa87be7ba2f9d837bccf046478fc5f5359bed855c29f86c9277fc1fb2cfbfa6a963b6ca47657d6457c9be34cbc415a945ee6264b1a0346df2abba2f22f4ff34994b210d2d8ddbc887e7ca70a66ab78d7d728321413a3535c87cf12cd2ebba4a000c5deb18826957e1a45a44625cf546f175facb5a4dca5a1cd1bd4d7a34d1df1b4f7b50af3928c5c46b9a13b6a89562c358b840f96a78dfd94503ee5a744048d506d88e9f3b705a3ff1eb0f0cb5bdece1c094f1831e7425b0cbad4fc82522d5b204002329059b68c50f5954163c1722cafb6970a675b1d05595a2c3384c70d25ca69a8f96b5cc14d28b3c817f2d9abeccbd97646e41dfad98f8a78c96eb3226bc4e97d5a558ddee690c960f5bd471bc2e7ec0db116eed1535f7d92bcdf8bbb0e30551c97c74bc88993a6e64bffd6a81928b6463803494281134098fdb11831746a2f527060d08966194a04d0094b6e28ee968d336650d224b8da34d1eb03871f6c00a6c383c8aab59611f31f643ca8eded350e4d4e35476482e6507b4369585f2974d6f564c1dc2aef47b247ef3a397bac6b56344c5b3668180d9467f5e386ed37e859aef9498585837e3d0c2a09629fb951a0d34310e0697dce073b633ff9064b1a02eab1982b1af73920054eb48051876d44f0a50afabdec30bb032dfa4399bd4b8f874dc99e3079a85f6ce0e989fd36a738b4b70a1439ff720a26464fb651b18c2d18b6b60b2ba1cd98eb92b227a74e72695666c4f6fa4bde7b89508ffc1760a822665bd3abeacedd2cd8ca43002668b75d78b2e57a19559cb63904d5c63cedfe0ed9bff2ad22ecde862f701922f5f807e0a50ff9aaba260069a7aacda366258b3a1008a0d75af0d45ba88915d185219481a255dea0b03c103648847f747c37e39c289102e5437acae80e7d2a4c94018f63bdec73d99fab3ff690bd300296876d7d352996f95c1ef0deec3cab272e533334ed2fa30b5e9e159bb61b9ddf0230ede51f6b6dcaf146989d934bd205848cd1e1f6f5dc215930bbd18fcf8ec5a2899d7ca08c3098a2ad8916c62a42793c17b2fba8ad1ff2f856e9569075882cae8ea52af7b7a8aa62f7447e817bbe42b8ecb1902a3435e7464036b329afb484857ae082ba8d146aa50cecad36baa27e485efe851b2fba6a3afee4ac122ac2a6604592165da1cee4741d273422e98226a05c1c0268ae3e9b7ab2d87adb08992aba1bc527921edbddd5d5e7b8dd1b55395736168fa5d16abbe80c3ee55fb6b3c7cdc7041ec1d0fb05468183e2adfdfd5be608253d76ca23d6b8d62a0d5860d6ffa901dd0a7af514e354efd7d7b8ccb011e6449c230e047110c24db09d4a3c4bf683b32d94b97d0c4c85eeaad916e387b4e4d7796165ebc840d6b407e117b73bf1ebe7356b58e18e1069fb40d4163e930a8c5033ba312809585b50e6551e3f12087acf33ebfad8306b1a987c211ab0e41d9a133f1b03b12f6be4670f59847d642532ba76b02608b58416627758d4e2e514b458d34692ad5d9ba72fc6d40d69ad424c2c815feec274f9e8e51c9f6ac06bf9e7d0140d0517617d485ad91146d37ac395abc74094b404b9086491fb1b44f4d9bf519f86d3457098e84bd39bf632d0a8d0a86a5d7402067ed86600d186f7aafc96893b130665ccf8f76b66d69446927f621f00c280e3632984724001947b8ae69d80810f5568baf6e7c4aaf224d7f2b09c53723106f387dbf1eb2ce69914bcb9f29ec6b0efd3006dc16755f1d5cf6a257179e5713439784c591e1e6a0c2b9ab287efa3037b8890cf0ac2325f97584d275c62f284cf28093fbab3b1a86927c72813a2b34cd1ee3f38698a74c1d4ff3e8c334dc18b2397db1fbadd11c32010fe01147740c43e7ff4bb0a5c5aeb64baf7d5e0e99c62d35b6c0c8b1e5d8311275fb6d4d04c298842dc75c4d92ed7dbfec751b843f9d66b25a6ca3891f8ed0b0fcc6947b8a99f23f3d052f551ded48b9dc7bcea2748101a0a904dcf6868fcdf23c622b8ce7c49c5f3b22a6a7d1be988a9bc038d6a66c393479df709bd30d9f7c5b1a332b661fbbae8b8e6971178691575f00bed0ed1db2b1c0fa484241ca8e52454026f92ec7e8926e82fbf16cffd9dd347fa63d5af18320c5ac6e5490d8b68ee56874dcf6c28d86de62fe78a8946a55f74dba0af473ec72550dfd98fe9dfc83a31137930099a764a95f32669598c58214b77cb29339d691cbf1387d8c84d812a221fd1045444dfb8688b48e897ca3e8f5046e85f32dee554057b116a22e7500c795277c5608ce5ef026acd83744cc330d2f9b62b94e388304f24f4cac8fc99f29904966a8fe558df1a953a42fa93c760479549913846ab5a56fc9593e1eac6f2bf2f6137ab261aee70ced472a78bb91bbb062d463bd003e81cfc91f2d17aef9f666b180fca98209d5356a5523c6eefe92bc4e1565625aa12f661991bd288f8cf99ecefdeff84aeb0480268f0b4c70fc148e75e0466ce6e754dd590f840d15303dbf42eb5d810d362400cd4171601f5eb57950f5dd8af86a76105d466edd6db80a5788d261ada5c2b5f3263ceb53d8eeb6e74ea933d42ce41925460395b836124ce150e07301b3fde4d83fa04f23b709a25b45e798e77c04b2af4232296fa19982ec377cf13acf9778e6f797e1b9baa0ea1b7dd39f60157da845497faf7c14dab299784ed0ffd253198a1dfaa9cd4c8e19d8161c3a97b96aafb64e8c4bc265afc0b4b594642fd4b8994827a5d07215013f2b2570b969ffefe6f3ebee51824cc33e64486864b44e26802fc932b6c149694f80f5868287bde0c1184a865d0f865a81af2447dbc6911e55b4cd1fd4e6e53dce544af9732b18d2b93cb5f6a361ed34c0927d55a62f74f9206a39da74a3e6ac3879854089acc68dd3ead872c7a7318fc8f9b963da1cff937cdfd504faaba08ac608e02b028e1be952122c13329ad2aebb253164bf2ae38e3a1121c5e418ca7aadf3d50ac5181ed9aae561c0d9b87efa1725bce020996f1e6fcd8e8b6ffb9a3966fdf1a8e0e3eeb8b9448c4d666b73669c27bc0a801a06de1eb864e05154ea74922b3c6bb9b6f682ceebf5a31df6132ccb838145b3a9e7cbb26ad7b9558a402c4d0c219a443eb271edc309bb241a6ce78887d8442e24d832fa4c0106a2605d10f3670b407bf3fb67bb90877351e29f96dc9957856f06e8917721171aee29a59499f8c9cf2f5b08ced5afb16fce52cc89e48e8f7e82b306f8511f6e874c9e3307f9eca57b65042050482dbbf6c9c023ab91a4173c5e45f4c9fcf7b96958adc95d79259161716ffb985e0fb5acaac3c089894d0b560ddfa41be956a8f2d6f53623c26fc4b2772056cbde1415cd0f5e66e6ee71a4862d1176df87c77cf65bcb25125ac78d072d1ab73030a63992fb1cd9685e05d6c361cc068689859853adc9cb1d55adf2aee792025464cbfa60ef8c69f57d00c0904b68cbe5192b5bc446971f128e08fa69805da03c027b2090dac43ee972e78f3b80105124c9b879532e5964c824f4559519e43f34c536a64b7a4329d66384b767595602375f49b2e10687587ec2e071f0d5c04734a328ffb4caeed73bce329e1172104261a488c5f75a6a68011abe1b5e94b6f4ffe94d6a649e22034230226f9e7bee11477bad0e2048212475a2699a4d275ab08fb6ae0cd00636a815185debb39a704212816d31005f89b4d88242672eb0c67e9b27c2651f0f4efd020c69d140aac7510d781b08c501cc2713dda74c81068f7557665835c7f90f16c3a934d5cf722d21b734abc730f5e5847a4cbe3bdbfc81abe0e7d924614f24dc5b4718a2d742fd1af08407d74ad6698cb19d09e0a72f633519d592c273c795d389f42827a8684194df40978c281db628b94e410cebb98133c97d582f530c1b64cc519446247fe806672a88b36f736f174a37e0de150286f6578daa4f279d9661f46c697c4ee505607f56b41213867721d2186c2279cb02b6bbba591702c1d775591669a6cd558ebadd1586d84642171f74f6ebbcc7e33ec59e712bb7a48ec6c2753d0f595fce7e294fbc51740be00c16fe116c2285c47f0db64aa3228b11000a5441a25e428c6c73bbe494bc2955cf3411d3c4bc5f61828095d7847d85574b9d124267d264230447fc39c076f9635d878c4ed606389af16b23d2033189c7e4c38011c96419afa3579ff034bcffbcbef31138748312d3e8a7f10ac4864b82e5b691566f7eade9c67dd152546b13590504c574d3190acdac3efbb4d8e45dcdf7dac93a9d77b0afbefea6383db70a717badf0b7e1a8abd548b7b48407d20decba4bf1f404400ae6271e13869a815f46fb313659fcf4f34c92f261f8cedcd53404f884f8a987882f8770ffea8ff81cc821290ae2d804e5e84cf6b2850f95a93ee8485670f517a1728794581eecbbf3d1091a69a90aef8922f0607b662b003b496a28c4361a179b831d5a956ceb7a06024b34a406766561ab7d60434479f1e19cf0518f63923b5f44baf0103d3f4e178e1230465a7b37a396918b7a93de0a9c6ac963ac57a3130d96e8ad773cfafd573905357b51d8460f4e113298e2e150c8e0904bd79e259fa96c03eb9a80b3d2ba7c0c672e8cc2e7193fab198fa953712a0c697ae35594f4292927d132242011ab29d1ad2402f4abc1303a5f88ffd487eea43742909b6af6c95bf7b8b4d10de63b600e538b7281d1dbdf2668753e6b69c7096dab7c81139e00490aed6bf82836208ee02e8367737786975671f3f26b191c80c784923ac056d718d3f330bf279c87f995b10d77c63b15b3acf5cafd483e5f478e2049db9e10fc4d5d64e5035a3c2686aaa8f0919af9d8abe56714ee773c2684445a7ac05d953e4144ee285a44320096b1d5337b53e5a3a7fd4cd67aba9869347db81ddfea37de95440343d9cd43605a1fc699167ad4de52af06d209ad4ec2cf52716453bd4372c48035c1c1c6b1692b40ee30c21f7d86e83d4cccc1b7860cca255498650b23edea355357bb6828d5f9ba4dba68ee7c44d94f56d0c01df5b5beb47aa1bfe80b643514051876b79338bff95030af9f26da87bd0e7aa479bb772b2d164942aea28f1295b0950b832ddffd91cb0832b733150d18ffaef90d0ba499eef5c5b12c3ba22d23a5e0b6481ce228b346406443f10346b1c351e11c87bf5f9773468adac65023f666f6eea60ebfd1abd392dd0af4927fe5d360f2bae58a387f9d72503ad2a103794a737cd83dcc0cf8e5941aa5e634cf55153508acd6de9317bab67414e7099dd79aab64a49bc15a7664ec47176a6ce449d6520ae78d22dd023c88358af4f78d97b35407c7bf5f134a28cd7cb2f69379a960485fc84a2a80deef2c1aadff5e190be25acb5d453d8856645e52365792ee84f0b0473de5a2179ed41e2f4d4e3900fcb8da1893846c0395b4d04fe0a319da525b0368c52bd84d093c087aa4cc2ff08a4637905c3f635dece14bcb416c462ea77f1d182716ab84084965d1d1d85cefdea8ef037945f8f968cc21ac40a6c7cbe37bcb17e3feea0a4b51b49a113c998aec18eab47a7afe1eece5fe9169f55bb750413acc50563fbe9a64f0c02529086d0f99e710e7d1278124a189c201c13a23bb2384193faab18310cb97f93b8ffcb62f5be56bcfdf7731d8acfccff38f362abc4b939cce3479e8268d3241a8b33ccd8c5fc8d4e2c5a712c70754c76d429af1cd2328161478106a7545c08d43c604feaaf14c0517936794519f5530af7b89b1f9832184a982df61d37683de195e5a1b5eefa38c1493a4c699a303074fecfeca1c5217717984b06e8b766839694a93e44b256e9b178ea16aa51b650c5ce127dce6196dbb7f7ab33f0ea3724fb14d6d3b0896b28c841485252c300f5cc00b0a2dbe48ceac85301e9810cffb9cfa622b9dab514c757215a3cb0494798123850f00d0020e593b6d8c4546b09bf29fee0ac349af1960527f37732c642af866545c86d63786195f5279882fe2f0403446d144c1ed8f4023fdaf1e06ed63cacd04c8620b313f9f95a0bde59a4ee54883732b219b062b143ee68492b48e3c6303da3e80e7826e6a32924da3299d2a17bcf748a38b84f5b3d6852f03310697f0d6436d23c40d90ec12ebd25184b4db3789fb7c1c73827c80ffb802af0b62c23ea002edc9761d63702ec1197ffaab5a043d25d45ceb3ead88824cecf8c73030b6de1462e9ce30b70865c41bf4b74a7495a6675b83e453a4b1a6d20b1f78289a4bea4294095828ea1b9fb343ce1fd1d21e57a79865d22a4f5a1dcf587b01cd58b13c064074b86ea9de478bdd9ff6d2e6ef3b95b5029514ed960b62bd42fdfa0e598c0e4ec59b3aa0b3d6d40d33f110558a5682bdf5ab611486d8aeb07c38efe294560ea5faa791f3660ebfd51ce05936caa6a0e1cf6b40f0cd758f80bf5c677b1d8ccc60442004bd869c4310b24580dd5a1e6ff4ccee8c60c57d5b43e7ca07cf993f6f0284e8e3f9cc05e8b6d2a80ea6b2fdf320390cce7aba306799f8b387de89c0325ec7446b552567d3848868f9cb59dcc117551447bcfb74676b11a453e3cdd065217864ef3c4af05ea96aa20bb020fdbf18edd5179db7b67b29debdaabea5145a8d008565a627add2ad9a2a1a839a03b2ba5347848d36ebe94fd525016028cfe1cf77e55b00738cc8d7bb4c49c22b0df2c2f983c8fcf37daf7993fa765fe6bd0fc1aaf71a83ad954da01dc1aebbfbbe0ed792149b8d049cd332ce376ba0312028746da4f9c846c1288aad8d7028336cf39560fd799b09116fc0aa5f216d65e743699df418ccd980a0b0babd15390a71ec04c81ca342715a95da2d765f73abf0a8f843f8f5873c87d4c4d78c40b1fef0489edf226d3419073c82a80debb92658eeacb0760d5b361342d8a28a37bdd13597c41dfe3154a08863a562d34f8569b566ed4cba305c7b01df56f197329ff4ec0c89bc6a35669376001ff23c0d3f2f6c0b2c26c1da8ad61ab05761504c165b6dd14b2539bcbb9ed048ab7eabe61fd6eb9ef4397ed70fb4fbfbe062fb7f8a5be4ea43de539c6c807492bfe7498d77115abd0a6a25d502d5ab45b58928a5f8a1c3ff08e357bdcc8c482a71f0e53817a12494f5fb674d55a941ccfbd67fef8091e6e7251e1c51afcd76abfe54c7268c1bf6792a4198c7292080d0a1024255791840915e83379aca2915b13210374b917ea459fb8cfd0d4f9f4a9d6996aa28b6fac27b9e530a75820e33d432cd8273b284612a9d0511623f9e5486fc23105d0f56afc877c65796bee6ed6238723014cfdaa5dada2e248eb4a36105cd17989f9cacace12f4f515a96c04954b03d75aea1a115446c15f8681e5bdde2363d0599d792dbf66d66cde6ce71b4d56fec16b878e96107a2d15dafef3ec26b1091549532a857d5207997eedf1dd65cbe915ef6fe7c23a416bea41e84ef130a8bce80a2bfaa0bd455a8281f18b9291483d45e1addf3a63781bee9cbb69aee314c06c6761402bb0b32e4013d6baa5d16d532198ea28d9a7714e5d5bf700802f8875c4fe3bf41363f743225a77a58767288cd050891ba20c62ecfb79234620285b74ce30c499e24ddcc79e97de5608afc5e42fde7fa2eb8183e10a37e2714118205bb3b07693255eb35a450db0f53d5ceb710026790b4fba91b3fe3bbfabbc5aace3dcce67097fee9a017fbf73e52d89823dc467f8559438d524b84db171ae134d48a468331276e83ea45804cf6ba56944a5bc85a67e744dd10def09e221857af02043fa85ff24fa23272c19e140dabeb20dd34b76c42e9512ce94edc5a3d320161c3e69469d9f2dd6c7dc9b93aef33496d443b08216e95798621286d021caf5c43fdb9a1cc1db9c8433f697a2c83379e44e88894ebbf4236e92e9600339c80175dee687fc5aa5f6fa9650a0853a941bead9a803513bbb973f90160a4011ea33c8196e6ba777bc3f4566a6ed025cb7b9f988f7201f58468a33d1d06273f04fc0310d2e9a4a8ad78f0aa6fe0ab27ade5d5814cc51283612021910e60fd8218b283c167e9aecea65cd5d8e76a1cbdd3f3fc96f530d9f5a9b19d1cadff8f40336f8029d766f3b164fac9cb5794403f60df81ec90252a2e5de01f3740a7e4fd65a6244bc8efb74873d96a07634aefed3fc1be2f5109469bf360589cb8dfc00d81321754b35b2f42fc7aa4108f179df50bb","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
