<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c742ccc1730eec7721ba9616e644ecefafac499290bcfb5ac41861b72658dd88787ce044fe37a9731601748bad623dc8db76520bf023768c23ee8375f895ce4d027368726ff82a4a15fd4523dd804e72f705e2ab02305a8dc69c3604f5eb1aef5eb20906a4e479330696a2ed3cd6c6d9d82e5adb9309c510293e3a0ba90c6b65625456426ed207a0cb5fdcfdebbcb705d58789f73016f0fbcc08decfb8f02211e270a6c49155744c9d7d7f5475d02dc3a1c4d0aa8f80eca1179c698dbfd18ff5fd85dd919c5819d1864d5e5a30781139e945b497fd85a5aa0beacf6bf728bd94d39d9a386e834e30deebf60b2ad3af7063ddcb23113e1237574498c0cdfd7732fd8c53362a106d1ca7f61f7348196e19ec1884de9eec78c6bbc911dbf9920f652c3af2c961da332de9743f9dce92806a031cdd05fb525aa9b34d727b14f8675169e09dfed200df1b8c39d40059dc3aa52b8041ebc0b6fff34a6a49e0405b3e58cf12202c0c27319e0a8c7900df6d51460268362321c5a0b3903c7ac94e2305865206617a389d9fd044e51c827018a74f1427822cc4380a465c57c9ebe8d098e0878bc1bec150041fae5047737a86cc279b42b87a27c3734ff7e9df9c6cc498f631b533b051fb6506367b0741f8b4e38e68099410648c0b258f956a5022f4010652111f6c62c004844217976696f1004e1220fbdd8ced522566edd2c73c8257969f6a5fcbbec25969faceb7d568eca74f4a92be1fdb87a5b22e253784abcc5ee7840b1be0678adb0e78285acda3fc71eafe2fa44c1153a4e30f3d993e162718d1229c659a90ac9b0bbba5b4ae345de51d27e6f0f4ee844025bc0de35dd3ab0b47a564ee0ef8d0157dd1d0068b320ed7796b596be5638a1a778c974546c68869948b1a4311f9fc737466990538a6f2fbcd4fcde8db5257c215a2112192f794a33a711ba86ec76f0c39291e72ba5e3452ec74e747f177a1ccb3b092ef72c59f28887c7f9abcfb8c0848675c6d545ae39649057c68702c71365e30b75430e29d88cb7445e3ff3ca0b34d2549535a1eef0d1dfbf734f601a9f84ef6c838891f39d92092224f6c42f6b1ca3d6cba491b17aa696710c9e20cf731424aeebfa6ae1e827ca303f6d336044810f98a3222d8bd0b1d4bb96a4a753de9b4fe58347062ae00fcbf1d76147c801e55bbc9160f532593ad2ba623716e473752606544e15f4888406cb18fb592e1d4d3b9c32945a9eeee03aecd992c70f7651e2d38e3e1c76e061b947ca9a6e56a9f441c12b41be51648078a4c9c5262c27e3c6e0a2b50141da159b6c0196785a53d616782b7e057bca446f9327195bd84f9d5d3cdf285a33ab7154de8222e946146eabff05bac2dbab11e099a12778f51d8fc295eddd6b52b81f4e537addfe1992f5648572569d115e6e3293c100ba384f67ca35ab4ed1809440e253b0b6bfc241d84ff85eabb52a24f488442eed6c7e365a39d24b1afc39a0879c827a5383b1aa963c3af4adcfd2ab6f29d3771e73c51f41b5dfa75b3d751e15e876546ab9b6b2e63326edcca79287352362f7f8faab802ec2c672794db8bfe258b54634529582e01e853edff3f6517ba30bfa849b1fa54c211037b165c3bf90199c88c2c49b77997831926012a704da818af775fcf0ca76359ac49f09abcd477fadd1c11f18b0106fe2db15b9a850c1dbc5bdd4fca7d7c35a306e69ef1e23e11a776f6c4e9463384e87cecd65d4d23462f2b2476168edeacbb898a7cc7ed91711774a3dae387cedf77512774f40286692b801eeb8ddeb3f308b53de6f2a3ba2e0b49374ea18d69d8772f592478c3ec3f716b9b3974ff1c2674ab6bbe67b86655da9c0b814eeb7ae7a7aa1afb9fc3acf10d9e2c6ecd05c9416330eea9f044578b7852d5e0da0498f16a7e18e9a637dd0d7f119737cd9643645cf5b081e0cc42ce58512226c519adfbcf9fdcfed47599b16e2805bb9c8751ef812a63255e97f54e98999e1019850de0435641c55faf6f307fc25f1fbcac91a3c7705456eced9cee2d40d0611c5be489c2c709c64a0302ca08d06b96acab703de8392c29eb36096023f71c1e748ab5b6987644c41ded66365355e8ad954b901db289cf8c23326739cac2075648a1a6ef257cce3590ee9fa9cdd057c39df929fd208b9e9d8a4a30cc021a920f20f5d4961f324d5e6b2850c55a017da8054d09bd9f38290a00f00d6540e0301ac4918d024f96ca69f5e57206690bbc74997a06db399b8abea07620d83f5897b7b9a77306e2e719b1892352a2d6e27f2d36e1971d02ff2443a05426b30ba559c36d63b667f2f13698d33bf095033fff4b7dd1b31238f8a559246edcd2c8d78f1616599618a8f2c118604fbdbb26ab1b62f3a15d8ddfc9e57eb6010d37bc24ae08a8f27fa61b6bb66ef39a4d4eed8126d0d0f55249b590af1ea3358f0f0f0a7bdb5660d6a35da414c9de107097bd63acc54f15d41914aa6e40096ca3a9037d24aebbb48e6e1bdbd8ff9bae62a7f22ef8a7821b62b5cada08b4f618ae9d32a348967f00738c40d27b39055fb120b77b3d3a5dd2e20fa5a00f538132cde1d21d31c025a67a7f202361f9d4f71bbbd84ab2a105bacc343ee0ce6cb288f7608c3bdc8adaa1255dd4658039622dc090f12f213c2992bf0ee76d80ec6ec9528eb5adaa134a8e1a643ee6b7c26a36fcee0a05767055b6c1de95f8d579ac0782f1464fc38536f5e0e4b665a88d69574995af7a2fcb1f556d718362858fbe753a51cb26957cddadf1849eab6bfb7800ab7c6492741eb40d9bb39c1838f415e5b3fbecb24aaa875bbbf9e2911e7f21e4478fcd78fbd85fc2a088ebe64deba991ae588f609b872f57cdc8e371f5d15c900601f5847e6923c0450fac4fa639c51dd177fb9821d60d6e28cbb7c61e2a3016d0b402276b6307e44abe48a41554af95cee444659c62a2523e0ab6187b6ed2e71ae5492d5ad574913827465b8a2c92a66c86aa17a533f68049ad6b7338ebbda6a83731f0ec95f3467889e6cc1dba0a7be2e2d32d7c36dfd00a6b00a2d061e5be028c2cebf95b193a18dd14186074f1171729a5a3c3ed99ca7ca9e73cf3e370f686492c44f77accb0deee7dee973036b2c65b7bfb384a77d9fc9970aad57511e76986acb057c7c1384b1965444ec0010a7ab90340d7389c45411dfa83e3702dc4761384b1bc44743db818ef6c4c658367c6acdf6397511aeb67b602f0166b39b4add03febf1d8118a5b7cbf48221f57fcac9843ffee81efb9022f04bdc3f8829f7c0f1043ac70a7c055dde0c0f6f0f8ec5c72569bc521f9744f65e07c4210d055531f9c33555fdbe81eb4c86d6e53fae17aa3a7b4cf6214cb6c2d0b052c029b8df061399ef75a91832c3c151ae9588b1309104d87f4564c335dad11d393387b992e12abb6e6954e4dac47b2b715c08a986483a11224369d570fc001a53c27b213d44bb6a788d2a1a687e515d29c3d455e1a98630ca1236d2af136ca29e172a1e5e6d7cb37bd18d80590a8de0049fd601cb20234f7ea4ee40adb5f71c49a5d433549a56da089af32438ccc1c986ed0289b67643b9fdd1860db651dafa491692993d602c40c4add18e9d34d8fecffa0ab0883dfe22e99aa881bd997424ce479e699b4380858de9deb08e460fbe67970bdedb041fe5ab06a57f41fd8054d062036047d5f8301bd74548a8bc49ea3c543d81451153c33fa275a5b6c6a062084f643f51a56ec9c7105eaebb07758852ef3d6e495a1e96892be1ccc414ffdb014866a39e7e481fd2becb0b281fecd0c05275caba053645defc24642f925fee9ada0116822d14d5894f6ba6456a8e08f508214eaf32720f676da7a0709ba342e0108782b48b5484f7977542905ed972fcec907d206f4b5bbdcb0b8b5fe35092197e7cbcfe65dbbce10ea6a3e8a893b8736b3093d8dab5d18755709ecafaf78c4abe23b1d20d9d36e620863f2061495b7d54e164de356080d3c4e902f95ce8437db81dfb7dcae00c473550f6ef0b4737e256e105270d9d7d553c277323b004a2a9ecde93d8e4d2453e1259142bbb300e4b333acbaa08779fddb5000ffdd4d2449d6c690373723bb01b68dd9ba3773c27ff75291c30b7720e9224de087938ab1e40f9ef73e05b9397392a1620e81af40d6b07b5cb359910fea5a4c54c1ce17462c5915d029bafa3151efa54025fb2ad26d247be6aca0247345aaff1ed2bb2f2133d24b7a5ddc7f8148cbd8f2b3cc82487b7e5c783b336b1c044598ffafef323375c2c3842c2af785018890193be29465100a94eacdfa35658582cb06327efbe72a2dbcad6020c8e9e8b72af3c1b76df3186d6aafa04add2777bfbb38093a22465b6eeee8c5f8dad2f566f3399e849a883f03c675b1dfc14f8bacd977d1d900c3cf4350acbcb7c807412a0a8c1ca59467f30e3c4a632af33deeea6103bfb82a1e99622a0e635ede437a44bc0abf9407968ef98babd23ac03a8a662bfc9b43e9a80c9957a1fd51f0230b4d9e19fe00a990ca95c1999611fac9e4f4ae5be0729c006e43cbc1c1f944148c167d9e4246ef2622df3f5dfeee33cdc9d3157027085545abfb4d7e99c9399934df7ca9367330469643f9233052b2e02f59dffc0b0c3c79adbcab3d77a1f3ff68538ce173e25d5754ed4f60b52714b2dde6878017e9f1860e7cc8bd5086116d7794641add399a5d92ea9e4f4c7e591e459f5c98558ec33ab3210a8af2355e0d3612dd90f709757d836b60cedbb9a538da588e7217dcc2c45b3608535b7c756b7da93cfa25f5caf31c081de1630329f59ee6d54a367e7bf3093818e81a9bb19a9cbe129d3ee9b1e39bcd80d2c20f116e272afb54d2fe81c561b50b7738bcbd39556ce652e6aef52f8ec08af585842dbaa2f69d73b255aba346677a3c35e5ca13026453ef3d86cf41e2ad6c35f0ca0a7728001f6a9514397c645e145e05de9a8c05d979a4bfe378d8ec893388209344ddde4fcf45b2bbe1f32dceb2b8eada883c3bb82d4fd3f0c79b52a6be36e45c4dbcbdfb06c3efdf6e5f7ce3269a44fed718d70993834c4778c96c6c5ff6ddb17e9cf81e572c3f2921819e411d27d4010e6f3131f86e8c386dbac009b8299cd27cb62aa6d6b7e16f41a75cdf0c00343909f15ae11dd9f8cd76da53d55d198993261c2e166eb0b8c1324b1cfd361b3fcdf2fc8cb982c9ac034e63dc2d1f217fd25e7727369c861faafff53a1a72e472956c66231aa300723280999819cd795b5cebd1798c33481d5815f6496a09554261fe9e34b21f0aede0e94857fa7acc077896f1ed86cb276f57d19365cddd9c83543be65df0e5d18549960cbf7ae2c883b8b5ef79a12ead4ddeb507676f3fb0355994f2cc0ed63230ea40f82261d880bb85ffa0c2690eb23ce76c00dc848e61f07aff84173381839ca9c8740f07a67aa6fea9f25e40e71eddb9ee4d6b06d63056d068769d9e86ab4027c407b6d783fa32afad48972a19d20728edc6cee7cef8e88b73b338dba7d4f0d66fd5b2d71366d61577da0fd6846dea3de688996309a58d5f86089bcb1a303b1760593078d8e53c1e336da915dcfc40c103dc4c71abaddea8af455cdc5e7921590e684a72103d85dc710416d423e0ba576cbe9202e448361548df79d60a843d1d8cf9f677f2a716aed362ef1d1d2078fe63b79704e652d5aa07863a964f395c0787be6b4efd5c2ba2c8de9099293d16ed10388aaebe69a19f925bc837b67eb1aa202644c68f9422705742d6761dc147b822f54d0afd2a7a7549a52a7be5ace20ff9a6c6bce73eb5a62a7f23f925415822f444161152cfe8d2dc5a46a2900b2938823ca4c54d70b9d6fc3bb515dfea59b10354acca5a793cc11113c40647ea9bbdce688c001414daa1be269614ddf902bf0007f05fb37ad2e8b3f9ede74fdb82b76f9026a1cb44ecccb7465aa844c1ff36ac0ffb60937dd5fdd16efe8c819dea47bc9b12efaa62a191d13a9e02d5223389daa5d0ff93862db219f34a21127f38dab1de7217deb904bf234b739a83b3dbb76ef8e9a523799d7c3e2813f56b846e7c60fe482c0c3a2eaedd4ca543b0bab0e366e64a71627427fbad1a6610455f74a61b6f54b7b4d32c9855a68b51bfc752d10f2e59bcec83420301a16ff8a32926742349d73146542801445599020568d3c8635d9155e6c0b53aa454a63b8d584bdecd7b3f21badcdd7e21ac52ca844c11d60ddaa01045be5d69a241fb52e4ce552fc9c7cc99aab10ff06b40cf62df57d792fef6363ea0f8efa935e2d958fd681c9917db19e0c3acf24efbd680c9d6a0e50c145a160e1fc395a6588755caa1cf861b830ee707414aae01e94c8725408f748ee46761a3e042ca4b502749f6052f1304efced0e6b450765d25dc3d6ed912241547a69683ecf142cbc65fdf5abc0104a9754751cde8c71a9b69143c6f1c09ce4d1245cbfdaf133d5a733d3718beabbeb7961c21654d61c6112fbac7ea645001db643239519a28e3e37f54e5180affc2f9c0b170e1addfe2ea5e77100ff66a17c0964e4e141c235f1a2cbe495da40b63708abb265d6cd0b54de8882de8ba812c1b4dfc8fec8457e6ad55d29242e339e84342124df89b6083dfcd48e4820137dbc1ed8a2b94c7a9e6d3591cb953ac5b730de105b14a63ef53428090d373441509801aa4eeddfa36b082b6cba156fa1e5f4228e6c4e070f21bd2bbcca91e5550a25b43b096ecf81bcb68e5d952c10405f3a6dbacfc8f14b8b213515dbe0fa844b452e860ff790f464b41cac51f49bc3ccb204757e505cd14598dfa36d501f1c9cb7aa9aa22e4e336a721f318895c8a33aa399f3c693630eb45ae514c99750fe9a11025aac585ba76172a0fa97363a5e5de5e5df2b1014a2f6d4a9cd756d83373a96de4fa67dccf961b6f6ecb3c9ce1b2ab8ee75341a58cf412269ebe10979c50a0dc50a8a76c7c11b354884488e031b07076673950698e8bb06a30b3ea6580eefd5379c349dff67b5bdbb477c39ecd24cb71a901f3719dba91e7af261536484a7e72a85f7673baaeeafe3dd132dcaf0cbe708e8faa76acccf17cb3abc2999a5af11826aa3d1dc0ee3b412eb429bb284d17901c39ddb4b110da327b8bc34fdbd313a693776d590938afa69bbb489a8e6de2f828ef5f210462e57a7b6679ec1fd05e00c570a301c9cca566c4fee2b257c39201747cce1d6717826415a6db4e2918b260e8d250944a4dd859465bfc0ca4b2414102f3e3da609d2d7c863544209151205b9bd15f14b4191e695972c7f405b4cb61ef3200746f92bcd53cc8fbac8c4188628d1d5fc189cd50ffe8149454abb10ee09e2844d170684c64d05161af8b5cc78de568d0b8499d99ed192b6d5c83e4767bdfecca9f48cefc5a5d47fe8304597e624e00d8df85ad87e99008f27fd9f71e091c9b06a7bc86df78c8e20dc7aaf62cf5927deaca33e79d1bb4075655fc7462819cd0add5ab36a8eb55082cb64b2a3e5d6563d2162c659dace2a71b7334a68f00a9fe2cf90cacfaec9b6d9f12a5ba9a8977d8b9cc623ea92b038f9c4e87db1d9e8b7e0458a2c1dddac0d6a832bf8c62dbd1bee432224aa62fa6ded11e5d822b4c33bcf2aa130c24e3ea7f1b417781b0d142eb3b5ca8b4bde8132d58e2efce76192bb32f8f537e78753f0ea2dcc584ebe4b3d04beac42c45c870700ad8c242e754a1e7a5882ed2850226ef43dcf490560f1a10a94a61270c1f2ce18db4212cc9c6fc210b9cd390342f1abe8451333e5abe5e1d8657bd42b4a45ad754b0be3049f32f3c9f7272e32ebe78fdbb35f634bb99f5562430d35044b817f6750d0df74fe1f5aa0684c7933123312c89dc350f7aa8c72cc89c37d5c8c8ff4e119395f9879fb097cd1cf6e4d1964280308d7c79610e8b63f39e964728de10e43793400f0848e6f081d0a06b0ee16e3ad3b1a8462c9776de505114b8a7343d44e3d2a1e02e5d201ccd35eb104fdbeb0f1a811fe591c506da526bdcd49b8e7b8a78415c329dfd9d0cfc626ed1cf88675f0c85c83b867941fe412747db9360816af95caeea9790d7dc61744afec96ddc1192a67fa35e532319b7860e2b3747e9916bbc321e7d80c8c34fe0ed803cffa36a0e01edf4c0c52d648bc23326bf29705ee5da9b24633bb101aac59aba658fc4f42f55750eeadf3aa967fcd6d68e680c2a49b0c08f2b3575d9ef866a2f084003c7e62b2a0c7e4f6ae6694483509f6cb3c2b0914bccad53800f209f5963cefd9375e7723a52498fc2dc67c473139d0817c64245be25f4aace6947993456dc79b7df6f026931e803a26aae966e2e432d195d0fe80bb5a9f30a8beca4251f303f896e64afb57101acb578b9d1cc2d28527a0b3d4011b841786b558f3dd8ad6880a6913d8b57a16137dadf56c4adf173e51d0b09ca622be3a4fe44c0bc5a986b03a4406960936635284189dbccf0cabe2745ca5e778bbf569268233d6652d99bbf0eb6a20121f445f16143d920e46db55395c767079d8906089f45f019d9fdddda271ae8942bb023ef7e160c9083e2a760c81a5ba523e940353c083a051d25f43a2d9d0e0a9c1fdc49464588e82c5c17f4f2901ec28d5d6ba0dd532c00daf8726fa9ef3c3936b7f2282efb2768324f56f029dd8676befced622ec85189bd7388263f1acaa22f1f14b6fd4aac4a42e65cb8cd902519e6e599fdeeb3d0e2cf68490657a34f06801e7b75d7d8fea66b1b35cef63681f02ebf16fbb7d6052be2bbd92bfbe19ff72a243ba7c73b5f0c68ec344f66db18ded535f9d1d750cf22798a57f6cefd70cfce80ec78db4b62a3252a2559895cd56d9124ff86ea0e5edefd3569f2ab6204d16a8679204c54a54843b6376c85d4de8dda94170ea7939838ecbb3526fae4975afa26b9c35b53c582ca280d82b03095ce5a5f26df47e192239bba1101452430746c16ea57cd24eb9dd503c6a1eaa30c80ba0cc3c49fc3f712d27a9d8a17724da6536facfa0165ac3395bfa0eec79b2a677da13604201b325d48faab67e33b17d8a0c8121e1c6a28c986a2b28e0b476c28aa254e7f87f3b7869f9356979d1676336bd2680c52cb78cc568a36fc8144ecb19cd7dc7ba316881cd811597dc565cf8724faaf7ba387d95e432bfc4c6b8a35dd73105ee29dc5fbd807c9c15a4cc4de81497495187927a5ac8f8edbde53ee3813d44a203d0de4bdb2381796826c0697a8462c3bbbdb1eeeec2f278bfdc8fb8aed12478caa5736479af4c2624b7c294c767197ad34613760debc53698cec9227a4165f1dcf1a8eb1b1131df62cf8df89a57e4e424d3b44cf1d013edbb7d557ae9328a29cd418d6e7d05438f19b48ef0681cdf5988d8c5982cfefc928be03688ab0d1ae647068a366d64a589952302f6d0a4377461ec1b99fd9d68e28dd6a098fc08beedb88908e7f8882baa47cef63aa3469ff5afb9991c91dd0cfe82750d2f8410080aee45fa391372d0e2fd36c602a8a2e6f4177844436607a8b1f54eefb5691c2daf1889812d228f3b6764563b046b3ff82f6b44e0ff8309112112e06677c5122ea6209019b576ce2751a7d8dbe5afac2cc6d3d35f3cc8c46096f67399484a4ec637db68fbfe9791b7a02117dcea78c4f9e61b87a476cca61a58ba7be15ef1992c5d0b6659c8a887d8d334e95e82109ffa90e013dee207eea23779e544222dd6db8e0a792ddfa2aeec79206427a1c8376009125347c20c855180a2bbb93aa30e6f6275e3a3b52b0909996d302cf59173e835c96998255ff051fa3c5d99935d7e837c61393c2185969d935a821b745b62cd5fd4f44952530e7e31494419509ed2e30ddc5394fc55ee6ada645021c57e3edbbf4ea68dc95f488248495eae82aa9d385e380818970f056f1202dcc44cc7c1c86e849c82ca355bb3b4775cd6f6009a4628db830bb97f752b7d039e04cc11f1cbb4d2320fba135ce3074479d2f2190462c8aefd69f3450cb02186f5017d5feaf7dd1dec95a484020bcdeb47ae59826e0b3eb74e52bd893ca6f07c16ba6ff4a0a327b6e252cd40f66a126b4f8e0b37c8eb5670a93f823158a22256d47ed399776c2e47589a58fbbbef0a80e09241d848186fec79acdfcf71e6a63d488d53d2336b20a19a48535f0f31a38e336c28d44a8e6e2978c3842f145d54d80ddcab2f80977b6cfa2c70d6492fd86a4342aad4e3ca2f497c4854b7304a1d54da3eeb0ea73feecd0d880ac5aaf8eaf8706f70e468a54f22375a43465700365acbbcd067704117aaf778b70f510971b2c617100561ab5475e2b1085dbc9ca9f998c6218dd2def30b64e71e3bc9bc3c0ad0af4741fac85f11ec393be1476290e7cb685b69cf0ebc02ce27d8f3b60b32a5fafc531f4f113e66ae48228294a17d074e6346269f96b494b66d52808c95e9600b76096b2c2814d61aac327d6a77568fd03c718f282aacadfec4b7ce951721b23cf1d5e32db3a57bfb3a50a52b69ba72219ef85839f266d74364fb5753d02f4f81178b2dc4d81682b2e10d6f667efc4aa6879dd7b397312e0d180c5b37863e68b6367569d612d40aefc6100d81ee4c31df7d16cad5c951a8e86387e813a6300eb4d7bafd72392f288c3afb69d3b457368d0c843fffd7bd217a3d13c8bdbb3509d7950c07a81b84d50dd384dd279436c27dc325ef1b7fd6615e7243641694386a45ce56a18ae5d8f61362ac8bedeaf6fa934cf48b27fc890edd400787b881c87b58ea20607fe62096c886b8ecec04ba09743db7d87008329cb7f9fbcf383dbd7176636cd1e09e9a3858967474204fe5d236e42e323cb1aa49b098706fb95a8abdadae5f1158a869290afdc1804fec1c7a70e35462b57709f85b4823cbb22013ab3ec946c1227ea641e6b87abbb787bc3b0a6d99d8fe3f85a26ff3811ac15fe626ca29c58cf1381728897a1b3b912d17c309843e9db12fcb70ee112ac6468b84bad5005bc86c480de4666c17746c7dd9b571e892ca1d16458d52a1068e9177e07c986029be9585a7b3bf6d81e79b1cfc1b7378c170257731e499cea461dd76ad2363ad1ca8dab998f931a3f374407ed7d2de1d813a2200ce9bee9b6bfe29c44c1c41421cd61339585260f125467dca0ed2ff044912ec108ace1e8db542c1b69c32833702f49b7417a4287c2b8b0b7201a60311a38a57b9c13e623c7ba1766dae8b07348e3bfaecec3bc1042fdea37c95dda9d19e3376be41a2df72de718d254c7d180b9616679614f55e72225b0613fd9557e2c4f16787b92f9c514c93afc43062584716851f0f434949e54321d21fc06502d27c7240fe9c9d56af4404b3a5943593fccea09de60065f097f672b43797fd701d7b4049a9fa1c052c8832d529911b3eade42ca6ec6690214ff4f0d6398c78a12a48fe1cb96861dce6ce8a21aa957b2bbd5be919ef7c9e739155c42c98af344cb0e12b104caba4859c9aa32d3584b85fce1a449fc1b7f9064e10765a3786e969490ae71eadc0d550f1507169c74c8dce2ff9b904c40f71c69e4a1f7a8ea0e65ceeac8133783fbb863d8950d9c16bd10b0e17bcf2ab2d3cc939258fc3b1ed58ba74172b9e89ddab042ffa475a86ee503b875308eaf3b5dd22d0a41b64189c781f47f741095a665452fd772e57ec534aa6caf20b01451b2591aa26222da4e593e7bb897eda073a713450e13f9157696a0b6e1a66e5cc87bd791a3f07ceefe0036b236da9fc08b596c365f62fc38d2cee2390deef0e30f7660d16d8378d9d03cedd84f1492cccd716093ec45e7cb2341b66135cd9cd1ff94264b26064530ac5dfc575c427dc9060dd0091a6f33fd616bbce97e409ea481c69d435ddc8528e696ccc2c27c90223e08b02efc5851a51e6416e7f008ed953149e09f70086aca772ac97238d167dc36d666cf916534f19762b3b085fccc26e654025808c9c0a7f1b4dccdff96f581da5c37aaaccf69a40e43bee5cb96978677b87fa038e2832ec16b260f1a6e5f7fe54cfc782f4e2dc040764d66a4879ffa8d7c66e0c61b7a5188cdf6812094857090cc5c793aab1a345326be53c08ec77e260ef90bdb2191016461843476b7768290606d648af94df9151063d38671339437b79fef83a4305751a3f30c8fa9e58b64bf77fa76b07fbf075fceabb4719d0d2edb55de51380be072f65b92bc6b2a202f50ec6e270729f0907e8f02ca10ca208eebd0b17864475f6e75c7139fed84841aa71cd1b3d6098cd3d8be163fcd01440cac9846cb9fd1727fae2dda409ca2797f59152cde55c6cc2c2c73776308e18aff918be05a291439c6f47cbdfd3fe48077ce2584e1d50d93347cbe5e9c9f1945cfd8e38124b474239bb01cb7bb97f4a7a37a4fe91eeb4bd5c7cc4a85470718b15c2ded97d0f17ef6d3ef8e9448be24f82fa57341cc5cfe112ad889ac625765f4aa278c9cb8ea32c495794cf1ccef2671eb4f795f096ea617c7e5fe648a46dc9c3674098296dbb1fb1a8a78299386c483b86b134d46aca5f30423a3451a42051e04d44d8cc57779e06c6022b5b97adcaf4451834858d462083b0508725ae0fea6261dadafe9b23d96591ac5d3adcd99835c98ef61b7ed7a3a1a20a5ce6d0db71b2671f112ad4c4fe59edf5ccbaa3d98f8e4821b084169ab0897cf132bb164476a9782a16944356edbcf6dfcaf522dbf68491b456954686123538e2b8e100cab93bdccdbc3ba88b0e0a8ea359358bcdc0d45ffc805b9273519c70a4b54e66241b7968ea50b731ea03c42dce182e53ba6b0568ed79b210458a4b4760b5630aa087f6cff4d549c3a13208d60b8c22acd7dd71e425543d2170f219c0f5fc203d793c2313fcb94f66a23edd9431d571c70b5a5a614dacef1ac88a53c63576ba5f986fcaa5e60e44b8201014bf9d49696d3e1b1ce7223d393c59587b5c0fc9c20199421fe1a36eb2f8f46073b3b1f2a29cd2e9c551d6073f810bf5ae4804bd5584132af23c3b96c9a101ccb5dfda9996926cd43993acf6316b6b5948a0eafc1aecdb94c44835e706bc90becd510f4e3cdefcd9f5ea671136e96140fb3e7744306d6ea7c41c9ff66d50da17949c16a5a7ed7626ad53d547a3dda5658a7b3b9b940ba6d7a814bbb51cafb7868276201bbaa6bfcce5bb7d482a4c18b996f7d3b7a7440a95174db2d401b994eb68fd4cfc5d0813ef3612b57672b3dc9eb8ad036ce424b72942bcf2751ea8aa221e837e97fec13d7fcd359f84bedddf049b7f2d2da019ebd641a00f437a8a891c9a7c13345b46c1d5debc6267fdc4f886cfb7b9070925ac08176785a72e5875af6e6e0d632a06db66dfbd1f9ac7e3d69f7b4baee56d9cc441505c715f64fdf2fc202b65cf5b26b9e6fe14bed0d072bf2ef89d465e9b463d9df030e5417e04e330e6880b5159e91e7a0e418e8923df35b2ae21e5591dae5e5ac70cc94be289c634b9cb4599991a04e311d0fef5536fc8774fa40277e3b421b68bc3dcdd0836fccec8e29d1ab87826c76cb98589276403e43ce65d229ea0f7cec1fbc012ac5e7df512abc3008616907009b07b7f321fb0a459a8c32b171c745a2fb1c185538013c8f3845a1f88295902ff5fc374ebc4f78f2356dd134045680eeb9928fe9a93bb9a0a14379d0a24ab0224a54234aeb02e85248956d998d244cd696d2555517457879749f4e29fad8aa71d48692c87ab5614efa6d05cc7308bdb4ad0a19e04bb311f504f1188281022e8be0faa461c721564292940d8ab02c4cfd9e33f768ce7da533549b6603d28bf855d44f1701d9b92080b8a72ba7d0e79dba3cfb1f0f44ae8b114c0ac79c41dd16cf297df47f47df8371dce0de2d2d47be4290dd4cfe5b85292806dd0cd48261e2b04691a77454b1dcb7960b035713d948f28fd2fc40b5527bac736c778065754c4de10680dbeacb5d6b88359d826b0e93a0486bc966b19ce3d470a9afc0913896a53d625102695ff1ddfb818fd337758a018ec89dbf8b78b7a096dc2c29127ee5f2b479872be6b3fd2c019c34b5395a3c418170357e0500b1a08cee31cc12c4682a6dbb0f6642cc37af2111b4ad15780d265c0a85946623296d539d84c8429392cad5ff02d119f3fdabfb58e243fad3633a7b0215ac4a4c596b327c1dc7517d1d7dd85a1eff873855c1db96f176b8d89b601d691ff038d0cba505cfa42db6dd993c67ccc072b8ea23c3ca94cc7b3957f436cf28307be97018005008a51d06af352229b67f61ad9c0cf38cf7d2eb9fb739ebb1cd6c30484ad46ef2ef61a054bc75d87cbe65714c9fa9265b28be59a7779887f5276f7f8c0939e78b3166339ec87efb831a4b3350046e83d26d4a4628f11112fc7cb9e4638867765aff2a85d1cd900926cee0f3c6461203f780bc6d68b3a035f73029b939265a40d747ba53e735e26b1768cb150852208a81d8ab979dcc409ba3add250e4b45f5d1cc7ccd72454c4183d571845d9efdbbac072305a14d35ab96350cb0073b60f41a737e521","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
