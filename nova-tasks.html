<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"105044515614d2365c5509c28a7dd8e3c07571596befc5d5f0343f903ccda8908add823ad4d5d9d787c1d86b681582023c2c6755d8d90bd9b75fb0d800f2b8423c2a78c33c9f1a9217f283b598a22f2cf08c641c3c81bf1b3d09f736417b188cce1fd7b9439afcfbe4e10621f06093f9eabda9470c5ba99d17d77789f8326de93c9f025f5af923c386d446286a2c04a72c5984178fbcfa6c66f160a22c9a89bbebd5e2aeb83b63f8b56a01234612a5e5a0275aa7fd3cfa8e6147d6153c1fb41594f0a6d8c83eebe93c5252f67d7cb0ada33abd43d25467222dd46feb441404db573ed8d1bdfc1b454ef97faa13d1b8d648ebe9d84d100112c9296871873fd715ec40b01772effd9e1b0f51bcc19764ea0b55c0c243f70656e5d420b704a97bfdbe16a2023a932bf81a9029ad26a1afa32dab8594bbf1fd333b7249a696dd50c2f1f08f25e3bed660ef4cc1413eae47968e1d73235f87dc7e4b4a74ce2f46e6baa7ba1deb8063bd0a5386e25d852ef2ed180412c7b13b67e06e488cf453556c3c5b2fa4f88121a64f68521e293eac28143962376878a86b643515d04c9a7ef3a68229006311b65a96049e5d289da7d97b679bc0e0d9c99f329cdc273c8e728627a203b873e85c76a3c9d1ccc7f9cb3fea4af10937df9bf14394b3908c94a87361ae03c437abb9047d094939fb8aecda4700195cfdf2856e6109e5ce8ddeec1e26c56d59f23d852820dce06724db04ff4b6225a708ded77e28471601ef449d1acd0c44fc6606471bc0cb38b61ec488fdac5c1caa079ca194eb7da20da0cfd0646b416a91dc493ae94eb862e1153f022ef903bff0e82cdcfad74701b6b913aa49d93e5b46f766a69d75f789b0074610d9229bfdc16f3b47daf39f7f1cfee85dc7012b5570014448bc56ef4df563383ea2c8aa9f6ca132ab576907b1534226c7020077aa323f958ff3260ba285f857ab10c0a4c3a589b3db60b821379cddf8e4cdb48d12807f9cc1c802f29727ff60c4988649ba32ba3e865ce68a915ceb524c11e5698491da3ecf322e6ba3b4b17daea80f56ada957c07613d9c9e4e5d88c136b7dc92bbbe5f4b47943064b2427358dfa350439b525a460452dbcad697a52cf8580625909ed19adeef70f62392a360d37b97c12d9c7ba8b41f99bd31744b28669aea49764ff11d114b871d7218bcc1cdd1807721b2b9dadaa19c8b221cb99906e17fa8313d7e8638a9874bc61b18e253703b7b80a9ed82a58adf77d5db3b9a22a5adb161dd6626f68543be26e9d5ea7ce7bd4f1e5465c5b1370dfd73c6d3394eeec5fda5f54a14e79bed73e9f27e8e77397f7fd91d0edd791b1319c5dc45c5774df36e44fb0e236dbc690eee27e9069ff716e7c40eb29f56fe853ed7660602469cacd0be1abbddc42da53c703cc667cb2a4d37647b82854818f853f1b1979eb3b8c7e640347825713bac130b9ce8ad5608e92dafa4fe3752d7df228f97b9abf15f9d7b6f44e8516b3935ee354d5be75326a91f1fa54163aeca81e10ae34974f6b4800636c6c30b920eeb36aea7e1a957e35fd59f0449bb132e7ffe9d0a156c791d26a3210562a376116f5f129891369343498be428cc4197574541599d09b0c1dd51663bd3790f7592dbd185e9c4247b8be514dd3da44bb90beccfcfb95a85e9d1a729f7a7db52faf0f3b9aa4653ab9aec3e1bfb2387b75ae7510664419322c54e04641013633f77480d4f320aabccbb99e0fe19130d933bcfc1eeda1159a93e05d506d66ff541feb38bbbf6d0bea36a4245d9862c2df641487b6252980bf45626f2100fcb9b2621702afb32e575f471244cf646b9f8afce76c0ac07807a00fb3cb0a539aa95e1d9027315ac9d978bbd6900115be4755bbaa217f9b251c9317363f41010d260de5234877a7aa56bf720d38b1d1f4fbfeb9f0b8bd4197d2ca692606dc628a3a3321f921c4e05db39b790d6ea0941ce9e73708fdb9c5060f38eda0d28d3d29ef40e6c586e16adbc382b08fbbc8a9319814b3a36086837f67850d8e67f6d4b59a52510725dbb8776b1b41a054d072437956089ec32f5ac8e3ea643b6c68f586e34de26783227070276034c9454739bafc8771ba0df6cac9dace8d22f5df790d7b2858f9cd2b3de227307082700f5e71100a35502b1eb07613c5d8ef972859f5c7ba5db9cb8a27f21238f45375ec5af8dca7c785d96a63c4f7f947781354d6e7ea950f1aef4d417ad09f5673704b1c0175edcca4177604ce09ca404e038e3ac9a05d503f62f44a3f43d11605265fa729d74f4e18e9c2d13790a27b586b11e9570f6866561a81b2d0265d0a3d3bcea55d1008e66f0c3a5e8a2d2fce1b68bf82105c0ecdf82136e9024600afe76efd40d37fc16e3372d97c54e1f8253f66f462122618a2eb0c82d1869680b2c48b80c655bd741f2ff5b31585c2214b97ad8c415727dea85279cfbd63dd4c3da71e651efc921ccb6562cc3fec80f8036b13751de7b79e479669d67956375198862deb67b4aca086aa019f140525468975dcb949fdcee29d3ae2995db4b6f4e212f9775cf1b9796a12f3ba8d013fcee0549edf315a713d6bf5f13edaf427f6d4d644e4bb91c042d6402a1534a194b23e6d2e28da848214d505eb78000c1e5c8e8a129136d49191f0eb38da840460f2b6710ae8de72cc14ef5cbc8c209fb73e9e928e5bcaba4acb5f15dd906c85dad7f4ac87bf402c72f2b06ce6c62b12c716a5361ec5752d540e45405e0da4f002faaf6be3fd13d97a4ac05d0d848084f3905b3484ff10b1add343a470b74ec36be16ac921f20187088ba9bcc1def7bcc4e7237639b0915ded80bfe04752943085736cd725f25479442fc28cab7c01f61d9f2a75dd8ca66ba8a5405a982b32b3bd76ab93c222f16bde8aec6a9fee434cb1ca8603ad88f318d2e7db9d27781332e86547719574bbf074e91f39fc0a1de91de4b0eab0c5730a7684e9b0825c9a5eaa3c992ca26b159c5a18d480d39c89c6ca6f992d863325df8cca3b7111d8d8c8fa80376bd95b8ca993ced3fa65171e5cf3bd317fa9155efff5b7c39a64ec7cce9a796b907a2b96cdb41647efd600b7d1e606238ac6400e38be0112d3b10304fb650a9d9e96aa2be3655f40f7316ada55eec302dc2e92f78dbdfd9dcda2da8d805cbf45a4402dd8dc80fa195f0307527b66216ad4b214eafec955d5993c26810337a71948853744b78485f4d5667f674500144bdb414dedb14251fb4638418c524e1bc7dc2370777d801c7ea482e715b725a0a96e67eb1d2937dc447734bbe365a5a1e3745f32f291db1127e86fc735b02b93b0b4e344bddf1103ed85d308d96b1c7e6645b02ee4fc3cc8b91e4c8b769f491c63344984b1a55433c455d003f9b22186de09abbcb4d7ee6a0bcde2d11a61877c8016ce387b4a7ad56fd94c383a2aa8ae4ea3966b965077ee6601fffc5e7394b6b2593d1b849000335768d404c5c15ed2cca9e737a7bc5db75d395037a616731e214d83a8545c8acfa3b75d96d937dc419b6c71311539e1cee6168e48e919286298b4400ce098d036ff0c43a24da083371d843ab9ef3e1bc511c9752a2f77b94b5e98960576419ab45877be8d9503f42a9989ab991b6a2cb30169c1bf0504d04d12ae8eaff258c9bc9d43406ac9ed83a9a43c31490465ba17689af26c60cdbc89d58827f2c98d7fa5f9abc6e53cbb9d16c863bd8366c55ec3f3bd496aa134d538b63b7be8e7ab9a0f76d35ba3765a82fbb16bf4955998ccec4c6dd2ea3e3ed855dd2cda1f679b3dd61c7ab518f6a710c8b51842295edfb7f2d618d94f61a76c2b7e6acafbc844eb5b931b18589e1fcfd230773fb3380a7682934c219a92720f1ee80319c84f5254dd4478a2815cc829590074bfe2cf8ecddaa53625a85fa5f57266f47f3abc3a8f8f806a67834b80903b8f12bbc4ca75a5a723958f39a02a4e31461f5bd799fa370423f801551cf66e2f8775fce8589c8d28071184fa8e0d2d677efdb47e4db04cd9c897d5574b11d3bebb130874fc802eb21b55db7778b15cfdd117efc42afb0bb45a9b5c21d9eb7695f599a7c70de0167d4fc268bc2680311f3ff30038f1bea9839690e58cc3cc10ca26be7b57f509871049850284fc1ac6ba1d620fbd52b0cf54bdf869bec025863f9e6e0ff8380a7b1e1852e36723f24a92fedb640a33a3b6d40916e6046ff85436a84f7160a0d5409a8c3aec4b885c2252505532007e45042844438b73aeafbf161a9fa1e15db496989918a805511e599d8833ad4ac39048cc9dcb7e60cc5d2710414976f48f05559e7b9dbf60dae08d2968f0ad06092826b75536253d2bb261da3a2fb2365fb4e6dbc44b52bfeaf12093ac1fb3ed5e1bcf2fc27bfba526037e5cc6793e9a93a414005a630f24141fedfbfda79239e53f061c0bb0da7f0177de51f790d02367a4bb45b229b838265201e9b4db3319e7e25a2c14fce80aad57a126d4881aa6fd1d6a5dac64d322e17b2677e61004836c2e1b9cad5aa811abadf0453f2c0f6be8ffea1dbc3b728819efc1eafe316fa15f3492437026cd3384a0c022ef139b674c9e8d3f428f651df08b4e9ae55d07edb81774fde14d1be0b9b41ce79b73f3b2a339633ed036472a90724d3a2b9cae40b4cf6e5e8eaad24f72e66fac5652d46f0bb5f17b5448da0b8a80072e7aa05b4b7ece4349588e230b003ed822ef11523088694f1c802c6a8808c0692db0ac0fa7a43944fb80ad23fe87c5f7f955dfd5c45013fddbccbcd1f951194422b1a2e8423765889b6ac10ecb1f5f714a6a0644b127e65762528eaa609823f039f3c7e3a88c6a5c4e9befd2a3b2fd03f786067e447d4b395680cc35af54dee3a66c989cc9f1df753e190ee3f81e253ea15cfc3d5770d55c3b6974a38d5722a8231d95a7b098644da39167e7efd22ae244431b1f715d4428ee5bea2c035d58ed16ff8efd822ef0950b60ff41a0d64621fe16216ae126ddd6aee5eb225575b6fa5036a31aaa39a1d209096cd5df1639889975c5bddc27378d647cb8a7113a6f0cb82dd4fe3dec3dacf4c6f9fa0cbc91aa6ac87b2c61ba6768e2cd03a8b269dc72ca1e19940a67718af9b69babca2ac4675ecc9dda86520046856558e61e0858cb24e75144d951b91e1f3649882ba0a4fe876c8c653b1bb5eb60ad3f1687ed75d739f4b8cc8ac048d5af12e1cb3505e6418a166c4f59ab3f94b46ede256aef0b1d1e5d19e56f09b1baecba6e0f2d2b483c5c390a493213b509870b113acfe1300800fe447a9be035920f843caca32c3c3666b2827b45dfad9a8bac63486d3a587fea5553af950058b2d6bf9b7f280bb80e783fb262e70a3167a30b916c344bb32e7af319c8b8c5b59c2204e0697c1f27cf09630ef47ce66091f61770eaf124fa18c66fdb77331d2853564ac87e319880a8d3de65ea63cbf37654647697c94ad7a93e2ec9e6ba07d4e4f719b161f8e345a8204f9cd8ade994ed78aa9f95373b29913522fe8352f3d9f74109f51e6b137e316fa62232a4e0733dea01d26ee7274d01d83bbd1d8e77ae8ddfaf3e0d59eae770f55bf5efd666eb983af3e34334b4f3830d5827abf33b61d4bc4078f5f1a0b331f19ea333ea4990e4882166d761acb9b529299e7f991cbb36a33cebf05f95084e154f1355c0855c53c412e4aa9d7dc5c3ca675be450616ddf34f85535d1a4b3408fcfb2536b4cd7129d92274416533333a509e06a267e23ad08f8e892328f4707eba01013ea712ad116fbf158abe75cf2033af20377c8b3cc8170199c9bdf81b83633a01b55b957d547eb2f787ffe2e658f92184c290a9c25cb75c8f4d303a1ead2a71c16f402c6a69f8de371760d3fa337eaadecd00c210088d7fc8ef2b3126fd9cc7bbe1ccc60c9df41a54100e47d32b2962ca6ebc1d6ae565297bf2c97b038e12f43fa0679f6375c352851b5b6131de95c5a7d007995faca4aa3d0ff6e5d0a7eafc6b28847a4533ce5b56a0a5ac28aaed2cecacfeff90ca6aac2036abb06a64fa8883e09a5840c9fede5afb6fb966a0a511752a42c9346e94803199bd61fe580a2361ae637e7a6ee891b955b7fd227ec1826d54610a068367e506ba55422f4da2b5f866045066ce486c0b1e6cbac2cad94efc396efc909ec1c12b74adea79ca70cafa762f8a3276bb9c566be10479cf308551232d46b7f07a8c748c5690dd7e87a4484e734f0d670d5555f386564ef242ca7708014e7f09c967977823f88ec4fee3a0d55736dc1129f8e9e2887d2228338122a632afb932d59eac04568e436593d0d29de814503f8d2bbdd68939b11b870a6ad22a3f1a04c37e096b2f937d1deb07fb620e84409cbaa329a7a305905832280737176788e3c7e30f837b83cf7b3a83e0facb0438a445a57f54acd44e1aa0485f131e94c470611be9b4c74ad59d1d685c57c302fa2e1609d7379e73a78fac7e884153191138712550b88201e5965bfebec14edcd5d85bdd3452c8da30272313f4e9441c7432982d831d47df9f5bd89ec51aea67d2b7f2742f6ac37cdb3f0afeee1a4658d4e54bae870925fc85c6de54fbf095af695468ef1cf7642ffdc444041b862e75fa730c99c9167839c345358d4060c39432dd9908feb5a52efa38f3b965e13358fb6408c6989db1969128d53ad3572906bd98ab2346cede13a185d103f7194233651c07074c04d10e47b095d2bccc244149f966c95450ab9653de81514c91d289ebfa339563090b8b14c736989a7f844c586549ebddb1dac72f5db2bcd67c79f83faaa8addb27a2fad68dd02a9e48c5e3d5a552aa5ca00c6d4a2801c33c6669effc9063bbc61d833dcf7c79cec8d2f09cc2b6303828509cd949b645fe1b548320cd2e80ab3b52b4d4cb42bac99c176a467702c77cabf0048788b73243aef60eceedcdb7f3a51d596830da2e449547012b57d586ee7287c17c0e99bf18b7ca5c40dd6097383a9c640f9dedba3e8ac49bbd97f0d31a039c772fd2fd87895aed39e8b223c34b60d33647fa15cdc5f4841010d1dd9fb7879dab52da2e03ea015ac45e698c531c00e29b3db8df1c28159c3d98b77ff122b737f41d9b5f476259beaa395cd39f46f204a647900e217c50a2cb48533af939e4c866e79c3115bb58b4a0c8ac5866363fa7553f8fb43c202438e40a2fa6bfdd73968e0b219b22bce3c4767a8eeadaf3cd78118defabf02c0b94e5012dca4b1355d804cf90fc2382d673c99022c41f2e03b08b932e9ef58cd0d4b3a4202c6f23be88377d683b21b08d013afdd12e6b3add7f3da3e300281ca83e883fa4be56702366c58b1cd3feeb6a97146cc6968e1a7650a90fa0c812a65ccdba6a60b5c15d329efb152d503b4449b0bf3b41a36d8bd9b49673e43fc85d5ffc752016a114fa66d2553af5de46cc4db46967705e896df46306440e3dcfe0312b6f8f35fc27cf2278978fbbe01ac3c822784b3d8ae3fdbba982cb19552b9b7adf2356c5c780037339241f7ce66438d0477135be9b9903a1f9ca1ae7fa28f6c9ed6b9d0b398b33d2cc51f02e13d4f626047bf8b6dc8fdd090fc607f00bf9e993dffe60c4dd97d36dd52e0d5435976c764c749c016df4006fee19d5fa73e4ebe28c2f5cd548bfa3bf5337fc165cb8e7bc1088de2a336bd3f511bb5a112b3cad8f06cf6d7d79c5e8e64f5b761272ccb6ae9afcd45c88768c346ab6cf18cd85d376d90dfc56c2bbfa8c24356616fa85e93bf6fbb75b0f1ba0193cc29a03720d5f3c2c268a3e71789212c90272a571f008f0877786266c43c36ca14790513229cb2139440ddb487f55bad2585956314b251d330ac53048a2fe2fd88f118d969f83a3d0bcbd7e99f4c446fa258513603d0a363a4f5b52a11c368bb9bc288e308f7de5506bb5ca94128b58d6c1eee991ba9f7edf9062ed142530860926c4069df6cda104957e30fc71f7ac25a9228a60ac8f628e7be9e024cc6c574e597de12f2b7d68cbb62b11e3668a8dad9a502f29d2bd1205a00dbd46a53f57dd0de7e7da4eaf8dca3ed057af4287666892cf2813a0cff80bd9248a848c803606e949310b5e2a28c1fc2a4d7b7e4ef578a8530e5b2e2be41f0529261488ee06b531cb81a12d440292f2e61eaa548ac03ecb496cd6e42f82a6c29378ad726a1ae88567f2352f274832945c1660c7762d3488cf6d375686ae96797a038729bd38769b2ac20ff8bfa5d53039d40a18269543821b6df9bc7c9201c13869b685bf77f6bc77be97b1a5f731f23e30177f4af093f11b92e445dc939b155ecf881a9c34402633410a8ff1a84d15783e8e8114bde7c757d33a6d90af92597a274b013e2ace600f0bf32c21120029b937e7809641ea257d9230996c15ede7d99d9afa3c018a3313fc345d35ddbe0174935064ed3d7373f8885ca81f0252d279adc8b523d10f57bd52e0768cb6e49659f7dc926ee4d64decabfd36c44460e8b56ee10493414374ad9ee0d8b19e8ba5d414a9b492ed424ebaaacdcbc2d034735b6ac70ed7130b14141cd763a8581e55ec9e02ced52e99da9aa8c52aa8d277b4e8619b2950502eb7f60ade1b020881164a8766ec2b41eced787dcf8d5e9c2e47bf8247f7f6c1d8944583b5d260c3e649a6bc6db89a0add23fda8caf726b8ce73c71a2eb7e862979ad20ba121a937616d5c8a6b84b25bc2fdf7fa2c799561394471e71f0b1e4ad1b6fc496513a272fb73866386f4dead2482e75c0b1c25d811c659b49924e88ee91ccf1e350dbc21eb29d8f4e06bb2a067489655c82918d6c153514f0be02e70f27d0800af2f128b4413461efa904c45902e92d754006c1f964ef517763b9382fb644a8a293faf85cfd90aad892183c13c9842ab0e1bcf1e309f6a525079818f3a24346afa729dfd2f7dd83cc02697694150fafafaf4be4cd4083a9afd143134bd7fb485e6417aac048cf1b69ba552ef9db9aae85c135585fc098d5d2b79f0076f351d51bd89247e993e5cf43b435a6c6f7c9e24938633b645c1d4ec96fe86ded0822dc235d311cc1403d19100e30cc2793f427ab1ac72e4da69bfe5b60c012ee5617cc2f0dbbf56840e5bcb0b0edb4fabdcb99e99f9d86804c0bc25fa737d45a384c54bf133423244d1ea0048e2320f4b5dffee2411434539ead791f50591241e9c09e8f65a11a8bda4528e5c5dfd71608ec70dc80a8e9d29f727671b4382f86927e132883063d9aa944a79bbbd6cacf5d86d806678769e60ac7216a43f4bd50489cbf35dd4916206aebf3c8b2b4737195d4d0d8546ac007e8a188e218b59af70c7cd6c6db76793e767dd468c39a798b6cd6b1e45f9c34f872128028bdaf326cda1e7760f6bec48a2cff05efec33fa28aa66902e7f35a38fa4acea391afd23d8a6630bf9de0b48cc4532629a0d23c4b38f08ce3da336782b117fa0b3c1fe8aba1bc8cde78206cfbee452f001f4bf84325a3c08795c3937cfeb2cb6d303cbd18ed3ce5b89f99ae7874b684bd783b6600b02994b8428f7f624f659c9451bc6f8045fe098ccf932053b00ead34043cc89b72c93dfe06fc46256469b05b25cbdee5f3b1ee9d681535ce930dfc297b431f786bbf90adb152a832629ed79139c115687ca3fa88729d5e121fb68ec12f28a26ec315088cd72342d15e2efb1437ab8d4db6c48bf1880b534ce8e75e3f901cbe2dc841b30e7c53c9c405a28b9889772b04be1a413b6f2a08c8bf0d35dd7a4956b76fde4441afdb3c8ff751d77baa1f9e34f681e9d91787246e89b12adee6fc2784fc3bb0aed08220ebd543b70df5859058aa2aedce2db123614f70b70338387657445b4c225bd63e28fe7e41bd932db85e08c6b69e919763a0fd6814e15ccf4a774287f0ad4fe9c58cb3883e93459bf0afefe03a3fba7017e60271eeaa4299a7e218577e0cd18e44bd01a3949a4ac4a9b9322581bf439c6746424369be16fefb5fd48fc366a43dd4f43d1ce3676e3cec50a032823ee2a1d6301a08f5a37543e6b301bed51905d2cd31e9aee0faf5d72370b868f9d6330f519a443e698e1e4515fab6a66aca199fb122f4d0e6b3867888b3106b745671302d6c7d1ce8b0e017282745d4d201b940acfeb84759b94cc4a1c0051668173a45c472c62744e5585457abb6340d29447855df627d045dff3a36844cf18b824e310893ad914b9c7e2d5f2890122afacd6a4170792881a8e6b95f792e3e5991560e87670547ff22b529184f4e3dd06e855f90fa18888def0318d406d0378002d02d2c1b5bcc31412b8dde0b118dc648cc02bb0cb8a5031f28ade1e880996b6641e0ff2f8dee8899ed60afd86b09b53b91eaf7a25ee98a1d9a8519788fa961e6c469b1d692970b05da14043cbc464ff7c055056d6bc71d6efe32265bceeb1483a2ad6085aba44824d6dcb9e01b13406b4e4366c6de1d1a8e38b6464d971159adf6cb6ceab78f823a77e4c3660b968ee051b100655ce6c3bce2c1e595056fbf4d76a75258fa539dd3d6e799dd69253afe619f9407dd279d802357c53cf675ad4cfe20283b8317a183db9d7f075467afab78c1f192cb02517dfc1a0444827c664401c0cafa4d99e11c7c2d91755ce3956668f6e6f907fb8b5e5016282282100441f57b069456ef4bf365478f5fd970c6c0c123248c5beac9e8db6176566ad81f47fd5371262c1df1a057fec21df77e3fcc3d158873dabb0e88da521b1446dce326b12a38bb25db8e935745fa466ef06a534ae2c413265594ede5b0820556e4601e132bbb116b21acfc794f7318636066b6db025c8a501e685799a0cf6b7b67f720c3cf104176ddcdd6b3c1a465c60f31e9c887072f59395afa39c280b73428416f7a05093155d6a31f5a400b5221a3165e267c29be0dd96e36bd0bf9168a41fbd4ce788a5a44c38a734f434d83bdc3d81f715827720cd9f7e619701ff87497b4951710f66e3773acc0f93bfa44abb98c90c128694c16ad7957cf3b3c29476ce6c49e7a4ab88f403787f61106a46ace88282d55d67fb4caf1538f93937d542a3b3917e17f83a09c9743d7a72a4ef5ee5b241a089c875f82bd9d618fdded4f02107cabb9e53c6f30324754f176c21969ad12df4a71861c8bb9fb88ea76fc8a7467b6c3020f9ed67842922a20f08ef7050c28252cddd77d3a2af08103189555824e81583bbac246982e7b671886fa2fb39beda5b51c7123589c649b503556f05ca5b50f5e35ca9700585d0cf0dd3f8790380298da6363fdb8b2c629394b971611500fb1e80e5dfaee8c04d3c579cd6dd412be2ee5978e77811c968b13059e7dfe985a84e6e0bf2100a71aa40960ce9d6dfc318f22837d044947b962ea782193934eec2395e3c5ab5a21cc33ddd78bee50ea8650320ead7b90a5d0a7041af22fa2cbed9f4c500770326ca883cf924b3c225bc0d1b8ba552d6a0ad6a700a44dec104bda6fa8d64798ec8b8cc276d21455d8394b75e7afe7fee7f84f481c7dc1414fb7660582c580f91dee4037cdf70273e363a64232a94740685c7f345e44ce0c0fc34cbe6cfd5c2be7566aaed243320d3b3fe4dd05b1a8d155036f25ff55440e7b9a5bb83586a2790f7d4004c941ea3f702f785f4128bc3e367a17d3413d25f1440a67c733138efc70d620f00fadbb7e9bbaaa166de59b42c30e97bb232ca4b96a8e88115daa37f40b6dd8b687ec6790bf0b643175da8e5883b19e508154691003d10dd069390555bdb69b750e0ec90a8c244edc7ed3a6bfaeefc710c470dc6c005b4510103008539855421ac3d211067de578dd512fab84a65bdbe7bdc22784be7b46a6c6bd2a41857bdfe4ea5afbca1903cb45ac56f669c5d586a30012d804ba276117b3ce9613edc1a008896216ce8c5d078029d89b4c805ff90f58803b1244f4bc46132a64a20e6e68051c86ba97e3db1c647cde37549eb64d3d2771828d936bc3c36a927b668f7e44ad60978785de9ed4af743d28feaf918f61cd37bfbf7d493add11783e208b8891908cdd650770774f06684a26eef9765897af92503ab57f8516f55beca7eb0bf8ec10b1df031939c599ba29d01bd168f88911ccde5fed7c197948be0eb788b0264f3a2991351cadef293e9fce9e99e9112b3fff6b0ee562cafd33293ecc53e1c1cbcf4b40c9f925cc93bffeae0a4a6218534ec3d4aabe2f2bba4475e9f62dfcb1ab64946485bf0de6db286f3d639cf1ef2fb2a511ccc5a00cf02b86638170986e7616f6f19ca52c716b538b58574413f91ff5a854b551fb336e5f0d68784b169f54ff8f434ad6d82e8b84a861074b0a5e386d37db3ef493698faa55d10f0d7ff8e7532abe6be221fd97537ddc751c8a4931c568c382f3ed97dd9087dc7a275fbc8c6eaae9249dec20d06a14cee954faf402c743f64ede168c5ec888316e923b362fbb1740e634d3c64cd9343d069daec13cc4145bcac7df1df7977b7c7b920b354e71e0fa54259cfbd2838d4ac865488ed8c3436d07c54f36c6ce34dd14f2d7eddf5a3502cc49fa5d00da966ce50d5637d02d24d371c32c5247b61d26ea3b64133b5d5802389be07ce0e09e79f5770cb2d9b5f8d204aacad5d48c0cad09d73665ed4ccbc4781992538b0ef6531e96ff0ff1ab740262e9f4026f0510ac351c1bd3f19a214e2b72574ac3061dc989781970d09107081e275686b3d62c0c40046b0d942dd45c9a22ca2ca9c5509dc60356438c127156afdb5377e8bf7c691f5587dac740646006fcfd5dd4cd4ec0bbeb82e523cbcf73d31a858e4f32557a3f267c4102ff9da4048a890d52a1095fe6c90855622e60e160c580d65e966366056eec01b4ece8b1bda388f915eab418571c14b4bd67d72ffba41dbaafa3c29d6905eb91b252aa0d63c544a9a7fbc8969e4c82e775a036b806fcfbec8d9fd2e924b7a57c48f9abe7dc0057d54a64a9a255854cb3128bab6f051bc91ab4e4bc436202fd8a0231b49c5020e32630f7e7cfcc72b6ee2b7cfb921a749be694fc7cee0bf398a7d265fb3b86f0ee6e1e3ab9d7aa1abd43dfacb25398598e391df82e62c192afcb11eee879edc1c65f7e93fd3174b9ad810df90ebdb6b3b7a2bca3baa76079480c23cf1d10694a5456891a85f92f712ec99f690a4d5783224ef83b8ce22d747bb69a4125c27769e90cfbc654b752571a8d48d83031e63958b7e2b00a3f9f37bf9f913d16a060694081c2814608dfbcb0b757ecef6668366f11b7b3249dd29c8b8f1a4aea228e6b89dfad3c6370b04113d92c4ad398e06b06e3d1f075ad855c58a6e563b4418ec1019d80dc0fdc57cadaffe8ad0c0088ba957ab123313709f07962068ac37fde4464238b97cec6dfe6b42398f97d7de257a2c7a8aa893d05320a9bb7da269079f72f0245ed0a342c2a3e061f9c6fa6a04381e391aa97356d0516907419387b436776b0d1fd5975475c5fa39afc2113165c0e7923b7c6f831d31c0f754ac7763254afd4556479fadaadc022c899c4d1ec9ef66941f676c8e05b0e11946f676174d0624f4264c40d6971371cf597771f5dce91ff6d019c569ef2e249a634c50fe428a0e88574e866cfd9a0acd9dd0831ee9c946e21c7f466f47ee55ce3ececbe3a0cfc71c6e669388c5b537ec41408676db232dc2e158a269785638ea346650cdcb5a711325346fdcb03c2acd65b7f2a023e7760fe64b63802e1e58d5b9e37ef47f14e982e78c70d7cdd3d1b2b4ad5f6077610d78cbf64d1fe8adc65cb10df7637d9cddd8cef5f99814c1beb2a55659ccbe7b4e443d89f0b7fddc0a93b13e64db88f73fc0f716b0e8c3ed56f47d4d5d47a2612c6e55dd727f2d8cb9b1d18f2242b7c518720a313baad1a695d8c58ef9ad598a831ae7b90bb31d19b4a7bd211cad7364ffac4ba9096a7f69cd9c8f72ee6a3a57a6144f151979a52ae43714a2e5758f3c3c876ae426fc4ae1f2fa13e9ffb5910d6c8cb2c3b3ff2acbb391f6c6c6323ce6d717ba2deedea78ad257911f8be099277c296e9c61a3d4d503bf2d62813e9d9876cd502ee56d408b50aa1ade7a34898d6d9498222b8a6887726015055a890dd35e911d5066c13b4fc3a55bed663ccfce2856f250e65cba3776ae8926babd9b54086ecdf964276f390e39363fc35c0eaf1a74ea6f330e57b5f3ac76eab371d4a396ff8656cfd336866715a031a5053b48450b0f2f7b692b0f4af2619c1d0da86fdeab531ec6b00636cc038d1805c4081a676834e441c95ae6eb1b9193c79a0d759e9c7c8f53f640f364f6ab3cd8871c721812fcc2be85f25bec269b69c6f659a8864f10008b1be7a377c8f826dba023f0d9a36752a4fe2ba0bed0a76a3590e51f330406cfcda10f7ec865192520bad02820463aacdd6e178673751641eb8510c5f4ace0d99b758e069dc3e1b1bef47d1e2ba159483f1e5c97ff6a926f566ea827afe9b112f336b77d856f700a2e9f7521d5b676c8301efa67f6f49f5d6ba739051bc8750d88461a9ccbf0b65a336633e7097e58d84d7b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
