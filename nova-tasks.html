<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05fce57db9498eaf6e5c9e3e93ee182fcef3a374e46a067ade6c581cbf39535d5a4b424cd739310e80deca1ab8b7eb0150fd4bad49e82c0fa2b7c469e090b51e0eedd49699053839949813d846dd7ab8bd629e3dd9dba550f4f52e78604af972b3fe1925ca321477af1e5ae52010568d47d31eaa63d0263959584b20d3277d6f179496d2be398eb63b443f1347a092b78f7bc7776563f8845caee4b240ea9c4efad2d1a5122b5465b643fd0a759092e1d5524ebc25950e6020c7f0e049ec1be1602fd90b6b169d85f15acc9badca38d16c240f97765a9627f5d135931b498d5664e58328f45bcc93b4108cd5fd030e96aebf6b10c73678d0184ec58b01e136ec8d9f8cee705cb13b9b72e8ebbb271365c5c69795bfa1aed053357a7364be6f21fbeaa132f060db64f41b85934af3b6bff3bd67cf1418f585b6939bd0fa8133e164d81f74ad6f308f8f3a25f404af08bd5b6289862444d3b9f479c75184acbe734629279e2820fdf5bafe2deca50d44132e5c8c044a04cc9e3cb86e7f42f2f5df012cc31210c50748783d293379b115b1473630c8314a1347ca77bb77ac334ec8b53db6ec2dfd0a838c36489440250a5ef946675b39ec1eba784c9ae76ea78444adafb47a746d79153157ae7fffa05de9b0c40d9da8aea4613cc3fbd61382a12b0aa6879780ed386b472795be8135f3d895e35764d7cbe8b4c7166e89ac91b5245ded6ce622522bb6986908f40541c1e12045162279140276ff97929435c99b620df2fc45106b2db8f949983d0676695f6b093993ee4aa22f137e973806f7e2f67946bdb3f226cc75ca49a444fd059bd461577bfe0d3b6147ccad4badc9dc0bc9867b17ebfb401b4e20239f01444b1a1c734dc82928431d19cb5ff08d849e6634f0b8143511527f1b438399ad711a7cd0f6b8b6ec7d1cb32bcad0c31b3aeb13df088c4472ee48dee165c993817c06c509892ab0161769834d2b7b375fbd71b323b7251ffe9319c66824a53676ebfc97f2a38cd8ff84a5d0a7d258dff2e2e120a76527bd891e89b063898b089f433f09ddf462d48fa75866007c12d6fbb1d85fad8a581abc12f331fc307765cda8a8f658ccd198e5bee824c595b114a5252252237b0326d9328cdfa680f533279aa340661458ae561cebbd604bb998e994f747816c95744b628fd262e1498c92fb3a8d4966ffbc78e60a091998c8054604e2000d8b84ed2ac067854461c8b384a0423f86c872b62282e7abc4dbcd40a2ee8881b19e9ba880b8944dd7fd55e57ee67f983ba156a14cc84e7a4645f35f7fa8736207fcf3ddf42dd28b5c54052d4f678485f7d8133454b04661defbcac8715dc2cf65ae1f4858c9646281d371d9ca9a6cecb0c82e67635f16382ddf21fc663dcc67b5eb83b4bb701f50a0b9321dc4871bc1cb805137ccb8ccc6fefb6dd5df262b8e0764fb7ecf48ac4f232c32287646293fc4e6ab43ce4afc9236936398bf88913e470b76cdb8cb9743fdded5fef92d9d575e46e9e10d20292567c75cea56d11dcffe17f470ca46709b0cda5df699cbaeac495ebcb6cf9b7958d6eec0233ee80f4615f3af4a50093eaf5640b6700d7b299c13cb9a8c27bca80f1dd2b1748e3a9183ca1f3865f457878f53db4f07e6a0a4d50f453f9266befdf4c8b3f066d372531150743662fe786d4f2da551d6b912a7598ce0e60216e6d4e0b68f5a99097f95a294e1cd0c4b86d713626c9f3b3f66aff2d785a11c587058f9957d4c1e06b6c6e677e2b134e0622aa32b639253ed82739e113bd415f92c21bdee2a6ce608fbeb4eac7e48fa26a6720ca155573d5fdd6c14d7a92bc660c9fc1f0e1747870ef8f10d5596dc3b237bacd9a6e48ac5be8d3476cd8929837276fcdd124347279a4111f8791fe96e3905b749844a12ce138a08a1c7faaf9d7000a1be14b3e6e54465d5f3999813113af0a55fd84806ca79789ad4675cca42a8151827362caf62b6231bfd48e2fd0726dfc93f741370e0ab80c9073c11f47b37748235301d3751d97ee79ae7b8cd99724685144bfc6a45bdbed0f177ac96e6c4efd88d19f1df7cd7a0ac4bde29ef7e7551a7cc4ac5d5a530eaa732b45d37a15faa895cb7e51d364d3f7b91703f1f13e7ca70d99c981643f6ae4809e025954268881ce7db3f0fe7bfd03145fbc1c8fd9fb575543947bde5f0fd546099839fabd8c3ac15588981bbe801f5e6e9b4662a91ac1e21d3eac856f8913ebc2181c0be14aef9aa7c1bc853e0cb356311fae3351f65f9638312bdaf458177f2a8ffcadccb39d37d91ecbd7638c23c481600c0f1d60bc420746ce6d9d89840b0405f31830498f812887464aa8782bef152873261b98d6bc92a48c1c4801d7aadc275b6f040bd91b2148b56133d9f74e85a681bd38ebda11106d1d52d2ae2af86beb9e40740348bebfd2200121fefc99caabb1e107fb79496e6d5245f2357c11856ea4be8f98e72d0f4ddc9db428766068e5d4447b64bc84aee5dd97635eb3c89a4de53f7d366a18abe50dbce899d45f8de47b900b791c5722ff3233fe5c8110e5855942de0282e5e4572b09d1415e254a8b268cf74155e973db78296dc4849421b48a58536e4e5e8c3c844ed13b9f1d9155858809bd9a3e981e6ac6af5d75859d75f541c5bd78789faaf53d5674696b12d504b3a3c66366b161a308d16b5a360d0db7851298acb65c0ee808d36dfff1bb1e05b65523d4f6ba2a23c8206b10f62d305142c8932d58fc6443418611d69def24ca0f68007c22e6267059175faebf7916cfe9996bd9c30b7a2c26e2bd2e520ada0ac2ff9606a22c804f6cd3cb61bbe0ffa30f227066dc85a14a68049017d4c3546baefd61515619b700b1e8fe07837c255a02f22147bf44c970c1c5b171127e91f942a1df70001636e63fdcd5776eda35fbb567a41a644927f2f93fd7dd6c4c3c2db41d437391df591064743f4e1ddd605be795d5894826f0032b2f2c2649a7e9ab38cfb4cebdf991d1be036ef99a5e677d1e692aa24a1d9a535e8fd462d9978512c096eccbd4a6b5784b981214c68b741e4f6c175445f1b03b86c6efefe6d75c79282bcd327887ba1ded6f4f9bbfa09e46ec77e39470414f87c7ce38c9acd2858446a7cc3ff2abe2073a99deafb65a0644c4b4b47132dadc14c2f61c460c475adfcaa2afe89b80d381a061ee1cde10a8db30a7a6c1124c943d0ca7998531795044396ca04b2ce1afc40e696779fab204ee97bca213bb64a4bb0e544692e5aaf53973dcb1c9a2a4d9362e00077d329b5799545ac43dcd3edc0197b5a1bb14244d211dc023c88fea2233b6992b144fb0b177dce24b33993eca7231aaf2b10d61ff49c36fd43a95556a0d5494f326763b107f295f300b9f8fb67441e5b845eac1870cccaa57bd3e2eab31c4772edf823222adbb0034546577e5a0238799a78bb309042168333d25fa0fedf6b61dbd65b799741438333c70a6abb2f1a0abd9a88439347cdfc7c628156681a2679ce3601da446329870011e5c9725483c73db0b1cf3379693c0c442c1f0c4b80c736e1b2f6b77bf4b1cbad972eaa1d845766f15e292b8e239fbe1c15eb6e3cb12da76aed94ed5724262b933f02d6f0dbb39a1488a7cf604772f969c405aa8d6e75a0870d5cfc0cd94e1a830c69576849c9b66b7bee84999c388c3ed2c385e836e1e62b54a035f76a326a29f23120d1900eeb8ee9a54d2e8f23ae0504cbd0ac745664f95db451b90be6124fc462c90e078b8b03061c7714cd8038055464f64b1c68508dc1af92afeee668d8ae0524e4254be1b7e56251eeeab900283b28048b60c996fcfa810fa1b02e01ab99f63e73a21e848a509ec996a27b87b84ff7fc9ca29f5430ac51d921fd063d031a6a9fac209ab806673062b59030d8056a3adc9126779debb751d021f4c67d5703abde97c1009162df44bd8c72a7bbf71a47449d520d1c3a1c156c6738733cee132cbea10c137d20cf0b61d3a5575e324ebd19f04dd0bf889dfc6833e92d8121a3697d7d56008b7192e70e79681972d991fa6ca456cdb6f64831a7ee3267c6747cd01845c76b6b9a429a631ffb22ecf82db7b935bad2c8547bda45a1fcaa506b6f60c5a363aeeb991ff4d7e9b43951812b2e9a62cf7f3e93066787cec978254e34c1a8c5db768169c92e1d46bb6cdc89c2159e96297a81e559843e0013b054c78ec10632529f2b950e7f95421648b12039038f008fa9d2f7173a0fe5b4ee83696b78b081d6f8485e1021d0562f68771ffb936dd0e8eb8fcec7ea7a222f08307fda5196c7c60f9668a2236ca905a8cfa1c6078cfb23dec4ece1d3e7c6319227fb8bd4286a5152e6c1c92296b480edf538b5f9016890e5711899b0668757e7285f2dcf0137fc27bee2fff40231f7c3ee85300ce6c3d00d7ddf3c78d4c2ecefa71b85abbd1e54771a0407ef24f7db509d6b9cf2ce7d5d6293b61cbca67de72433684b59f4c1d75cae3ed74620f07a363a75b229cd103589308e3d7404d15d352d93b230c8db47840f2f3b734c0b20da9e9ede3ff3afd709d6a78d9a2796bd0b164fa7889c489778c3ef35d6b6fd912226d7099cfb9746907c86f1be534d7bca0f454329ee3d85bb08931007a8a0849d4f0c86ab747158385e1f572afb3df6200080c77ef35237d55d1470d1849f487e658020971a42c7ddd9398f8362b4492b9b50b3de7eac989e7ca8a0cf4a35b9f836e37e6795b4271d687c585bdcdf3c2194a92c23f16587d4af01586ef1e02f85620c3bbbe97923adbfae99950508f8de4b4bec28bda53050dd64b96b759c06d894cbcdd6ba8387ef51e7b1718d44685143ca3cef6adb64c9f0d9e9cb196128ce675dab0398f8b602e20f5d7f064ba88c404f4a37df943b904b7c389e1e4f9bbabf650189f6ebfb5efe18c5db0b5fb0286b5b3968f448a90fe206280ade7c2c8892c64cccb3487ecdbb21bdf96e995678c42c84f0dbf34832a1496a8259f48a300b09d697351f51e480074d4214f3ad17852183bef7a0ab33f7497efa18ce36c6a32349f3c1d471e4cf0ea0657eb62979003817e759efc5cbc52c2e1c6e275ba39d482c0587f51305e1b131f21055035333d2342507395957a87c0ac3e5a0dc9165975e18d22888c601ff58e0d55b578537582b150a51b2c59a1e92d8cb4f1883432027a34a3cebc8d2ee7830966bbbe49d4538b9989c129e833b2843407eebe5d73611d5a734bf7b97b0a6f6bafd16e5acf96fcd39d402dccdaa3b69d6c8d0c5593140688da67b0917c50c8445edcd8f11d07e971a65626dbd0506555a759df76ec15e3a8673beda3ab633c5133a518f98aa988718aa72d7adb46c9896fdcc64cc368a8ab0e4c5f6d7702cb1edfefa3c6d92e260ab64489a477f5bced5ef88097039e7493515daa4fde60b9e4518e11d891e82a16213d1e56c8d9c74c7afce60e3e7fee0472ad85f40ac6bb9c92a57c12f63286bd803a4a486ca7d16326a7c0aa6117746012214960a60fe21d3eca615ea261d16bd5ba0f928ef0cfa74e9579a952f85e1eb5a39553bfd0e524111bc52f3ddda852a238acd85bc2ba4970862995f3f9442dc0b856e4eb4d65f38646c6a8617e0b5975a2cb530fba66880a7eecf41728590254146fe538620cd3c03b9a3d853120a6ff9723f61a05c1361a433ab85c6273b1ce2b2ea0221549b5cb4d812194c3c94ed2cd6e5a9872f5af55113a98d8399152d578765bee67ae22667ecc6ee1be2421575d356334a0f5c4f3e389e3195f4480dffc71ffcf867c9b2ac559065018c352e9024ba7a8d5a74dddafe5a4dfaebf602811d4b3c6c7fd8804d3c3f218357c2af72bb56ec649fe028c5e76254ecedb30e3b9e95e87a4840e91726dbc377c38ef219be16e15fcbeec9d72e7a643ec8568393f4db98272b1bc4ed75619bf9a6e5293b1863ae2a9f6d75add2bc2584bea16676dc0b534e9d636a1a0549b0b5b6777f757766c8d8cad6e7d7331b1be4cb632f198f83350f8adf94ba187f024ced6be57d275cfbc9dba43900ddfbba46ec1f8be28ac852bc9a3d410f6402aa2eaa37353a25d2a782209b30b5389b00aaa53712fa519f6112ce65363219dbd22ead9e6c2f8cec6ff288f39f4f82b172b2d48348e94cbf52f390ab5ec0fde9d69236e1a96c37cd3af983409eb671b3d6bf4a82f47a97f9d6aafde6e7c48df6cf4ac83505d11dce51526516d89d94686c75aa81884464d3b2f74f8f8a3013f9d1203bb9bef83b88b245c77b148f3524d6b2f77d85ce86cf3e93db9866fa1eea31919ef7e7ac8bbd5eba239b9e109bd232f109ea79310c5d3dc7007a6a16710923915e6e687adf85c12bbcca1abde008cd9f1032811efcb3714d9521bdeb02f93fe688e4116ef6e6e9271602d8f2708a72dd1bf6169144271c1ecfe5e054c2c65401ef6f1f11e4df20a674a4af383bc694bd2469f6654f05b10376449259127703e4baa11a6dc61014fcc94a5b29d5a821fe528c9d98190d169f207648f882dc45c07e1ecf70a6e2eb2ae3fba6fa4b82b522b2d7748e9f6119169aa422efd3119739c2ec10bb3c12ad50204ef5b48d864875151376d2c38a62d068017ec6dd8da1bc49db0ccbb222731295891eab4d2e299f545a226ff4cff725b46e57afcbb0d644f9ae33a9be753ab5fad086ff913feadc8eb40b18c28c2d59fb75390d54fff718d7f8367aa776c44fa9e5dd35581f8c37f172ff78a2d0ff5ffe0a0f2dfd57d5b4af2fb954d7ad9e16874249eb55b62cf15c60431de6c52da8378d44436932edb40cd5702c1caeaf7f35cb4b60c0edd6dde73241d6c3586d68b7d1c6699946b66ebd0f04e2523da6a4610e5e4e0a52a26ea08a1df8034b48c044e0998537347179752ac411179736ae0ec50fa04e8a833501f1c51fd07861685768dae326974167e1f37ef35f32dbf60c658deb20e8c893bf39c8dc359f5daeefeba864a15d2327b2d65ea47ebe7d365a6221fa41150584008736e864a0234545c45311a046acfd89ac37bb502de2be04db88f1299b7338f7a87f94921f53ccafd17ee118ad6500ab1691055d022d079177bc97192a5ead10cdf6766d4b391579eaf2333f0e37801329e4fbddcba8dc7290ca618dbf1148c96e09690e9162ea2f93c5b4a384609e5a1c7344c53ea43785268568d80c2395f3781a92bb225b689029f857a727123ab4daf74c169ff92ba60321948915f2963c53ed20d3c4c05389f0eeedcf31c723cb362d1f1b369853291522e86e44579b0f623697f2404386221c6801f374d2b7e3d93fe3577c404e0e09499b0a84f26809c1ea24ac01730fdbf02c7e56b6a1cbe1d6c8b84298f17bc4a3084a162f8a6172cc6c2e5bf7987a5c30e6e63f6d2419cd0796967ea6d8661b174bbc77cb2447152627b37618e15627697256d6c56514032b4086535bedb98834670313fb1b45aaae1d87ff2a89ce5b8543e56b8e51d5324da36bdae79bd7b7ae322e98a2e9d95211358718b180cf6c0f9ccf8ae851cdaaf1f0ec7956e0eb12b325924fa0643ada579f070ed1781bd3cb9e99ff5881a4b89b8734a94c4fa85f0721becfb3f1cc8063add818f14355d7512bc7edaef43fa0b408ae1689eb1634c879549c046f4b42ea8d76ad6318a7dee0193d5b843ab2141b28a8649066c74807d3afef817d06f708c536f6a030666f16d3e0c99c5905e936acf40d3c26b02de998cdfe5800fcefad070750d3fc998782ca801371078a441d88375617666dfd8c558c897a5b3222cb565d847b3b4c9232a773e648d1cb83bf654f3c6d25202571fa35661485e05779ce7dee613f13f77e81c8cfd954331adca4246cba02f5691d1012d6c27e18cb9df66737c338d6298dee55872f763e735ed9e1000da0abf66b995b119938859c2328047308d3232754f5a458b7d3167f3cf2af861a02fe5614e0f52b036ce39357cda5b6606b7c348981a158189c20c0fdc676876661a0d6769e9c7fc083cac6587d55d4de11864159a6613d78175b041e6657fe2e599cebd397521c3b192697f11cdb4e296072468fb4be1a8c2944a08ab7e66b7e35d36936b7e9995f0bff5f5dc6a4665dc64dd802fd15e9d1d7f3091481f9eef3e990b165414c438240be6d50068a39605044ea51bbdd51be40e03b1720f65b845a09fb182ac4d6b09c6b2141c831a3c1c7888f22460f4672ed8cdbfeff0f5ca1fe7e2f25c58e789333c450460811814b82a85db9ceaf3ccec875237dbf3f1798bac237d928212c4394b2da2317fb1c2ba3c384efc2f79f47487de9e37bbfa768a70b6a725e0aaf0878a59e5254be16677ca21bd8155d8b0629611b342cb7ecfe9bed449f27077b3d202e05acd8f63671ba0f983cd47cb1d9157ad22fd816c2a92a17d5cd7ca4b7f448a8900ccc4ea7a5509eb1e4340d28042a626523ded9b7e918a43543a532a2c9a404105c0403877c49068a63dba15efa3938746fb74dce68aa22d9acdbe697b405b5cdcf4ae55b9177a4dc5545720c5594e3922dbb63874d08c9b718ed3ceed39f2f65f36a0fd501d673a3a9f3781eb910d0c30e114986ad5e55225af0a4854c68c0fbcbef68936afd90713d981fb097c7ad78952118fd37b26ee74814c570473824f9e2422e3014f9effe988fb3a17147a695c5b127bf12ef8a440cde7e9fac1f8f9f2aa184bec47b5859af3f4ede710bea020a330b4ff7fccf73b908249ace426067c58e10c625a1b98fa5d25a71bae20545ad42d25d8dc52200fa6a6898e719a98baa1646c048e6af67b7cafdfeed1d64f1647a5b05d66cd2fe76b5edcaefece7d8e55d1202c13ad0fd9dd295802ed1ba84f39ce3d42769b7d01a0cdb1b957ccb4790402a27d5a2d43312138252eefb2975209b5d819753ca296559f4b0552b0841c0d506d6579945a3b6a364ad53ad9d98b6424d9c3d1064ce40e2fbf4e93507801c1ccc5c5cc8c8efaa8607279ca9d736638ce3c93de7d2930bff460a52e0540059140e4f815b268ec76e6a8df9c1786a39c1c3e803eadd7687fe97f1e738ebcec3148a14febdd0f3635cc58c404cf15c8964a157d7219c2fa142f9d5a29336cdd701e36b063454ccf66abb67049c3d8afbe939ed8a5d945ddd595035a43d58780183f2975dab8e90d17ee33afb18e4f07c29e8b6e99febc58c98a18f81822892bfca12fbdcfc45e37ad7aae40ee4ce84b6384cff1313a737a15481cb1b008d388e1228bdf15196ca4e0d21f8dcc9d73433cc6a679731c2a14ff8120982bc8172928857f8bc9d55ea556f5cce1252df9581e5cde297fa941fcf0f9fdd4f60423deec40241c00a7e066257471c30ee46035d89836d0db4576f091d633cba491a6b31942f29b7e02b3d96a7f2b61831ee51e9c2acb7e8cf2f1e9c8a488dfde9d39fe604101489227a134b61545adbccdf8cb91cebed73aaa5a9059eb9dd1a9d5ddbcd8105889ce994e7d513735c85b60d7824354a13ce43ee2b63874214b5a88f5a7ca44aff53336bbf1b15260632661e4efc6cf1b3c07437a9d852a1aa3725c007173d3b31c0eea56b3400d8e81b178bdbc8611149904dec9047a8a916ba922093c5853a0ab5556dadeae7366764bbf994f034f33c71d05386c10376b247c2abf62247213e4ec9712d18ec470830608f45ff2164d0eff9b1849f2b59a1c16eba1cbb8a2e01d5b3eabf0e4adac5134dbf89fb64d84f3ef1e33e1978044552e96c0d8c76d9d46ca1989147f1a5a9e0aada8922368f6edf187542893144be2edc0428d9f784cee47c384cac676bf17286d058c6d6163f9c953d46d334592eab90cfb9645bdc3c2842fca339baf0fbc60306d67e089fba0060055c4a84312bceb04c03c0f26ad0fece4ade49f23ddbb3a11e26e47bfdc9ba284a26faac14ce001486740a686d5d5624348b17841d15efc047462edfadd6037658363435be9d46a8ca408a1ffed1bc3b560b17b28c0f9b81140f2e41d87a2febb6aaa5fad2df3f0d128b28c0cb2da562b78b0c2b0f5e64e2e84221c06398cbe39f06f76c09227131f4900b11a022416ba95fb1184bd2c96c1139d28ac81b90e778566cd871687d666cf040d8e77894e3e455ed049865d54e3a761ec3972742006b7c6918526e5f4dfc4ac65fbba903a2fced36506261659e89e8f68ae3a90e5341f2f2b50cd8e21e40ab974e414b4ea3e8ff4bc96ae5f4cb9ca23610b9b87ba51627a364cc9c3e63c567eadf9f43bae01ceb6e12baad359c10f525046255e39fe064a3c8e4d133a55a0376f5c81cb4eb1ea20ee8122843174e8ce81817b670651db3eca2a467c2c055e304d1840ce66d1bc9ee31360d7fc0902b9579e72ccfe2947c821577158797c2158b061ac09cbe0929afcd6cd8ae94bd1ec97c37839743afd3faff237cd1be721f121f35c737c71336229077145ac2bfab3142ed45daf20a56df240d4df34b34acd3c20226b014086e1398cf35b7f5f4c965dd4624285c1ecf2e6c5aa59babfe16685411169e6a317285c581cca9a5489fc333f9b00c643c9d764286ec03011a0c8e5c3c3c262ee4ae81a059091735ca95f333a7e9c0ef5f4fe3bb1db5902001ff851b6ab46a60459d7029834abd973b1124c4e414c809c9fef1e21d29a46f73d9c24dc4d9023266416dfe5fd73d64ba1ad8b60067b75ccf78e9aa8a2de5678b95fb72bde7b38f2bdf23ae5d1a8c29c5dfcf5432880b83a6fc3a62bcdda9a5ff7295e0b82e67c8a53dbaab33bef8a9218f397a8eb568d14e5e99d5d31390eed684f23d7d97174dde90e1d421e57ff96542282485a2cbe2e02dce719708d9a8bc0915cdc6e1cde58296992e4786e096b7e89ad4039611a12ff339109dcfbf620d331f106ec6c6b02137e6d277f2fc9a15513b2f490a60a45dfc2421020562b726c4db31a2fad4adbaed0249b8c181d63f80db6df2fd41e991a5c6bac6db79e8def6522b89fe37e68ac67e9ae7d450cb4752f636cf687693f99223139c7460642b4c2d1648bd7af91f57061d930e764da317bd37d20b83f897267d94cc539809667753937faaff7b8e61793fdcdf943ed9a0b7f26975effdcf93df34f482e04ecbc1528f2912b1b65fdb4ffb8cab1ddc4f93303a6e7a2a540eaf66de38f04dc73e2c474cb900f15514369bcbbcda37da2732b53d6aa3ddefa0a6c49fac80ec4dfcfb051bc59f4ee6bf5e3509b15a99dbb747df43ac025066ef0be7137f730997191bd9a3796d823b901774a4a317c1411a247285be001e8837f466e44ca445b53cac51c03b06f698f85f1a9b35c64844d444ba46b440e39d772dc819d7b9f00d58afb93b8284b718442fac3564cfc0e35e7956c89a235ae363d4fbccd397ad4ba1dfa7d12980c671fec2fadfad92028eeffa8e5f160cb4d44b46cebc72ed24e8a361eae43dc5cf03b7477867bddf3461cdfe1426c527ad11e8fc020767085995546fa88d0c780e633c5420cbd9f365d7ca27ed13e83c5789924c88036a08d2a04041906fa17cde3304e2fd1b1d83970d507b92489f0ba6658ed665b6925c76e22a034ea85700453613d92ed1dd351dde825720efaf0aab6263237cd163c665da5579cb38ae5c3293056ea76813ed8a7c4090ebd787b8dd749b381f5d3d9fa91fa2d2e2920b6322209fd9ac378eaba05daf8505e657404340cb7aa032d03196603ba2c2dc0da2ae4d72216e6f44771ff4db665a743a14db691168110d9aec4eb846b1101c6941088075f2d4119fe8c6f8e8cc6c232a223ab9f447f5d88cc1545bbe21f1e7453ca6547ad4f1cd4d3b176330b26ab1d738fafa2955a6b1c2aa64a21379090f120e73e8e53e32ea5a57e05a2b071208edaa3259585867bdcb037141c22c54c4f3472b2b516e78337c9e9077a4d650854a3499bf95c82a06c9b20b78f92e0e1e910bd6cd4c9ef3667dab6592c594ea097aa634b60b1be2bc94da1b66e7ca64eb1b7c4da95fb272264e509966563291900dbd456fbec151e0c345edb2129ed0a83fc0eeadc1c2d3d7b46779003ac84739cd764756be67993230ab825a5442ccdf6cb81027e930d5148ddb1107754adc05f986682b6265fd4fa588ffbf13ebebbd7dd406d5c0ea5c6032f8c411110ac148b228d1624bfc4f348bd4488b28944a72cc8339c1ada6f91d4dceef91c2de256687319c113884c0e836bc8304f1f9db51d088496c3babe8b634c2038569a08d79f0afc795572c683cc8f0a7eca0cf0b12411c6abf2a90700813bd8696c841b6f0f46ce7a9b417bfccc1bb0c72b2d129d2f77347451ff95606f040672118df589177d3ca14a9360cf6f97ebf4a8db4bde190d3b3dea35815625d59ae918144b3029ef152f2e6495d7985fc84d2ea933f7f06519db705a1ae73b8c58ee25e1e9aff4f6129221a2602bba35ec08935e54bb0942af0ab8fe372e95ae94f5ccf4fa876c54423bafc944aff597cd650f13aa92d305a22dbbd7f7eb48be8fbf4c9c2a9f30227de106140b20ca28de73ad2c20fff9dbc741699b7cc866bc5173653c07f67b233940cf7dfce804508f777079ea7328f9144b3b190979d35df63efbd004ec3b86c639b58c8e5dd5b78b901b01506393bb2b4b0de650d4bca46acebbd0a9a97de8c23caf804f208faaac78741d90a30b4e210204665d2e2c10daae3d6e191f1913e81f03ba964b25760ae3620b74344275eb1d46eec322c3a18e88e4553ae719eba74db0e1e7a8917a580c308a0f397498724b52882239071126cd95ed72443df72c7d4135ab3ee32bcb88b9b1016a274a400ee687fb596c9909952e7f2da0c30505acf0f371cfe6f41baeb900da990433badf992d0251bfb7cfd90179e925cf52cfbc522317c52affa62a391af6e9d839606c21aee626a541eeeea45b9139f6fc3eddf2622c1737b41746234ac951be9e5a0e5e6970535b26b95a3e52e37de4daf24b9c3434cf030abed5b35fc9e45e272b1ca8bbb2569807c4e579e7996881ba5faa257b9647d1967e5fa0d8eba6a3ce5406cbfa72009f2fe6e6058e4cd84023f3156bcf39744d928ac4ae0e03756f71eb7ee37392fefad49a3504a5f56a0a2f6d1e3fc5b3300582953d0d996bfb151a86c9b80fa11dea0ff3163e3dc7148e45aa4bf8abc912ca2178542a86f476c236cbfd39f729c322a7f79981dd79a0e614c7c020878c68ab0c54dee1d5e16f1fa294dff884b4010149d07518133ecda09dcceec29cc35fbf1e368bf16c4e70d7d2974ace1efad78a8cd3b331e3c7aad98dd3b59f49868ca8ebe9b963600330b5abedcf28508674713e55defafc0e6ea215c8da2ecd19effba59219155773a622fd10e9e4e75f046ef8b5d7aefb79eb5cb948df81d46a25ba5b694462cfc085345057a8200371e01832f45f6f91b2b27e7cd16e1004aa6388a1e54b87153995fc8687d64a51faa19e05ce0a9f923d4c668580ec10bd61f38085ddb9ec5396d3d84f74d5cc2429bb17feebc355bed7b17a39e59baa19c7ed9357349a27dd6d4ec2388eef7e5b5d7fcdf204759ad1aced831cc3149dbc2c86c155234991e016ccaab5823cca77400594e6afe9979dd8031f3333de5c77e1799fc08b02488da357eff8d409de36de40bee4e0882363748e3eb5e19ef390868f9d0a16683b7ff5740789251c7cb1dfa67e21dc5536eebe4deb0ef6204e138d9a5fa8b7939e1484305408a5a82a56aa2d2f5a489c8ee05c0090511793013d57909e31045e0a35a63960bb93411383b96c1d8347c03b085389607a411aa65c55aef8566e8718a4c4319021d343a54399dcc34ee3422be9b18b83bc2f50bb0edb87699bed661621b568683079d2301ee0520ec27d59e84fe26d16d9ae144bcb3528752d36f7a522ac411cdbf9359ef3aa1955c0af2f890cfcc72579e695b556b2dccb2eb3323c3a7abef4da03ae747ac41765a8bc265ea28902d7e97182224ade27a46f859e810b7989c926c8066b4119be6e7a76f12fff60eb289d6d40586274c63ad4fc89ed815bcc66f6e1e9fc1fe400fe2c6ed72573a741c01451ccc531ff607a2219c79cba9a2c259bf2f84c41c9888b77a1f438f33aa42491184801e404f0947dfacab16aaecf3c29691d7b337a4c1c6714d6a63ceed2b26c609e855886e5de10a7eae0836b7a0c29dd68cc3f62ba990cb1e1aad5dbb00d8a09a627d0cfab8328ebd9fba2c1c8c71e7435ec355aee1ccadb0bbcf4022ec17ce995f501a0a5e0e1de95de703a12c384f02494987c34344e326d2d49b6ee836b15c0b0532eb53f5f36ec46a940223ffb395ad95b04e6dfd30170eb99f752f275cf55a74e5d88484887c31272984ce3d923bf4211322dc44f358ea9a80595fe7b314cf34fb1710713697ed739def25bff6ca7cb3c7f13dbe7d9f964e98749664b1181a7b0684e45f70332a1bc9915f013d622a7fcdcad07820fb2a7f9ebcf0f4ac0cd5b947377816d314692878f43c2f4b5e1ed6cd592f8231c66273b57b8aa16ec720c89cc9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
