<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a28f3efbcf0333a1c1ee1b8aa278ba9dde33f06c8bacb92f135d514c6c5a2c9c9d84d7417bed7714a4743732cf91fbad7fea9f07555f176d93288b3be87e26058ec074b840cd75eb9c732f4b22c9c14560131b315a0c421de6d9e1b9ac904f0142d3a706bee1d58683c639b40a0e9e55b07f3c62df8a3df35da00190a3ed53fffddac6859c3be326375d9596d1d0649d6d2e1caa800a562ffbb9fca35b6af98ade14785944acb9848641d6bf22118fdca5a6dd110df97e9b8d57cc49a569455e88292af67b7197e868a9f2aead729ebafca7f097426cb67fc5251889b99cf77c01ab1f7c9adf1fa5e7311aca728aa226c645054347970541f2db7b5d7515b526c97900ed4f17731142f37bebf84548001a1a002f3777eaf84894c1a24baea2bdc777f6ee25599ff2ad4f4b8a015c00e8990e219fc2bc2d29296de44bf383bb3e990a4a73099971f1d32424fabb74d31f349ab98a48b79aa38c1376941d7716a3b4687cdd135cc1a0601210dcb72ae95f64321b830b53f033cc5df0bd04b95f68c304f05bff4ee6fcd6b21c2222ebc853f48723c24a9e4d24b1377752b3432b145b5c25dfe227ca911c5a8a31de434821871158ccf4e162be47d013d98c313f227a7b93878fb900ca63a543f242806ea24c63c66abde97d2518c14e882d43dbf9f9205161b5bce713084c555fa047e5566c6bb940aef915d1dbe0923391704ad2b3989209024f59fb751b4c92cc4b777f641bff3e9b7d2bad11da682a661d0ec11c48cea4e24dda96ec7c16aa1012c35425de8920c9324cf2ee6258a68b4e3e890a87f2247dcc9d2b7911b73b7ce020d91c5d751915af9c9214c73c9638f454ee417c996231db74c925ac3b060df9eee42aaca6dbc7b7d1095bc05ad8972dfb034b9f73c271c28a5cfacccde2e0d9f40a56db7aac35b547ff3f117d9114ccbf10a64e4ff9206826b1e5b9366fc529cb414bfba1b0a4cf73312102393515b43353d1f900406ef3f65063e4500a184512fd6ffc747e00477657ccf3c19aaeeb74204eaaebf2954c39784e03845aec8bb681d6c22ecef3962d63f179265719fd1cde6f69a1a20b9335debf4b5e705c6a86b1c0a7f5da9bc993491b079477ec36a9b6f475aa7a4b1cedac8be43c781674a5a0449a97b9b1c291bc758fef25f96f48111f542d0c9424679586f193ea62ae3a2899435c1e4f898aab730fd3ca0f330f7196cab95fd4f08da177c15494fab20ffc94777562c7274f8400493454c212917bbf3ef5bad88635558681c094166f462c9aa89977f73737bb1916a7741493d0e31614aa38b118d584d3b130e5b3eaf9bbba1f3717c71f8caafae0f6292689b54f9e1e79ec759c194b5b9a61089147050671ef246c3f0e95e3d38f3e1f5ebab6d8594c71afd1f0b4791b1cf16c55a96542a6edec417a93bfba813dfe1ec2684a9f8ed5228f70d2668e629ef9f1a988edbbb726ce2ab9b5c368bdddb67283845ec1a3f525127deaecf5860df128e7da23109abc8a61d748b6420eedac499ac923385827da05ac5cf33895b07fdcabf9a58747e582824f1a703a15e0a131508a2dde741d248f78794c91baebc5ed89d3fda952253882f02ad58485168d8fd1ea1ab21fbb759b8715beee70145f46ec3cdf4dea44324475fc88c4a9ead18706668fe1a4be41557bdfe8414cc89b7d80be1662b444da3f470d6ed15a2f0aca734b701d6f3789bf99e781200f6ae9ffcc6edc483abb9c02e0a1def4a12ccd2d84ca3b04a1742363831769dd6865638b391356cb1e9ff1483d898a1f8817fb889a9c63c056c2515f5fcabc0a79ae720ba262f4beccf03d175df794a7cade8ca1aeedc15b9172cfed3cec017df7deff140bae13dfade065c43b856c3adb56173d996d8e4b991ac4e369bc22f309c252a62634cc81fb6a202d53bb3ced2e37841495734619295adea914ce50ede5103c033506bebf6aa8d6c678bf4f1cdb1e0952ab114a9bb992c6bc9cba1f5979ce35c047361e68acf749e7ba0d3279871c6c2998b9fe42423cc3c24aadfcd44ef315b1a41d2817799df7c6a3b3fcee3efa0e80e47d3639ccf20d361b1845e270d8590b63d430afbe866720c5b52407c16470713f611193cede6a28885d4fe3d214f30aa30d65dc6512a913d31f410f0427bff9c08af52c638fe95c3b720ed8a4690054c73f3c5e5e8a08dde053d4d9bb226ccb209c4f23a783722de013cb3beeb70e70a94143d93a3a2ee696e9d10ee69d22c6d7678024f70a28264268119fc9395a5f0d234d8adf47b00b65c8c77dfcd72d515771904b55d5f021c971f6f2ab0b484d8aad8c73a129ab4531b4eeedec046a31fe549e5995e510dab7e29f97399ed916abd7433107b90f47109ad80afc0a5214c3d93761b5514d0aa4eb55108e576565771bd78d57a31eb07a0d3e67df96d8f81f0460fef7cfebbec26f0ca9206a525111c0e47c32fb33e9d48d97689948dcd6a74bc921c9f4c16f3b6de4fab9a8d094b7efd065da55e210ecff5b6db07b3aea999198379fc02736451b8ffe129338a121511bffb5a4402981a14a0645f45f2d1a0f30149e7bac34afb3c93999009add4dd50178b692462cd7e112430d295c795ca4bdd7279cc06070ffee4e97cf86b8bb226ba8b4da4d6904cdbc46d37d38a8345f1cedc2b9bfc462eb896d8c1c14cf1e3d284604474935bdc2f2ab8eaa2a30987769459c50fb97d4386e36760820b155287276446e2d750dd177a0fdf9239676dcb43dae905b919494fdd413b38704ed14e19db22c859709a2412ac3226b7415504e2bb181c93a7a2e71a96c58222a97c276fcd4a293aa91ce2458f3c68991f6eeb63dfe5ffaeef46e14af2cb963a767a9d37bff766a35c1063ae71234a7253dcc396fb2dec92f918045d3837ebd4368626d6bae48d536e9dcf8f52a21099265b278d1dd585ec27fc2695e8744c1a8cf45d7fb84cce2fbd8ff2b04f7655a98df2e7e8082f53c7bae6a0500fbd3d9b81fe6b4038e95d4b2b822d73508a5649de90f44dfa322a1c6da1c7aa25041246574044182993690f21cfbf3c6304b98ce4a10ca49676499db47f16f9796c272a997d13b025d9428e3cb9d9ec03a63aa6117d6095ddd10e4dfb0a8bbe9d8b1b357702e5a80105173bf1738fe98c36ac1de5e1c1bc5790b6843ead1520f50d93e1136617ba4bedf7e8a9f212513f0fbba5f0c2e0e9f7b917c9e2bcd6c06ab823f860d5f19f40ec55d54aeb54dd1dfbc6c7d3b3bc4d7eaa6de241b85b074ba84dc8543f4cbd695149b45e87aa18c5d8fd2ca2f29215f5d4545d7969333c14fd70613cb2f464868ac22189e54b54d388a8d129763b7b7abd542c4eb7ce4fcdd71a4bfec8247767970afd1ca5b12d8c8dc689eee156e89cc7c454000f4f10b651d7da2a1dc2adc45b826b9e4d26c7a924b9b3b5f28d169051e6ccdd0ecdfed267e590e914fcdbd0e8f0ef1e4e3a42b8c8ddd798ed8ff046c0acaa9d6577b5ae472f9535821e69971062400c986e7c4e1804b93018c26dbaf50c4bc9cdd6099085551a0b7ab33fcd2096f9c03b90a262bb1c3f13ed048bffe910967de53899088183fdfcd4da9ed869eed1bb22dbb314f58361be2fc640ec2e9d5775f30f26786599d352b294f52159bdb420256fc78d201ff83b2607c0e7a2207a026542c6994e0d83e8c4e89efd1495a7dcce871e707ee3714f667802a7157b4a7dda7361096637d89095017e3aef774ef8db9f5fd30995248942ebc3a2cecd5372fdb23ab2d04cd6edbf5a48f3b198b0711c9684b4350db42e88d5872006de7cb3b2c72e9633812c12ac2d26ebcb4ea603e2e24b767e37da506328078c4396e2158853b71a253286d1dded6e913cf783df568e3e0a3869a84d34d2915c074fc6a2159b56f97094ac61289a929f1c7c78347068f2565f344ac4067487005c671b861fe286661ac3ba3c500a448dfab42d8ae71221957a5372e9663f36c0f15be028f7048c301541614f9808faedc5834ee076bac1233c15fb58f3ec99fcaeaf4247c42e78bfd163f45048ac6202ddcc894b1d9b6f4b23fd4b18360af30c096bca9905abd3600631aedce55e9168bbf7d8941f52a96d662cbf91c07c258741a4069069e98a0371102d11d8ab81dbddb656d830311fc935bdd872ae2cbce5f7aeb41087343762d4a10fd9cab96ae37b284630ef143d2b0c0812b15403368e9d20a8d1d33754c570d708e0accfd84f240be94030ff1fdd7dafd8bcd41bb39c63d2c661d491cbb830fe640888f1b69cd49edbd11fa4b5a07b5f3f0d8aa86bce9caa6374705b2c37fae4efb5fdb476caedf24e113977507311603c35ab595b87c08c90af5450586ef206f19dccc6bad96a929d29af3c69aafc34ad272e31b707976b245ef994a52d08a89d03130c1b5ea65afecc7c9bcce52e398c2b682e54bc08209e8b91c869fa45a2dcd3b637b13bdfbb00c63282d4a49b7f1159a667d9e46c0677a7c876fc8a4c429c948d3df5c649dbecfe375f94ad0f8bd11469358f6c2be79a0c89e33705dee5957bef4a06055dedb032f44b4b528db748be503c44d154b0c872386f704856b03e9c5713a30e9fadf85a2c8829a6ae185da6e9c53dfcf6954b6873e46016fe1b6122adaa1d2aa2faf21e45eef1476cb17d71a4bb0be3da69d8b6db932a1dd77cc2175f3c9ffc95aa78698b425aa3d5e53cc915e83388e5f765ed02f629ba4cbb617151c91c35b97fac5a938110a5dd8e26c3046058e05d4e93f55ce06066e289fa55a500eac188e462ca2747f811363b904580df6044acded9c29c92a966364cbfdfac003e85412793629a891f55c4deb94c6fa3d7864f2ab93c12b9a30de0c614b4f0dddd07118e95c6b32e0dcbbf564d808b264df4ed2160b0e8cfbbc148202a7640058096e0c64fdf763f24aa1f0492fac2a342554e4d0f070d24221e1871586915d78a36763988027cf76518ca58675c0165297dae9270b60e9afd062847198535ad95be8c9d8f600c63526eecd598820fbfb6fa23165db4eda575eb09e65481f1cdc3a17795e28e1ee358e4dc3ac31b20a59aa49dab73e6b1b67c76ce4a35f97b572bc987d53064f09a82dd6c8290f34c8520c1b2537f687b551dba267a03e43a8f25cc3e7066c989e928426b73698232ebb0bee1569a2318ccde58e316e01be913b10d24e16ae4bb646bb93f07d3cec2ff0802c0d78570bc97ef826088536910974db845a1f766cb167053b7924e6f8072cfa4b7252042397f4730d40636ce16a95307efc1ccce183d5dec0f6ec29dfee75d823ad123e1bfe6149e8c07b7c15244cb2fef9857d6d59daf573b6a48c1bd75c8e084fd171dc1547487f326c74c8ac36fda65dc2fb4259b9f765f159386401bbd0c81c917e377cf7e2d7ff3ff4f27cae7cac5e7bb41ab4ccf941fb942ab7ca359a44bf31454b74a9190419200ff1f018fba4247f488a068bf1a63484bc8a4b3185f979dc1bff505ec0221b5078733898294a9f361f482cf00611900f26f04f3b1ab9ae6500a4fa96b84446921b3fcd5057ddd66ecb00970da48d7689e898c417493219b2ce800241774cc63113e419bc0fdeaf1109130e0d4343aa20d836b5d0a9a6a47b607f0095ae94e19f381c50c19fa1aecdf88cace80ce443e98c62fba9aa62abd3de86d9822d0c2c79ddb62dc6ff71ca53ffb3218ceb359a087296b2a3e3933fc69ac71e2a67f7442ee7321671d723a44a6727364f8b029a5e6e0d3bef87f0cb3a3a786a71b2743d2c5b7475c48881c7772c8876a136a752de6207251884db7ce7ad041d9d204c8ae1f7a8930230a91d6448e4ee9e95e0267fd4bd625d8f0474b99f3430ebad18f8c820db6e7920c05d5eeae32372990d2110f46250e2f7c98caa5d317d9b87c3c800ed208eec7d8e28dd20c6e1ff79f0fe32b6ce47c66d568a3bc3acdca7ce484a20c3d009a847f50188c5f8d0e6948c4ce8459f0406594715595ba6469d3e0b5c9bbf4b579973ea9ec5d9f4e4896e7de4771fc2f2e3ce4f34e1c0aabf998926098c90d472439a97f56d88cd2f46ad2b55c1948bea80d765e5834cc4150addf789f9c118f8b604ea4aff925cf01858a2637c406d11cf3be513a6a3e0d657075ac441e304779ab338dd3b0d48dc71191566afd348ccdf71d58d2406a249d04019f89ea2ece2c423423afe6ae23ac6ccf86de73de8d3add75f5fa9e625502ae561395fe7186d09527549e918671d7a21ed7cfc13cdd6a724f47b7e92dcb6a5c17d95c6036ee37686d6c5554f74b5802fbb76306a0f9ad48a33ed9a489bdef9d9f4f79e1393b343cd955440f02f93c9fef256af2d44fc8700555ec1d0f119f9ea52deaf208fb5066badd79e0a7bed66f1bad693dfeef5abd02368d1c4b5faa684f4193f4fa63e6a5bc326978052bea63445804bf0c9581f19ac4d4014750e2174857246f1569459449780a2c8550823a3cb57810a18d6d48acc6ef1e2c0e194dd9df885e55236b881739a1ce792d649f65f1f20a2fd5fa82540f18bbc925088b5787c369b35cc7de5419ccdbeaa868ae33d7c161824c75f732bd84421987ad6c724235695c041e73aa9d1afaf0381b4283d468e00b61fb914ab5a7617951b5901c24da31b338056943c428e1e99b812805b233ccf7266d6ca3ea1f055debe832ed26644ba9a2f7ff5899dedc59f15d4b0d48bd93fce5571ea2c748e9894a0747d5505c3770042348989bdd39c98203e81a5c759c6328ccc322dcac225da47db07fae3e92d672ca3195bc23f9eb0ec741fda2fe846c5b7f0af0fe327fc2bc0c38f35ecd67e3472ffb79bd50365e753582f6fd5f630aa282ee3bcecd8fb8ca1d5615b9cd1dbc65ca920bb173250a55f53cac7a23a70c54b0c7c80d81f26b0f18f06e3593c5abdb300977b67bfa28e5b56129f69aeb8304410fd36e9d4b1b0df3495296105618607a9388b09d279dbfec24ab74974f9155c0039d53fde3070bb17d4463c5c958712b5bc8d2ffa4715ca5ef012a70d498698290d8de348d7eda0f958051c64edb8c36481efdcae6a8282f2212b503eebe2f226a33eb8e1c81139126e3cd9914c05cae532f2f45debcc30104e38daada42dffc9dee658d56adf399432703fc4247f724303260c0611b5edce3ab15786c6067a3c34c64eb408edc87103f986a0fd7db704bd0d5e53d2703ba9e77c4f4de44ff9adbc13233950320abe65a553335ccdc78bcfd6321a91bba6fe4556cb8428a66533017dec136f1eb4fcec168845addb3d5c7d2e0abaca5ebca214ae4b23a64ba32bc0237d826b46e849d6a231a3430130ef69bad82b9ac77626846cb9c4c14c79f3af7e405c2563592d45affc4339628be1a6c7c0493f6ed9beb9388d60a25f4dda410da9854bd90d0820037abd1275ff80f96130375b32c37e9d0a523999aa7c0c403df6eb71f5f7fa4a22fd83921ef97181bf7d7ea87b7900c2a0b44b013eb200f1848d95c983cf787fe293646b2fbb5537066d94f08c9bf6a8ad5ddb35df15a7a3080097332ebc53ebfb58b07127a2dd5c98a745db5429352ddd6d9f9c4baf822f36f96480140c4afcb45aa55bf76a790f70884f477b535cb4a8f79ca857e6ac4c12e1db7fb3b0dc1e35723ab2b31fd8d24bfe9bde28e53dea9187a2d9407b7d000f6603c6f11cfd40f85cc23b83b54faedac968ca67547cfdfcac2f7334d7b77ef3a83e1d1e8201b6bfbaf4e4c0c5696887dea4a1efe5a94761778acd9ece9853785959ddfa42bdf57986a72189721ab93eec55798001d30e0a1d1dbfafa0a8331671e86519890ae443026504481863bb6d3f29db00ad0f33985d3c7408324ab1fb155ddb4ceb1d73c1ef6eaf25c6ca6cbb9dff63a2e0bfded9fb5129cf812e53b34ca6e36d48c6ebb1433cee582b3f779298c960cbd64e006d8956312a18c96d99ed94b63051ae02703858426316a5e07c6b3d6cbb5075421dc1314aa0de6266c62f6c1b54b8dc926bc1550a9e054fabc3abfdd60808381e62e890932f3b49fce24479ec68a8779c0ec602fe3c2bac2ddd4d22908e4b827ff8cceec4e2975a1cf1863524204e1df149d65eab8d49b2de51f7b4be1e9728502bb918111a5ba6c7a1d078e23888688d349ea415da76be2d7f5fe74f00bcc536feaad044a13a09bac81c82ffde1fcff263a2ab49e88e1f6f5dd2543df55e26f19718cbc2d430513e85a8c6e501d4a5e5aad9140b6855460f6a49bdcf27e18120ef7dadbe3187521c4c0c180f828d56b2ce85e70eb257fbdc971cd6bf8df86d538f7648b0a1bf545825a272fc38248672388dd947210475f3c4bc58a691e2b95055b83761b3e49eed8bddb38a8dab22fdbafe9dd57f9fca650f4b7222405c0964f7584bf169ee2022ba1bff68163a80a0a279637ccb6c5f797ed9502ecb1ff98dd05e27b744b08b561bbdacf28513e2cca775d66beaaafcc0d022eeed26fdd0fce4dbf644f43570c2542c98629b29fde3ca6599ec5453bd618af479e9fbbf418a50eb74d1a13228e009543798f1684266e7ca6902f9c5f0033244edc9487f36448b5265464656b4d019909c5ece09fdf73a2a72b3c290c4d7f9de0e18856a27bffd1e5e1531ffc33cdacf17a6c7c8897aca89fb23ce236452747a6e45b7a6cc386e72c4b1533dd9cd92a43c4fe6c9080914c3cd24c883f63d31803d1232266125ea2a57c62ff16e285dc5d8ac3da0a1c0c22d7eaa0ffaef3826bf5eef85c1965907d4e9d6f401c611b495649d3b104f15098a41cbb04a2f93b7ccc4ba2845585f671a87c7b9dfdbc1792d25a4b628a21a72ead443bd8f9088bec8385ea266a7930f3fea8fce4ea1aa9600e1b69a36e4eb364272723aae96072e5bbd1a1a98cb5618c728350181e49c09db53f93549f9efcf069d2658cdf794fab900d8aa795603339fdf32cf81cfb2da02bc3017cbb311b61b48ced98573ece6b472d9f4e8a527519518b242f3dcdc77c3f78a9c063e1e308d660b86c1f0b7ab99b58cc14e482c2a72d03a2b78c43a063f47164a83c5edb2720d209c3db40ebc3560275322f56b20d0e23522141cc21390d32e69aca1bf5eca2735a863a91f16555f3eb0256e6efd96ddbcfb8f094db3c998f960cc752750768b2073efec1daf656e989cfcaf639d13a6bef4eb68b8f0c483462e6550acb1079bd8c1c6a78b5d5307891d47c94ce888e167231824e8ccda5ef597c2e0b25f829408738a7189e36d326a7026b1c519397c9c2527455da5ffbe4fa1a055b566e5f7cbbabbf0a8e48fe01c417786e704d71ec41e91f826ce9e1798d22fc9300a4f6c28799713219a9c1723d6eb2c757281914af8bda53c4370fad1da11830ee5d759f08525b4c95fec9cd6f8282cef0a2e8ce40da9865ccd8965a234acb84b4a7a0720d4d10ffbd5044256ff408adf6a3209980cd9221e5e988dde4850dcf6f166fe714f6e1d904eb20fdf36dae6aa6402cd28527d6bc6061ed449324b3aa88d33ca58beba5364eeb49e40a8091cfc89e4a7d26fde1c34c721fcad11a69dae9c89584824c5a0cb90190e1d60e52ea5c5c3f75dc03e52d7dee8682e50fff6a8ba786f1a45501283158d7bcff3d0335d3339bb41d72271ecb52d525d061e5ee58ad3c1046ec8b0fc7de0dceb2b8fb91e325d9d946e1e2dfe05c2bff0867dfadf21d95b1e755e5e7fe3814a927043fecbfe38d31946f8075c3e80a78f3adb0914378a9173403313465a2c7c8e42ddef81d70fee13c2f82e5a81c5564f6e1d920eab72663eca5f08dbd6ee4978bb20d3f3ac56a53a7256691da4b7025263d1d5d85f6204426b2dd1c9f6aa5eedd50ff191b1e047d1852911b2827cc64929da1552f7a71269af6d7f80b0ed620086ac213842ead6b4f7133ad4dfe227d5fa1ab3376e2645a83435567db8a7bc8f8fc1edb47493e63bc50df87cac5d03195aae941664ead07beeffde72a4d7438d1a3631eec2598185113160c5d86fc58d200d3241cdd136911c6ff91d83b3a1a19d372981b36cb5f41ba5668861baa823b2b444b2f4a65dea1d2e3eb10a53d35295b38f42773fcf2c4bbdb9178a2bf3842d330aafbb780c58c3264a5164d54135dc4f2df9f87bfe010be379546bab3ed59f40c4ca442217fa03c387c390048dff6f313dcc67f695652aa1c624fe27321fc3e74522d934352fb83d389f17799252e9afdb92368948cc109bfb02733a1583b0900bb3afe05f5bce7763e9316dfc9dbb5f1de6fe5be3735e1b8cc2f67a14afdcd7e13570cb2502f3a462e76c9b52d2c77b4e94561044613d046a5aebc33130e2af60a21a83835393311729094892f189354b0bb0d9edbac389e652d0c18a9a884bd51fa2064d26790e30cd0f25405575f027fec8fc42c8d5fcd0848b282ee7334bfbd3270a2b9705bd5aa2eb6c92302043b83b3707cf390f515d2f8980828e2f1ea0ee58a967e5380b7522827ab1cb873fc38ee8e3dc71b6cbe9fcc789589f3d9e124569bcc543c73cea902f1df3df4922580c8be99a2249ed81a8f416efa4ee509bb423b8ce1fec2ba1e26abc81be2ed7718b2cb7f8d70abe9c4b7e6ebc4e80ec84338efd623a88538d4fc8eefb22b2c90dbcba7a2bc69f19cf97bcd09f1f686b4130ce53674d321e81cb31bc129059be1cd2a18e34addcb222f03eb731f84d7d352ff4950a79c1466e3b54cf9f91661001a828828e19eecb6564096bea4aab6a79d93d292232ec9b82e77f10368511709cbe191ef68f717aed1e84ed9d6a7c33349a2b8a70364312263a80086ccd243015805ff42d8401eccbdf1d76d2408b88fd834750a1ad73f33abfecd9aef72af908160cebc64db3f1935c350a79dffb29e7f4cad52eaee265413a7eea1f185c414f959ea2887edb8221f19e2c0738017f77ae13d528b2f1134d15dfa75cb9e2936e8616b0f51f47dc0f4f736567e354c54659ffae966c43f52e27751a9c475a40ceb5b342b9861816e7992b91b21edb2413c4960bf65c56db6bb396f7147f76534847df7bbab6211ac98a84559c73f659d91404adf2d4e92226262619b037c8c8d83ef829926d70dcac5e89a09e6f0cab42c620846292747b1057699167dbcedcca72912b5865531b893921163bc8509c9a8e9a63ea046101f13eb0f91facdecf2ebafba273133c70b1402a06b38dce2f0ed81e547da378fe4b68113a4fc75942fad40b2e1917fa2e7d312f6335bcaa1224daf19c62bf23c67becb2b39e74bda5d51819b26c4836e425d10ad5a75917d4ad9966f1d0dc87909ea3b0ec832010d9bf3ae53d5692c2dbf0de296fad3b8c1305c38f50ee9d81b70b38f2178bc6f6c6a7939f06ff766e54f947d9724503c97dd1f78d7bc90ab6ab0a1f3fa030cbbf1d7b6155dfc5a27ec32dd5eb3767b55175ee387d976e85ebe62ecb4182f27f4dc9ddef1a94d522bfb723f06db935ed72957aec5535b43d9aa7822b11aab5204448afa0230c2ffe5214388da7c75064cc1ea44f497de49aea8ef959630ef748836348ee769569d17a53bad241de233139795a96c40463b936103d497e86629aa883593c80524da633f5c8b39853df423a5969588a6ae8ddf7673df27993960c9e9d97b9f7a784805db7c20a719d3c5f18f3a0a27f6c082e46a0ed197eb271423e67db806b3eac2477f5b91104bd6016c78619718e84c0e7a872c59edcf023391234dc690f505d188ea6dee5160db8317cc4b7e2063533333e59781e8f0d4997b7f0649d2e3666768cd603a04f43297a8a545f88939699dbb571a183f4c645c23fdffb869e927f0ea2ff6fd2d38a5403e7248569df1ae17c628db91bb1e530f307a977a6690094ac783fbb04827df7ebdaf44c2ba9535cf35d532fa7089ec8731e9d398e9cfaf3f0d12ff4b7b2159debfc311364e7b4524aa04fe724f3b375e287f138ed7d6cf924967ff74490bfa1f2d12014d656e8a5d6834cf70bc2aa813c471865cd9a1da799e5d13e478b3be26d84a8f3ff1e781b440eb62a306fe816607c1c300911deda52eac5c40b88ebdce88299f24580318c0d4f92efc036c4f6b79f53fb1b77593363cbd8273193e15e6313897d189e287b6802c71b1a6542bbf61f931c385148ab6b726ff2922281ebeb700080a2719a780a2c339f449651f16076112702a4c2b87063534132a4ccedf1b2896031e99707b6c673a3f7c768c0f21290462ef71071ef21e4df2652c494c38dbadf6a23cd59927c608ec53e772085978ce833adb9946ed15adf99d2bd0befe8a560f9b8227dba9d388b081cadf819e0915407be8549befaf66c9813673308d2ed11f20a72dcad838912073ba643a4ef8b651f09f1e232dd2939bcd0a2980aa24339b0a8c31d6c3f03005538028324777977e9d34b505256f19dc984c4daf4b39b2fd17f778c54a372c0af686fd22fbf2c33f4abb4b13fbd4325d750928c33af6f872986574c58f5b0477de975b948dfca5258fcaa6361d655faa9b6660d75a8feb2b5f46af01b0cd68f2752dd05d529f9a286ac080a932d32f03905f9553aaf3b796912f01a3fd479db21566886f6cb678acfa3701374af8349659c1655b3a5fac15c9a395a17425c7e02bde3a167951621be8179f7a2dc33765b434f73664e061d861c501bff3e4354fc89858aa59f7ebf046c39ff935777dff74e5f3ce47abdae21e55fd0651d76ba948f4086df17f7ef92f024369ffa9a4d8320e75bcccc2a63e922e54c63668e09b609fa9910c925bdbe8efdb7a6fce7bf062b503db0c1089c55ac96d3398be57a5c1579dab2deffe7d1caa80399738892130cd987404cc7d8ec07261b79b68d6af713ed578a5c4b1399360ef5e69a3ffd792f07af36c6548afea89c4129f82b0e33e7067042cf549a48008004b7f8ffe9ba5555e567027421fc8710cf62db409e7cacd93b5c2dee326bbfe78fc5ebc20befb73b12ffb8e10e9544c0fe5e7815245a29bef562bfbfc13c7f369d89004c89104cf271302154c6a17becfd6a39b337928c4e82805a7f0a60223dbb493e09abdf50318986c648733ccee1a0bd1bec80de2681804e9095cf64b6e524189e392f607f015cc2d914cdcc90c9baa58ca7de619f85792b4013a93632673be34c0d5b326af406180deafb7da58cebc34b547a24e99b541948707488e2714358d2d7e209886278030690adee04db03c80f07926d96a9627be6c3d50d72acf84c69755e223276d61733a26542612515f63564a99f44ce3d08d0cdd85fdb58bb1984079b38151e4699151001e6a4a7c240efc001aacecc9faa1c8ceeeb25f7b3d8927e6eb54b9a04f7e75fa438faa6d723927f0f83e455c9bb7062e06c0e240e467f2bec8a9b530aeed0270014580e5b0396b32f6d0f6bf5304f11d63b3964c8648dbd7a479bae5a91f09633390239bbcdfb892699d9fb151d7e5ff3a47c62be6b4eee3e0707ab18b68fc1533a92c5d3dad7e32f09e96538784ba014d2871384dc1e590a993353809ab00e42e523b49c58091b9c3ec98b51ff34894dfaf01673258e174c583891ad966c1aed981fb59ddf09c5661c6bc14c5ea56105783d267ef7e758470e420e2890b9e560d5a436b4db7549560a2c4df01d4a584b2d74535382273c9debd8fe64bbac2eaad329a7fb3ed2c8ff6f69e66cf63d2be4b9b24c9488e8f15ab5c330a9f75c6dbbc9a9a1b70f425d3164aa18fb4dc5a370ef697c4c93b4975fd5c528ac85aef5cc0007e72674981f1ce0143103b84862ece1636fd082a2ce92927f1211deb0c7c7530741e1a47c370d4a89d571bb33eababf0c5c3842ed541fe70a786bf45f8ec7fdb7387ff9b72f0d569201e80a29f9c00f00d0867d99ba1e19665805944a1905c4c6f4af03ecb55f3b0d004f94e2c9f0157f7a74e53c2c6c63c70653c7d511a429b5e2ef0221dec17ca10d3b95896a7bcc9a94b82e0bdf75ddf0148b6f79073ab4f2ad1b1e2540480fd85f8ea6e6804817dd002fa1e97bdda3a4c574f2af0e7e9830bcf6ad9ec0743c539bacdcf49809ec110c5199d7b97f50eb02a1922b0ab146512928da1562c77519f9d26f2bfe2070b6dbaee508d97ae8dacdaa62a584d71f48bec930a667cbf4ef0a09e5ba4c5680173abded6a9c3e4fa6ef09896f860b7b3e8aa5a27bc303f86fb0d1440e24f1e2517c833b346ec4b7d5424eab1b60fa10f1da117ee8a95ddf559244ecb073176577fd6da74463fd83b176eb4575342ce0300e0e47889cc407a8313923cafd8cc540b06fb897ce4788f8eaa7c0df2cd9739d38f89f7811045935bf608b620c85eff8754d20113ee415bc841d7fd1c4c96bc2b9bc1e6249d23b18846cfca9bde1040eb8180251412143457bd6eb115648f0f0ee5e2e2bb66769b74f112d5bf3a31baabfafd645629b359ed0a612b2441b8e0fd87bdbd2fb0acf6b877b8a0d1fa86ad762e70ca83495f983a779940f7ea2fff2da69de454207e4b1f521ee8b98dc5ef3d785f5b8054c28","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
