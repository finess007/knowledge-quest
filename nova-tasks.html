<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"befe895bf71d581ee8beac4c10a0b5a607fbd3fe0b867b632891472438f6bc37cbc167304daafeaf433dc774271d4f5edaf4c895c002994b62daa02828983d5b562c3d8ff3051193858da543b91dd08b61c3bf17d227121fd61e9e00a738773ea193ceb1385674a044e998752734529e56e040da8668222f25907df3e8a0d1fea2686c5e9367d530fabb94458858781ba060f3138c5f09a964280bf04386e806b06a0b8628bb1289751bd3d58bc1f0807ef7022bc25f1c508e3f84e87e596d6e967965a894851960483bec5e47d88f4bc6260fe8b8b9fc530a9a7e0a5c6441bb87266e62ee2d917161383d59dc05ef1942a049ea3f6d69bca69c09f4f3ba91a244905c84b3d7c648d44f5d9cf0f164e088eef9dab57c80fc0042c13b958dff54c75d6ae4a30a88f6c134d6542ab086c6ebfd6b995a407d29a27b9616278c1545400c4de8ea7edd00495297a0dec7158b6c7a298e8bde7dd4c4906ca981cc84b3bf7171272a2fadb64cef5a4c225bd1d648e818b6c886278aeb59bfe403c21e22cbcd03bc23fc8e646ec03197c15c8fbd351bcfbdf6961a6a675dcf2c45391090888fc1790d31459ebc7972221899a48a529790155544258c4a7537afb09adf173555e6fe174a496c210a06257fa5b92032817c5d7f8ddf0afb134f5cdf39356c9a4512310ee38612f107b843899894cadffd7ce50c2c5d589a6ea2c3df37914103d652da8b533983a006e5ffb70ce5f48aacc40ea9e95b6b621bd04c9289a4fbca5c63901b50b2aa2c9ad22511cf8a1176f7bdb482af81e5c76f0fce21ba61b66ea9c3415e3fe010d1781ce33a6e79a77953d78c4a0f0290fa3661fcc7151758a665c86d84d876353b8090f8c79fb2e537f2abb2d33d8e31820d8e0a89ff62d19a4f62c00783111528b255c1742c2c3c8515a21b4ae5d03b81d8c937651c32ae17163c80d45474957af79eb56a61b4881b5bd110d3b1aded2b8dbe0d326d804c018cf99fe5c598db807f1029306457f3f207460825ea322e8b2719aaf9f6d45576edfc86444b7ebd89bb56e4c93129a1bac7f4c9f11e5c54f31e30d5bd34d4dc7a6d1cc5644d77ac2f7685fb278b56f65a1b86ac34e26fef8f0870bde26d1133e23898a5ec0b21a3dce6fe141f8bb769fe459db7bf0ffd074d0d1ee7becd2b9c49a58a2e36d4ecdfa06ea5670600e3ce4541b934cd12cba700e74be0066f5134871dc98b1daab57797cc830bf1b382eddefb86f6df8ce08583e86048dba8d45ee3ad43f4013aa4fda8965762cce3dbae48684df17d14705a35e3348c24d14d631ead36937640a1a8b46d24f88892bd5c40a95118f73650e0e93672ea6bcd95345a859be2ef3764c0bb19bd6fd004fb61c9df43219a60babd45c32f4ba34da32f7d6415cc0a16b2d1420a211786572451a66078050e190954dffc4ed508897da110f1ca63a8ba568e0483d7e2c02866ba1368477aafe8d3f0f95ea57bebc8592220c6955340a675544ad78e34c13426e0df0de287b9d3ff1e783f75344bed78bb674c439591839179e361bff409e76c710d8f8f5abb1c2d8334e573e085b4cde73a492e410d4bf739d5335c6c24490167f908c3ff47374b23508756fedfc18a879cba2283e3325334018fb842277d9a7b8ebf8592b57a83819a4ddba980167a41068112b8ac66f39337fdad9ec43effb2fc2c42e1736e6b9bb2327af8d6fcfa489e5102f5d9e4a4d517938c6ba86a446cadbe8139b168c2f8623596657374a67e0c12a264596fc8cace7a298616f95fe5452f47b8fc2231b1fb7a2d0853aa0f8d48cf4a44aa353c94ea3486eb28525db9d2f27ebd139d4418cf6b9e3243320ef185b714960a5cd0e5292b6a923030adbfbb88fee1cd1ffa19e045050806aa525800558663cc0fd845d3384ad38c7d7b09326beacb274267b30d3cc2efed0acbdb9a9e690085e5d011a7943ac8f89d70550af5e79bb8fd96e754cf97b32257fceecb9c325250a2f7f6cdbef5e81e747131889670ced5679c84ca0905cf33fea76f4914f8ac570a82f57bf3f6e195b4233359345b174166de1cd01dab1fb53ebdd57a08c19ea14cfde23c71f0880ca3fc597699fbc3228ccf96c048266f65f0bac56655c2d095a8ca824793522f3d89ec65b6b8a38c21b49030c2fb01e8973a4e5e0f30037c6f7ac961726a5f43e1ae71e1500f1c9c030ece1350ed38f709cd3eeb14d290c912ba3a3b9531f99e1f788780fd2b9a7635d3b9877bba431451486195ac5a2f8e8edb637e0e200683508e70c3aa8ea9a4f5993f6f009dc299772708345648b0df7d93cb6d24a94b550cb2cfb61d1af69f43ab1f9bf1c10fae42a40d828011e354b29b558f816c884b3a576e0c7868d16b70a272f062deeafb5ec7ef3422b93b3012b40d4b8181f129fb43448ec0aabe8d9a31ca8f39550eaf7b02c888c4788779f3c855140caa192be319c893a13c6e8f009276b0db90de93be4f7d417b1a1c443e68a7a8f2ac3908b64933bcc9bc825a9febd1cf971dd8195a45eeebf028b6d7a0844af76b280b603710f70e25302f32563f95388a3682e9ac187d9764850735f5261cbfb8d6e33878428511eb3c10f562d825c58ef764c7406fc03a1baae89a97222714e5f58f2f8c407681d0fff73696c2922eba4d0491be7c0e41d0b230ef5ac0d5ae4c04df3c63b73516a555f8dd2228603f457969fe3c3980a84e32879b143a77626a30bab00bf61a4723d7361b1120d562769859747efdf73aa4650ab942261dad081762835f7fee2c2db2d1357a3f19d15668fc10283aea3ebf2a14da6bff25aa464580d47328d4c693201f5b557c58809a28c21bf9eb38e3fa6fe65561c881e41cd504739cc8e900f0f5f27374e4218c427e18325c7f7a52de9f0f13725d17a803f45ed90575fcac697570cf9e657e48de8024e4ed80988e189756be8ba56d37c2474e94431a99048f39e831e5969c0aa57f9aabf5710ae36d9eed947f1747bb32750e63747159ad30a88ca08863cfdbc96cdb39516921b6628cd230b1987ebace91c536bff73364c6fe27a7da35bad635bdf83fd65e663eba9258cf123cae147398e4baf9657a3b79d925899df9077ca2e732624cff376bbea1e046b23293b89c2db9b85ab8671e2a01ce31b3d9d8fb8f2c1fde203227495d44f56732262434660da6ced138c462d85ae867aa2b34e67e6395066c36964e2478cd22a6c17d5a9c77d748a0f3b193d91ddd64455edbb4204c82687eb890ae5e9452d4dc5679b81afbbd51ab1b10f4cca9eb83b4a24064ce18b996884b2abeea13bac7a2485b53ac10090e35bbc14b6b41e237e1b0d19c6e31c82cfd1ecdab59de75aed2f6237ae5fb96a0f96480b00bcb11c483ed14f00b080ab80a49a3ec0309a4d254a8efdc5561aa8766d72b042d47c620c177b24e46a5ecbbd9f36cc555d9dd90aee768c349211e87591dc0c5ad6043e9743b637ae4e57a43cdc20675cf4d6b2bad41f893fcc519407c52c1b683375abe4de865acde32bdafa5701bc3784e0153714a1c47862e9882aee9d67e4dc339fa368de508642a6406c67ee5804e73e21a1fb36b0ab5632e4a70a7766149fc6846ce12690bae340fda275c3b34f217e28cbf80330fcdc68879921508e7f14af4fbe903d2ecbc90d357ac7b41f58be2b7ad39cab1e1b7032e97f07841c372337d7eb9d9a21e4665b5ba3597731850c4d2a68a9369665fc2462cc3d376458a178798665c7d91cfc983e014edabdac85bd6d963bb2f708cac4c210594c217fd07348d82cb113cd16851cec2fe262b5815743086036737d60542a94a8b26d295b9c499dd53800f743865159a569373a1493b0281dabc39cfaec3ca14796e9423b44fd47f8ece4353bb4f2c96c5fe42fd7c7d392a5d5208d7b634e5590788161504f1c02d3bc1382bb81c37c8262ac113a2a75f92a0b8164f9755f7f173659102acaaff9c0cf707f63221f1904285fb2c24972fca14ed2838648bc6ad39e8c9e321f90f4111ce9631da346df26a1286443a96d7e4bf61034ff97196faace142c541e93ec7495bafa190f2403713fc93ab1aaedae7dd725d019c438ddf1061aae8b3e41f940e6d397e3eb62fec884f88c21fa3b110f863a6de6bc06f03e049cec1c3bb7f90074cc634e22a158f8f21c834931b7664c91de575a11e26c8f724e1b3214ea53c2fd8ba74644b79708d79ec51024fe977df7619e858493c1f5d3e2d25ea547926fce6b72b492f61853ce6ca73d7768f1b6884f78261eafa15000c40c681035bffac0717cef407ac495a5a2ea847bb71ed69fe052f7361660e2836781dfc9f64e7f502c9e357b76279c1b60730264f0d6ac829748637707e086424390f9b1039a6ddbe1c2cfd09c56278aa8092c5507b52af478daad1e2218e4007e85d02fe86cb598d4145eb08d8d88105be07a64803ec77164330dbed13d8eb88291fa87147b240de9c730a6a944f0c0e93da58f2219265720fcd96ad15f4b84f2339d909c82cf1e444ac4b9be274d5e74a5efb73377ff7ce831e0bcf8a2d71e4568e04beb3e2d3c8fa5ca0bef12406b9cd1aa4e22031dd3d7b6b85c2f09bcc47cfa551c8bba142f772788f7017f61834159083b450b53a5a3fb0b3dd803d2d623c643edbb0b00420b4cbdcf161900e34df40144bc714fd953f8d1831f006fe3d8c46cbd7ccc5b9c197890bfd109e3656b55c5b13a2a2d9c8f681410b9d439ea7cace3c1c865b31d21e1452d4c78a4ac7e7808cc89e614f083c21f83eb2366175ee3d1b41c822a08690ca7a6f113428e1dedea059c2521a3418a726dccf91b77f7ddf690369a9222691bf1c8b11995700fa13a7e973b72c06f81e8d6f94338f1a688ec4ec03948130ea6c9542b4d0361e044a896b05fbd0e8eea0f36ca8fc74a5c6dcb3f9356c1b905b259c2b535af8e66550d97575a15c9572fd19938d93829f3734c2567aa9a6c32e0b1e71e8f96454d8b7d00e4b83423037f175c42d5efd628c59c567fc3020ead38653efeec8ca903672be86a13b0ca5a253ae88e5fc80ec616ee6bea6e6080301a888235f1433e702d16eaaa8241681ec1b70face49104ffbe93e3002d3317717a71004ce93e3a28e269af028d6a7450a8c88ca6d78f6e296b9a4fa32e931665084f0b71cb74398bf365485778caef94cf050e63563efd717253e9470cf6151eda8a89959e0237006ed98b1459bbb47d88d9d701fbbcd4d7c61045b097199d07945db4765383866409c53cbb7ed11225a99958feb6fef514b47bf9699097521bd0017d1c28ffd4b10f356fb715e2a731c48d0c995efc0c51fb6a24933ad1bf8db4a54f2f69a019af6c5d83a5ac5f705400cfd843b8b0b1c141f1b26bdec61441470538582e375714e74f9757fd1cdff6276bb843ec65a6ff9df286aadc8f6b75efa881381b3d4fa4531dcebffe3152332c5c37c8237346af0fd5d508135e2ceb53ac15335d8c93cc5f9a6292e1adb9b0e21f4862332706799b8b910c7af618dd4550db99b7a49dd93265cc6397010b3e14be153b62c103fb3b11489c565ffed9d740308747003ce4530721a4eff32cb412a2fadc0f739bfd337d65a077951eeae7d36b913df20702ae83f4837accbfcd4e02515cc2d2e54eb73bd67ee1843ae5979b2d11a35cbdbc800be2bf0479c64a1816483078d2d20d93f0172046bd2499f6396ea3c46f931b65b7e93602236daf16b271c9f46763b247339e165ecc5f8cfbee6328a634bdc82946a5a06c37f11754910a72903ad42d41a7bfc58c6fb593afbbfa6811dc5bca038f91fad4c1d48c4513d47ecab3d71f5f344019dda4f1f718f74a5873619810626863bd82c97677007308bb042bac2bf759f96b0031b8a5728b44cbacfb17c2bfccb16126a61fab05c1b680a7fb451bcc0c76e84fd6619d952a78a548075d3bba6aac6a2c76a6e7224d1772fb2af1596a161f8a1a383f3fd8b233699f8b2f9d7a3faa7891c1a0cedac6c2c453c2ea5660ef69d4552f41f5a8947ec4cb5be5c6d1c70f10fa4570a5e6dd203acdd6c18c6031915d65e30ac4842055a366f71a1826e68e00c9bef08009889690b0313abaec01c3785931561ac93e33fb548fbc73598e945d000fc9ad89877ed554d8b508d8f49460034709d42995348ac219708eadb3a6ea094ed9ba539de736ac147c0707883eeb7cecde08a013e4d9822516d78fbe0cbf2adf37db817ad66e38f2e0ccad423538b33a34252450c1d7d56cab2329bebd74fc83a2c360ca8abe257daf42113696a17ca8f7e5050fae4faf977e5f5402313708c74509bb59db19699904b0353ae0ab196a26df384576cd5b879262851b243c6b59fe3b0646078b6721e82b87aa3376c0bf32ed123a2710dc4121017ade662442aed09c1bcf3a246828a9933e61b14febf34b3e8e350afd80ce079120b0c17c9614655131d73cc95330db5edc0c50ecbd0a5716c328099befdef51300879526c204af6128717f838494fcfbaac5dde8f1ef1d532ee1f3713a41b5fa0fffd4493748576a38084de2807b7c7421c68abbfacd62b63bd7dd010f0ad114149a171b418d69412e8b7d968cb711658a2dddae1288cd6c8bc4f175b35ff1fce40c5b92640882d8b8df547320463e00d95c41d3360357c5f5d5c39b8a03412fe4cd815ef51ffdbc90e3599f6a7e9f94b08c5dc4844540f68e0bac7f6398a56f6900a6995962137f40d30172b51f370a46a745d9446db84efe749f081c23eb3d9b67fa42de1bf0e41dfe1220387dbeda8c74eebc6230898e8e27a879be0c1c9d5444639724b4f884e279fa094b5edbcda0d1320f8fac86735a74b13d71230f4791a6951f6546c5f5823f922a438c61ace5fcf2690db2caf3ed6904823b77fb31aebfa555fea37a4483ab841230dcd154d9464eb8e5b28802ec6707447d44371de368454278cc81819dda60a10f8d5c758517360072b328d6bfe38e07404985626b0bdad0da05ab14ac6caa2290fda29b1af3c43784cf0fb50de0c9c539445186f4d75582a98a0c23c773e52f7b716fca7e6ea49e7152e6d16dacdb159762f7c4e79fe0d3ea0ce62caf4474639b933f3c984d744db1f419d60016eb8cb3074a3c674926b43a62db8f12c944f44342f0a22d3b21923c0aa1885412ff70ec4b2a61cc769ee5f502a8140a3467ed272bdd550723e56a73a7e9ad49c9a00470ac03475b22e988483e1316c69da05088ff43fc50f11e3d85e1b8dd53a538df806d76a447431b0be074b2f9b588b8d978f2be030e64219e0b45948059729502e37f849c2bd3f31829a1d679d6c242eaabe8d3a5c4f7d4f91fa88e71963fe0095af36f92959df4fd9c98e74f9a8bcbdd2ea99f715386a9b97c094c7264e49427302fbf0abdc922b185bd87f97a1a908cc113d5aedab29f199467c72b27cbdb089240e0e1c732640777407ccc7ac57e32ebd13685f90b09705086a9f281c07cb4fd47efb82774b1dada689ddb44403716eee47fcd0ddf8cbf13091a489279cdab7b29e4fd196bdc81c012305e22a5eebb0e0f80710992ecdfd20e0ba1ac9b2c03d9f15c3bd64ed7506925313b488c1d04e55b493c4d9396a1413c12546dfbbe372c0beb900b866f16377636b352262b0f0c507d7e28502c7734a7f39c9e0d23f2b7635e6d9ed4463a00c0385d48580bbe31bb73a40fb072f3c251bbaaf9691a6a730b86899ff9b4de88a16d80da0b7d5404dcf8732abd4c521ca4ed14409c8b132449334f9efdd726adaac04f501b875cb4df75557b728052c40bef970e6831a742e239bb2f4ff5e6a1e6748fc60adebec16501b7381988d5f898399b76b66912f0788df3a0a52b3e1044e2c94af6041b5e11590421fafc2a0264cd3a3d96c9c1d36a8c9f186553c0c574b85f1070094b34a41a1fdb55fcb47f36667733e4064c2cba83c2fb8fd018c710cd8087a7406421534b3cf372dd74479973f229394676a709f78a6cd39a34247076c28da2a8c6569ad401b8fc4257aa96c8c38907c2660dddac9224a6255da5237c54a46a4f90c29a5e38ebe5bf63778b71a9d82c753f908d3d6e884762b1263821c3d237f40050bcee3b38a9a2937cfc97a69975f1a72a18c762cb228d3f4dbd15efc26d537d73ae1670674ec2a1487b3365639e4cf113677bbf9c66a145858380717822a7e7e7382093b499dfa9ef80c5dd71c7fc87a35d7fc85a40b1407affe4d093635ea7b6e9f3dbb065e8809530a302a026cf2288517847d669bacfab98a062e1a26bd01a4b9ba4b6e6d9449fa2d0c687eb6a0d79ae1b51e3c1f82553db17f993d5b7825890688511fa77bcda871df52fc7960bde92eb802512ff60177e5cf7b7c7a3007a39bd859af4972c73fa5460763786a57654bc8076dc7af8e5bcc2829a20a292f1ef6ab05fced1bd43ffbeb814efd4cff57aba218af25497f7ac85d30664360b568f3a6d26eb82d8d4a9d86edfea3e972a600a9f62c5780533f76dedc763f8585ef841773312a534294a6a4ef6f58be5645f24d1cd45be35f0b6ab4e1b66f1b2e1c499e5bebbd2b14cdedfba1933320facfe45da40164e117e156aecf04a719ca7a30ee6356c01ef15e5e0c2c432f5ca3007d44bf656a7047573d666a33657de070d65f2923e74b0bc4536a773a8205f74bb7b6c49493fde45d811662911eb5debb92d5dac639c942d657347042ee0497ec09dd4bd4913ca9f643726f070a82aca48ea87816e21549859005de82465cd1566287ee606d71b470929a711b07753b3325412e63e1736f925f802d11362d1c437e457b5086e5d772281f0c81a7c7e1c1b28151ca3b118d85e370cb66f8d16bb2109a3d38dba0852469e6e36105fa8edc150b589a26ed70bd1e6fdb1c22a686d888763cbff3b7b909f4c877d0e19cc4e8a2922e8bb0cfe377f4a2466607e265ff4ba0f1443babb9ac037ef376880833b8b3a5cc1514e90f1280c7b8827e8caa1f6018499d3f0ac98dfab65174a09fee9e76c44eee8a49130eb7d68ffcb831a861ceb31b81ae2ff792ddf492ddeada3f2fa1508ae3c36642e8368d2a8d5de5409a4a66886988d152aa5365a9f6a21d48cd9cab46ac81e6a673d5b4e4b0386d02daed60f549336753fe149549d89af9d2d0edad3fd0077fe0a8a02a926e3cd307b319070cc6bfa896e0a185b429815bd70bfad3bc81d3c7f5f58f6c642d70f67ba375f43f8e53ccbaba0e4bea631d2505ebea39fea4cc2a6d0948110eb9f974b2ec12de7ab8630777bad97ab9ede0f11648bc9483c26dda84b93478861267e90d1f67a9020f3dcd2733dfd5a4a2d9485d0750e3ae05307698d039d0262ba9ee49ea30c31d14bcf15bf9d035c31758eaca20c1504121fe8c9b39164934ea16c47051b9cd4b280cbebda2d6d7bdd8ca4939d3406af56f19d2bba9e5d4f35e6b8632af713d667208475e16954caf67f701332e2e5094165eeeb8d39eee4ca10f19d8829e3e39b24aa2c06869dde233e82dfe19045ef56501a256e511a6ab26a128ca6ce7132badf7327b73e0c0b14e82aaf8382dddb0aa7e24c2e1e58c25ec1180b5bd3afffef83a68a170dc5236a1df40fb9b0ca4a8929c78f5e4073b037e71de2eb22d380c283df7cc9f83c83f39b37d2283856c11b6b7c6f3f59756a730fa728d5ed9748b8ba41beebc306119c0bafcb1928b371982dda67ca1927e8eecbec786010047c46eaf26ee8e86dbe950db17f561dd2046988e6eaa6eabf9d3d87f5555b5d06e9ed59c49c681aaf56c85464eeea2c82c1d1fea29c4d45de06b0462296cac0f2b0280b06403fc85aa668c991f6de47a6e4c70caa6ef4aa870677fa87aa25c46b9995aa15a55d7237871b0f77822b0ea5d830fdb0ebb5e9371bcde3f9e6d0aef2576c771b334c11d79e3e88f6b1cfea8200c827f6076b4014cb0004d75be9264cd86daf88b2dd170134f9760d0b9998d816eaa007e63801e65725c45cd26cd1c01b44f5ac85b8f72f25a31599833df4f751c59a15ed0d1d9686ddad3827203b68431d1dbfa8466faa5d3601938f4aed8b3a5a3431f1f3e8709dbd0d4ff9855736a8693063e83fb18c345a727d68eac6beeb32962708ba4df5c452407c997cbfad19b8bf09067bd7b6befbb494215cb3206612b994862b725ee205d0282b21f84cd8b56847a1b06b6ec63c5dfbca534ff599d07e34d61c7aade879584cb7b4bf023635cd3e674d854cf17f9c4873643778aa0710e22154bf03a61c2f81910e26fd294af82dc1dcbbe4e2cd846503eae3c1bfb6e9e9afc26f57ac0a90a60a24ee901c90a9407be5482146d20e0682150be6a53821651344656fe4f010bda584c18a5f1810993b93a263341802a0d47697e892bdabf1de56ff45e8b85e3be5964327872357f5d99fc3616d71e2c34782d6be772d0a30580df58951da5a81471b37503b5a669a1709989588369c0bdcc80f891e60fdb42c5529d19e3ebf704f6567fd14cb399b33c3e4f61b222ed9347767d2017903e195321762b6bba4dc3e49eb2337bb2a1129aa7bdc17a170d1b32d56a2861009b17e7fe25c654702139a5025c2799c1761ee60e72f7719e1ad23eb360ba991bf626e7e9c65920d2850e81bd0b9ff18b2177df45178c5eab403d20ce2f3327e9f799784f15c42cfae03ef994abfa1393aefadc0d95ef096fcc9e25005834719e23a82ce279667fefc94fd4551313f1c19c2ec89eb52050183038798502b15ee6ac92ac8819a664ed7d4c4bb8c60c75860b90afa02bfcf6dbf2692ad81e1b12f02a84dcc9e0e055ea5a0f9c03bf7177f1045a0472dba072d64a53a80200167290e1025139ca08d6d41077b4ad90eea1d5bb36ae3a8b6c61abe85967ea74b6a03fd7140eb566502c1fea42780702d12f4700d87faae5f9886cb975ec6c3260336878309e3651e249d5d2489bd493dd59197678f38b2a53dac6dc7a5cacac3a1a15683c8a8320e297107e0c3d9454cf72c51cfbfd31fa3e2fc18f0d4df1c53bb3fcf11ef22bad2120e520bafc30dba2081f180d6727696c6e65d28bb884a2f94aa0235d38573c339dda7aa6641d1e9cbcc77f0bb386b8540738d9680651da2f859dc95a770cda7c196ec765a3f87ad9bb0c72653423cbcd0245db8c712984883303336af8f29cdbebd623b00d9cc15b72f1ea9d52765628a39b5998f19bd38ee82f53c743c77b696b9752824a41276ea8408ebc4d841cf805d3f066453d51b759adc586a4e9c7bbe21dfe90d3ff64d8f31a71b3fd25eb3cfb1894f04e1af0b2417190f7e6d7570f48e5bf3d5aba2696dd193df29ab8cae5ce394008169898a0971e8ce734f928227168e1a2542541724158437de52232c9600a70faafb995100f2fc3e2fddb57778eec25080a2f5ca963d21c03a1da59a89b75b951f42fc219dd308b33ad9fa0ecc0c07bcf7399f42a94164387b341c9b5aa89ad8bcc9c6159f4a7bf71c97addb086347ecb8a8cb4d16038b714ad2371838d13a13ad5eec8f626c930d397b56e777f849c6098f96996541e740c944c788d6a8eb2f94a000abd1f0afc2fff15025ec7edc2a454feb9bc27225738a0b8a42cac4a2631fc653f97db18da04da8035cf7d4004c9d709e83355ea6c741e418a378dcefb73d6eec88b48d43e63ebed1193700a93e276b49e43aff64aca9bfde2711c0020a4d1a311ee623ac9dcc508020f26200134d201f2a931542a0612196ae360a81a2e9eb39bf07ba0422fd6200e333c88968edcdd0728f919e5b8deb01fb4f101e2225d45e098593ec7327b4e95b5eef2b4a31a71a60a5d06c2202ba8e5d39c457b7fcba15cd73f8745469263e64e8c04d36f5851f9df9029e4bf510f09fc4ec2fc858b07636899fc7b78cbfbb5b1f5cdd417b2425f406c29448940ec3c56a495c23b6dadde2f40833f8a4b239eb71c2bbd6d13b49c1d019e4fe9984d4cebe02b66ccafdf9dcbd11153aa7892f65ae2a3ed4f92f44449ca85392784f8ad80f19dcc285f6bd182968cdb745c91cf9269d4615a39a76655e3e6fa7952b619882ef212c5c893bd2252751c13eda1bfb280b01c9442c083cec518dcc8770cbc6a25a8e4048b8006c613388ed714b8c0870ed3da78a3bf25b7a6b1d582a5be4e74a372b0c8b18165bf855dece700462e39576ab0a09661910f8a4525e1addedf3ef46658c721e8d0533065df8cf58e9d849739efab2c547618c7a88e0c5ce96831eef7bacfd5e832290a3916eab04178161537c1f0efb9db5e38d3c3e0b4ef1ea36eeaea5e1588b7e0eb0a50e07fef5e2897903983a36a86269031f7f24e5bbc19df21fe9d4dff19ce38161ef23c47b21d0c840c034301e1b98173224022d05d72583f6819abbdb7f7414edb4ffb97a879d28219643ce5fb9dbeefdad462366a2d2a34e6a5be304a6eae187089cac831e68fef1732b52ea33b34c7c314ee7b326a869b93d26e663ccec2407e0acefd766d0c3d8d50d7d93ad3495e5a2efb05a1d4d1428022c401367fd455cf978d080e5f5ecb54841155c734f866929ed80749b7e2225cfab812ffb11e2b0ca66308a5ec20108c273673af85a680746b84f939dc4fc4374bae8aaa63fb60af5e60c448c2e949f53a2ecd3d33e394da7b6648919072f6f47cc8b21fe74a706510ee07f72c17d0919fae0f5b84b60ebcf95c0790db887e8fcdc2d0d98ac8c2b66276c071c59e3339261ee8de0471f79b08f4efc862ed662ccd019afd232ce1a40c0423d331860ab64cce660e99285669ba1a471270d1d7163e540714eab6ee27da27f3052a7ea2d62b99082f800baf6c1063d5d0f7b87b46bf65ca5820c2250e8c71a00023eb0ba367a2df1f279335ef1fa42ae87990f66b0e2ef795611c39fb60ccd21bcbb986eb3b36556cf5eb690bea5dae6ee0b52653962b00221377b0b8381dd52ea1b56b8adfbd7da7b6fb1764ab75631b620e1fe871bfa45e192be302f04dbc95f60373b13cd85d4da6efebc5cd8f91af2a360a72407e8a0d6f6b230d7c63b40609d2de64e68a5eb1ef3df5d486e097b3c7f1bf7d4b05fc571161ffc9e74e6b40c4b7c12ee107c1f048d2166fa3faeb2fdde956ff2b4facc71b8a72cbd92f934173ffe638cb30a13f221835a0506a3285231f76ae10b0438aa105bd90a58c439df32af43afc9fa44d8db33fbae05e3230d958b27e6798fb5f5547132926c9b3604376187811cf814635f5b74eea49459b42b05e778e1c968f7ac8a5253c4ab1240a9e7898ea9282a368a6ae4c9b8a8d75d9e2e12dc28f8252df597dbb05713fd3980bfb18f02e62afcaca45efe07ccdfe0644b74e34535703093d7b828b5bdcc05d66cbfcf12705fbea2be846733017488d81372fa6d400d967ae4dcafda5a249798de91b3775d77688a2437e26b533c32f7905deddbb10fbbe3a6e7462775e9648bf53b21048bf4de7b2f3537bdd98ab4dbb19c96d236fb5956e94819939311b146c4045bedb3c82f674872fe18dcd14644033fa5d1a11a0e0dc2aea16c5ce9b8ce64024359dfba5809eb081adc5912f3d3dd96aa8d4e788554a8f8d25014d4bb54e34f287282cb908f872ef69b9176994994aefa46b6fa3560a2493f1bc53c48c5eafd5c3b4a1801422690b062b451999b6d41d0ec33f19016546ab3350daa941be2687a5613c36f5be78b89c562c8767762b9f16b5136bb6785e0472dcebeea83c28b8784bc7af4d8c33a731c73f762a2e038c2dc11f021436f5808a57834e0f41695404bdb393ffe66f549f954f734baa10963cef63707805d95300d590d1626cfa6d787d0fbe3130a10d6e2158eb527a2b8f058b762f7dbf363485876046f7903ec33d44d899d819ba2ce56a5bbf10b91934cc3b794da718279e57513c36d0c6f386c136bf6abcc26091784035ff670b2562e07990ca57e775ccf67b82847153628f5a6251d4aa67c2af833d50c1e51af2cdf3fd5744a15d81063224bbbf85624bdedf78b5b897904c9774772553b8ae06e57de5edbc5ff8029f41a33c6cf273ec1cdb8abb510d5c2699280dd1b520c4107aee6ce8dec38496ab87f9b7378b5bb1cb428aabeeca27a047e0bebfb8025a92fb069885fb15819b7a3281af2f5307cbe8740b28d63741cabe37f769373440b22f284539833a1ddaa5e4b4f8c6ea5ce01ba3a5ac7a5ff8eb246bad3f360a109a1a242dca56fbd53964638cbb343813b889e2123c98aeb7ab597d1eb5c47213dbf3f63616c037b5cab0f9aaf80f05b38546648ac7fb620bb43528b4aedd4c33d01c42ae025ecd5991b5e1ea5930167e63d7aa2c732b5701bf05e28242a65cc995392f0428d817d8d94d60808eb0d083e2bc2569469f310469b1bce9fc0579d8a6c63cbec3f2d82e22e06b284303948e19e7f4c4ba829cb75d129daec04b24ce84b2a2fa90a2fea0210dffcfb54fad917c35df3c9261bc16072483b3b6316d0c02b9ab0f52ffd861ae006c185ce948db93b48ea37fcdecda","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
