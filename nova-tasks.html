<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6cd19d17bd70bb3ee04da8d26acac60cccb5882d8d5dc2ef04144802acf1550510ad96afa42f96816405e1353be79452bc7c742388ade7d9fa243c671bd35469a952d45d409a701751ad442f0a02702f7dfbf089c8aed97c9ad611f82cc755447899ab2ef2f52bfdaebb1e1f9771047837c33b3b9c6d60fa583b42304409f6cf35dbb441071845904d1636eb67f2415ada7661165336fa42fb029c42e73cdab1b0bbd8c790b084ca60fb2e2191d744c7cd54ba581041235b01a83e1f69f022e1ea70059996c6f1a9cacf743b449d907b8a83d2f33e9885f891008a0bcfe2fd834b1d674492756683f0176b8d3a22ddbcf19e464e7f77e8a45472829beaf586f2eff03d2672dfa8589535e66948fff379c9544b4ce729ab7233729cc9beaccd2b835e6aa43043b4058ecf3e523915a28cf3c6f3b6464c0039dc2725ae824f15e6849921e0da5b75656d51ad9ac50a416945811a8e48af89c684372319f25fbd80d5fe90728a7cc1f2c6c545ab8455a840ae6ae08ae92769cca1a6ea72d1a373a82a406add8e7058dd7ed0e9e277937bbde48689fcb7ac35d83097414708c38b09e62026e3af8877f9d9ad9173c4411d8abbcb9c527d31adc5126004714719af8810016a22e4b24add37acf838507aaa6ea9015012d927638a15b2ddcb5f0926618c09b84b265da69507eaca2062aa3e981bea818059e0ffdfe848c0096b07ac2e8cb9c62da7bfd196d777e475ebf83f8c8059cc4817686007d65e59c1839bd188578b26ef5020ec8ef8fb5c1d86b0443dbf861a02b751f09aef732ffba3b2deb6a7148c6a5b2e6aa9a16042f8b5407dc6ae3cd764febb1b8dc02a89a9425475bbdd66079d7ea626ada73763ead4d34481fdc067acb6ef3d93dcba2b3c093fe4e5958c10c7936c31b7ca382aa6fb1bd05351f16b488f7d5377f8ab727165a711800e30bea2411b897ca784c26eafe720e06ca9c3adf4ea2401d7b276a77da6cd02299a8c6ef5c2c217a1fc2e9f078ee63eacfe1d68318d4bdb6fc2c64ca07f3ec703b590b0a9cc2f8843a71ab8cdfc938f819c09966b1a7826552f38ac9ea146ebd9bb6adb35f5529a23f3bc28864dd95662abf793f2911c8cf7b6c277285c3e303da3477f819286f9ed3e55ae0abe7eb3494c27253520caed7c43bfae0b6c75ab8eb9ba996d3d6cb3025cafb30abd884d42100a84b96227824feaa1c4a6442baef262e411dadc7147319e1320de6f61661b44e9d605d0007ea7778180b96947a5f08ca674170bfeeac524480b5e4da6d7d8c74c1a40e159f63b4d9a779cb3e5cfd0ec302c60a2bb1bff5e8e118423d48ddf5f22d387c597accd50381fab008155e93be5890cd17cf28d0d9f1454ea1bed6be03fd3b8a2d3389954a4551f9f81647b75ef5bb4e79c18efabeb50ad5d26ad1d652832dc68303ebc260202ced37d703ae2ce5024a40d600cd150e22f62683a36d5f916d5ad6f51ccfcee00bc92741285afc9728c9320d11f67010f52aae64b8df877f5ffb01b99fb2fbf4ed42db60cd3a881132d3f2d31c0dbb60fec790401d3bedf713ecfd53ac35560f7a967c42747cd453d34a25bce32db6694cc906a05c5470ccbecfaa3c58ff00b72a55e62f68176ea6c9e9a79285b89a539f5fd318a406c22bb58ef8268c2edbc9f9998137a829ad052015344124b21cd0e213d7e3152dc0a462ecfa2d82d09f9dc1d2c4b04e27964d6dfef48e9571a3ff8bb4713b89dbc8e1577fc41507044a84e34cd7da311d7b342901da78dd2dcdd66d98bc8ba573a6759eb6605389ec768ae3cfb390de5229fb40abc5d97adbbebe78c903fa060e9c70db2cd2c9f6dddb56018b95dcdce50ee12dd8412abb46e4c45d74999072f7bded1f7d5c89aaf723581621247375c37de5f107d30e621c105fc952c7634fd666232318467348e603accdf49d7f5aa5176b775c08cdb154c78aa3063d0cc41baa00027639cd2107e0b564689315a43ee4498d24e505a352c81637775db498bf6858ae5ae4969b156cba70b02117b4216eb93e10223995a02f29d42ee1065012ba22e2ce453febfc1f9ad471d30c68b424af0ba2917f1371d9f5c4d2f0e0f958b8281a0037d93c2e9a462215b5022e07a4019f750a086a8a368a3563fe17302370e16320a788132e06b99b6490f1899201da6a51ea0bc40c2f071588c7251aa2f2dc4426276ab32c4cb451f788d1f03ae6636d7607caab5411d0ce1bd96162db1a4b756064a40b8fba03371a55ce8e7001c577ef35d75b3fc4a35a22f808dba2d90a8775350f0b0aed02ecab92e2675254ae537c1339991de8f49a820ffd160e15a16c36c7f4bbdbf75cf18c619b9cd17092911a8ff6603c1dc99bc0e42d095d3329bd550f69843ba1e12c6a3a2d46b68dfe4e898e1bc8694704552f776b22711cb323589ba8b11e866e892bedac296431d9a77dc57db47be1eeeb22b8b208330b01f8a04d34b37d234f54482e05bfa5ac946ec3c89fa74caddbf532384932e952809b6fad3f8131d806e8913543aa2223a845b8d00d739610730d3ce1537735c8c469fad18c67a16743be9759f50862f881f743962a1c0e7a0824ec24d181ddeef203a86680288236add1102609a198b3c1d5eeef57ec76ed71fef60d62e7f96b4baaa87ccaf1df19e476e4d8505d5bf989ec7f5be94ca4285ea075a59ab519b51cffd987db60bf5cce743ec44065ee83dfc6b42791733592dee115a7c07a6ac0e8cb58b416856342628e3fb1be8ae9ee9caebbfee316a0f694efce55cc1e5e6848517b5608dbf8b7a397454ffc798d62a5c14b2a4ceaea0b25df7be85dcafb7f7507479cc1e7bb5a806f1d7c54b62b3cc635c98f898170907f834abf88ffd89b9a2051a43fea7f5d6bd3f7a7bba6ac77ad23db438e2f47921837764b7b5007b76e78af88980151ce5d304b738cec8a631163b3cb5918f0bc278adeff01e458ed9f770426d8dcbb8a3c7d063198179af99beb7f2362379bbe65babce52fe62c0533903b2b5cce1c7b198f92738c049d6ec69b6d4181c0a40b6400cd52a59b2bd3a82828297a9402dc3efc6bbf10388e7dbeffd58818d0639a3ce809f70ab56f2fc05f03b5b57583450662a67ec04e2371a3172eac56522632f6a9dc19fdc4e731c4938a00dd95608bdde285fc3840012895a2678a0e1f4e0774da681d8795c2c2151747455a3dacf5f38afb6dd66cb58e7e22c29f06c38a372936a2cc8fbd9acb633dcf51fcb631a66696ab252da4335af80307c54135f9b479159bd7f851ebd38afb705ef01a1625404c926da4ce9b92cbb601a46e73008898b1a65d8479c0a64ecab664c442754fd8f7b637f8d714a13bd44299ab7373f36b39d1b54e33f381fc6b58741b7810c0192f547030f868b9881c2af6a02a8260b913c86cbd673ab64b9cf6dd9e98eb6a7aff7f53c9dc839d2fefed070ddb333c6df9da61cd6d5d076c27cff64b0e3c67417d0fa38e6fc03faf5b7aa8979f71285a07516170dcd96bcb8b43032c61849c42f99a29695db947db72444c67c5e11f3971809f7ebf0c961cf5f005acb58dc404b1a11a81f3550166b39c381e76fb7b04713e3daae49f1406fc00b41bcfbd326ec0e540b0903492ba6a12eb8091c5b1eed64f113fb199c7491260c7004df807b8365be2f1c0a8153fc4d15b91e3f9f81edcee4a6798389f4fee8399214ee9c00c9636d59e5d5e7053f72b1980bac28e22fd4700da098fd0648db37d95a4ac8fa89680994dbba6ea82182f3f5494036902d68b215554cd06335c6d906442ccdf0dc8d98ccafc14c0810f2141a3c72964831a0220d6b9ac1879c2a1bbe6ef3ab7501e23461f7b4c10d62733e60a1586bcbb9897f3d3a9031365000f2f2e8c25e9c155d699631cdfcf25737c5c75b212337083ffa3e91ea53c83f5bc28c42581802823465c78dd91f0a15f6676c2ec98448a3d127d6307f45541a5e8e28bccf9efdd314074c790188f85e5e3a47f1fe3bdbb9d6a9aab75bf5a1ae131e5adb6e8f6f02d3a8d9cd9e8ecc9461babe5e4cde44b483554a3bb55c20032abbb2fd663843d200a14e37b92e509fa81147c917f720d8cdf203b576524f0d105189b0144a55e3d62357818328c8bd2c6435654ded1bf4feabf2711dd58252b093f7ba30a0c1f500ed4af17091b5fe44252eee13c5c632a02e3f7f2960a72777f8e107feaf04e16193acad5437b84e662baa5d2395f483ef1e9155b6186d07eeb091952c23a7b21dddea3227deeb952b398d71fdff27fa3f674fbfa7f9df6dc4df146ce4543c0c3108b582c99ddbe723ad567de0c559f3e32d4976213c7ad22dea84c0f921a50102e7d50f83c3a9514d72db91262d01a3d6468eb74fef3f6b549e9f872e1c3e7d0251a8d5c966a5e3b607c289ba23c115f8fb12fd982e596a6d3a4061787dae46f377c467804e755652fde03bab0d56a4295f3840d10d49557737709c2d0abfd5028e18a14035f050e4d00155ba2a4681c4b0caf45bffa3bef69a409e422b8aed094d1c03b6224d0121bbab98124e5c49f9556e61be81f909e73acc410a1b0aa35f33f3147a4612e93fa334e3c712f38f6f58bfb0c476658cd030c402f3a0e45e2fbf9e08820f38a9e9dadd9c040c592c4f28a68c900b5c0643f39a8b0b4e8dd9faa15ab4449a11e680f44778232f54c730795d775ed96427db835223eeecdbb981921178007862336f2266b0aa5a30fbcba6d2da7255ff21488ff83bf190db729c9472b99ec9deaaffb88216e479b79cd9c8d751e71030b1f2875eaa7af73edf702b66eb0002321009c187977968be58a3962803caa6d39e8dd1172f2e003dcc0c40aefec0602417af0e0ddb6d190060857ab768a3a0c7d7ad85b09f0cc84031a4a600940f0c9637cae2310238545e54a97499511e662872c4281f002a511952dce20dc583c7c99fea0d932b60d2b1688206b9950d9f482ea031ba4275cf13dddbf2032f197ca03c37f6e35523c1d018dd6e3d08262cd8d1e9aca49570a745e71a40254027a1b28c60cc858a159cc564f58aff7d67d28dddbf3536d83f9d7d148c703da1af7ce5df883b0691e38ffde89850ae6e91e5e3f02868fdaf6bb57957da0904ec5d62999c22c9a753daa23b02c643825f11f290aa868fb0b68cc5137c574294af1e18e4d55a8d43120d901d6a608d7efef5a5ba9c84e73f58ec75cb51fa04ccd74bba6b682deaeb1cc308b6cde315eef7b0bdaa19900299896066d0993d7e715ba694440ffcb561c6cb4d9a8b41388db1d353cfa3ab02a18ddcddd73356fb5ecbeb306dd092c07241807ee7ca48eba3a6e0eb8520d2df605efa8646c0594097cd9ee51af9e160219dc3abb2025aa684b735dc207fbc055b74352b3a5ec4d509760e04ada6ad5e23c04d2e5163e802f26e896bff765941a1839d6e4edad87a8ca6d7291bdeca0b4dc7220b097529dac4ae27163332d1ab40c0fc37bfb370e00463a349964e3311a604dc8a11d97ad0156669bb01383016fbfda978e754edc4f9f0554752974e2f94a33b2e8cdf9c99461905c9e3711cec1acbc5633c0c8d042aafbebce17fa9594ceee3ce857e899843277b930607132f3263fb7bca0fe91395dbca82fd21cc0c849ef6411e6c7bb517e12957238d7af42c45cd1b8b4e2ea9b04f417038ccf7f285ef41f0393058b097c5125a3d5f5904f9bcdea071a38c2f2dbd481b178b73d40af562587c09c7ceb5193fff591edddf74ab0849aa816444c024a70f6eaf425a392da19f0700eee4628b478552e05a4050cc4c50647145fe860a492f901d91da2c743896b07f20e9959c04b267f49a5fbe60aeb382556a8c9d7aab94a2c7ab90bfd145a12ca312b8abc7a04ebb0d524e117fa47bce9978148eb7289c6bf16dc63fe4ee2c7d4f1dc7f4a5c9abc8551750b151e5931418c41857eeb6646d63825f1a6081e227b33575b9ad8435f0cca6e127f33cd48c738f478470154b3c4f8068cbb569466b3edbd3a86bd15dd0d16dfe8a9c3a98002821e80af459e275a996dc50243f2255482232076c17ee04af35acb26991c6a54501e5947fbad7e2ba68e65b2c1f0c0d5d1c5df64cada0f16126d0d6e9414f9b906fb16b2c3dfa3e3a3e4ae821c980f888f96cdec26236d5f1eef9c32c60dec53394aea3c0ea5031f0a6e6ffcbbf00843958c6d23e3517d81d19650592e81b9c81748399e0749e8c5e0bf1a8606591aac33748096c603f2f63ba6c1c140b4a5aa829a78beee0a3d5736b2f1d463470f4e28082cbd3395b81e92f0f8f5770e2223f24c7a60db214e755f072829314e96f20267db0c49237331c117596b93ef447f39f21dfc8f7d3f34156915000cd3b6652490bce061663832cada69dbd596b6cc6279d242158dfe0fc3205744b9921a08f8021a643ad8b7f8852e18f319656a39fd0b3481a32dafd3082fc3a0cc9b0f4d606bb27f544d29461e9d99ce05c3e67ddbec7033680359f9bb6b4598d23bf31c5d8f62bbc27c62c9eefd6a97f10e94374d619e685777f3bcfceeb8c11e797bfcff7a10114a20d6d0fb50f95d9434f25c2219a8732d97f7fef0d19fcebb87c982aafa1758cbcf8cb4d7beb9ba2178f581e9a6f5128aad81b3edb771844faa3c68e4bc407d90b9aa430bc1f948669bbac2157c645d3f2ab4c95292000dad45b86c37346b48eb5d3f1fa5423a3f0e03b186543d2e40aad4a063faf690af7abed6a8150bd934ec0a8756a8b97aa4a443ef3d08558a8046a3a0896a3aca6e708c461e9df86eae6cbf96d41dbebbf264490a29f4a4d5b1713a4f3dd859a633ab620e0d4cd86581f4ea73f5f19796fc400f872b8ee9da2026ac475e1cda48c0727746a9bc96e96d770fe3a9806fab51ea77a1226baa5a3c54a54a5cb11817a3165f23bbe5f9e90b3c22e33d822548e534d8830911d709090e7f092d2685e0180ec9e31107140eaa87d7bdbd2effaef1c92ba9b93396ffe5748c22ab6256748155ee5fc73098f4315f263ed3677498813e1cff67e25c8f9a2e71d4aa54e51a28edd2655fb24a04450af563d213bd6615ea05313c4f1e791fba18f017b76cf16954b0704352f3150ee9f2e9aef0481acbbc3a01026aa3540ace57204be554a2052a58da65bc6fbad75e2c4b3b131805f2578ce3a8be3e85e8aa523bc10940928e628880d89bdd0a323d65e668017d5e477bacaf2fa7babd3b186e22e6ab447b7734e36711b2594c41e8bfefdbee4a5400a8df289b1abbfa8bf4bc0cc1ea37d2476a63820ced97e831e8a55c896121e87d0a2a0d157373d5f2edbc2cd37e93d7d9a60574c32920f95be69e35483b56c5e52d249a635de1d71eb1928b20996f036b2a41d2b1a8b41442626f541372941c18a1d5b430fe473c69a7815cc307529682275c60bc6ee2f675dfd796a555931ba7cdd059338b0cb8da819b8f8da7e0d83f0fa5e024ca4b60a0f70d844371a9b766a1409bc2340439a4f679b089d8385a54cca19468ea515390eddddcfcf452fbde27f844ba8e72bfd988fba3b81cb9851e3d616bda5ca42dcb184fc9240b09dcb0d5ea12f5b7fdd5c126d8c8db4cbfd578449fd793e3f9e53f5b15234b185cd4d8affd01e1c878094205103b508d6b48d7c6c1a827871c14a85a73dec3d4f8d7dbd1686184efc6e6949061bd7d0443b52c61282fad790f68f418423620560f2cec5c59f249e786c9173b85d4f590b41dcb1ff170ff158d5e9696f1a752a91f88efba6228aa1f38e395e20f1a2089748323a54abcbf2aec572deff5c6f4a8b3621c298588600f47f4fa0cca957277f392aa5e97fe203c226c9626b7d82a51d8b693803aa52fe917937eecdf054534e81c7f00979a9594584cb75cff24fe675e9526cfa97c072ac06f6a90e389ec242b3ec4eca6672bd83490b4e67071a6ccdc4df1ab11364dca291a784602810b11ae4075e70859f937fd947cc88618a51f8964e911090b628f7d0f4f900d525b1927842f2d31abb598f03cee84a11728d968af733348f108ecbaeb7b782ad7e3e7b522b62597bb7a46b6690c4bfddc335ef8c32f1ec2352da45300aa160706a7edde6da2703f3e680cdeaf0ea0f29f22ca5a4dc2256f82a27ceda88665458c5802bedf93b78d29c30066004eca9229ae64b7c855c40cc3cb853024be5c67299fa0f034d211bc8625063f01bd4efb20c0095adc926d8a671f4afe678821a20712c97ba29b6b97eb8cbe93da102840efb38a8a42b66be9cbcd896501a9422b3bb81b1be13432bc103c40c9f9980141de2d7fd38448b889df0353f8a497b00c7e2bfb5941853d5632aaff42eaaaa6772d8d4574d8a3c7b228fbe419932a3517c600def89101a0a2de8a77ef511a23ec4c98067bc250fa4868f4ae2f4661ac12ecafa3467dd580a07232f4f577a0d15acf235910a8dfaa1d9ec07bc86e4fbb25a9e4d19ddc374bf98805ccc0f7eca1c5b806680c3e1f6fe1a91c985073de3b7f547447fef17a3864b799b4d30bc818d6c8aad8b23f3fbdb38ac0cc54fcfb14b0677f8fe57cace9c6f79900400e9f253fb98825bc7be9fd93811365cf3ad2f6c7c6f9e08fdd4f773be8031b3e8a20ed4b5d379b0156e02ef4c82fb9dd3ccf2b24bb66bc80bec14287a3ae46fe49d35eb03a54e6274728519c14640d178edecd565f44a74f548a6cc227f95c91caf97d177fafacfc03fc653790cd87814a54837324e40f977ca01edd3f2a6d8acc981659386b55a912b3cf051e611838419e634340b0e734009cc58814b0c3ca9be918519b3205df9b00f6e971e10778d2f1a39c493572d069633bf3e7e1eb5e38e0b69bae67f21181125d4a397c4eaaeb3b9edda50918edca4749d662c1c7bb73a2a4424c60ff001718563f260571a644eb6f7ad038a4327dae0b8a1d653d3007cac44543cfa147809795d85b52e93080f0683656deb3a78ac51e8e5a3111817931e36ae7d23f98aa668af28bfd4dd9257a1964c899c5678ab7b5acea1b4ae031e134b691e3830da12d91402c27bc4ded0b700606b779c426d0d112316c49cb94ad0e5f3d33df07b685a2fe7f1a8cb9d6acf0a053cc43f2900044461684096ad02363a1966e16ffb0f6d295537a4bb15eecf598b75d1647a14128e3f6fef0eafb397020f988a08267bf92385eae146e251b1586a09772405f627cff9aae1359b8ce7a54d026c05ff964bec674bc394ca876f6366fc450fe2f4d17b2e7f956079b4bd6b2dc7e08ed953f734b47c1e161847d311e7d953d60ea2e0bcc3391b984a947b85089f12b957853d29289de697c2ed08bb05bf8587575eba7f3c4e6bf929765b0901166596503f1b1cca24c24bcae324b6e422a6f635ac148903352ad59bd34c027cc7b0622e233c27b8451c2ed040772cc5b6503699b50522d51871cbf244f67ad60049f1674f0de25d4b3456cff8d9e0187a95b1606930c859c354284995a9bd4166cbb8345f9aa0cb3c7ce14dfad1b6bbe07e97468bd52b1a1a73651ece1e01ec68557e01b10db0bb0abf18c8585e979f012e99b4660b94e479aa746c51cadc91483c161a52eb04b8b14efff07c51b3ccf0689145cac924ed8a2669121d624fe5feebf0e0d331b94c38cc23c1855c4420f6e77e3a3fb0187591d2a793c81202fc46f8255c054032809a16c7aebd5e72e1b66c6f4ce91ccb823a947e66b3edde8b2272e2a68607069f89979b7d79a0985b9503e158b33f47ab290ce2c88d6d66ec2a993ecff42372dbf80fc5e0e274d3c811122070092f6b9c7b28a3ba8263a4c801e95134cdb19ed30aa206c958e7ba33bf2193c43f863c3d8d3cf3deab7569df2a5deb73e84f76d6b02233af5ecdf6b11fc5d8d2feeb27643b56b6e6059db2a5e1eb1e0b43dc61c935c141028512d227ff7aa3e2f2d6ebbcf8665a1b0d455169b79b5f420a14c89fce7f7701e0458b71e4498ef7e3f10e8b5a257544eef99edc3caa7f15f02819ca4212d1f9095658636040c86fffae17f81ceb75220a2326c4688e85d34162aedba0eb3c71094eadeb885402b320e5ca11b3fdc4e33937a2f2ad3fd6b1c7bc80f98bfb5943528724ee682488c95e1cea4b8dbc4119764372f4a5fc7926e8de7546cb8369da064f9a5c06ada68a250e8a70e64e4eb1e45b2b2fd54659aeb3d9230dc4b2c9615908edde3fb38bcf574ac41f4fe5e0d40d684fcd5cbe8be750f6a6f5b95cbcf2212d663c1d0cc12b0c013d0bee47cbc3f75396e5d51f53577814ba998a0bf8458f1ea1dc1cef3dd676311e81d3f346eb6bc1903fed5762687e651d0dab3259dbf683dddcc3a35d1e219a7dff8a8881628e8b0df312921b02cc915544377192f197737e57ce088f76ce16ce56c6290faa051f944eaba05437ea12e04d2555d22999e7183ca437c9b4e261fc7e3a418a916a31ed905e651fe2a81362f0e8661ad37af9e942831827935b21be96b3f05637870839edac21e518be98b180fadeb13e8663c4c9be6bcaabffb782bf2de1ad2b90a7689469e3cb53780b95c8cfe7839db7965b610179ca88105e40753a5e5203863348a367f454e08462d55c5df3eb1b720907745a471fa04eeecb602c3b2a401a4f8fa4291f18c0ececa5c0a6bd9e91243b2e0b3e21f3ad144ce254ed3dcb2a2a68530c28f41d0b9388fd11cfabc6096db5fe3808053c33301ebd98432d3cbeaae367abcc158867cd4458d8a41797371cb854249618a4d081ea1a0c3e0fd36af4a17300ad40b0a6e396b4c56a028b39dffb38f6941273b76315aff4d4aa1341b7680663abb44531f58c409172806e0ed21ad1a8a83d015e886ddd16e48b7f12a5f48bab0beaa0a39a615166896f781f273ff8c3bc758c3b057bb3ffe05353c44669334e0492e2910a2868a4f21662046e1b15b4fdf1925a9c7c06f9674595cdc3e20a8fda9b70ec0b90e6c9d75ead7aacc4bfb724e86d12145678f705bf9b202792201576093938a56f343b85c5294d6d62cc2562f617cad4486e36372e184affe0ef18aa44da474356ca52c8ac404255ecfa9014add12d62b285863fa3a596dd5cc9cbc235850eaf1d4a762ea9d35e51c91ae0f62ea30466cd04af53423488ea612258c124a3ae0d64f132f4e78443fd9d9a346492bcd19b9551e1129a4c854f786e5b04683b6b741f037910915a325d3dcd03f6100e339c4375a578876285425830271902981093d75dc8293fe66569a1986ac4168ba5552f7862206677f1d3870f33aa4d69f32aef4a1d071492b59c53011a42730306e6a9cb7c5caf66628adca08dbb7a4f2147f67de5151f420f3263ab846dc5304adc69d919392bea96d0dba1691c45809d7177a612db2e46c4e519029fed529bdeeb4936a1a3a38a67957a61e1d1f83330e846c609de780f5a17619c58f5565ff8be552ef79f3632080e958ea5de5e59d624ebb1817a98eb8eac6e68e90fdb963706172c92349caa48a79e0b2b91f200c789a9c1f128d220e1f4b767c1f282a72f644f93a85b95fb71131750f84ca948678984409991c895ca727988ef4a9da4251c6b8e70e666989cbbe003c9b1de0b31013822c0a7eba3b74e9dabedaf269e74e778aeeef7a7cfa682b3e8e5d012de00ca884338e96acd743c43c0c8f7dce42b4d8f873c04b243474b46b886458ef113969e74dc483e18f646065f2c3395300d354f1fe390b641c37cc5c867bbf7ada159b718fa3c162ab37338be42e534a2dc37570db4ad9510dae96200841a6d95331dbcf3ab6032e2706bd1bc38ce900a39946ca37b39df3f9729561d5bf127ab25c0edc50c90e7c20c445a4443c64496c26a3bd26c4da8944628c6ac9c79bcdb5b3460b8730e7b646698dad11e9d1276774a9682ee7da70c3c0e2f1344f823eea2743b21fea796fa78c6c9b01a5941f974f3fad265be01ca200b5b4e5ae70381b264b23aa2914e5c227e8832c5ec3923d99a57fedb82d4dadadb95492faf44f08100bd963b978ad96233e3efd980750d82969e7af44bed81a6a51da0a5ab8b163dbe0688ee53ee8283f231d5811bb13728914de3ecdafb9794f863ea321618027ca07bb48a6aa690bd267361168a5df25f46cae431ead3918252efb89cb0e24773991b37917282aa06a42d6faaf8c4fa67ddb517cfbdc3eb0d7ddd2ed7615826c97573fd5ecbd82591e14d885fb905f9c283df9e0fbc10ce4edc4617af09c664004002f761702e4f87a2fce47aed6dbdaefc56d9a5be6d3fb80931c2d4ca54de2ebf184d790ac85a408bb97c7cbee5319a6157af51b780219a753b4ce7919d7e8b7cea6ca5e80c612e09ea89fb42c377dbcd9233a610c6938f46744676c583d2dd0d2f269897cca142b5d746385edf8d2393b2da800e44f429661347dcae5f2f43f007a7390800e3cfb5e513194074392cae5e6910f77e5ddd0445429549e96667454e4a5d71a18d6742fa9faaecedbe8d28076f515eeb43335f92554c0bc2feb8f5fdba5f39849980ad857cae786f26c384b718f2ae2f1834d77535112defa3d4e08024b8db8bb126afa153cd440f083c9312cc80e1b923d20fd4b76eee53b8c98ba1f040aa8adb0066c123b1e17800244e49f63805a3bbbfd99526f824dfae01a8fa3430831128926a117e8bda14e783866fd7ac519f48ba0f5bf0b6cf5d63bc9847b0d5e492723e87818e533e0c00bff47f3eb3cfc9e1787ffe4e07387a47fd6f9b1a11989f91a8f8398dead08287f764467f54c3ee7248829da68d93a1ff3847fba9fc37ff2a74f8640b4094a94b471d79e95d49ccd87fc9f99366e6ded600ccab4acbb54f59524063eeb8dcba9058dde662c3c37192cb7b839ec5193fda218a54b5ea5ce43538642a535bf93270c4f3dac6e95b6be615148f08df1e61766b1e713a59a18efd091231247d81f43514d559845e0da4927da2c3411a2ae1cd4946f322029bb1874d70db2cf03cb9093f5698b8c3bbc3846c9d634a8ee8b32f3d02bb247826a02a7e810d7bc7bc194c98555adf2e7b414665e33c6b4e98c2ac1a7029da5ac07fe00ae25cb3d354813277a53abb44011586b0bf290bf3da9cc6ed7e5b9272056bdd44a9298121dd0f392976e7d0563a7b41597ec87aa04b1fbd63361a6e8efd7cd1237b59d240db84864a69016605e8adcfc6e16b6243aea209841f06ce724df3acc4c90a7597f35eadb593fd70c14e3a63e6be55d15ee020f9df47485202005a28884a7163ebd652e422856553cb96f6d96b0c4d7a5067561121b2a8762646b67a4bacd5030203f718d77cf3fa7df653f449308b8f81b6d0ee937cb07c7a734bfa2e8a1c624e1ae23df92b7969f6ae675df87d59aedeeef143a33b05314e26999c773ef238dafef0e10f7d1120e199b1834a81149bcc703fddd57c60263bff10e7cfe7fa87c1c15c2405cc0ff24d5016b8276db25356f53c752cffc611cb69e2b78fdd35b519b92087802e464fdcd3277fb5c0e88bdd647dff7be096e433c94c846ec0733b296832f08a078312449cd47da564e4c145ba4ceccf6973706314631edae851e2cab0220a2b3c9df286c2f96fae535f7adc7fa6fc620cd8ef9e2f7a280117abf9b41541bdc3ffbbf2bac2419e61c3d8f73da90f754c78c604bc89d3bdbfdd762013702bd2a2ebb57dc6bbad883a34006740432119d2dd38e049c10046796370588e92c10867d76306afb2c0166a60cf847aa168895612b5bbc17dab72b228c9f659624d295558b872e4daff61614c8902596d3024853008a300eda45815d73374f254a19e9215dfe63634749c9a36e6048c1f8a9297f35921360247d2a63f7eb8922b15a38066412b803488be3895081a5909c463b0fdce447c3661f8ecab31d07fca5d20843a6565cc8997db7d7dcb696c4722997e2da2386714d43323a998bd828f02855bd9e08f8060fbcd1ddfeb3a7b8fefe468bee96608f748bb73d5e830b920a422b4d96c1c16fe16bd008c24fa29f57e39dfb033e179d0414bc27c1d4ee27fca6a0f936bbea5153458b8d345dc928f9fcb945266725ed320327b011377dce234392f085e975d551c199d77ff0b486a18db93de493e927f94952121bed6bef614a7fe537348024e47593f919d4413b12ce2fc4fd41a564d81afaa53de556e8598721fa59dae2d76cc3a6d95bf66b3615a9981724fc527505411f4e2ee334ff4cf1566fa3e22f02cd1bc251e95","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
