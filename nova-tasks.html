<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4fe0150e80dfdc2cf5f9cf9b3722944ff925a9913af448455b46f77b07cbce2b9157433bf94e10b44d95dbe1ed3112464ac06df569698ef27c7bcbfe17244b6f499ac3c7a15cf550a92afa425df53bf4493fec8f5952905548935dc29ad2496e74e3af07518578cb1c91ddce9e7c583e27b3c5b09f6e09e0e9cd0f17b0deeda8f990c285c2d81e4d9fd115b3a74a780162e63393bef00300cd9ab0fd1db7d4874bd36ff9ec7f2879f265e4e06493552de3258a580658e05c572c22616432f37b6c6694e34259660f4a462c0f498e0964d1951f6bf2741aef0f350cc83a6740ac568bcc524671ff1b1908750f0261b7c19e13bf59b0d547fb15c3f48bd41442b4347417db252b36efd21ff095a206db8742b6c6896b292743ba0f77e53e1d8097fa6ec4456840715b508d5ccf41e1b2b7feea7e2ff52a35600b52b1b4e858e15a2b80e6fe608e6c3e8fd4eb285b0e02b612e9b95dd1c25b18cc51b6cd79b8bd51ea42d55614987a8e928eab4dda9681f11d0320f6031872256d32a8aeb004be94724c48f372777a1215a946fbb49c92e1bb33e266af68dcaeba038ce271ee2fdf6226d8ad4c00c8273f70fbaa8be1530c493e59f72940e65223af0dd1e33e0a91540033f10b89be169557964be341e446f901364333b2a8768de3aa9853bcdd12b9218ee6736349d22678e73e46f4b9c0813566120e3338ea4f5af22de4008e334818a64b0d634319649b88da8ddb94ebf77a627c14c560f2f55c5e850df5d01a4216e400c5e2844908cf2507628e4be18cba45cc69029f17d216e602cb4fae1c9014eec8d4acb6624d1172fc3df20b78f54a4ebc32f5a5aa06177a75fbb2c3928478c995b8e522b5c5dd8ad080e77c2d3c2dc8991690840ff27390133b30667aed259349f5da4657cdf6a8a3b9aeaba6b2cadeecbaf96189f25cea739110e19e998e3a5de873d9301ae503a4d2894d249e3b74ad56a6ede0cfa062ae80e827a66308d8a1767c69f8d7ec6dc8a1f02ad82d21d51b2236b67d77ea95cd14a555c3a6d24fafd798c0b6d51314966786882dfffcabe3ca9eeb0aa9d6e676271911f8f12471529a8a0ff3717d41996c0d1ba9c9566798ded07299e0d9e26b151f0c98aa309879eac6ff2c7ba0b2bd9a6a95f8e92065c1221badc78a7219ce28a3644b4feede3a44883fc28cd9256c574e1ff5cc2328f58e0255de30c0a6dd51b84a877df75353c7f132c75d1f03dfe02f1de89f0a7129cefb9256c2404ed637c1c6d3818aa0fb592c5ebc2754ec848f5d49dc72c5c1f0f7cb7d7eba0ee1ea293b2e384156f5d2e0be9d640a21f42560e7a4016f1105b6a4f411134bdb33d813461cea41bd40e3efa31fbdb325ca37b9a085767617ab754af0be453ff1629337909dd5ee676bc0b144cdd80b1df74c390ef02b64592bd388f8590892372eb2a0f9728c937749c46cd03b279550a923cd9a6ad9f3deec927ad96786e0c606ad10d95ac0104021b2a23da2069266f1b90fa31d8f8adf8a6e87e8aeeced1d7f0c50e569ed01491df8d1dd34af41e3af5cc2a16cc7e0471a1e63153297e663b486aa732a69c9505b1beab78a4f09b27d5ed6aa3985b8d70eac792a1a71291b7a69a45282cc0a957d060a1d8035a0a7f5f44a0e8e4e0047246f87f11b4a1c42390a9af6eba59831c96db4fad1933aeade58c0889796ed96b94b0ba677047dca79936c79d80cbcb20140c55e4276e5297cf6c4204613e5f91a4ca89d35b20d153e8a1124fe160c0da5db1a29147d72583e0376a5c08c5d48bf8372926e6e9d98e0c88ef62928eae078e85837eda1806869de8732577f67c211ffe768cea5cb71cfa3ee6915aa9da290fb4211ecf2903026f3c754fe407267ae729696b4fe4057a54d9a06c664b59413c55dbc915e83852cffbbf07fb9a3c18e472ee57c60eef044b8fe67af36fdef577a7879d9c77052d4b4e3ab04755314f0b8b1b375bb317c7b415eccba6482803cc9009281ad772adc11a81615bbf507a28bd91b2e1e04b258c1bff2036fa66696f352822aac8441c0e1f798d2a58f402574f897e9a78ebbfdcb0287e2da676a2f950c144bb9e87bb3813c39f2ebcab391687f86a108b2eec7df81f6ee0e64fe435637d4bb241a7b5d547ee4902007d38ba4a5f4bf7a9b3f62fd9125945f4c51acbcce8bce8d05007e288cdbc22d3f5d93c0b491fd335c2cbd501d1c78e72d5584ddac1004324e7216f45ebeed3efe10d0f8d838fb299770b165f24b782e9961164ede863addd5fbb669fab657de397d8c10bfeec009b99c4faffcd4962540d0542fa28af5f0020f2ba18be0049fbd6c72ee38268480db1e397401401ff160c115572604b5515bd69f97cb1f859e29e73d7c33d0970b7795d539016a324c10e02d946edc4daa890c3776445b72befb1f1be90ec13abdc878fcbe9eb7db57273111fe1fa1319078bb48a89804b413512377f9b015b0fd9ae64a625b2df6dbce6047e9ed7701285c4f59d340dd70d5b8a89814c7204447ff87e731ef65ad7c514a4cc4b68e1f5353f0c9b16651637360a5a7b9bfe79186175681cbce8c44dd399809d2008f8151f546b4bf797c91e8226bd790f423d1a4b99353b99bea337fe105ed798befb7c285de6126893ef6099b49ab62c34127ad26ca882a0640fc806d31456cfaaaaafdf33a2beec86c9d4637e9afff99ce4852235dd64de7ce5aaf13220b73308841c9983d23e089614e84cd75afcc68f07afae5b642add25b2ed856a136ccfee85a9efdfe5a5482e3f78b8c75cce659cdf0686a5b95fb0787d319b013f66dda39d5366a88c7e408d802c8d942dcc74870883b0b40a114222d967d8ba4fcb856db5aba4df256dbfb30d030ac58a3b15e8fa14af3fc9470b6b0517cc041a91bd25339ff48dd5d64ab300a4e7f0d9b6a709d8757ce9c04db6de64df406ff2e83ec19c7561462d586048fc1cad796ce804be5abaa355184f4e7c29ad644c77712f20d5461980a4e3d5691b7a0b459610e7732f5cf5ef963f5b6eb4845f3f8b92a650117b1d8320952cb0bae001eda4aec5aa880e52803e704a85303cc2b6a6116a27e88255fb46c4106a0c090d3379501f796ff950ea37debd0c869e59d50b80d73f28bf15cc2fae204ac2800cbb61c1931e3f8851956061d0b5e9860fab0077320198f070a89b40e99bfd73de1de41a27a3aad6eaab6feb6c64dc300d747eaa70c8451ab15b2dbbf24e4de64b72f7e57157c42ec16cf0daa707c693fa993a30cd952218fa555ead400ef5685ca32e8ac7e85b377fe293976fe8a35b2641022a089ccdd981997aa12df4ea4907c080a3735303e9a89bd2fa4164d40462aba68feb7d28baeaeaab3a143436f860fd2627dd9d31cbd757328ab336a75a5e615b4832d7397175fe787247635feb2783c2d501746c0c4580e6a862f575b41436a8d4aec7ec91bf8726d1d5d9e93cc55562fbb63756cedccb6f385db71f5abe444b042e53af15210d116de745a7dcb903cd4d0669c1d3cefe4f2367815c63b3bab0f7229fca735463b35cd815e053374abd32e1b44424378123fc3ac97d4fbbb4631167eb8c4b3b4445a0b3bb54c7ecb5b78e3af8a73738c17ba5d641b58feee093325112d838c6c0515d8f1d7dd3e69de28a00683918e6eb0dd853bcb77c90b6814965d4da03ff0959ae784da804b220b34d7c0bd9624cedac7ba454724c93115cafa535af55bd7a71313d2a2ba7dc848f072b8e77c4e5a5b045319eede3ea9e922bdbd087007f6a0e4e29e07953e064367135a57d7645bc26d5ddf91b34ad3cbf719c3d33b92aa56886e6d2a02de46e3f276ee0ca1c6ef7fae214e8fa758014b1e88a7d42bc42f1870c14e693a1de284b6d48dba59a2dfcdc680c7dd1f63a6f7baed20d818c6715333b545a74d1915ae98604f0d914d983610f1846b211e55e64b7c18a3d585956c776b85ab0b7b08affb119ddbd4463e96df9afa345fac276d3758878abd9bfe923179a84437e09cf9d3bcab2c5f09cf548bbe3ef381b4c72da3c2d4dfb7963a13275aedaa540cf65efae59ac7016282204bf5203b61699624e0db751352631beed0941c34f6f7b493f304bd899ef28c383035c38369f4392d8c69604cd5573e0c04a2d2303efd267541e2bab550cdcf16ae69aed65cb9f711873a8483e70283872d60e0f1e64903e0eaa5a0656b9031bdf83345ea2ad48fea71f42e4f883e6aa5546a01b5adf14d52028c8d13a3e4da6d706ef1e8cb66fea6a0477c93825164cd3f7e129aa27e20e046c01755eee3b0620df1b78576a6e40e9db3e25f057ab2cb25d4bee1bdd11ceb0ae3e5c76b6e5b040c0f1485a2f88a39cefdfd3c269574f6571d8b28b79bbd56ea58713565d5001358ec1e54d2f86975604b1dedfba82a073c49ce5452f0321d2ef4bf904b53e5a2ed17924840fbfea6b86f100236db08beeaaa87cc187de837218c715a2ac3e56071b7a0a8ecf1fc23ea758e40fb7ca83d17cbc31132a0874a0d2aaf98c4903c3cf8f49a086df49c3b57a24f7d616dace9b7580c22aea6e76685fc95919ca25bf6c1042eabc007630bf91e971a1a65ebd9246f65c09187d0f99c124ffc8b3ed6799dc05fc8c6947e6ac20f1315e2c37e3a2d47eb283bcd9ca5a429fb48363aeb8d4851b74d2f85f1fb1f725daf01ce2462cee9b525a840cc316eb2ae7e3a19e972cb4d7df129d8700d26a8e7df1d531b3340ee039205ee2e69e0934873bc9bc07f3b6273de3cfe44e7ffc868f4a50500638a09a015d601ee12d7fc1a2c4a97a59e7de920dd0daeccc86bd2b4fe1cdcc8f86f22a69954ba8cbb3c5c8575312c1beb4f77b163ad48fbef7700bede9fdbe3fe7d540aaa1c3d4999acea6cfcdc1647e2129d93b5ccca80476e46f5eb2e3e12486fd726398f89a2beb7bfbbfef67088f65e5f25b32f36dba5d0b906c3c2f90f6d7ee6ae45b490810d4b6bb8e3b9fe06ea25d1f53ef6122d58ba9bf102c58882451590f81162fb2d9dd1d892791f995f237c7ff7dba7d334543b3055aadd47d618d5ca9186bb5d2a26d2de191e898f8c1eca175526ef9e86b847bd91cf533b1de950d54e6c71cc7e5445b52dddf774e75a7c401a6be577177b1efa23c5e716d5686f5af1535ef947406fd692cb771eb3a05a8d6349db5bc6d68ca8dd56155e11ea8b2fc46a42ef76b8d0a0d104f729f2743998df7c1e482d2cd7fae54776ea3659ec7394ce8834c381d694e318e072cc36c00a748ff93776b376363fb7568fecee3114be17ceb892900e6c67aa7f4172c8cf17ab7cb6e92aad0410f947e39a6a1d47119c2800ac1852c996caff0ba49ee96c32165aa417774a3facbcced289ad9f8e7b5ab086a1264557db90396d61a0c40f41353c54a85ad516827199cd51096d66dddf11d565382539109af4f0863dfdab4baa89d504bf39b59fba8ad1f9ac37a25549708732195a731ee24702f13ec31ea9baccf97b31f8fed9a022423baeb476020372a4907906fb7bcbf3d871123ba5d5f6f42a1b350481ca2ac11d0b8ab18fffbd6250b019b124eeb5248767e78c3b2a6de9e67926bd957fad1397db15410816f5bfb8ce381665091cfd6a0a20c76ee0bf4b1b38101f65917c002047d0466b387b33bc635d1395e026b10b2542d5124d1df7a6cecce13affbcc513b567caa651de135deeace43d1feab4a7fcbffb6c71434fa55df78967e7a67d7f158199877797f69944a1399294458e1e1d6ac9b6f2a37739d9460c1200443ab962d34d51a109c6015aef724f825b5fc56024ce933dedc3ac7b3209f072af7ff28a4abd33d5934bed5be65f3df451ccdf85329839da821abd681fbee4b4f8f5b150692c808e8d3f4a71a0f0f3451a6c272c9151d34c81e2dabf1f9efbc2567efdab8d9f0cd46a52d608d18a489f5343dceae270bdee205737c0ab5bb960deae58121ca15d7df24aa106285b19a03499121f93b89a21e13eb2d81374e0025966be28a4f5245b020a0a4d2eee4854b47de83fdce934a3097a4b356813509e09e6afad863539c1b5b02ac3790f67392641d468f4b481ff3af8c80a765e2eea2ace849d7b75411665051f572c7a4e503297c7db8bdad86568f2e13a84aeed95ed2ad844395f587b2d61b84d263af75a3822c5eeda1c0ced54190e2128a39bbb65df6cec462a18762a2f96659c24bcd4c7bb2e6721ef09022c58fb3419fd9f2ed596918a90e39c68e0952b494e772d3c751d611033922913a8c542aea3c50a1e084fdb142215268116334f9c384611876d691c693be45a551756e42dbaa1c6586c252cc0151349e1a8a08810ce7b27c92613c91dc34d8c04990996bbd6953675f58a4413ea8daf41a10063130a7479e2f8ae68b080de5ef1b62c39c05f1637035aa87f07f0c0126b71f8e6600bc3bca09373188d6730be40fd657fba5ade66366c26306473f6b6534b3ba018b74944e28732aa450b80e2df22d1ca1784c5ad007267e9d2050d013f85c7f9642fd03511d981fc3f7ad360b505108c025b53e7c6faa2cfeec017d59b1ea53bc637af878509b86f2501ef31fdaccf382b296935b7394c3b88ba92eb769478d0ef06cc90e6152d23cf9c8e0d1155ba375a1feeb4b62159f77b083e44d160de5a0ab954c4463e296a8851ad92762c394e591022592aeb701cacf3fcbecea35536b04a9cded88d9d67a8b757a9cea9727145e007f67dab5a26a2e577c9e10202e47f8f0018ca54779e8a0c5d907047d689d22d1529b2c77c1b654eeed564e0d2a234dfbcaa908979fcd1a90b29cf4a8e314eba4461eb52609cbc06ab08a89f18c3b5fa8e351cfa3ee6d79a275ef123b1c3d92d776602d1a4bfa759baf3dbed95d07aafa4822f832fe84181a478b26dabb90cdbeda9b0e2f4debceab84d54688498ad402bca51e8dca1d3c9f8d4b1c932f9bb14b470b997c95a5efc1c18b7f5c230027430f1373f89fdcb1fa7df5808b5841097546747e04c9d8cd588399937694ee75f24dc11205b37890f1eba03c17f5eafe9a174ccf9ce71f96e9877e12519ac381a9b53432f07ede48971f56f440bd615c884932d720dfab8057000ab6e9c55441aadce530259f98eb2cd8ebea6f0cd230a673c6ce8092b499687be3a74a264b1ebef2114a0c22fe26e677d38823601e8d5a301f4dbaf82a3a16130be13a99381fe460f7693c836f83f199c7ed84f914331f3820e70f779bf8104bcf34d26df26095bc0b574cb638a2049153892a0792abdfa0390ad745b852c92512802050a56a3a8eae3957b63aa5e7a5b2359988eb42e90f84dab72409f244bec008afff086464caf7cf04e1b97ea9bf4b8b021a57d6667139e480b5b4220c723e17d9cecc17b8b71fd6a02d06115939b8f22995d9caf3de4086289da236943937bd8e8f3f5c08d09a2956f6432dbe3002dd88cf5e87aca682643f92d09c52ee46b2e6fc4e70f077597343903ec2f0a11dd1d2566a8782ad1b620417756154b2d819b3004fddf81db7404c72a511e60e3b57db6a33683d7bdc706d250990633ce62d4b8ddebb89f79db53da6fbbc71c4d0ec565ba837552e0fb175d6b5afffbd826926b863ff91841fd979d5a69185dde9ff634665ae00d60be99abd938be8132e5935b37d5c3e49ed03b69603eb98e676051803dbbc882468c44001773f41982c85ceba3088abfe39f2847b403474f5da4c187aa80ceecd78b6c99794d06ea8ba86bd69ee2c3a9645ac3a4252b71639db93a469765322e5721ad708c0046d3c3fbc00939ca13740e7435dc95dec162904573eee004fb7341c91a8e0df8fd625a33edc429531f6e194166ef40e8650b48f594878a1362f4399e4be782caa8bd7add9cade89608deef92fee662c386fc92b8970783e4d328b51314632742014d33e7624decfbf343cba7bea75bf969457e2d59731a05b767bdf745219d32e0eafce36f3de5d0b681685e8d5444d2db9b2c77f46c5db520ae7ce55c1b15c6939494dca4a8924f8c06dd24f3eab4eff144405a8a1d86690d1c6787347eb15eaa4c757554b7cbd143e42e8eece6949a7b5a5e90b9b827078192cb1e1d14391fa5463a64e69278228811ea25b3b65d6dd7d2aa69133799e22bf3cf747d04571a51382330204e5a52b572f6ccc19491157eb87dde56f7305899f4d84db7984d8f7599d92b35977caa7c268f185f7ed509be0b46f2f4f10c2e75fd183930d43f3be83f736525084dd3a93e4b09d5fce258c47467a84fb3168f90a9240dfae2a2ce3fc44ddff3c515f5c334f541c0a30935d9879836e199652820ca777e4cc45f917193f00fb3507d4a84c4115db428a67f6ee55d98e794624eefabced515af7f16091d0f017ece0e8ffff78298cee057c32bd03e9737831e904fde88c9b5c206c68c969c81a703930ea3157d9884ad051aec661ac3fe88e564762d5d9c462b4ff1a31ef3c190f6da5ac7a25b12c97e7767c89dd3725d130b0c43930648032a79562dc6aa2c04e6af0970166163cd571e3f21650d90274636e650339f1b43dc803b080db009621b28f955a299878bd01b0079e31b36a56d753029aa65379cacaec4c19d222e9cc04158254415e0b79709217a0e7fa404d0da1e113d0a51d0d5d0a50b703e182f8bcbfd1bdca34a6b73a2de40db04648205a6c36ded2a13ce4586d5fa99f9d4a38ac208fce7e9362192fc1a783c5128a7a31e6f85ec14db1f37fce754c2ecf9538c0da2ff8602457aa9a80b01e2fe6b5e4f03ab4edafd3614d171ae49f02e199452f43c883633b63b40c201a9ccaf1fc9a5538f20dacd07b326d003ed91544ce3ff102f305e5a582d5e3e0a5957dff04223add3c45b7d6ae1c52b5e9e19a843b7d7e54bd63536ddb2371a22f774408f4ac25d78fc8a7f9580549ee74c08d8c21298fc0d8c4a673cabcc3dc50032a1c61f7d5e5ca31afa1921c312c1aac82143589cae9e6e7a01b008e208e895c98e674a88df3f0917f8760fc326374168a4b5368fda5dd2b4a7ffa491f3394586c4ea038a11d1edcd2aefc662b4d5abaa7a0498e20642f35475f0dcf1f1b70c24f3af8413c4c0a0da5caf7599bd82af6ec85724d73d784392b11db4ab228bf0ad1c904af24398b019eae57aa2bcbc7447c32d8c7f099dc9282c1fad38ed3099479c6f01365304a3dca2530d4bae1c5b86763cb0c5012c379484bb8666165906891bdfdbf754fa7c06589c8f6c99b91ba9733a006c5400059be732639879a3d29e9934adec7da142578bb0ba241105947bd10cf9ff89ad00781d431cef6f0037427ce17359b2949e9db0c27ebdbe697d23b8235d7f38d541e1e635ddc0273195babe195d847c0d7d63202673c4e1f8fab1f1ca2f93f6eaeda7c55d0fc1b7829d7e4ad77735112f8552d1023cf35663a04c22d22e107f79f093cd9af274355ce4ac85dd4eaab54876c03d521c69801e38552401824ad3253836604076b6e2730c4d751943b36b2f07ff78fcc148da3d4ad83b1a4379a65b538a22e34bec649fa2301233ede19d907f0dd50741ebf3eab742759ca38d03e220907ec604b48e0b6c1c8335b3e84f377d31228a5e032848c4930d5d82fdfe483e780aa23231d39ffb670be50fac870f87fda537bd52037208e65e1e3a9440ad2e1308d5578c60276c6ffa2605c1a052d7759ab4d372cbda904ba6c5bb28cc0f62d56ac4e60fa0bce68f3282dea5a2dec747707813e406a2a0f35a5002006dfd4290638dccdc70f32ab1a423357fb3313cc589da6319ce25eb1ee426f07e862b99767972020d5c036e58114b6d5edf22af63df6b3ee4689cd33319ec3f944682ada73aa7488968a1a4244bd0dd80ebbe7e59530db1fd33733611d07b1428325f9c1ae940de2c8c78e2a9b0c905df52857429e121bb0b0fe2f71af4bcbdb2256624420103a673b14a1de425c4cbc335005f1d623c482bca6955622b9ccc9c67ae86b7f294d7c9f3e94c50c71dbe36efeb0a381d98ba8f1a414327642ff84f00e694fda113b7a8b73dab1e9aa0844ba4fbff0c1671abadafec6c06f455d4808945a9ec9a6fe89697551d4b7d465e815eb88b3846160c11f5aa6020f4d8e9cd47591a43c9a6d4c948675fef88790a33e53bd6cc50e0294fcb93605a69de0d9a2232c5f0dc096c58b31f20f29864762f39f9faefb49c1312cc295117b545c66ac27271d7c2e5c49ca6e623f032fff83d738a3641c2dc00dd7604c792f5f48f1fb4542b1bc8bc24a7c7e4eb7aa2da3acb19874fd42ca6fed277342fcecbe1bfff46cd92f07a44a888648ee9772d29e05046b7e78de19a85d6a505dd6c21e9ca2f6c41071bee05eb36dd1f78aed6345dc88be02387f360c2b52f57517c07b800757c7591bb51190bf8781940f43a142449e6746ff6938182dc8418d547996535aebbb7fb5c71faee891d6019c188886b4da1bf22ccaf332098e6178157cf6c72094400d30b7e2624a0094902af216beb95e39e83a0d2476acba14a415e3b80b0abf5a8775cc226e91855ab9e1b88c5bc9e89965306d1a312ce199a081652dcc23ade820247e35ea2a50807854fa4af5d9e47f27cbff34cc16b41e1f2c8c332fb649f47e50532e9dc0ac2201795fada3928e106e48fcaeea585265c2b0c9ae3ca971d81440f200fe08c4eb3aaeffe28ca0744dc561fe4d596bb1ee10a63c641d864556e14b6fe8a6256c1f7832ef8a6cbbb07155d86187bdba81880352834c38b5f1aaa04bd05b3c6ea2ec3530e8316bb9e92f4a12ca71bb9d562474f082c049ddec030e8df5662a78e79b34b8fc264ef62bccd704d60cccf081a4c628a5d2c52a28bf3d0db7e29b33bec057663628efed1ae12804ff986912c8f265032d34e153f0247152b465db61254c37c2d1e2b9f1eb9082f617d6fd78d2e7d9f33b08c1dec7ba92dc42df65dfbd631eddef0fa443a648332fba8e0e4e4d76e563117ca6e7023050d0980cae0de9a693e13076b7f6645824fef5d535f7fd0567d4d6a7b71aca92518f13dd346b2299b526bd86e5d9ae846b4616fc7260191b12e09f8e392d99b5e92e5c3d289ec6a1599b322e97fa8a3532aeb6c19d1b610bbf1f7872c42a7fc0d5282e15e472328b7a73cfb29e21183583b160e220620e78f9c2ad57bb7d5a02ed9bd444c329bc53d13953f2274f2e802eeb4f09e60c018201600f8890c1046afe351224978d901cad68fef3c8c954b9222adea34a1d3ce903d2510760f5d93d729baa007185a0f8782961e138f38899ece657865f170c9417e34638c2bfdbdf93976463f4557f289b26f09b7d36a8edd5e950ae21927a0651c71754ef97934e94768776cd56bfa2d80785d66f6a58394abf140fd8908deaa0cf6aebc79cf62f19d74ff41345f9e868bb4a42843d2602b9db0937d31b08147269d51954542971eaedc3eaded595e5e5cd1ee46119d1e4097adbe3c277038e2ac847a22601ae5bc8fc5e1ee212c6e3d60cb7ec47fab251b017cb2230144045edf8c4b525fb3e79372085bec1795fbe6d320420ba2dc219ea77065162e2ee6438b3fdfac5122b9b4959d3d8ea05c4f934ff910e58489d485ed1342fdd2cf2c20fbd9626ed157bcd2fda411cfd38fb3399865612de86f0fd934bb703e22ccda026f3355bca9abb78bcdd38e499f642610ee816b3d1829552f992d7ec7bd2568e17dd3ef885f3407634440c5c5257e568cfcfef8dc2e14530fcf8878946df0c9b44ef7b197c124bcf619fe0d23e2143b280cc552ae44ecb0356bff21ba639d888e2d53ee107789487e4732148e7621d1e9afb3fccb85b1aea8ddd3bb886cd1d5cd9c1f637f10332b6c967973ec7796e900c90bd15a7f717e9f8c4105604c434e876b92fc828253c28fd655ca0b0a1c2067417a3de82027437fb9de869242b505ce80d2eb4e06bb7c34ff3478e8f300b5c97cb02ce84e3e7826897b7e05a9395562b2c6282feeffb7599329fd906fa511dd3ad8921e57ae7c1abb72fd00f80c50477aa71615572a43a504d282ee03c72ea54dcc14dfb16520096542391a70efd47dc8e067a79975fb7abb8729dd3f9bad834e9bc7a43bbf507ea1b99f357a11cafdabad44ba3f396708634671d901088f98204c344947c54db5913ab1624e73d922bcdfef41d440d27a33f3d753de6833b780692281ff78487297cf23fda02c196d8a495a871510e000d3ecfdb06a6073a06621e42b609b9818e9639e17627aa31d672b46f8590456766bd3d0180ef830b96c737d3b93360b8fbf6d02384380816523277276954bb5f32ec3fb4b0ce14bbfd702168f4e1be1e740c64d48d47e5f261998d911cd381a17457a25e1c380b113e1651ef2d851092b6c00c6c4670f23fe46d4271b6a879627f73d444bbb8fea6fa99cb4831d36629e809f72d7f22aa9d86d1e516675e5e3f7f61245e2b8f9b5c3444ebf58f73e58173d4e320f3ad93eb4c6d159464c894ba28902e925963b39095c697aaad04915d57927c9e84eb0e7a4da395719b76caccc27e76cd0f85a3d445723826e266dc16c70ff36a423f92164675329b09fa5684edf71c1da2413fcec3bd0b6575f2f8ccce931b5b360b76bb379b7133da55f002b79004f8167dbc5b59d93d9b9c9bc19e1915c88764e953f78c97b178898aac649705e80ee7c76ca47efec069c86656195685f9ae70e924777006826f877df006dca861a769e49b4abc03279144212a6620c59255c7f33b83de99b3c6615afc48ac78658f095671a82461cf721f89cf26769001d718ca776df9d6a11e2626b9551a397de27a559ec4545da0e383951d812f41f1d10faf391c5b07343be6b99d4edce533c200507b405e22a33bb91277f43f1d65d295186dc983a3e85091634b595dd0ad310bb89897961f06dfd9cba3f716950c3478f3623e80c2f549e878b6b83cfe9367eba1697c434f3de4fcfe6bcad1b088ed8758349fcc93a1967d3e2ec1e880bc895cb4711c84a14098c0371f8803eb3fe54a9fc5849e74c5a084f0a0e18ce6d88d4d244a6d235c328e6aa07f504ef4b87762b4f1fff8ee5878dafe5dfb7a64a8d67806994a3dab1b0c2d8e9dfcd3de3122607cd8a640dbbe8c75d3d3cba17ff510cfbb70c570e4e063488e513d1458ee466ce75c254791a72d123f3ffad7ff380f6444f8c76db5541f64b9f5f8b2d0407c67e083864a23eeaeb957ded02b4eab3b8690e54571c101a6b74b73733f3eefb35816d829818afb241f23583fd4d871148f409392f6ede65a84fa5fca6099d83761c73644e9f7f4ef196ac49595e8881ebea0c437750b85a04478abb376dafcbdc40cd8584bac4e6d8b091b9ed664325b125e1bb7161060a5ed9a1e7409474835be1deacc0d5a5a5b4631c52611e11a243479ceca4cbf03b926583aba0723a214f31324a3699c55e76337e20ce82f41f5bcdee19dda92f82521d0ce95ce1e958a4e209174b55020d4af7a45e1ddb9be4b4561932a8a5d2d34f31dd7a9cc987820dad6f40607b5c94eac17fd728b5522d69ca87df8c59524f86b77a8910eba48e99ad96fddd5130fc320a17ccd9efc3eb982fc3e0977d46e6d5b5fd560004383780c1e36b9ed9297db69262ec1d26113826066f2de6f37d15cb3ce5d300dbbe3c97aa2258c045f1ad2a631aeee45ae961174e854c2bd26fdab1cca90052dc50a06748aa42da7dcd05646b6bebcd3ef7f91df20131165b7e841498f4aca77856e2857970b45a9ba650ed9386f5c8f64542c06bd2a0888fc1e1f76169974a515c44cbf47ca8e1e1c81fa3271ebcfa853cfa822e0ccbdc5d6bf2eb8f0ee2addcbdb02b653b847293e29950119e3e4ba95e019f4bf8476baf3ecede65e97f7721206a4e068a915e479b8cf44bbca9cfe2b364477d08e7b320545ab75cd049d7fdc866a97aba9e82bcbd8227562994f17e21c1a9d3250a3b1178db625ad85c09719839278bee87f95f49dcd892198686b92ce2f36bdac8f3e96b5c51074ce70a779631dfc9cb4edacf2d33b8b62f935d8dbae3cae9ba9e4544444f7ebc32b225872bb1512cedfc508f8f1529de248a5c935f9c7b71ada5985b4482109a6b0cb576bac837033587d249e6efb8fcec6a7d991b9e86ac7898a1eb0b068a2ff71a97321836083f68b0d477fda012539c8cd64751940b7f911c9ea84cd0afae50403c698374a29c9d90f9f3101308a951f81f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
