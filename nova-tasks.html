<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"349685d7c6737edf42a77a272509eb8f25ab1be2faf0a2d0a50069aae221decf9a85d7fb20bce4dd41b8d0fb7702561f0780150278f55bcf2afcf7b3cfbf18213a471859608723dc3a7d41d97473babf87c6d1d9f6856d9da040d25b40633a9667e817ffa9f988a24a31e61d40a06ebd84f3470a06c124ae3782909c45888d062d5ad5693f69222647eb6d3374a83563315ec8c813d5bd26b89f74d6c3ebe80d2f924710e05e5d34de0529a80b11a08c8438e320c4361eaea0587f47799bbcc37060833777ad5ca5687b20682db7cfb38bc93a3a2dd6b96f05588e6f242d20616e574dcf2774afa77754e03ebb11b4e0ec6adf7fa05be8cc256bbc4d8df8c4de1ee346558bb490c2ad9adcc640d120307210888f9ae150bcbb19e8fd90a53d7b12372c0b2be7a930826ff513b5b40742a5f73d17923db051451b96981442f6addb55e35b5b449f4c6ea9fec94c7e13d7f92384e9caa0f4bd8563505adee59c1f1eb7e78cc6193bd3dcc8321f6ea32b9e6863c3d9a2f35d8d243daf95792836aaf6e762131c29cf1eb6155f39dec2e5ade891e6122e1407538bd259118e89292bbc12df37c21d1c8ad64f197674b3b9d089ad8e611f91a82eeebddaeba1067f961ef9c4518c609e51e7129a99e1554fd7973b5e78e1d52a5c42a3409ce22c4f72827ea873d7f60d646cc5967866e064b1157a5888d6db41f89e9854f4924c1188bcce8cf1dedb3c491da5042468c65a42f1bcee895bc6564571411eed7c27411852379e75517b9f60960b4846645203ef19922fd8ded5d989843d1d3336faabb1c62810ddc464a81918409e478bafd65ccd5fb464e9a6b872535dee0cac9ef762cd6e2d9d6258c61f0940a8e6702ba485f97a134ce9466f70b518e3260fba710c5d40f5dda63e28c7e7c97210c3b195c05101d547531713b1ab6fb55d2fe9a19928a6acf657874a3d312ac521b59e7c520a0d52af9f3173303133a9943769c29115605cdd2c32bc9ce81d4c8cf3019ca2dfc8d780f563604436b4d33fed50f168bee1d880a151cb3260ece0ca3319e4ad54de931716ece254b9fc0ccbfc926cf6c46224f9f090179039b74b4a40d10c282ebf65036576623bd3c7ea7ada3ee37001981d7a2617bcfbe14d9277422471f02c2bfad0277f5d0b1ee6783d748bc3ada815cea8a671ff1468bbf105a57ef84d2c1baa648c384541feb91713095adcdbc961382aac772f0ebcee3e177fd236f551813d4f71077ec4699dba7fc94af8a6ddbf83f028d978b104affbf7850c04b50e0d4943c0af4a47828c7bc5279f033dc687d81f73e87d362869ac3f40362b9ac7fb07abfd4d6366d5fe917283a2e052ae8e8fddfa02e1c2bffc4f54fe6587f6782777ae03c69fc00f545e41bdc218cbd3480cdb70b907ab0c10c5e1059248faad13110af4a87d176dd2649ca7fb8ef44d1c282209a13ea852a8b5673b85e6fa52b29bdd5f70edba52f7090c3aadfd44ea799b69d052619ec010006bb5012e7e1473dc6d0815bd8ac2a4426739194cc70e2c020c295a2c2dc6fa4a243b62256ff921682619359625a0262a8913d481eb7d3c19c7673b4334b716b0016daf7fdcb199ec0a9efe805449fbda1524778d76a9d0520c2d188eaeaa771a6a28b5c9a2f57d82d545e90f8719fc0dc2d828aa143724fb5a42b43acb41d80ce1b16570034e0d676285b98b7e10653d12be4c68de30f13a6496d81e18d5d4dde22549e57f6e70dc830b993f50595190dce87083396d2ce0b9abe6a618e103b2d87d555167e3beb4eb6130210cc791e3b3f0c1d8550b0216069ccd3a338e7548881b627b33521892c8dfb2ba4a7f40dcac3aa9367dfa6ea608bf30a3eadd9c7cc1c69aca284e6d1d4b98966ae690595024cabbf2e2020fa06ffdb250fd1886b9cb2662329adea7aa9afaac1359bc1feb5fa2c0af0d4e11a1d4f9581e0c72c516164abf3c961e5739dfe83c76675561d212cfbbd562f45466eaef2d8730bd5524cae5e22d87eb7ecfb7f96eb01fb0a59f290525bf20fba25f4121ee4308635f2db69c92e856b96eda66200222f89cd0e02121fe277c73edd65998821c4df0303df047989fa702c212cd2aed92b18213c20b613f887397eaf2e11e50045dbe59211492d8cc98096c25594f0825002f29d290abb953302ad08205e034b7bc4fb32befde88485b63f0ac1796070f7df45e2927501c04a1285df71ec30d379cc464b52d413582d5a14a8e3e3d3df4b46e4d4e0b83d6230e89f22f0c92d3c996c4e63813b11d8fde9cd12709a8d10eb91f73b96e0e511f735d25bd36460ad2988633856e9989dbadd6949373084de0a7ec99bbfa8ee9f722add262848bd248d520705f0276eac0bf6cfcd1124a2883d4949c8e43ab51f567b12111b735fdc74e84a2f95d41680c4c59e9446589972937e019fd53ba250a476aa270375fd9cdf0bb9a787d083eef33e928b2db5b6255f2aa6a1993aee5e56995e746c0a1922a2b77ad77c8c1da1a579b488518c0d6fd5bd84c0dafc7fe6d077255083be7f48b7ccdecd4978c8ca56e75da910442a4f8632ff966b0784f0f23fb74899261e80338cd4e5ec26a99e0b199c1e0342cc15298d438313f5ca017745c1a9da80a1698415c3111867f48167b2754a70de4971817484181875656b74dd65879a5d86b2d12319ea7740c263ee47568e2db7b0108b0adaf82e07d5fa50aa1b319eae19fe3422060d31541850fba65ba839600870b0b31937cdcb68b661633244e82f622a53fadfa3863997e859f5bbad4aabf25b3b5d0d6bd1d89f98bcf0e7e813588abe20836c5319e0a48b4f34a09bb2992ecc484afb04c74fc0cba401de4eaf6dc723691bbfba92b90982261111f1481b260302bdfa00ec845817b4b97fc5622abf4fa03fb8615a7f4636380eba3f8a20b55bd4e9913e58567aed65e1a77e4d8d175121d4b126e51c205e482b6a6cb65b7c6a2693ac4f96441ecc1b45c4fa1c64c90360c8aeafafc6ea95d8c00c5846a34fea8f54e355e4bde0adfcb0be690443b3cf1d90962234fe07236d8bfc0a8c71c9226571649d62075f812d27c07263233e1530241533bba60617427d3305fa501f709b5e87d9e39fe06b2589a46404e3250fadb84c8bb29b8597b35720604eb1b832faf74f77e3f342195082655280b3ad4e45b3bdd3ed56b76f60d9c3ae425e7adaca0758dd4589cefd5b514a1c7b98896d448cf52c0a23f856d3e461517f4b102fa956a767aa57ec5436e5ed09036e8afe26e0514d5d813b8124d223513cba29b256b5d2c0794e2c044cbd1db3266c16a6838d2c2c0d932a6f6cb7db2028492bcfe56e7743d534e6582516ae0995ae693b19378a2f62c188670cfd0fb41326af53f0018174cca111ffd71936b1c798c08eb508d305dc78c452440cc17f00d07c728e8ddc96cc005e0ad7d7d437b7ffcd8a4f3c751103ef14905bb32021ec44fa5f347cf33c416d893afffef7588a2fc42ba672f1753b4e1da49ec7d07faeaf95798c92f0a80746a91213ae5ca6240d6649330dd6e97c5cf71de041644777c2636ed033d46393223f3175bd127572c0893b308f633c00fa225eca377ed265bf1d67a3c13e9fadc011a75217de8919436b31be97cc97cfbdf1141dea0deaef8b3f03ff809c5d2272d17effb66e2e5c0d0bed995ef2ea377d69cb03a3dbd43cf0e594d0970401a4e880c517b963a98900c68802d96999b57377419ec7a72124bdee926c783073d0665c279d01904ca4e0ab38a80285b660e98cb5325fed882e58a09652f1321db0703f1615d6e73965edd149253ac6c75a0dc5c188d753907e7febbe282fe898821ccc785b90a542f7836394d83c9d78c629d600e7b0f4857b65a511d50bf296c062f7a54391f40ed19ddc265b4e6b45e80e26f78ff1a062f71baea25f122338aae68b5c1381381917e0e3de62b889a3a9a0c0eb5f12192924bc37f600e9262bcfeee276c8915a4a9f40f4069e0c8a66c42e478aaa97171c5f68aa0e51791ddc7302433d8f53d28ef50a9197b2d0292c24197c38c3d1c7f7831443868c3f28975628e58777dd36542cc7c2ab0fc9a82c073baef8ea41b32bf3f9d244714d7d57e45e5aba368b03b31ae858b12af97dda5770c18022dd497f73be7818e4133a824cf52073a40e6aa0261597cab18c1e222fc16889749e5011094b263d66df358cb66fd2064fa71d713a921bacb66ffa2a05c07a007c029773f337ac8df1e325523092e503b59acc0b3432dcd0e0fc0341d645d00d42b8428b33d71de1a5bc83db2826d008f9af415f0976aea0041126208741e17b4121a6ee7dc567fcb7c3547bb7121efea6ffe0864b7998cc0668b55f718e4b1b0bb05a185fe2ac6e386b1d7a1300e9119ebbc8c0427ed661896a14cfd55b3231218bc7ea66197e27c7bbcda0a07d6e9b370ee6d61e3e8bf215703101e29c54331942bbace1795d0395d7b58100dd08c1e190dfd7632124890522294b178253e5a9a39082da0cbae64871256ba3425a10696c4c06c8d202e1df26460fed33688e20a652541a245ff78ee00f17ddca6df6028345115ffd8a610a3ecc898babffeefa6b4dd975c83538e71a3b12023ac20c44b5c609773bb2357c0a62395d63dc8b90189cdc644f682e9c1335f5e8f231dce63d1ba174890ebe81e7de6fd03e91b30d9fe8d01304607a1f920820273862c4723bc19e298ddd1205d7f5793a515f416891bdd3730d767e844e3851993be35fd4b63297dc8ef66c15da8cf5a65583beec99cdf6180d7a22b6b3a31cb622d7b5551221068c225dc6528b8bc2245547a81c3b61f653c021b876f184e3c4928d291a44197a0cf3faea3ad635bd52ae0589afe09a6ad2ef7a3c329b8757ffa248789fe5489234e07b4f84badca8694bcadebb8eb82f786463a154213094c24293521089b9c3712902f18fe2865ea39ba139f90310e0420febc66a573bba23903cccc838bc17df10f748c634f709151f226a8b5b04e746c4b2ad7778cc90ccf0a513f71d7e358268a0e2be9161ea35de4c12de88f14b6c8ff68a68ba24c212999e215b961f4fdcbcddf88feee15a1450853ae5c7e8cb595b5ceaf40641699330479b39c5cef1e5aaedbd82e84ed477b202f4227e6738191d3ccc7e7a160e3183ebb3c41fdf77e80ef26970055c33e0fe1b99e2b520fbc39bdcfe89b1349a10bfe8625ee39d4c9a33ba87c02af00bf1e9fc2dfa8837e783cc158e0d925a75186f7a67db4b4c86462418090f9a26ceedb3143d83ef39c3ae5215380f5f1f5df906485d54666bf971e55c3403dfe3a9711cd777f72f49e5e398f56ea17ded06d527fef6744084a221b776d28c9a786de3bf6857ec517e5795f56e473cd5956e53e8a8de664d385489a2f6290146d4a7968c88cf7a44f5daee300ad5282320235be49eedf1999668fd1c3cea09a05e2f255724a3857f3340d0ab3d6f1ffa67bb392d6571d68f146a695174e967d074e9eeada9c784f98bc19ff9c976c61e2016007065525a5419fbe14c1b7d94da81ff5973834ad2ae03fc2aa94f346dc9a10931d813e781dcbb8efaefc0af2997da7e63112da2ffd0c7eaa1a3c93c324f5be06d5305fc48e86b8586c85ba5c36851aca7779ab416103fee0c80550acfc2a7142a657b6586298f4441b1a9194114034ba7785428bf1cc3a2d05f5ce75e5e6b6ff9269936168e6d6e4b247dfb58b38be085151bed9d4bd167a9089e1c9be54747b162ee071202bbc7ff8f889c511b08c76488c274d4cd8d3d921c29c3db5ad52795579b112e9b3ba7c812aae086762dd9148fcc2c11184cdae7305c697d8cb42157bae699795f57d5da33cd651d7f0d2da03914d74e7d30aa9b43beee8cc450d45fe9f42faab79f3f426db0a12ef22fd68070cfaac6ba042752eaffbb8ad78fbfe3de9ba73eb850ca6bec0f34b983ad6c8c4ff1f13e90d450cf4adefb4aaf06ef20533cc04ac276e21bb24b7170764684c7861d122b03852fcf40c0b8cdac2eaccff7b37e9452daee53f2980b40c9e1fb15effb58c4644160a437832c2cd873b4b16c93bab86276381381b5303f86bc938b3b2163f461c10211d8cacb2d437caa69f6c19a8a2461286d7e67528b8b94d919ce670c0813853f790cc88b896ee03033ddc358d4e9f0426f279af10176ffce8294583d24c5506c58d17d816d90c6bfd7fa2b5978f33b9f85e5e4600742a0b748f48ffbb69061de9a7ee0cc13adc2a1e0c703c506e366fc0ce7db7fe498497f6a425d3b9c16ee737f340578e0e0421e17df5c2db234a6d58432e49a825b045c3abd5e6140e4eb045cb4180d6fca0d7ab8cd8fcc67bb0ff4adefd3919bddf384290124d8bf0699419537e8b4b71f3e37ddf1c8021ec5c5abcde5598837da6c69e0d2c089f40d7a3ed61a937cc906f655540187c800430818e6a6c1e495f2c8fc638ccb90029acf65860e897ff18c92223184129868dd8d810e6e28a37660c45849827494160ccc8b6345b1d7671955fb0efadefc13affb79a1dbedb9b06976db248d63ec9c29ce8472481c86e488be77aa1a5aaded7e3f461e2e05c9bd3ffc9b233bbc589e4b7ae1e666103c3a89d6a98e00015977c4b678d75c43a9c709247f38aa4b757a94d8fbf83ff62321186d7abf1515bd75bcfecbda9f398c04f979cb73fd0e3ff38b93402b292a2b6eca4c15dc28efd4621b4f7a8da79ca39dda559b2e0f2ae3a66e658999a39f87bc5ab86066c708ef949c312428ba1e4a0b53a36d35ff8a6a18ba4b2fa2bb7b60a0fcf6b4aa0b45a80daeb2203d7ff22e80fb7ec18bbcfea4b63d7fd7481e56fb58751f3a4b609e3b7b601c63feee3342f24e8b904b05d99740c41bdc21cadbb3b4c8e8a2b5f910e7df84618e9d84a6f767f1403040da4d896179329bf0d10d92696a61435cecc9564e15a2450ef995dbdaeee413f808feea437edbeb4bdfac574bc7065745a41949629481e17f291a2c1a376ca0065b8bdc3896f9c3b0c6129d5f4ee0a9ef3648ca0f65a507faf2f7bb6f4ff23a0d1cae522264cd609d06a8cc9fb63ab403c3bd503ae07b562a4f870f2cd8fe1dd25445cb2772290c202c4372d3fdb76281deba4180089fbf6da6208cb485b209b29552ea87bd67adfa7df7582e1fc6dcd373288bf0408a5ae2218bfeae983e46ec1ffff8868a1cc04003b1243c01587dba6c47be1a480ef90f02019bf51e9b5259ec1609393fb73fdbaca497b6a88d382471f82d7d4cf46284ed86fbe860b5f5a8c5cd5f49242480dd333a359a13d62193f26d97ccf0623e40e81cf626849dd236bae748ec424845121ee6280aafd277579e21d86b5e4c76af967c10ee527b9f2fccc56605e6f357ff7b5cde4ec78509c6b40496f3075ac94e741a8eb76b053b8390301ec5b68bf3f8cc380dad89dcd3847814cb7cb7aa89ae82d1b3d46019142c6742c75f55f9302239e10bb5120c398a51bd9bdb630f6a659e347e8bbe3fc56dad9570d1a98ebc0007db32206284d577354b65a6a03bff9dd0e8c5e0c3ee9aa635e66dc63c745f6ad3304d676a726eb095d91f1d8a48ece624035468233850b82e82deda98ff2e56e72b6aef0e8530e1e7727c9f09f1a2df35d7b73bc8997c3893d556dcd718ec833cd2fc63811a4e87c51e843c3db3d5429cd10acc24d06494a390ba17875462ee6f986bceada7a3f2552b94f96095ee65a6b9ee7dacc2f075ef9bde9a684c45eb6080ad7a42aed02b4584ef6ac0ea479dda5279e28a0b54420f44e35576386b1ecfdc9ca89a89d99c5dff4a2e442efe19146db9774c2e5f0e9e93870911bca751e01dcc42728beb5e7f816475d861e242803e367ad5b381820c8352ccaf18fe5f3f4526a925c974a813f1d698298717df6d0689e092e9965df91f2978bb1b5d3c333f3622abf3b5c58382e2741c4bd4e257d7a7b834d0414d790278c3568683e77ea02bf0efab11ff27a7d98a1ecb0becd48be725be4fde3afa4f5b962518df12c9423b9217200d5ce4b7b9318f3390fafd5e68faf551598cc77f4b94505def95229f4e2b42236d6beee15a5daf31bb78d38f3707e68d07fb38fc41e5df82f672af1da473f64850cb60a2fb53fd6b7ea7ece787efab47b700fbf05db2dfdda0a3c53d5f0316abd00312f86acc8b3a79e6e9b6cf47483a6909fd3c9e64b7ffc93bda51ba31afdf63a1026dd0b9ee392d6be8dfbf6085b809fd34061799633c3707316c434fa26d8fd863c3d0915d07ec679ebe7ad28de06c8f4450c449e48c2de37da03bfcdeab79ac55a8aae7dd36e767f6d2a1fc83616191af8e8362e7e66d18ef2159266a37c115c9975a8501f2f0e880cd98b02cbb8354359a98571ec2abc3a5e50380367a56c2c09038f6714965968a0a740cfc2e9aff52c9c6ce5834271b1d31242ca0ea55817f387694fea3541c9a9bb3691f8dbec39818baa1c7b71bdb32ecc0667583614b17fad35265574de656afb431103d11dfc39bdf34f2eb7e3fddb578419005901831b06cadf415a4718d8e47a92aa7fd2b1b4ac3a610b2b596e528223497b32add7b6546836c78cda96b434747b03551a9ff5b3c48471ab75874ab8a8307d31db5128ff84df3bc4da641dae47bf34d4dbb0c8aaad7c1c83dbc8931922c97a5441efb8fe686f1f997c26fc7ca50c66c840153481268ce1f94fecdca7c2cb801ba3eed13df41fd68c82d08d8db32a0c7a5a3bf024a4ffde6b6c2ae3303c250f0ba8e8d132663168a07ff563c730fec9dba76aa58304b396e3b3cdeb8b8f2871f0a65ff972ea2390259bc3fb0093af7dfde30b275bc2b654937f964226834d6d3f64377fb411a602afc92a8948d99c540afdf5448e046b7e894182f196b8d74e4a67d1c8d7cdd6794452368939225cb844f34b1c96740c375672b599913910b68ff4d38095b2a098a7a38d3ef0ebfd9566bde242d49b6ad395c8e08feaaead484243bca47e09d306493af363ecace52c87aebd4e71c27ad6f649902b62944f0f3844464f69bc7f213232b8df800a167e2307cdc28c75b3437681820dcd1f3e35fcfc62bcd43a0933c7925c02d58b9e915f31cb5051e1092b09aef0dba6f55c6e8f3f0e132653e34d4e25b94f5bf17008ff4fb7102b5e30e1d65eef8c23dd0d35c734d56239ab0f330fca46d0cd9b0574274a9a4f9de022c73de6be9d7311d2ab7d9b73809b30f485731f5e06b91577e82cf29ccd2b9ba5b92affe6af8b24763d90480029d0b8b42ee10e7afcc672713b670e1970289c406cc898e72df6847e4d002f9c61d27437f9b803924709b2762caa0c15e92606cc4db409fb035d79d43ecde0741cfcde4cfd4210a99d74450f9c7571355d79093c0b84b962465c08ff4c85ca77e4afc3951c27e8a2ee9022feb21e08263f8819dc8355cf3f00a2532862beb9b754448869fb5a740ff0bb3403bb50662fe25bd847e01b88d95ae4f8445dd5493ac4ce7cd8233dc232780f18fb3bce55c0b33c680d2d6531239f9116367e392537b615832925365ab7e926679e3949074f30a0c3e9e043343a21288353d5c9f55f3da3fc8e586fbb89ef34bf531aaab51b07cbd68c194a08eb7e615378a6c26440d5115a8d1d0788da98098c9d86e43932a80eeea9febda3a3788d91f80704048cce517c479f84fdee31e5b30c6dcf2ab9d50b6b104d320f04a6e7e32eeb33601c0b92a134b08f708af1a5535e1668654508df07dffffdef4ea8e1ff7ca8e68a85bc6bac13cf9457c3866d3f2df604526d7c90fb25bc1a334e84e64757cec59948cbaab3b816c620f9081ac6739cae05f837b17d307786368ead87c89af158f50d621ba4b87c90dae71f21d2ca91871b6e71c93fdf6ad3c415d8f7d3b69f3cf5a8e5b8747433f0b159706b160da1fa1004d2d79ead9b3eb8a4374d9f8ece90cbf222c1937665be70d72b2e2a137f460cf602eb3b04b0b669d36ddb07e0f39d581cc23a16220a3f0c2bb0767612d841a8cf222dca40e4296c72d393ca925629f313b396d67fdad97829180c5cdcc75f783028e40f022576d02ae184c345fb5265c79dd7b06b8b2a4c386d08fa184c55c96f592f2f01d242bcca3df230122c5e3cd9f5ad3b97a2611c135fc6f731179f2f2c30f2976444071f4b5b3124a28dc218ac362f3b732dd780f20cf01823a48e3484c439947b5bfc51d61930bf1c237249f864d9f6a80cabd90f92a41ed0c6e84a7d49200a8cc2a0f9e40d9e45e49a0ce35e6605d976e052838baf8937c68914ddd3b782391de4b7387429e913063c2da24837e98f59ef2652cebe31708ef2c5873dff08de2a4a2b4829fb102d67a26fc792608e99007b00a7fdf8f07bbd42878c8cc18a500bbccc4fd26c2ec08066799125244aa2d93ba480e4f06730c57d6155ab9ed7d783426da4e57637f04d39efcac620cb32156c54397d6328d0710c68d3d99318a72c838651ab319c99c4563cb5370e52d3daab8f35de7f06d3d8e86e73ccbd0e566188546a567dc54f39bbcc79c21e4d115959f3d718a61d5ce6cce7477cdd460cc2c7ff396f378ce40cec09e73f863ddaac60ee0ad9ced22ed9a39b6ab113ce37f82dc0bd3bdd3db13ea76b7039bf1b980307295b49db415499b278ed718d750206c1101df2d05f6030b8af9ab4b71f66a2a92c8d75d19213eedc0af0b1808b20230f3a7c0c030aff33f65f3348b0a4358938a8c3691ce644b1959d2ecdd5b9eb48171a839e7dc6c71efa7af2183f1c8f8f24f356ebf40817dd9e979d6a4650c5276eeffa9603bef3038f96c4509b9e3c377652683910ec8a7da7d59a955c7fa90a16dd8665e6cfb3add3634d2c4cda8569163ad613419c5ca7fe8634f3341bd8a34ceb34019139d978effcb910fe15be7b431fb2d6b49aadc72b53352b14c26e1136ac9d9e58d0ea0f5b62ff7d694292425b684ac4013937b1b7c2496f2052d18b11027b246ac7be647f3d2962d2aeca8dd8e1f06717afdebc799e6608f74fad6c69fd474edfd3e523c7e1bb476d7d27a6035c29c787408343ef8b257f58ce53d4399cb5a7e8d1d69662a15cc32f7eff6d32c3e6763ba632524aa47c01a8d9ace53ec6138178c6efa8cbadd8ebf7530877368e71edab624821b88a621375258d71642d6f45a555cf71493891cb7bba48f193139a8f31150b50a33c6e9685d30d5f73702fb3fbcd534d9d31e23815c12082ab400729fc684e32eaba9bfc88bb5f007eebaef499a3699be1f2f4db4db8e9a25778f38d18eb16eb18f501f9641992c1de0cc5185d07fcabc99fce2f402a789429ea27a5701c38e88e51a44b6e1b63e1b1ba901ae9aad7124dd958262e326105b7c88687c54721574865621ee784903b29ae6f4b34317dcf5ce165082c4b15814ba4c9746c1e76206971cf00933af29def0445540d8416bdb358461f509d059fec4f920f22cdb087dbe7687fd2ac89b746f030e8b14af16b116e19f7e1a12022484f636bd35e38f181aebdc5f2f19f3e09522bb60bf140da1847d4a32c8bf07e8de537a6869b57621d716db21ca7f3bc295000818fd6660aace31bcf07ffd6dd8f10fa1476e0a077b5d471812dc9396ddc334b9b7f2026511c85d2e28cdee17d13167ec2b364ad711e2936050c69055a2372f59d0c20a6b7a46a8d85fb7ad09303aa414dd1fa9f4f927e781c22ce72944a16e247c7307ec2656f266e0daade443c7b578d7dd23a9935ff6888531bdd7bf6981b8168638aec6b5426adab405cd34bb15f83f429d27d0804bcca8a0d6e6b32bac1b12b9aca8228fd43c93f8009c97b05f89d20a650977dd080c2fad06786141784850e8e96613544295c34bfd24e9be7ef8b6fbc494bec00ae6ff927a689ea9f3ee1cd299921025fd914e6794f5ce95720dfed0bf18a923bd101ae161f1fa2996fa3f529ce71e6eeadccff7ed90631a6286e71a208ea9414c79e1b93e53edaebc4414a79b59d4d07db38b98ec1f15f0449be7be0b635bdd72451a50077b45898e629be5b48eddd6e3a4409711cd9c6ab385700a4b05759639b1feda5e3ba1e3a389a4b80f8715c2895d9cb6ab64db5e630925fe146c09dfd71a3ecbae582dc98c8aeac419a110c9127814aa5d786f5a34d7ca83dd64074ca6cefeeabb3dc8138adf56cfce71b8c3cc17f27fe4efe38f0467838a60dcd5b0855f166c876dc330504b6285640280c8bab0eb1bc86af66edfc76cdbea228971f673ef15ed8d5f014bed2d5729d5daa3609dd0ed5b3a7f49139e111a0e0a039fe615ebc2887b2fc8604d19e09b11861b54ef29b0c4e809e07b4121cc139c661d03a0bc0b63bd96c8d2777e5466ca634af868d0b4bbbff27c651bf41c7c5226ece857993c9c6f8b6dec0e2b0ed92e9fefdfd25247b941eb1d289e664aaff4ac9970b38e2832186b6848d10fca4c28084da1db37965384e23cab788e990e294e89a8e43c4808f12b4c50fe5d705d77ed500b359b5f8b9b909c117390f16331682430fa302848e3d60a11a05dc7530c79a1142c8a707f48c998bcb4ac527f85dc2ba8819780814bc2eb927d9a82ef53e96e20d87e4fa096ce33b0d2241d497dae514e4c97955b9ae1563e7d8a3a155a4907931213d720ab34147ee97aa963d2a4ed921d54b9c03ede7a09389ebd636d5ee8b106b273f55ced4f2fa2da5caa38b9d0b9d86d27d769dd896909000af5ad4988b180afc04db847adc661f71bd4bfd806aa71c2e1b43450ca1abc90fc6df891f90a5e5323a1a257600df6a8b5164f5d694c8b6213940e0175073c18d7e9e5c6ee57c7e81d6a3c916c8fa38fa6c197ff5e112b93aea8944b17c390c67987f72f2dd04dd0630ab26a781592563e82cd6600fc923ee53ecd8303c7ec5d410aceff4255d37e0a544ca29266c2e1498edd61150b0ec3273ac0c93223b20e2c8f4513514db5fe2c3678ea8f865c16056ec073d34ed977c8ed90065f8f09ca88dfef839eba7f03eac7681a697dbe59fbf370ae9a25066c978a9f0275927cb7a5e9bb6839be0c900128c9d01e0df55a16296014803dce243316c95a932e5ac2191c625ad48951306ee22d8be74329ac5c0b7c7c5a99b6625eb468b65f383c3277fff8e3c9d8f4e3afb6797bdc211e87220e1c4739b5c897eb2e4b123f5939ef9bfbe47380d3f6008e7d9dbd5ed7060186bc36f8b202f766b1fc3badf2fef25e147d85f2f4d638a51d36cb65c424b9c2702e47f84d01eab3ef4996b776fb3681d8ce603301efa0dbb194d3e2cd4b73575c338e97ca247e56ff2888785c438a5d24cd3c578452ad8fa0bc1ee1b1fddaaab8476d0d31b0d5d230af5172a7da3c25eadf124a4cc53959bbaf80060ad72d681bbc2635384bcae92e44bf2f61947e541345f758fca14ecffe264192fa1f5ec1911c54a9787dfc2ff298672092ed0b5e1f1162a313f7ae6dd13c2dccda88235460c92ca62037b04752d2484a94122279df4f1279cdb605df8da4e4ae3938f10a0fbd6fbc259720b180725982d411ba06d3dda274af9ef4a45373a35ea4d6f4e5bf8075dafbde6213180a8ddd8422db127dba3d372a64c81d59e687361311856d2c7641004ba7b52e1cf6023fb19d331763cc2a9373256af049e1f7806a3beca399d517a6440cb3d46ca8b623d1124bd36b648c8785981ef02e9cff0fc0dad52feeda2d98ce9e101332218e30f6b977e62e0b36a5da2113d0d2b7b0cc7a62edd09775985a163dc23367d139154333587029f742ec7fa8d3d1a92529012d65800d1191ce7d0e573d57b49214700b8df4f308219e34459be90160186d09efa604af4d92a95cfaadc0ef88b23d2466e83f3ac2bbe9cc00a28520151de2c51fb384bd8f854589b0438799ec816eb1b18702c60843fcda4ea74631e88cb6abdda0b8d866c4f9a8038aadcf07c3ca6eb21a41e19e55e8ea072c6a2f8e93c4a8349e62267615f688b531c1bebb6664ef7c144042be08a7bc50c412ebaa618862babf09fe78d7c4b20c089208cbe8cac8d841bb7dcb61df78d21bc959c60748bcbb647641838c511b5e19e84dc66098f23eb581a62b45b6929fb20055ed9ed55687d843bda00862b5847d41e2345e4c054ff775be50d07024ec6e5397f0deb0f2efd553e28ee6b48294a7545ca1808628bb9221d83128a9c55d2cbbdda50039791b5053b762efb77c9c1acdfc81cf9960de91728207739e2ac42af65615702346ab65b6ca3fa6fc43691f0eae4b82ac4ad271174900263eb711c861d63126bf3d7c961ad3f34433cb6eb7c7a3a5ef01069445fa54914a4372c02733a9a80b54577eb4a90bd67d35de1a79c1b6e60c5dec28e178de06a279a4dbeba8876fa0ad97759d58356a00d83bc4b27433c88e5366c4230ae4ab5d4805d3c3ee54f462609105c7de19919e023ff9dab792148a2c627feb6cf369be7dc835dade414c4557b967bfd7abc4adeb4529947ba08115169df379c9a75fa29fcf2b2df816e6792b3","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
