<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ca0bb478cebdd9a921910fd118f7cdafc4208dd30e5bde79b34d71871ee6fdf1713d7eb453b72bf7edcd2214f2eb212fdc761638dda53376bde840dcef846774641efed08244244697db58f1595fe98386acd809f097e76b4dfe412a0ac267a568680b6db639d76ded9692ab6c185f1e248923060c8ecaa326fdc947a96dd14fd963640115c831dfaaba480873dcf1509bd2c80451d61b0ed972675749ac36d69fa711d0a0511e4fcb380b1a809840ffe4ab5ab901f3cff33730c0b16a3147fc199dcc5ff6ab223d9314f9e48317e86a5d5c74d4014ba7252511cd6ad772c2566a05d66d2c5263ddca68cd6da870aa6e717a5702cb76095a96294cf024ae68336e3062a0e69317583031b2d11dd8ad944ae7b81b2eb05dd98a0abcecc74df391d87744c33ac547df8098b0623caa22ab815f4f8854666b8b9335472992e54903a24531dbbd5e7cac085a225e5adc8c43c37909fb6b5d53ed0ba22e9eef18ff35fcabc34b3f066cb3f4152c70d72d006fa09432464fdb85d18b21f7cc81dc91d1b820d0c9156b1c73453c95bfb52f1728f7d4a784a7d9307f580fedb408a2303ad62570a894000342607b53a4fd40574dfd9e6defe6783cd169757bb3633b49af0d5e20308e0acd4f411cfad995c71d8fc17b3561fa5f4437d1613187fbc86ab924e3db93eb841a69f253621fa823929eef79b10a3fb8c208f047d640d24e8782279656cee7715a1bd91d8e1672f40578d6d4dc85c6a894bad7b811b8b18676d4d97aeaee111011e06d46ca0f7683d52310483bb76bcc7b03241ca3ef91f274fd082fb47fc84a67903241178a666dbcb418a4094807b200a03e3fe1ab8a1f54f6a54268328cb2fcadbde295ec8e91e4c5f2d963b5c99e58500a898140ac575e5f90a67e0f272bd39736f22fcecb450b0bc54736d31cd31526cbbb372e01c14b4331abbc3edc3a21441beb804301d89b3ba4303002f8eb10c05c530b693d38dd460db37f2ee2f25d6cf57d3e8a7071e66d1251c44994b75f836cdd15ddb186da724640b72f45cd9299e4a98881654470cc162a94a6558f63c76f0491bee9bd60e821183f53101f6151f1022531b14d617bc3db1ad0d622b25aace35eb59acf3347a260484050b84ad454ff2684940d97bcdbaf8e61a01e9cf9f2ea1607f77568ac8a1e5cbbc03867a95cf94d80a2f986cfc68de1e8ef24f8a82258a52b955fcdb9fa0fff0dbba0b2df0084477ed145f6f1cc5231d45f8b00362090be5357e95d6f486ab5f07da638322840eb23e78d030283b3e4498245fa35b09ce33d541d2e7ac589be0b52575ac8e5a6aa5801ca5630273d840375cdbefda520fdefced7cab361b1b10aaaa92f0ac80795389d95f305fbc05b2c32104f6c78cf1f62624ff9bd2249ca44d6df4de053976e9fcd1a3550ee526caeaa292d3cd6ecd213a852811503650187942d9151fa4071637cd4861b0d42246fccb7f5e66e924a90f828d84fbf1da5f241031333bff23f47820ec30978535b374201963d448450f8ea50719aaca03aeb7ed8b21634966d8575393464f109cea50de5f09116bb139d0787ade92de3f00c8d98f72ad8b90d56f604fda96895d44599b50af819f0cf3dc7734e984c48bb2e873814fd2db26e03f9fc0946a847b13cbe2fb0fa1edca1cee7c81bf9b08ecf07cffba3d84717206ef0dbeba418ebe2df0ed9c54378cd1e6bacce9eac96ccd45833342426d2fcea0074f8d808ba292f4b8fdfefd6a1c0651ce2e447d4cab90790d96f704ca15d06a5160389a1d1ded52dde1ad4bf858f5e166a8c9f59a72b2a91b07815393c210b520de5806feb830a5f31146e8c102ec0a28ce057d6b443b3ee41d2436ad1f51613bb5bb5c5b8b19ad681c4df882113f28e6e3904398173ca0083397a6e82508653c4967ee29106f70f514c0192afed30d65d022d7b6af358fbd1367c90dfacc3e07cd56468fd9a29b769941a1c4e2b4775614d45335ef0045a88f5d0299f51e234ecd0c00803436b0a7b150b8f8390c172b0587ea9f9deaba83015ea4e0ad5f2792738798cebacb7d5a09130ce8000c447a754c075c9a3b7cab9510a697ef126e37d4feb592c66d751030476eea1e2161ec4e40b1afe47ca4ed398232d196603bf8745f38ad4cec6ebd0cffffa36d46c3f1772c717ae4dceb35f35d731183ff0d5b7e6812f03c54b6c0984ea0f6ca227929d18503495c5f0b5329f9b622ebdc893b67207ff1b4ceb6fca8d974d75d2015485ffb50e3724db696772b3feaf92bde643909135e8ae9722737d90f340bb485e88881d2d05acf0a4bde7811adb092c84aa5f4ffdc00f6aa33e87adf2d0eb24af3fa4f731f20f9bdac9a8e43cd47af5b878fe58b64590fb48137b5653f1ef1752c7ec2e55a1e284323b2bda55edd768077fe54787d226180be532e6c506c9d107f33520c591b7d35c6f83e2a99b439709596516db5533e0501f87609651187483082d7391abb9b32a162aa0c25efd94750e21c46baabe179769bf0ed584ba018a49c646ef230fe8d1e73a83d04fb99c3b8c59467c619d7765cb973da6b642840f7105ddb906c27d4598c5f2420abd9c6c5bb8df13a13f9b475d6cd84a165d0ad3cd07343557ac01fa0c10ae3f2ed4cb61ffb22236fb7e5be4f81aee9bc4f743c7abde2501e09e626f14fa803695d0615a9ffe66bb8091a61013aad023736b9cb50d720c6fb2f824a0f7a8b4861c20a2d5c3bb0b7707cdfc74edec7996158f9726a93a030ccc12a9582c12dfe80fbc32bd344fa1adac91854b1378e2d3fc48244a603ca880f20d9604dd5d776dfaeec4782e0fa0e6617246d3d0c3e1e63c1475ec86dc43d86538f9338ff25ead1bd3319b4ab0fd479e54c35b49e81488f1e57654af468400b4c52b7580c77ec05ddb64c3d34ba7804b289ea60ba566f4dd4cc07214fd1703e78adac452f7b687186d61735afd0be5fa66913dc1b0332282a18d07104050741b6b420fcf92727fcddab7650089ca9c86492993a41417c59fa41d34b5b653bf934aa9d4becac741d8db59da4aa4376f95d7ce6ab84cff90509ff3fc49cd8ae23be6eaf9ebf20d620b55de233f1ffd73bfa28839f608e917a6b119519537ae700d752111e59b522c7ea088a554b1f4b935dafda9332b3a3597cbd4fc53af8f24ae36c83c887affcad4052421bb88644c4edcc0239cac892a8d0f0ac2121d876303fa498beb24a1b3657d4a427b79e41b18370668b3d79ebe6b5917301989928c3b235dd8240bbd975fbd5def04b54dc7bc3907549e6fe908ec1cfbfbe554226039da32c976f069eda5ecb0be833644c0a5fc3eee2a26e1a33f103aed3c9f5973788bcabcbb8509140f544777e455256791d1508ce2d9b91e557c3b055d0f54f02617da9c9b28b020acb2e1144b4e0987dcd3499703623e67669f9b89533a9cc06b022ca4ba079c8e46db39c752da3f2d538185a0345c8b388fe4bd192dbce5df2787fc4e4bdbb5ef2f304c0686c7dd757a1b096c451f52b91fe44faf21060803e2d163fa60b4aa45e505098412621d2601d138de4c81f8d628ddf4ba18779e65955528dcbf5be56822d95ff28fd867b72b6ed3874364759ebee7e1ecc95041f7e263d60828133ef6949bb106408bf3371d3f86758904f7b3d7593cf40afc7f50746796f7cd4a9fcbb7c2b6cb7165d0f02cd31bd9a4e6971c62d4765f22e3706a1d2bb73c125bdac72262f5df38e7526a400c50c982e8e8f7dbefa6042f7502842e9b4d60e58974c475bdb1ed08f78b5c97510107fbb1cea961bd3e8c1ee33f1279e6fcb406aaea9f0beb2840f324610a7764e1ae78ce976867813d9e24cf0f23a4ed2ffb02d7ef6b306b8c1177de4d001c60292b072bef971611c2b75eeec3fbe0ec8494dec276a4318fce8b998724f26e5aa316a44a63a8a8d4e2737f7090bc20b292e86244cc3656bd64d5f70548e678706bc86f030d8a48d578b637f14c7703e80705e7de7e78fd6e9265d7e899b9b4e058c3c96cad45dae556a6de7f68cc0cf0f924b44220289e593a88fff2a032406d40a0dd5af70e362806057f03191ceddb6645b9c69863c002720de758a6be8f769d52e214f1c09294d038e6e70c74dd9cfc2cb4c8528b546cfd4e03c9bde090629c759558e66bcc182cfc7b58f56eed719eeeee22276d33ec605602ef7ce64c2995087d8440a310dc83ba5e6fe9ccf5881af95e18552155ecd8b22728c452256a53afb1ed7ed55aa590a4a8c100eff3160b3c11ea37fb89fca49209a00819ce4428d8a029c3afa9e112ad1b79ce1d81d33ebc730f8dca598f51181f7f93e02e0eae7ca4db98c2fe5843d6c938df402cf36f8d83bf0c4cb7ff74fad65ff43fcfc1edb3936521d8cd052201ff05630bf874387e4b1cf92433c91ab9d1fe4404bb87af141da1abd65f48bbba96c28118cf4a53e03e4c71f1681d61b2a9f354d221385e809314c7bad9c3cce3f1175b94636289a5b432af86d8002240c21966c97c946bcd61550d1cad6eb691f7959fd9e81ceb14fb338187fe670563d0b67e1e67dd7b07925871acdee61740c23d930d9bad6f64e921b140e6dd6d5f17610a182c01f71b69cd5b6604a1ba4e08ae4dee60fc5b5095b171c4e3b96fc00ef5a69eec02fa13b02e2b15d9e94e83d48bcde86d10645097490e760ba29cfbba3f498a96cbcad01fe88850e2f9bef03425753fd3d854a89cb4bd224f0f67ecce1637e035dd65538d8b60b838927c2d1781da6ad466bda4ba3a70eb527101876dcb95d7d4934ddac8a25bd0874ecad8161dd4b0538eb311b43f21c65fdddf3dbfbc665e539dff793dd3547897f2183498868dea65ff61f7375d3636797d591007aa50f7dcf063431772847dd06ba2d6ee398e5269d00fab4481b18dd70d5f62c27615eb0d9270dc16c01f80baab3936d680a2a89cba37179aa4b33c5490f102706bfccc83407f3178f72b5961ecc1213def954b110e6d73d037701805daa759e0a760398af2ee72a89a9adb262220e7ade344a36a4289656b5e7daef0c8e5c827b66ff6a1930bc26ddc32cb24ea2c771115dea0cc3feec4905bdde88ca392c1315198c11ba706dbb3cd4e7e6e5514e22cbe00a61b803c485aa8c24484d09719774313b07d4cd75ad2e39eddb442e9eab3a9e4d3d984221de6badeca535375cd6f47446daa13c8490bf6f62a0e42aa3899a6ed0c64591abbe543762c4c2f5234d751ef8abd129202239c5dc1ca577e6d51265cd2fcf52fbaa54db0c486988349f70f612671ded1308b9bf4afd17cabfd2da7015bd190910ceb6219843d9f618468fcba3aac52045ca3e7676756eb4f7fb5826d89778caa951611ed96735d09815beaa6fae79168a1406e9fea77d4b96d402146fffe0db16838ec7a3b9671f3ee2ee3d2d2bfcbfa0b5a481e345b8de3e5908055c2b15debdca950eeb7426c2a7814dfd2c78f74fcaca567f024e806b45ec1595efbc870cf9f564d6ffd88b8b7fb49b515144415d2c690091ca8c28ae5c56f9878feefa20d70ad610ad8f7ca309f0ab8170be9d1b8579fc9a4ec99d52fe7e7e9ead3855a1bff1b7bb1c6e1845406ef3afaf2b663f2746f0ab4043494b77a572196004b414d8df3930650d7737c8816b09e8870c913436a6cf94aad1fb9fd79225f0b2caeba69168bcc0fd741ad1eb80b735e55c803fe71480ba971cf8398a32ef0f70cb25076cdc98e3686b6e1beae96d8bb0e113f17138e1640c816a3dda8a98bb325012145e1e4ac541957d6d30e654770cec9b84823a9de3dae1f7dc44a3ab7a96a5c0a05066da6091f0ede8ed811b9e9510fb32e178497c9e21f95439c08e0e054b1a04b0a8d94c394413b16cfd846065ca4e437bf7b5db34119cf6d7be7ff885aced963355039f2b4496f2885a685f62e1791637cdb588722ae9a9c6e0b26937e20c5d733e34fad41540ec8e1e5101ba9353db4c90b510c5c82c9a4ce075b084019eca7574f1dbfb38870c94b02b82591e15ddbb5df50f8ef7a549b81fafa6797f5b6b09d801c848e5c9e8793a008a8b1f8959288c8927c7bf6748aa2ae222f29aea7e477190daa8a8abdfe0e1bfdbf6b493e097bd80990f7caa986a34b92f82ba96538dd018abc058a5a6a1dc3115067f089d598d1767a709558f78a25f48ffa4993c97a161f1c6e6b5be41473181f909e718ba02f3cb85bbf7a12449e04021851e9df6ab59de9cb40272f83e1438881af8ab6b8defa9a5a043e9fe061811c45d85d881c78a55c3e31701ea7585eb240005d395226d64528b276706eadf7561c850749e515ad417c976e507da71dbf73d4f6d805a735030d3f287416bf8841001666a17f690e9e1ce43ef40128a319bd330f7d3fb1ef7060e9fba66a4d5d4aa5913998fd0d76648188d53bae3af78132d9a7c09b0e9943f0668187c52016f8e4046ef0a1a62191ceff910a56449553594671f75cbf88d016c9ed1bdd616b99fb742ab9a33b5a579e3a98a19454effc7436f06ace90c60e7313c11140166a9d045c7f4bbb4d941515da7b677736771e08d2a223ec86df67d434f5de2414e4a49114d8e22148689500a3ff3fd61eb32fd864f419db3f34b714493a4e1338a6086a0bc98d134a66038a7a37092bd1924808e69985c5c236940ab3453f3b5fafa030b41ccd8a8d1afb6afb922f3151812d16f42b6e8f3a6f4caa5099dc811c6f11f400004f6dd182c33f35aaa895685da44cdf8724ed1983ea0f4ecf91e893d33e69bb56c947452596ee55cfb1557240033be56e0ea3a78ee1cbbed488dd7d7f95d0fe771a41f5c3e66bc5d9b7ba681cb719d8b3e1fadb03808accca6cef9d640781d832f09f02a02302ecef812a94206b097d0145838fca7be7d295db9da2e9d98664efdd0b0a5280b4ed82e4ebcb6f21a90bbbf9c3a4caf513aab6e6dec7d56540b95e1fc038341041a295ad6cd379ed8386802e4c268a8be30b99f92a9e3bc8aeb61817b38fda3cf8a1e362380115e6eda5ac0ae2b5991ce7961f74770de10ad5b575057fb87f585cfd06a8802ff48369efee348445de08e62d6ab2cd2e77273a68a0d0a9f663e9355c09dc19a86cbd354cfc9b107bd57177811ff713d521a910d076145fbfb46e57846c02d3548b693b3e2791693caf2be13412145ba4a3532507ffe95dbb42457dac8bd28e2ad03765e90b57f15ed4ee8d3817743d2a9861ac991065c19ceb7a8b1b35919018a333d5fc685010c369fdfeddd804d703a177e3c12dde2290e5495bb8c361a38a1a961649f78fc43f623bcb95c00f15d5f51c89027cbae3c988cb22b560a0e47135c2d7fb16795a8ff9d68308ef3a30bc8f2162f2cf1d0f404105c54a39af1e40275df80b8ad48a3e96fc9247b0dd5627eae6478b56e684587447a039abdcdf8122a802ec82a8872ab58ee5cc2fd8e695efa5f7b3359e586cf456e28fb50814c74da2cbae3854501f229d1c137aebdac82ce1c631275e0cf22edad019587d50f24ac355dff055ccf29aea3db0288eaa2bed472b715800a389460d2786b2b0a3e593a3ed2b17b7cae3cd9ac08e739b96798c0b4f37ce00f05391e3f7fc81406aa1fba65d5f2b9c1ff4c905dc9223647e0e735d9ee55a3a089993b7a4d8c5c05382786d4e6313e396882fb0a22fd64bbb7c44c4e519775d9e03b92445fbb8a88fabe0853412e0c89a5fb3b54cd9fcd2c3643101531916f16547e3871f18f977edff0fa584dba8eb001a660d1566d00b10b0d4c42506546b2ed5a4f657282dcf29621d9fcf3480486f84132fe1aa7160702cf4ff4c112730ae3bd163526ea2529773e9c910e800dd9f7b4dd02e43e9c18567c19f87b04e72169e4ff52650defb528cdb0460b2238234cb600965c687ad5fe2a4a7991367c2e2ebd5ee1cedc5ffd1c78c2bed6059fb68d512670d6e9278f863fb0e676d740932beb1d4fc3d194e5f1139232fcd239b44ef6672adca66306bd20f95a4f96f6e88aac97345c61c2937c85b6ce846e634f8e7890d054c09affdbe4ec7e7e2825296e662ce635d600cf100512717b40d98bd00b40ed3955a78802a1a9c4da80904e4498e706a90310473c0bc414c3a6c7e21d6c99faa882621f0216cdccec3b1636b275748b5cd4602f2abd0b6dc9c19e48b0edf0322359dc1531ce8f871f7ccdb92ebdfaf6103569b3b3917418a8dcfa407342bd3d324aef3503fbdddbabe2e0b2df10b58db18852eee1eba3b46eb7c374561b88016eb5927146482e215e967bb0f2c75a2ab5d9deb9a6c4629a2e7b01ac3fecf57d8547e6d1ea34a96b64d109f72c100efd64dddc23537d39ab451821472c3583713c7d475f1c6df3b8aff186f7285543cad07eae9c40bbb76570d075f4e5464560b4fd87fb6ed2fcd3373c707da6e9d66c335e38bd42fc9e3f2e408f65855bdd7e7ced1a1940af58556868e9e88609f395c4a30efe0291e6771599cca2c5cfa373bb0e1c65ce6c7d7155104a55442104486b72d046d66faf657abae8f7fe7b180058a24f034cf5e34a442023a1ce18124025fd1e44b79a4ed4913ee9638e2a0ec27e0dfc50dfe1b675f236df902300863fd2a0d2e07d41188c540b56834d6be767f7446e6c256c6bbe772470288c128addeaf5676c67975aeb7b8036fef423bb0be9d04f1f9e964709914edfece61686ae485262e0f219a2e161f8403a81014c171b5f70701e8aa3cfd2cca7ac43061d27846e9241e6b9a63a37ea8862eed84aaf70e5d8fe4a10dedf48f96852c98c580d4fd40c2ecc78fa305b372d52a778ccdb3fb46d7afad0985f61886df723c777912671f8545346640fc27e900b9076e09569f9a9b7da0efa57a4b9554dfeba2d7dedf7ea26ecd514c47bd95990ba70b6915b463c3d8a0c6eb046b6ec12d8801a0ff360f8368f6e43a8c26bef10a73b1a35b7dbe950ccd2fe80de48e84d72ef63d4f8bae831da4b4feb03335c4f871602f3f1a64e57e98d1d0433e8f1886351f638110a8286e9e555061fd5f77658260388fcfa046c21c55b1a43bd2e7142d51b4cab897e668ae77e5040834a5268f6860e23a6722e6540c43069f13ab9c399b70fe34b63cac30676ea492858523f9257a3c9349b26f2c509c5b98d468c5d50482be38cdb63e555c5192ea96ecc7eed50c6dbe59490106400b3ad6101f8a96afc6dd39017d8765633c062d7b5d9715544915b284fbc88ccbf510bd1ef3422e528f2d46792664ece224684cc21f6a8ba3b02f168a82b2ccf38fb34a29184f9fdcad83f31799ba62c52c0f9c3aba7b678fc9dddb61576f0c28f0d4abeed925bfc5e43d627721c6b01d6c9c6ded8d88ebfaa75ea9555735628db22ed594c7823304a3a42b7c186c5fd5cbe17d7e69b05a15142518cb9f29663dd0c6d6f0eb622022a8fde4d77f833533a69c09a3b56a1a3a8b77ac6a1cff97187a1e97dd1b65a41505833b474e7bf36b19bcc6a7574345f28fc003860a46dff6f314cf8deff6299165b3428605d13b0882c7ebe5b250ac1ed5c9b4cf3b22e82afbb761cee60d3d95a02da7a9c815d17cdb17548eac7bca6d3af3f6bebeae6d41075656363073acbdb05a6c4124fddf9a51c52c2fdbfa403fb6173fd05fa39c40180e02469121811c24917e85d680b00727b0cd797719120eb7bd02f8a0d07f0f5713173215e1ea83755de224fdd40893489e85842f66834c269106e07e97c1b181207eecfbc24b687a8ed6be18dd9b37911b9c6ac3011ecffeee679bef5932c21f92c3e6c03a450f9f9da847a120b22c0bf896cd2633d051f53c0403419ab1cf61ae6467a4827c7d312b73d26875e5f849d8d4252712cc0a3f3e5cd2e9d46e797a9ba9974c36c28ed50272a191cfb23ec98129cc7b310cfde8ce12abedddd5d3512f9c26ca61d16226bc32ea06864df755381e7d68262d9379b4f80217a83dc888ede4885807ecb13cb154877a2b576d50a3823927412a34cc0092ccba749e01f608bd26c298bb2739d4b11964052fdcb19c87249f5fb30c3bd41480cf688b89d873412e2945062944a47c92c3d1fc69c0e5c9e08caa445f90d7959964a82584dac1cdacefb233512647f3f60145a9e6aa64d6d5ca81ce55cce75b21383e7c9a1eac3164fca850e0a0c2f886f38bb3643d51c85ae4fd669f2976a17dbd64b1cce0f5d68cef26f416d137228194993c0e248df79253bad81e44e939f60c7da676c0a9b30e380de0cbd4fbcd9c311e67e9b549fa3ae2bd7bff96da6e88d8713570bef14b4ad2f6e17d5fadc051e5bfd5efee4187873ad11da43505abe40524633438d3b69f1f5008c79c0bdcc6fe6728ec94de9356fe8221164f654a6ca02d9ccddc901a46e479f3ededa37fe5b446f4b963f54bc290fe899101813976414f5409efd99208196ce6e55cf947c5c92899fb9a05ef1b9ba6a09dc070d875e65b206352adc9039c2e78ec0b5f3122db2992bddf2d20e216b61210af577e517ed3dc8b6a7842a236c60aa448b9ed6c20d550971861739c3f07c80b5071d8eaa0786ad0eed2a924ceaf5ab8b7f780c4a942139a1cd694a38d4242292fc4fc6cdfea7655db64beb58f93a6529047bd7a815290886fbb75678a16a580d61dbc4bd1817ed2c34e4c064706fdbef944a46bb1da7198c0b85d52e93377ae8879521d555581aee329d7ac0203dc15d001d1fb4d204c30c291ffe44a30942f55b123de8e2a62c66fede53912f93cc392d6fd14b054eb5d2daa4aa291efa2cbe423d204d5ab3645df86f6e6d1e24620f26aee5fbf9489d69fcfbed893632a4840361449d2fc094ea3d283b53e2019b6859c4c39497c80b9f9371b7977ac715ba5507ad9eec1b31277ac9fb6bbc454fa0753659c3ed5acb9f90e5e66746f16c36e3bf3202acb22e65eb646175c72cc513e6bb07e7d9dff96d4c92cf618dbbb21ed74c26f77fab50f648c7d49dd60e51b56aeb55e37d1a696046f473336ff95ad8ee87c168ee00d1f5ae351e0c883dcd4022437fc9301758d81b1600c7483fa6e82997c10bf794f7059ee70694678f73a3444a276e036db57d88fd444b6eaa6cbaef8a1a946db58bee416a117e8244efb77db55a909d377721c71eb4cf2d204120c2d4c52a86c646c1f3d61e0dd917440f517ed1c2f15ab8c839b39bda11650d1b5f0f15bae43d27841837052316623da79c3d06ac3295dad9fd7d01b52675bded8d1a9455392e88a6c3a05ff14f5a947bc4e80464639e0ee073e91c89c99b799b824a140e3931e864edda75b08f42ddcf7657788660f12665ff446f69fa36ef3c92b4acb26969a55346bd4dcba17912f17986edfab4907f1e275c04c9a49b8e344f1b6c2e3c9b7b4a43a753b47372d674f131e557a34f24b5c3e4d91916c3b264b39889a324603ee742324155814c7f63d9bfc65f0e4ccff2278a4673a1289c4749dee1bc1ef8957e79aa6d8d1708ced841a276e8127695f386c57ba9dda77565fcefaeedc71c72fb7610813f20009492cf33e8d11dc91107ff89ed6019162f24d50883cb865eba9f39aeaa5f1ef1eee8b19138f9c249f58d328507b64fa9e3e1c5905cb09dd31b0b79913ea38c6e1168636f1ed21a131ebbdf23f7f7db3b22bb4458a4c57eb4bb3fcff7c1b92f83e686c2604f8e10b6cb8129e335dbb76f34990e6bda8ce9c41348b5a11b3cbd570e4e2c829f20b6df05a34ee99f148bdd4a8e7fcc065df083fd967da6b7bb0f1a9a727e41c5514dfdb0a1348b590b6c01cc8993b97e79dc942cbc21fee1e187eaa8aa717bcc37b125f512cb4399c1e13bd05473a060cbb59d187aecfa8d1bb3b5fe2d742973220c1a1ac365ac3a44e86dc7482cfb7ec1071b51bab372b6554861b59eb3fbfab7273c65a909b1c7f077a18c5702d4cfcf49acc469e34b0d5d92de6d1d20323711b5a9de99c97aca37f1c2227969d048d9397155689f0cf1c904e8973ba9f23833c17fe844b1906ff611371a2e5ccd0bd92f21643bc1b81cac15329233d91af59f823f8c346be73f73033f21132804f76ce1837093b23bffb4ecb9ac0d7c72617fd372d6e142b94d4c5e4a4da41ffa51aa079419b2c6957603f10778e91c66f5483c2e3106037db8464301bfcf0de8e907960ef87d65ebde34957d51a0947ed2ee05a9ea0c443f71198cf5461151a19d97f099dacdee238295a14ada2d5c27ea0e8157ec32b1a47dd7c0b717988391d41002dc51ff4183ccbc0b0e4bec8fb5ce4c290fd2653cdd298564dd47d7babd2f7ad84b4eae9e098a91cf2d1f607b07c9062b9b34e0ed4a3bdf48d06e2ad6f4612e20074646ace1b37f71057c713bfc0fcffac48745c17c4e8195220386ebd134f2f6b4254bb86738fc7f83d74f6a7faf45871dff71f52169b5c0d926e3da0bb66c9eaba8c17c4fcc262f91fd916761f02348dcfd24e312e4daeecbc1ca5039e6a5785e767a06259fc64fcf81aa92f144a0af18e609add43129bc3d91429d5ebcd469ef297d07e214b77bcc73f48c4a86a334f3b33912780847e684a769dd307a76ac067549f068de2ecaae60e65ffc0f1a7ca778dea372cd780d72528aabb65dc5fe9904e2b8f408e04190a1d4ecad6ae01809151ce1fad22106c4eff27f2d5f84dd555ef938f6376beafff2f1dfae8577bf42b4a479266a1135da9d7d5bcfe1f019b069bda76c3e89c08776f24ec4e590e3f0b560e46b3c77cae89e3501d744db8f01201e1a7904ca15792ec8d00726201da678824172abb3639dda74238e5ab5b694269135f85609c3a08c35bf7ad2cbc26dcbde50b9545bc99f25de414d177f5bfc4a1f99a11018ec996dea8b2b763a682c54980d2ab0e6c95a132be9e1c625c21e4769efcb3cf986403d0036a89f826e2bcc672aa61bab681e5e198a5fc667896430d83b7ac16a34da41424a10bc30526ff6e961c331cb49aa5f10aff84a4837c96b210ecb445523fe2cc5a13f885b34a7115e035813e18176fa9453e79cde0c136ea57db5c5d61af25fc38e25e0b55defe0edecf7868340a356f080508fddc37d81a178c840a81e04e539550de22d5c7c6e729eb7980dd1dd0fd90b45674bf409933dbf394d98ab32e83aa9a0570ad3c2848777619e8cd39079eb8483a1f791b653ec8b7076a699262dfa76a49e5507a1ed7f391f73d8b00344df7e857067f6fa1e0be76043757c2a1db12d4b572d76b302e9d0ce384d76baf435295bb3329cd4b84c3d3bc45146ed7489cbece0432d8173f20e7522ebb2b45b95a11394026f2ae2ea7823978cd42f07786ce6e9a5404fda17581431ce276a05165f290d1778629d2ec4694b214d884df32ae1a2a018e9fd56a5fccb80122a2eed9f2315b5de5fbb745d696ab0c40db44b2d7046741c7951ccf2b4d8604da97fbabbd15df7a78d5f509eda7db0edc96be6a987e157e5dfb787f860103bd98b87afa93c1c21ca84103923090891aa49bb7e6cbff2e4501779832eee5c30e1b83d945d8f3da92d33980feca732cc52f027a1958a78c03ef7f8cb7aade6c632f3568c99768377e7c8fe856a077d964c925a6f3e8566309e85bd93e754e6e77ca37965c2648c1091d51a930857f06ee7ce6abc0b8b20fdcfda9b2fc47e00daf7317ae80ab4d5d6d212a48f9ed5fedaba1fc15df695997ad3739f426202efd8cf41e5ae3ab7c6af1ff207607b7ddedef6a5c6fa2d33cb5bc7055148e46476721173606ce6c534c8b6fe27afab67c4f55fe5e11d9ff479c03b48ab9e48a07071aa2feaee2787297ead2beb9c981bf53253338490e3a31c4a16fefa903d27de44d654dc7265d94b622cd3e5c0b7b094a421cf311307d170a6a7d026b252961d8d7e4c184d8d682ad8e9933698a12d662e8ebc2d080d726094bda63847e735f8134bc7368f73beb86e124786c0532eb7c519c0da774b6338f79c964b25ae3cc6b5bc21697cd9ea57d954756f91702cf7abb74a448c7fc75da2ac292fd99fd03d418c6afd692874356005835986dbf4e7b2b1b41ff8eef14d9f8e44ab1859cdc12670fbb3656991ac9f26686ec0b8752fb2ebc2464e4565b74db8fc0cfd1f10f39009ebf2123bbeb3b5a7b085b8bdc55993c51f577f060730a1e0584b8e6fd24842f4b0c27ceed9d394d5034b9ede370bcae95416ef385e656e6d17dd4a589d3a2425ab2acef6a9171f3fb60d133252e4fafed2a109f03dbc50b7a87311bf1944f59bbbb7bacb77b7e77afc09f02856f2ade52620941177eec09da1a033ed50dc9795ce818a66b6ee4c2ccaa3013287c622ab7a4be4ba3c1156c7869f5827f414f8060dce31ed2c17be00902fde774a0982cd2319e1018c55a8530b44ab77fe7431cbc471c6842160427e6fefc650cfc9e1fad4cce07d5cba93635267b32264f1f5dd17fff239120ee441a2171aeea5893440b93eac9850b2fb318e9883058650ad08c8b75dde55f91e3600c3e26ceb36da051a4d7a2d912f677ed9b3eac100b6917525f0239706555c5cbddd0b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
