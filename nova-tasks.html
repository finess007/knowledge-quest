<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6309faecdcfa7e79c644fe330c89e84c094798dd12e3e7b9021f21b6522c9935115e604988ed0d980a085daeb1492be5b2341fdfeb39a349630bee6df58926b601d854bf3792b731cc6e2226726eb96d7e002913c804ee27076bb35fd8a3e330ed14da0adc432cc4722bdfe548236b7b7a00114492c1d687160888b489fd943c3cdf4e43ebc7e03d91dbd15823cc0f296d2837e0980983fe8c84c4fdc4c8a2d3feb62097bf4891d789037b543dd28e8151ca61c45d482dab207ccbe6f4819fcb6e53a27083e58fcbf348740d8ee8c0f6182f0bb0e08714092df9998e53e6c58e1f736423ca6cfdedb4d2473647c9e087a64362bc9340970b9cf54d2233d7322bc3548af14e9ed62a491c0b6c3064bc66776501464e4943be7ecb5197a69dd18d556b198f3d578f829cd0a342e55c3a52cc51bb1a7e11f4a9e7bca34f20164f75e6952ecde1d99a2eeb504f5bf43749cd1dd818f9dd712c7adb19559849fb476c1484a85bd629be1c7852008ed0bc5205176e9bf0654031b004c28f70475d2031495ce900b53c67d2a18a4eb9f1cc94d7749a31d6ef48272d212a65092eef0b11fb78d11c997b3d64331b2fb43097120465bb2c5f071e9445354cb624cb667dad40e9138a461d5f16f30ee8d53d20c2d7126642307e51535a15b2f71d342255e5b538d7966339193fe653c76afe8a61e28071c9d8897df0cecb9319baad9d8a985b9693ec705940c926d0e473677ea3828c82fd28f0e4c1b690314db958142449d5bc25d2bfeac29013e55afd2d15ed0e316e6ee161a4e35a75a717d5eae365e71e33bbfe7169e28f6c60b3b6fdabfd663b7c0bc6bfb3d114164b6e3696c4f03b7f248911a3020e2d87574f86fb5e137fb389b66b8b51477de877ea1d2234bc3a1c2354abeb10166045e02519576c0216c83cdafb5b87a7b2fd13806f47133fa301ba5729eb2ac94e00a264e71502d586e43f319003f2c978095e2412ea255341c6e57a773a48542578441e9c2a4466b9670b3b8bd60e8e5ad0adf0401a3cb8c3c93e6fbe4180a1f1726d26241b2a5c053a49d26094e87dab1bcc5ad175cfa6b72098b223edc20ad4a11338550853d0cb09cda74764d45abe88357c82500764079b963d8abe4455a3a65893be99e6d1a390a7f63f162b6993fa5277db4571e6544195c54bbffa479f82e8b052f469bca93b9dfa1a408ea0afcb9ac0135f9f056057d65dffee0dd208d75064f0f042e2e46ae751ddf619549c8dc2399deed4f0eabd040f1dc03b59b9d138f33c78add486ed491527bbf84f25875f8115968c86e43bae2e1bac170264e4e49418e1c578ae48d691006ea9df9acf9baeadee15fddd33d6108fd49fd0e49eb08227770d4baa9b115ff9e692c4b7793067d8937d0b53991e1264838ac914bbe4fd8319b1ba5d5d48fa99dd7a0facbbf2ae49b21702e475043a2498cf0de66c9bfc6383f1067c0fbe5720e028ad090c06957b89ab304446bce479733ba4e931529085c5a5069808980d9d6ea30bfe3dcc503c4e5408da7e819fbd4754de67a4f053550ea3249ef6a353971e3090a29a45106535112edaa3597863087d12bc18628031f699bfca3fd7b6c775f621a5fced2bd1b0c06d4acb7da89449f2fdbe517af36b1e127e2f9beb7d63e96b4d1055f870b66bbe2eaec6cb5198921f65e0a2089915672e97dd939f0065275a3bea7f1b117c25c3948926ddcb039859b6d7d30589c9b88a2f71c56f248333c5a2b06e59d187fac506d8b73fc92dfece27d05a329e23d4c0e4adb26d541d565e411d8d38bc3577ea44c1a3fe9abd38719f4487f57ea6c75cfe42bd2aa1171b860c8283db407637e998acb3e343f62c1cb4e2d4f9296227b7ae4945e9a7e497a1baa2ed372ab1ff47090affd9a104c860d15645ace0152e03828b936a8ee335ff4600515a91fb31a86b6629447f4d1a8554d6cbb681d974e6c898b487127df332ac74f4dcfe278fe950799ba8f31f446cbc3efbf69afcfc308ad4014b0ea432c2f963818bd6086f407c4057c7cf8f9ac32b2bd8ff3f4fc4489334fe9e6fc12d30117571104b4a9b497ec7a2395132bb31dea72d25fa61dc812f0d10608212e15e55dabcd30932d8ee94af2dfbdee95e88c40cf91714efd363ac6b70e5a8b2f1d4506193a9b1e43275f5a316ad812919a875510d1455a37b5089ce2d7f38f8e37b69bcff9c19772c5f70519cfd9d825bf93920fc5f7a33a40b884ccc25f9fd55fb67d1a1567004004f41c62b16a17425612d7daff381d4271f9efe1e525a4de81cd91fff4afdee00d9ecbbdb3fff8db904ff2da34d0c6b28fcf97504e3e226b4526cbce543e50764c0bce227abc3aa2585ba3ea6e468e208b95b1b7e8fccc0e5e45dadf93d98a60670635e61e6a8d0cfa9e01037bd4c276a7f086f8372e18d693f32c0a103387fffdcc0aa4c946c893a3fa33db14f2072769fcd97de39e9119f75a08d4ebb3bdfb112b19d66eb14b8c6f6fe1626b68ee2fa6906f622fdf4b6ab400f276b50880e045913530b4d41ff47c23143fa87f5891272ec196c45840571f71ff52bc20f962a1cbfdb97a3e7d79e5c68cc5ffa6bad673b7e98f5737bc3590d060428a8373a94d6f3575569a0c92a3245d636f8a7b17a038047e8c657479b94878ada8d95f0802b646831e364f4a00a664a2970cca3ed935251206d84f704142dd96d041edb2b901f728aa03d1f0e9478d72399719a54c45f144f4f36db0a19581f5d4783d1f39eef626b9675d8671dda3f7d2e24525a46142858b0f931c0fb7ded8cb783619271dd3b47f733d84543c92c7e26116bb07d2726f45c79ce5d44a8ef9feedeb189af212c53ab056a6d4de9c86cb6825644fd8513385bba7f11e5aeba865f5ad90ee826056615c3bbb2e28cc5f6e893f0e555cf2fcdee16c8720d2582efd44c4da6014c9594ec7853e8b344066856dd6d44c9fca8811de88b3893918c674e6e729d89df68edc1c659e49e7b5e3afe974bdd43556484cb94629a59e20f2c06cc6c4fbf956ef79be202d80734052b79f2cc9f9219c582bb9091bcb8f4613f2cea50559d6be0bdce9e2b4070965a42931c383c5e01ea053cdd94329fbfa66676d1bee54593cd0d973af94965a52e1aa23c1114712c8ead4c7a6acc5d1424355bcc4a41d48b425193bf7511269d3af5459d0333597daf2c92b945de7b8f1a7c37c53c84e226c0e8f884ce6d479786deefad0a1e021f60bcfb17ce5d6573c98508beae25233a7e75f3d47e059184a1c7e2c13ed6fd80852ba7f16f4a602c24b5e150675c0198bcd6498d3486115de91b7684d5d7d4713e82216143b7f0232b121994d9355f1b3bf3860b9321436486f17c989a56becab68abd27a56af73f313635d0e25d770b58fea20160329ee3d72736653105d33d8ea5320f4cbdd06bb60033c9fbb3ef5be192afb08e496135cf8010a2f112f26a630261ee3e324866487a632fdfd6700b521da9bcff77c67e0e87f0b9e824158133a5840f5c3665283642c4bf123769d3193bd6d604c4ba8bcd6bcd2a260338108345655f92d52485c35898fcb64ec7c5b2b8614139d88783b2d1c3daeafd27653961708085e1babb1cbf5c9bf4d4374e992545413bb78cc41a63042630790ea0c73d0bccb5b62d67db1d3f866978d2d60b112e8a4b1b1365eacddcd107e54f941521a7b17d3328d9a52772fd5465b33c6dc0dd8a9344a340f34f0d6d7e96b38b1442b6180a56f15399db21fc7828af6d05f9f87ae73af513c35d7bd55c4fc45510ffa8f5a9ea290fa1cc34e8cc20e67b6b87389e327d83a44cdae7dd764315fb0f88ab714eb07c9257fea30b7ad23f5f1e27e2ffd801f7a1f56386c2bbfdc4668205b21da568679995079a3df77cda829918dbbfd1d0392c7c74fcb70a2416640445e9a2535c123a15bebdff09fdc1422c7d0f3f35bdc941080cb062490027cbd4b05c090d386654e5a54be6440b58f3b02dd7a4487036a4ec3355f0893208f3aeb140c4c2dde84d5f3a5971299e1f60b5d84baaf7978f5277f7811ecd7298a661c3b3d4ec6b45cb708b4f71c4132e214a4f341e92ddd82cdb4c59e406f34212a0f9e054311f1eb93b915b04c3b4ff3bea1e3ed3d96eaf38cda3231abf74beb0d5521a761e4b1857dbe26362c69d6b8aa1ee483d729c89933c49c944b96ba24c34f2407c57015a14d1e87120713a372aad5c9e198d440ec32e7d64244e714a55a8554b3f76291ef7719458710810eed3f78051569a976e92b4eb649ff6ba40f891a75b20762f125ca4ea87202bf0d5e3972b454e241bd79f432aa9082ca9c9ba2e58e6108469b5f5d72757aa80057153daf2e2091525ef76851e1daf6c3a38011f24f140b227e05956a0e389d5294122967692a9ac46a9c8a1407497b78698ba6538990632ae1fcca7d23474484d74d4826430307380f7387bf9ccf94b2663b42f24652718f8463e2ac3b3a7b06eae15454e0fe18214021107f772d8891707cff5e3011c30855a61ea9e9de6a906dedf7c8d11c88944e2bd75babece2b70085385e8f2f2103c5c1bb6990923f163ce5506e44b5808c009cf01a09fc3794cf99dcee2428b59f146d9dd1f2b975b4b7b1ec8fae86301dd86bd0d173fea21373290ed0c9aa320dd5fd759c161a6fa7bafd114e3b62abc77927fce7da19fdf7ce4b1558ef1ea784b54dc606b581192ec25583c7e25083a4248f77806a6875a532a9bb15de03b658dbca4674230c123c71a052b1b3a9ec7a8b42143c5e4ee3c917aff23e25a3dae86a3573f6be26287c0a75abcc6256215aa654e84d02bb7e1eb145c059387fff3c02fda8e16ce5534d5379e4a1956b3f1af5f2275836f9ade79e48a393251d1c51b7bf616b349b5d8250ee7d2547087f46860c6d25e35344838036496a501b9fc96515aa690b6e0a3de6199b38c76da63b450666acf80117c7e277a714d21d981479b9f42fe9ace6890bfb8a148bad534d7b3127631321b65c2f69d0bfd1acfc2361b706314c80749fb3b556eae8c7f902fd872149c24aa73966329159928b162a3dc69dd10747e8ee27f3a683fef677f05424ce85192eafde79d675a2869363c660e46e2d578166ea3dedac868aed1110c6c74cc3da14a688318984410f2557bf78cdc3efb5dab958a0cc640083867a55a91553d76db19496b325b6341b5ec4544bdb8acee65e635b76616d16daf1a4344d4285dbc3827069ffa6bb450f9f4ae109fcf89116652556407f81e3bf5d3032cb7927d1e7b21ac7484645ba34dc5120ceddb146e5876afd391dc216cdd07d49c3148b0096fb99088abb83e3eb77182e3ccc6f2ae247aa06fed2cdf7431ba66e04fe55afe8de0d2a61dd64c83f605e032e3fc142ba3ee440f020baa280cce6c59ecad1ab2db08ebe3d29ee9aaadeae7f310cd61e23b6f59ed79d00af42acebf3dec2a3b743470eddbee9d77b5524a547964f94facb72335b1b3354ab7172b5f76907f6bb062cf515d9070aa4baa816c053b369de38b8999afa102bb68db63c23536c0f81ad20a55d5f9ec54fc84afbf090b481c035354ad8601de9f7a3f7fcd701da0284191c7161d11bb94f576b77ec42ad7d1940e4010d97772c0b2db7579d9b99488dc3b0ed49f8dc5ca3b1d7514db90bf297c414c04f0383f15ed83ceac7db4cea6ad62c1e2b044e63a53b8d7f6c65118aa435b7d061fbc08d7e9883d2880ff2cb56eddecf2bcdb24e01695188478f999a498a4ce13999bdc55787aa9334d90473a61aa0494b8eec311a4001ddc327201a179a5b351b569e0b8bfd873f989305b4994c109fdacaac55383cbd6b6a07d737614bd5fbb8dbffd1459e65b1c88e986430f55b25d5eb81c74f6f9bdf9e792716d935625fb29ccf0e19e7516f570dcb548c6595d0cbf3efff0ad461bfcf97b9b95cd1487b4cc5f55329d942f3eee970eb7564117a0e0b4124a4ab320d14202a07e25d66a00040250b9df4f1f5b02dcd3f3123584686f7042fa02e86f2596f922b4fa769e9b4f111d2ffb8487a8997f1c5ae45131b36888963a93569b13a4ebb42ea9f49063e62c831ff00d7d2a35fdc21fbd38cc083a084404accc8a62af0d21f05886fccffdfd7f690059f892e97d3f7ab952fd0b51228ca8c43d9ef159ce39742284ea063e3f565550e5db122ae5b178d15db9edd7e5395f2e09a0df9689dc53b618fa0fdfa5211cecd80cdce26b9cc56e4a340d016a21e1c169b3e5f2500a446df1ee618e15470d46cef0d64c6670a27d3613db8594dbdb9f3c8b1f8768fe23ff503ab9009729d5a86975b909ad27bab24ba2cb6eca6a323e0b57a374770d4e2cd466fe3025d6c333dcdc9e95ad0b8bfabdd9321a84d8b7fd644a97a35681b6485612eea4559f31def8fb8a462c7ec0a43c5dd6083440f391e8674e3c5c125b4473713c32534b6e52f1e1761b2e31b818592fb7e8fb965c72b109a17cd35a0948c1483d51eaedb7b8e74d8ae139c06b205daca81fd9d8c06ed55f0412db2e7bab7193f93cddfab37b15a48d181253275bb82c08531dfaef651a12a9b140e73086976e7117c7360e93ddc7fc72eb994fce11734254618e8cc1e52df70d82accf8cedcd88e9f225794571ad2f9250b68caa80ce2a23573ae6f1a06af9b9e3086edae93d1a2db2fab6515293f5dfa5353dfc8c2c46c0a3adc925e570f425a4504ea71e04b56fa7f2c3b89334a5b186bde3234d3f8b693c423d47eea24020efa79df13d724202fb8bd2157397dd9772a1fa10a82f69f045251500ebfbeca586513d92806e7d2c04a43da89127b1fba4c2e7810e069f8e3860e64d0661a7526d3d081d02cd46c1fccd6b6cbb76abab1ca36c2945871eb5ed7b280e03689fef1ac446e7aaa434fe243223d8bd37b1fd3b9e83ab89660c3206e5c47510bcdd5d5ce89cc03c7ba0f4df6f5edc78580551f29392388f22bce731d1259f290b6e546ea718004c40bf5f7677f6b04c2fa66de02c3f50c745481506a7da7bbd9240bb695c4eb866109342cfbcfc4f91388469c808deb7be2c3c3666849f4d71d200e2ab07534b06be528dca6fe3f88353419750b2cce0f909a5919977f3628df397f6a1482ff2d1e34c0c8641db72da27ff20b5475dd29a30ec3fde4b94bbc3bf6f45a1ce3fe74a463b192dc41961cfa015c855da4132812c557e7265b0decad25d138af072ee1ecb6d06886fb7adc2bbba9d8c531107d507417e184cde25b7ba430f96a4e5c43f9c9b0893eadc73b7b83d42514a0b447af0bb5dea8b15e03a96deec250045b8805f52e5e3d25bb7378143f3b4cfcbbc221bc078de78984c71623c4e1c7c8b39d17f2aa728a8961aa29bb60ef8d55085f34d9f17fab8348dcd810f723ee183b5621d07186acaf5220db463ceb167d7ac8ac453f23c10ff7666104a30991688a059871e99feea7770a1fdc8f40ac97c6a9e1feb9703a877604f702c5e0a5c227bbf985fc1381019de021a00cbc1becd3697ced703e0bf790a92db748daae12a45bd9e891ba98e3fcd8e71ee7b865456f5f8f4d20bbbd81e762a54f3cbb1a7eb4ffcfe157f42009e48d53ef33546848e2d16a2d49ba09d97308ed7aa8bad7d5727e8459ac68d0c78438f6a1a6234e07340b6a9f8299ff1c8bc5b632019e5368fbdee340b0bde85be6114bec8a6f0e5f230660fc4ae479b096451a7c96d301a6ef06b03c502d94019fecd9f6bc51f3b7391bea38f4dee443e923e3dbcc80e4aecd93637fa0af08c53d8763b2101232c144c546ddd960c276642a701d92143a287a4dd577f20768bc771e60e182e2d857b32c209b99112bfe6690d7008affc4435e71f667199cf7a1c7300059d1e0e15f7eed09e30dc185cf04416e59cbeebb3a99367c75248c87c25e00f044d5c1ba5c128156ac5e71f6627f2dfb98cb66f0d65af028b6d0068f9394d2db921ef08e9c53deaba68764fbe0aa139365a046e4863a41679b58e3b81e548b5117a692e345472f61b7a8d0aa2607187b7fd010f78605c1c329ad2a354e702103a6eec3f2b0e80a28cadad2c78478abdab3795a052f6c1c6427775b9752620546ca4b0809406ec405f388b56a331af8e05a336fb432e374c2a3f6b4b14d588b3bdcc4988d87d46570244d52e90be9ba5baaa7e21359bd3ec4b532e22ae04f36cf7c8d1625aaa8c9518d82b88271f97008f34af139de4ae2604ad1e01c42f67b572b3f95ebf825adbc3606b2d54a1be93265604e76841430ffc9fbc5f8e652e02f1e38e6e8b5b093928386a6bc6b175d95c9a27d428a08026b1e743e3f34a15061bdd60daa66e9bbb8eae24cd6a80701dca88a49437aec0cf71ac6f00a50bf61ebf88a0bb5337aaf84554a9aa7fbce98e31c68271f15fe2bf60bab1acf749193c2cef63e8ea50d2cb31c39dd940bd979bd06c974f44d0fe17e89d079c6f5f703661a7682770b167ac1f65d69fc12fe0d4ac8e7dea343c95662a9b2978e1e391d8720c3db26995bc240d71037da759e8c6accbe97f74d58eab791431b241a671d875edcb8789c8f6fd51bf7a36adfad6b16309d6531f0a07bfd87df37e455857b954d533bc5d6197766c8487c8fc3a02a9cb28a2113c7ac8d96c596ba9066d65a387631d7a953f065b70de8d90204e4c404aac025fad9743726cd3e48b63c8c97ba726ea16b513296152be65ad70d69b8f00b187c64d568f43ad463060a466e79c59cf92767b72859954581af6be022f9bc0f8830854d75b332e82024c57a9bc06871ce3c5ec8d4db7628b703bbdb1190c9293d10eab98da66241dd3bb32d4a52a33b865f1dd873d136f506e8e1239b2722d3255cfa5ec9690fdaedbd980c861b1702a022fe1b7e832f10bba6a84864816e6fec1715fde623d2cf437caa3cd3021d7607009a5330228f68ae6bb7be1f49d91026647bf64118ba68328009f663ab75629ac63652dff8b552df7878d43dda1534706c27a7fe63be59e2138c5923abb485958880c32cf68b815fe29a4f632f224fa09bdbc64c7e8a1e1967bc9c66dcbcbba9e0f5cea8403f49f2604554a35b34bdaf3f5e711c90aa80349b911df8be804d49b1a7e67fc4a400bc769c4413f9b5a9d7c9f876367646f83194edba0a947533b9c5e1fea720d467ed8c89b05dfddc38801228c7d65f1e137b357a8b82388eeaee26b8da4ddc4dacdad5bb3ec818ae13d0d34b225b47c88f3277d86cdf7b2466a19cc8adbe87bd642b6801f101265547d0f30e92746b97e80f59ec0e15f65a96d08def7fdeefd49b52f22ee7d3b21a042a15784edf849a5374400e6fda2f7639fe79e45316acdc152081bd83cddfded922839fff988765fa7b53e535c82ee274814445ebade528698eae68ec0f99424172c50da8a0cb95241626204b7d16e800141365ecbf2e4842a24030956b6dee24d94c1ea7781785daf668382a4a00fa2dd9e61e887fb56a2a713caeb2a5ffea4407ddddb9aacfb27bb23588f4f993c9c05a8648d821a7e91a12e6c3ee8c3982953d95566f17c5a1db0f4f25088b669cb294724ea88527b24f61b214965f71e22684b6efba9893569174431321fd2d2e780885c982a655adeed818351c06f11a49bf32b7b4b1419f0401d81bbc76a8ce790ae7ca140db90d5213b41ab5c29ddc5203c5a8b41fffd803a162a46efbe20d147987a4caed19c2831764638597c014b7d5106b48656b40e18cff9602549949e8bad4b403a858990f834d7f83582e54d8e2531de6599b62ec9e738cdff3a280f31ca8c51b84bbca166e5655a7aefbff40932a3565c9d65fa9e74f07ca159f24a54155c624ee49af05c3d7c09a3f6af871282e12421633257ef011c6e2921602f0540d5adf06ddb2f0fb77f56e7be98afabb4385b9b7b8118235ea132cc2ecb96d659c71660036e779e59505134fc198548fa1a6769ce49f674d1a20ab73678adca43f3b4e2f478369e756ca692bb382910d05ba67a5eca4a922dae333a80f160c3a970d318e8639a2ddde49a64861d673f7ea91647f765f145edf4323cd8f6449433484923357ec56e2ea0e81b6d6be30598f56f26c80b0d164a411f32ab1d65a33cf408f5f0b6615fca5cefa7fb9ef1249d9a59d9b07cb4dadcb8cc63d07840bd2208334ee5ac2341050c62b4ad93d33fb1d03fed9ca18ecb4d1848a187fdd4a898741795d38d843232de8e007d154ea5c021f640febc5c529f9f05e21cef794c0d3d4d57af3423df2939f649dc743f3acb4817ebe537fbd7c66f2a725455d644d370dffa9179bcf7b570bc69de1f82e400018b36e48d82c9300f97e30ade575266ddaa0d418c629aea4e1934fb4e9a23d581295cfc7c3abee0594d817ad15e0cdc120d3cbc2497bcb62e28beeee72531eb198ea5faf1112c63e929c98293dccfe0edee215e43c3926afb2fb8c36e156ca6ee8d51ed1d6c06f48cf4e55d828d450cfa2169cba47bbe865b490ae6a5068f9f793baf0782908fc698d265135d27a253cf04d1b98eaf0ec970d041e50b4312ec24997577c0e62da49c4a4166950c09195d41084f4c3d81243a19a574351dd0908d5522704452cb19d7f0c07379c44f88d21e0325492bd9994d7f1e9e858f04b0c4ea0c5cbade729d1acc001792afac99e58f5b065b5fe4ab2d274a5b8f5d918d289874bf53444aa90b86570ee77ee6aaf6f3071b254b4e63071124d0b7ee5a1384cf53cc07ed717850f15dea6836ecff997f916f9bdeaf92c3520535131a2a039ae3f99fdfe733d9b0dfbb3a2965b0906edef81ea5356917b7b7ebf971f8a711b5712afeefcae782978c612f0abd3fabb8e951ba2688a230a0a628caccfac23ed91fe5085298dd086e7840badfd6c2184b8aad791f88a3a2c4d376cfe1693fd3a38e597233b562626bc4964d002ae63d507e29b112ed294563ac4d60a95bdb274df504fe8228e82d7e694c176e62990033b253b39dd92aa1d1a10e3ca83a3b227fce416e44cb293418175c8fd4cec3b407fd78d490a72fae263f7ec9bb49dab054b97c6eb24cb05ddaf7ccd252969d099a4f779339d6f5d569e06c28d5dabc531655c8074a9e2b8c4ae9ab182d0bb4835513eb11cdbbb3bcb50caca4e11c2586a3e2af44044ccfcec2975f8a76e5001efb5a98ba1eb5c2dd6fd13724fb56b53b8d2d22ede8fa8f8532ac1c5fa6090bf0fe29bab6ca575c130198188cfe35b04b62d74cb24ce64f4c7be4680df8379daf46835905d9a8801a080fd1506aae9fe973f47f8cd2fe5dd0c1b943c220ad795bac49c80afcc76b0814d8799f7ea4de4eab066161e7114a7a198d4f05695d3a55cc420dd8d45a8187ce0ce9d8d7c2aa23ffef42a9c2d347c53d96517971fb12df42df543b729d8f9b3652faf17e798eb57c60cce05370abf4b1eb0defdd436b64169c651dc5eda7596a53ccfe1f7e1004ff77fa7dd431c557584bb7a99a73229147bc70da39d4e9488a9e2a4dbcc6d7fa7474ecaa8d0b7a8be84c817f42fb27b18f0f23d6e6bd2bc92b2b309e8269d0d1e8c006b15ec6efda697797cf6623806c38f341b04e24d80d0800019498d4b0de8011f0e61d5994b39e6c61378252bfcefd3a30e4dae19162ad60663dfc59b54a4a895dbbb39015e51face14b6f7c502b69ba24f3603f3815c3b7682f465c0cd8f3443328428e56b6c4859abb518d2a969320ba5d758398637b212fea462fe028be85c1ce6f7d406d00f36d6ed2d9fbc89d75297217faf22b3406df1c1d78761837f8876716d50f1540ffe381737632027abfa9bf63a8e11d215fad7f9eb099c95d0b01ceda3625c032c3503fc5ac4dd441efe2b277d8fd1b6700ba135d26d135ec441982d97d8435bef7cf9ee8fd83471d121def057ceaf07363755d81576179b3c1c796add8ff70cc397c3f9d973c254943f615278c462ae9063e2997b025a541ada205319857ffd28fe7c21885e4993d46c3a647381caebe0f9beac62e08c08f72f0bbc43c98edaf4c98909e4775dc3129b2ba893e9a2c957fe2cac148c8df8b893ab6ab7336118a3182159489451d03b1d721ddd077ddc57181acf343b9f9dd2009779bc8c5f62950a537757b6f5dc6f8572768a8d17e2cd532cc4134aa16c3d7267433cc51d744d957268f24e4ff905ad40d15f0a7b26c4388bd62d43ac7c14e31c8bda6ed118dabcae71d69111e11e3fa1b1f5b6698a27c697c98e7339c9a2d74da6d432f13fc84ef3d8f2c63c0ac7000d7517b8605c976cc71bc245d36d59f13f75c91d676e3be5b4577dbb53588d776dd766685a49653c0b40c75676e8eb64822f2ae740522b77c239ca395f871a913aec6a870e8548587086b30b716f73eaa274af2de74ffae2ca13181a50ea2fa8cdc7071adce1c46df5b5ec746425aab3798b604e4dd31012f01cc06c9376979d0d10cac1da49a2fecaac79d036e326d7ac080bbcb998c4920050a5c7363923c6146030ce628312a9dcbcfb45c8336f01f9dd026f6b054c7daa47bc4c67ae0d586997f505adcfeae6aa2f7a9ea26f797558cc01c9ab36dde5c4ad03292a674e273da7bc4bf40f8b52f3582857a0d8141786f4dcbef0102833e152d810f0171d32c9f6ebe0cf23df9fed23eaebbe65cdce9c91ba3e7fee2d7eb6d07fc5e51eff12f765660cb32d4e3d79af817bde512b3592214772e7523c7bdd946b57a7c5ad6c0ce4dd07ae28616dd9bfd0effe643124716ffb5161e8ff7e9f23c96d42b961790a89452a1701a00b666c53aaba579e2188e4061d1a707f066876e631ada4b801bfe2dfb0156bd89665cbf3919acbeb89f80275dabfd51a820449b60ea8386cda91263885b77fa3a12219eadcd39c48a5f953ffd076c66679e0da08a7af1fa3c855555670491a7b9d7a83a93f49e3e546ae413b77225cbb3d76953cda65f3b34ab6e1265b93b2a435c5c00d4ddfdd5b3c5e91f2a99f667e274dfbc6d645c14daca39f13aa15fbf4ef7ff1f2079571364592264aec37f23f3045e4ced47aab70c8955b6ee34023d03b50cf2ec0173dae99726515e9dac604b73b753a9054ca17818e1e756b87b561dcd881590443277f075274594beae10f65fd7a28c315ca026497aaa6dda5eb0c0171f3a8baef430c7649be0f48dc158e6976eebc9b8db6c260208c53f3c8ea051e66a84ee34dc49517c26a996b11c7446c7dc1bf7fa61a93d9beadb23b961949e1d3279a701dec9d04edc70e13cd24e13fbe6f0bb703170785c73006dd31903d4741dd98c96df7a1feafa43f7a5ca822286795f63b6b46ffc2a5af619d442339cecf775ded77492aff65d5960ea5a895a7af03f7f1bdde3c8989de75f5ac526b99c51f84c455eb5945a0b3c4fe76be1a2e1704edd87d9de0c4d35f7c40c91e059e8a7ce271df37d1e58504e06ccf5208f39d524b841d8fc8a7d6ca527e5d8f2f96123efb37029e3fd68d0ca0d2c531ad0285d3cd9071602211e486f84e76ef732b91d2eb5a2dace73bf7e703d0ec6c190a0d337811389250f669026cc649d995285ba19279000e97dadb7f4ae68de91bbfd8e64ec3167fb27150925ea4bcf2d0abc9775dbcb607aa4512f1c12e2f6fc2d277d652b94cfdad4dfe0704cc9fbc5f8f7a077467690576ea9394d32b36584e82c277b7ca55b4aed68de777c43bef22a1b7579c468a07ba5fd2aeb43503eaeab1a76267c4c294e8f47e35f93d775c1ba709abaa5a4a49ac753a599acc7e27903fe62320874239d88d3e02f645b47b97cb51abcef2c25e1ba36586794f93216ebe896881cf26a24f2cd5a37e1d1262a3186b52e67bd5dfc495de60591117eb7b6a15d97b7d2841033cfd4e96321c18c96e13c29f0c559a407cbc9a8012d8ac34c244d07dca432a27dafee00f33dcb9fd6be0edb73f1b1421b803b3df72eaa536921181fd47ae11be8b5d9f5a323b2d4f372957e623ae6861183a5813572bfb51638201c0be3e3c9c1e0542c51b6f6b484ab3fb66df9933f611853d2bde6ad796b130ad69dfd68d9d638ef0b87d738d235327c75a0e4389e16e7d76f0f2ee0267b6af4178ee223de4cac944de61084c375057bd46acfe232a3cc90a69a6fa79d1c84e74cb17a71c737248dcc0461ded6e50e471a50fc40c7a9202d9eba6aa2afe00f5d01f0fd5707c0216d3c8472a603fad11a82416615c04b0bdd2a6eb00aa1f459ac6f9018079424ebd629a95642fb8b6710fea5ab0aa37043829e6803fd085f7f228790aadc8b755e6d01f7c275fbf36773f09d99f530429a16950d197b2a29a6d205a122e45151a62b7a7b05cf106f7031220ffcb8b419ef02f9edea28360ba667a83c6c3b33320cdeca366d286f702274b48608e63780f063b44dd34947e8a2d325bf364217df1f1504bd960d16e720a01ec2008ea39a0c868bd75604bebc1d3f58ceeea8a4eef6e086c6740a08ec26f2d1eac6bdf7f7bb29384241957898675f6d3875a76e7f40243951aa2b3ded316b1ee01ef62d19b65e5d932a1b4bd55d","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
