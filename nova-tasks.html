<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a2ab6d00dbfe4138e5c25a9c5956385450f90655479d1404da88798d697ce01c9a4968453789168bc7beb528de22c6d84e664f5ece17c43ad4734b6deef59feefd61f0d08c16ee117e256d88c4ddd7370b8a0293d9fd456e1a9367cf88ab64f21e406b3a1102cc144d18825870201c04e2bf97ca217d2770c16e2ea064b187ef6b0d96246ebfb6f1054f97af80b92187226d2021dc8ad92d3567acf67b12a7af3c55f9fe4bc5a972ff253a310859686d4fa91ef2cc44c0b17d20d878278e1c5eb0436c688b31bd971b86b576da59419feb017184b2c5d4a298ffbe34811cfc444dc1447fec9081d71502970ec03c57696e2673e300a7a8728ea656fb2b4c652dcb4025627f87dedd5320d1e8e0fb2a2725be555225b47cc50e172d8eb001908eaf9d64f9e5aa8acc95e6d65129c064d5422e750f202f34d4b02ff7581c9ce1455302e6675405e08c95823abb77708ef751f74060f07fecd3ad06abd44b7cb4c9564b2eab6e7a7d1e9ef925415eba553ce1615d08806e49d1232232795fa9b0307d3306853d2b275f5b273f900a9fcb8176115921a430841d058bf8cdbc49134440e6599ed91d4995f328e1a3681f310a7a2475dda6c431c35fbd2e8952b28ca9a01e6bb194af99f1ddea27e9ba34c361bb616ad183ba20df492eb4155a1fb3097e157b91427758baca9843fc7f8ee805a4983be55f6db09ea61d5da24299f2f268c36267cac550f7a9603cd811023da46771aa52067f4bf3ecfb05d2faf04361fb684ee61caa634aa89b17f12856dac2084af980dde234dfd94ee7cb1f96ccdc7759f75f93ae2e1cbd33b5e576b0805d2de9a2c2776e44954a35b9a5876b1d613a15e4667dfd3e37554ea24d8680496e591239710fda4b24e4ced7604d8c5f6031d5dd18a78ce1a7e9c8f2bdd7060ae06a33bf958a7a5d1699fcd5bab94202ff0aca74c0a4c6a669fab282f47b90eb9dd9e8a78e714493c501d25ad29237601d1cf06ccce53832aed5ec7f002d87644ead768b7784ff0513fc8672b3b6ba7c3fc15fdc38c67faa5be6d673820b98767df530d7ac99a2773cb7a76569e20b4f9c781eaa6d5fe94b345ebf8bece507675f24863cebfdc0a4d27d565a48943b6d73784d8ff85d40a1ad56ef5c58ca5a1b0d05faf7f9b6f6bfda89362dcef509149da8afdfe9619fca00673bffcba69937472e01c6e3e48d822de3465f480e07433d3994e8edb42c0c32be244affc032110e897a630a0769241e6f72027db7af9e290206b2e5ac907ca5bd1cd261895bfa1ec0ba0d390812e0f22fa56f2c0c5fe833878d273a00558dff726fb7f230fc1f032ab07a52807c830b0bc55169c07409a35735109f3a2401f8f53bccdbf0127f5b22cf23c84ed06eb54279c4ab4e36dccadc8495d4e0ad587fc675a944e7c2749e1fee1f705d0e0909e2afcabc2617828275c0464970c40b67d4da2f1f9aa95c5d3876565891bf66afdce2353ee996bdab973cca0cce3df29a3ae1d9dc5535fc4322b4ae6f526ccfbda3360eb6c95428f2bd0a6c7e79896d8f6a651ac0c0d4c11a8b356ae5f7eb07efd5b3884c145afb4eb423fc97408baadb42dce3b363846ca5462c6717fb30764d4c0aa209b005699b082e40adc78f0be0a96cbce81fd8bcbbce1e6361280d21dc7a7b25d971ec60f49dd006eb873e28e876e36f704102108f82207a97915d1df174831ffbca2b1314e39b1845461a8a59c0257f14de3a002b528c0cd26a406c21c2521e65e88563c63d1e611547700d810909e544d72a432083ac047bfc801d7f10cfb0421362fd660f722872b9699d7235764ab840267fc68931c8b86fe2f556623b4760677d50db4454362ce54c7210532ae219424073a9278b140fb3f50e1b7249b58c805847cfe4d303341b9ff21a99ae400be03d7203bc600b031e7e2f1824a1a7493bd5ee99c04609614edf475b0f0306c27424214389107d72e076c6d4c6127958f5c4dac779995664a057a2b1273bdc51e5f6f8ca94583b5c47040d4b87668f4608fdaf0e3951a594147c85d75522c8c1af3414316f980352bfd906829553fdd44ab7a81f2e513a1da6e1dec1fd5104000010127fd9042cf4afab6d9af80ee0bd4cad05af34146c23f22f4256323c5b202483f193604583135a920692056955e9213da462eb80794b8126dfef036d5641f4d4d0b02271eed52a186ab9f4c8a608cd95779dea4fde337efc7b3e79eaf3df7773440f94d4dffd0b5484ba20e00a7114d32c068e04437cacd0aa0515652d279b7b7608df16a84545724c8a47234e8239ac227e3827130b42e812923807d93ad79732e387c14ab5bfefcb9529861c9b31b7280a0ce0cbdfd5516ede07a51d7fe3372b1103e0c2fd0483f47d56573da2613c05c1c788460c77d431b73a0b0b71c4872e56fcca2543fe0a1eded7608dd87e4c042bca114f96977906dd4b7bd5de12d67543f26bb0541919d2f2b3fcde5c6f2582967da5ad4bda07857d4cbb7c3ee0222e01c25ee37181aa7ea25989129aba4557bfc40951828ec082a16534e1c5b1105f91049cba9fc896c13b3dd54bde7aae9937ee29e0180cc8366306e262b9328d22fe6aba22e34c30c1f79589f52bc3ca8924aecc926c6d4d40d6dd1d97708947b4a40f582e7ac69e1681b28f7ddb7fd9b9b4ec8f20f8ea3c08e6b635b6ba94023836146920067e9362082daddfdbff800b16ecb2ce6e6c70960ed45ed1a28f499e8543fb9d02d8556317afb0fceb6bc46d48ef2e116f1ad7b4f4d64b1cec89e067b36c766c98fa8943f30f397db9a70d41edbf7c673da354500d125604cb8b8d257832caf0dcc43e8f4fd31cac5ca79941f523ae5831b2c12392f13d6c8c8265a717f9581a126a91a8be145cb457e543fa7e949f5b32a77210028d04f8de3114bd507e9548f32bd2c8335b9dc01aaa4cf21000cb26605c99c8096e5f81ae6128cbb526c149c5ddb736f0f73f9178807fb2c6fdde3dabe080be8d49c1d58cae16a2c49f1564d3da7ba19d44dd1a8d4ebf9d0c630961e8a77f1e8c0287fe936370e9ab2383cfb693b064df630883651936f082d9f7c37f41082a59f32a0acd30799078bbe0d7589713c1b2d3d172d4a9e82c7de112ebd56f1023e3c7c8fc91631613265260faf2f6a1623f76376455db9b9a902958549513ed9377ba257ebe4f1c58db5d6e8d213b88b669a5e215f5ba4950ec4725156a1c5f29370049993b4d79c0e26a95e5302baeb6cfc8abb9407dcc003c706c63e34775f3cee330e9e6d5be6235cc19a0b3c85b4454b00ca3780ce2eda65d556779d546e365362185f23d935505f1f5328d470d251ca9a54905d404d37daf9162f6d91fc7076dc2db7eec8940f78388bb8e4de0ee5925f71a428c85ad6399eb2e66dea3e16cf84319a122f26d0d84900c1760fc6e92b25a743b401f3609f1d03565ecb0d29de9c4f6b14e796a0d388c2b76e5a689d3d82d1c5c102a507689a6577bd06a4132d701c59a0126b6875e00ad37e3e5d1113200b8e196fd443bdfafb932c81aa5cd3aec93a1eb9a11143fede31ec634f14d3c46d3b00602a37fa1159e2e835fbfc90cc1983c7dcf42c731fdbe02b9a82b78faeac151fad65983cb69857b0556bce19d22997e0db2163eec29dc41c7247c846b7160b3bd2bfea1c492eec7e6f18b4dfc6aeafefbdf729ead3ec64f8cb27d903a2d52a1740e08c57cd5b33a55810ea6a8d25318dd151882a663f6226d8cd1c129345baae7ec267bc1f2c4301cfd584c2b08de3633cca55e4d9f4e1937d1f5e145213e3fa044f68030686a6b2ed49df542a2dc5a162a7d68d1152a4ad9747020e2f903c6835fb69f51682d04f362744ef6f41541d8796a9e67fb5d3574b3940893a11b692d7d0d13e4a4073957da1144606540c3c09e69fa166d2a108621b1ff3e0c5f9a4cca6ceae2a9472fd98f449f5a7a3c8a03dd428e4cdf10295e0cf595c88ae124c527448c3b676be0c59462409a657f98856d984f5d733ea5e26d15faa10e5e085fd26a00893b64fa75a0ef48d86361c11f7da6d43635c30fb6feb9c069c4f2de8016ed977cb40ac479d5017d3108c1b2e81469c29382e3c0eef0662d347b294002dbd43c4545b62b62ba32c38a867d79e4f9b6865d5fe2afb91d828f29e92220c2b87372d9d375df33a06504f683dcb9920aab1a1d7b9785742129d6e6cf3ee1a76b0aa3af5a97540513e1b4d1772439b36ea49aefe28c98c26f1df2f90aabff092081e36d77c35cc7173d27699240003244708bfcfc3df17a267fdf85efaf565d790e740011f6dd3dd3f923c50fc4d14430f7c7e2fddfde02cdac40117cd5909a28884582c53bc874dc76af4b5fc96a204040f96bff04dd39b66c8b498e729464d5b4a9f905d75c14454fa1db7c0b259120d74045ccacf7e2d175b4da157b8cbabe54e54cbaaf3f9ad7b83b1adb536f5e0e3aa982679411ef963ab695d566f7b363464b445507969f4a3a6c72e6b55576f193f31df699dd03f40add5dce4c8c0daf390326d0b638c009fa4ed1b17b187e8adc2575b6b73bdcff375529926386d6dfda0df3a9cf52dcccc4057f7463b7235bcf94e3fc9877aca479d63df537d38074ba1829482e88bae2829be7c38194f328c1c75602446be87e53a1a2cfe3f8b65b982f05151e371f218f388859db20e12cb180328103244aac1d5068909ee03ca21664d7ca6ae03f26ffbfd23bc8737004339a564c9df1cf2dc5e350dd82334de85f9bfecef00f8a0a3a73e9cd8e5338a94528cdf4183a355e2545a3bfacbbccfbd5d2b75227c7919240e608eb3dddc7fc5c473d000c30787ed669eaae12467c26d5ef5fade3d5d1ec31f3444ef4f109261affb91dd7a8eb7c147439541fd17d243895e50e66570baf52c568079e19f3c84bc6592a4ffe8441dbd4e6056ad42fd10501d144112b7ca37d130bf0f0edefdc4d01a92175bc0a4dd9834eb6ab918790554b99b86846b8cb9bdcd9093c6a10793838bd939fbb9c024d26138d3777fda3c2c28eb4db100901b4d05be417df3dc6e46e93d13182ba70c174fb6741c4df5d847cad1403036fd917868dafaa122c9848b90f40732f04a17b2c2b3f47b0496f3c05b9efee69afdb68f8cf21917ae157413a27881c1d06d318383dff4d4d60b92f21a156ab8ff5162be9eb7bd627d073755d4a2284e7bcb4a3d30d7f8bc74b2f1fb0ef4dc6c4e763d9a4717a62d18773cf9297359bc560d1789e84f262f3a32c4d3636740d093e10bcb7b50a083e94192372867edc116e9dccdddff3ee71f3974f77f26f9f140237fcaf9a0a28575e5bf57ede6978e930e62bbb7ed6b2ef953b015911e1daafddc8fdd793be9e27301b26cb00f263d36321a0cd22e1e849d6a03ad811955cadfcd208fab144bd319e59f4000be5e17530de8c8e635b18fed3bd35fae58787da2c566b99a165f42a878a4d32c771a7f6b220b4d5d235ceadb34469d64239e336ee5bac56004b4ed3816c4dc5b8cd1fcaf61342fa6041e6fb50e28a756b6e193240903e39ee69affbde5469aed301b8633e07b2b14d0a04b84f967daea1baac9b8872a1e39995e0af0194dd30cf2a4036d72920ff4762626b3f109ba572106e252d6cbc676d7abdcfeba01e6f3f9f33babef9127b5cd9395cf4e62ee9ea6714b2834ce5a742686d5cb74f8ff0b30de6eb4e3bf5a121ab1b8cf5ba9a69973c7ac69ea624c0b23d433f1c9bffdec7bf2480813e1617dd79c3b2cfac3aa30f50415c391935bb93bd43f2f518157cb608a629c255acdf98abc84d1b7f9921f9061616ee4659ef69d17dee2cdad10ef2c7bbd14d94157f3eb95541e8f697bd212c69958ebe5464def537123a1f6db190abc1689209f7111d8ab7bd6cee5016279b2eca25908d2813d139a72d4ee2199c9159a3e505d7523aac6c10a0e8d02a49a903d0a6d98987334cd00c1dfc214fdd1197ccace26ffefc6c2b8cbbf7bcfc67711aa28893c16160d72375556e2f371a6d648bf2f5cc6000cb0192dceeffffdd80b3ea253cd4c765bcf837aedb2d26ab8f861f93662019998add08cf5dbd48dcc8258d17e90137f7f030f0f0c37e69c55b0cba1488bf8635c0727be6df2dfcbbc1181b176336dbbd7ad48e822b448f75f41c215bc7c75860ba396caab539dd23c601331fa1825636edf16ec094f672085404695a1d34ad7ff2ee7b49e0394de70d2ccc5fb29371009a7288edbaa4c04a0ac314e6f11210f29c50d90f8d231de647811b293a9badcd58bb67df5ae8bbb6e1b748d9da908e15e31032b6d74a41fa81690242d98a6b130a97b41230666ef01a4a631107c253cf755b863d497acda16788f82c869b60f889a1e1499c459569c70b014e2af2f9f96352c8c21b87a0f15889991b45045f09ddcf55c8b037b85cf5ab47467ba8f97ac601e86b67aafd765e76114edc7e2c46141f48d8d98c539e7e1216009f6d9108c96b317845faa029f8d88641dc3cd164da93bb548cf623fadf49955fcd10911ecb7f933fa6ecc577529defed71ee2f77240e434969adc7de4985d1dffa7e46e69c4318c9f56b5fdf1683a44a879cd805b2f226117a2e951c7bd440cad9bb5c5da183e85eadc33a7ce006115e9da38f9737e2f7628efdcf08871dd667234bc2c75b6839d46248b43952a44796120380b56d30c00e870ddc823623695f6abffa20d1fec1de7902775c751fe77856b69cb99bcecbdcf9f17f8e5359084ecda38c8a76618bca44948bfc69cdca3c92523ba6cb553386caed9ecc51a59a441bcb2e9a8799c9d5bf77b46198d0d0d5caa899659cd8d14a7b4767ab4c94288deaf5c47da721411c36751179b51744faf38241490545cd4b4918af7452d61b9d47f6497501b02777ef3fac07a518973dc7efec0648b0d8ebe9d29a0baf5eca971592d98e0b4de41aa32937e39547396af20fbb572daae33c1a7996f494f93aa3b793bb3fa1ea0fbaf9362e46483422f05b4bd1508e34f42ffe999d4993255ce0d4cf11dba48569448989c193019eb84cdfda091fdb005261553ac3b5efa013fc6ec642474dd71a7f001b392db3fec7a5eda2ff835f14c7a6303dc7b582f72485be7fe13817013e405f8a7a9679ffe85474efb7b0572d308b6fd46e8d964d876843479f0c318a38f78bfc309a0e0630ce36981685645e1d9d86191b1f0df5801dfaa47400544e8c6328e6e2d8c8e89aa5d5ededb1e1f0a0908db003ceae090cdde263421ff55f15071bf5ec84e95e10d108e9e4c0de4b5bc4ad5d67302c01d4479747d999832873b90186f8ebea6afc04a046bcf362a8cd3b56bc3c59c5fd6a019c87652b1840e671be5f7a515906a8f243f48a0ba4038a8c879b297ed081b7e6f01afb42cc2c23d6d40c12ec330508996bb351b4bae4184873065064304caf636c9badb2277a0d394e3701c57cabd7c0a6a790e4d5b4fc686fee191fea4c7661ced9ab5517d6fd5796c4f7bc25a4f22e6623aa70bca9059097dc37948156294db06f7edf3530b1dcc82d13948bce1999685d780ce34cfc49dee13e36aeb1039ebf2dea92161a1fe2d6418024279982a95a18f73e549c339c8884fd2a8509c7c88404427266e0450fd8ad9cc63aa6f7ba8aa3dbbb294f720a46774f83fd5d4e3424af8363b219792f6203237dc93085a0af29c15a1a40239515f5ef4119206a1f71ff5ccd0e1efdebc43342140da6b607879afd6b8876d15e36bcd5cfc07000ed32394277b59213fcc5e1b53c0c477b3d38cb1d5c793cd2b3129f9a55d39bb82f29f60fa793fc3e35b727b1a6cca0d667c8970f01ace93f5500a8763511db1d39ce7cd6ff961c2356065850a8ed17c3e1dd41214841deae67eb939a213623f65f6ef0efef2ff97925fbca445666480b8704b870dacffb503af8c26ae58c0c5720509cb46a4e357fe9743583fd011e314b89d977709baf629910c0842402c04a4e706ded38b72a12eec44d041902e1441e0a0600bbd7179294c4a4ebefc89003d38543407509ff0936f24e2f12b49135053da770bd09f55b0a9eef35598f93590b2703c3eb08d0ecc6a35bbfbee6d808e498ab8dff30ef4282b60212bf5b66116749dbc588d299f485307b74bc088da49053ad63a8babd3f1678e0fd8de675e423540c846857f21fc8fe68a4b3ee790c1fe3793106645aaf9840f371d042fd1b8db6065db14c536411268d557b030abf4037d951cd00137c1338c214be61e8229788ebe6a45758ae9be12676ec8516854fb463a8d2e33c6f86acbdfbf39faf796531ff417a60c624e8732eb6c04c5433016bd00f3572e7ab3f646aab707aa30871585f0dab580a13dfe3a2112c7503d0ea56c17602445c2d5d1b78ac115ef07824e460a3a1d9aca4922d888a0bd87cdaff022ecef9acf0f45769762b866f2001f9c67dc3e9b0796693613db48192960067ff558c6311684ef7c5f87d938da982e4045f5f3b10abb8a82fa11f08f7a93821786fe3dadf1bd6897167618cf45bc90800b36a1d72f8fdcbed8b0fa0bc4b317b743ed2ac999c9200afb053448e82fe4b0c1b0aa9770b7d7245dcbd68abefa4fe48d0c040c89bda019f6c9de3a4d00fa5226d49856c357d3df4274033f03ed5b9b5d150d3de6cf8a9475978be015256f782df4f83573169ea83de1bcebf7c37ce5c41abcc2f0dc481b264cf0a9658ab7566ce133c09e0d2ce683c96481e7052b5158751d84eb4c9558641c8014b753dc53746afbe241b99963058c6187aa3bd9f40858dc7b64248248f7202e1491c131e6a078bf164f06a7ced64eab1577f5ced8afebfb6cc66e360326378dd68582a3a0ee1f18e92e85c2647a145a8d0971943496763ec0c22617bd300d68a21b7571ff7c2cd675f4af4879a833e611bdca91d8c690d0c83b75f8336b68a362db346dddb1ebf95e6e7f32ba6e9e03c5d2caa147890629dea95bc3a099f607af0900076858aa581178d97e7f6b781980f408cabf310f77f71dd4929d962ad01ff18d1a13a89a231ef3d3e4e01d254fbb843bbab7710ce09cf6eefae3d2264ee5bdfe928212463973a90ce2d842e64803a5197a25d27fb800535258c0f886b345684a309d026decfb2f65d1e7f5951245be8f8cf9f15e982a9f087cf557163f74e716665459b0bea1c6237612cd26a322e45a7a03ce3eea6daf8fbdcf0817898260a362e4ac1bd489e915e4fd2344cd4997667d1ee3f0dd4482d2f92d8eb15cceaecc05aa859758ccceccfd6d355ca9b8a8e371865f7179a021906389d0a38f2fe1c18b958e348dd47e2823aadf78a8fdffc67d532a68773fa255ca5ba90b63eab07466099aed9f4dbd6d4a619448cb06f4973084314e1ce300da4903ad3ab64bafc74420d2014ea0efc51e583345be9d36919c0addac78a42a56d31eb72bc6e3391c3898971cf53453fe4646b00b25bf81ca92bb8bd1d669729557e05c2fa06dc6df30a543655984a418b584ed39bb69b08fc9b8ff66caba34d9bc21e39107efabf831721d7ed91653ae88c21a71872b3026524b351902af1cfbbcd29c7f0b5222727df7268c974f1e6fe6201ef85716dc9e5d13d6b39dce72c8c410bbaebcadb9956fa671cad8c4a3c36248aca4601cab681a7ef3ee6dfb10e372d55568b56b6cdd9619149dbdf561933d09ad9d92e9d51d9bb5a50520cbc2d6bf117559bb0c97eb191e1db7745fc2d3e30152cc9d7dd2a69e4be15a6a8385d70327fc54d505ba403d9549381bd8116427792f8a7e533c920e0155be7a2640a840add0371c05fc0af88c11c0f2b034db13c5e7ed72ff6aab6c00dc8223974ebb6afb86897f7c618f8e5abbee9435de1e3b699db711679623226c69fb7a02e768679de69e4252e69655dee62bfbfc4785c1a70276eaaeb8a8ff769aa8a5f076d61eadd1481f08772e0c20b5290e87fc337a4441870f66a071d922dc6bcb803849615f888c6777e4bc38b2bf183185a83d8cfc82112186a9c0fb892d2c8fd860d62271e72e3fd19ad29fce8d0aa5f1a57db533739525ff54959c5405a61678377f0a4072f64d80d07861e99ed307c1d84c293986e68c87e81aadb13357d0925f7455c155593efae71216b0442bcb5711f50d1618f04834463267de8c459d1320a352d18cf2fc97e8ce8321fe7826370fb320757e24f6df7798b16e7b49ea88974b5f432283c1d93ed44d5c1de702a8c90395d27c16b3edc8a08028a3aecc0c4bd9c1d634e57a700bb29684f0bd4f2d425e01f5ae35a2595b24ad1f3ddb2b7c8d586b4527bde6aa6c3953b46665c4534fc72567b6327fc7787b033c5c15e98588d427b4e25d68fec583ba283a940771dc63774d030afe17ed6c9ae835becb525780067dfe1fd8cb11fb9edc0cd931ccee208eddb654557a451fc5397b5e1d4496bb74a2d9499434aeaf7a8235c1d72d9f58cf1cacd80a1cf98bc4e1409c7dba0a2bac433615d22ac782c09c07d332e4aa302ae16c8de85943de5833a69e5dfe06398d0912f4bf0baf9a4bc6379c18f9a0136656b8ff4d0468df247f1b0d2249946757b68d78cb1ecf6899eae40ce5a125a5fcb8c988bdea03d938d3c72a94138fd1b0ce56829c160a5d6eef8ed3cb5163b9c4cbf633a9265ed124e348686dae1a2695e0dffc4a79d7cfe0ca6e60a618e1cf1ae15d49aa31e948dc20c1bfa25f5c80f64d8bdea09743f59bd129d36b5a5242916be9dd3d7fbf51a30ad82e352593d605f96b8c9e7a602749ea9a2a40aa66c22975e02957c6a7f998cdff4b7d709f7af24bbe26be79e84df52a450e08dd16f1365e4d3aaf2ddd579f5ada3207c3b6d58917369bee49ce3dab4457ccd6b21d5d2c029333deac736734a8a9dbe563d2385921e6b17c23ed5b9fc13258e06002089c91232b967b9bc7990b04a360c0b1183f10e9833d41d2bf6d86b00861cb43c65dfe33e1d61e55677eec03dbf2d8edcca243b2fe5e8eb3f6395b5170f23d0e963342f9dd2f160f52e65ae11bedc86fb50e3fe88755374e39a3cda7e8c95066f8f1108f7673f7d81905e05859ef7b3563db5ee6fb9c6b7d6a700dbee265690e59d17a835443bd7949ffc4c579468ff4b6aa53709c97bad7a4cf50c6bfb0f154f18bd86c0a484aeec402a561020d7e248fe1d9f1804bf20baf2590d99fd5f5a8f1f26df1e76129467984fb4290aa0c4651b44b92b709f853964bf5c846863e14e4e9d6c86433fd435a3b72fbe86641f2eeea18faf74f9f1ecde706b9eb140b0ca0c4c2aff4e98f1426148c86c40b2aa6e79b5af318d2e57e803465a92c56c38a65d6764164455cbaff310aa25f54f66d48ce5f0aad71b5c88c31d617a6aa2e4102bafa4cf6d16a3c66f15e0f146e20281b753a01469517af7d8853318a8bcca721734e54fca947480da392dc5f9b0faff2af38f601be8c53f94209ff25d92e85c08b986af3112e75cdf1682397fad0db4f32d1dd84a7effc108810ef9eccac1fb73d3c257023705674c5fb69ce27f11a3731bc787b82eda4e3f71ff1bdbed781f2208f2d5e875c8334e786dc47fa58d531929dd4888ed6d93596c6afd745b550af3b1d2527e99f0438dddd5bdcf4485032017ef791d1416edd78e1a0391d185544c89172ed861af8aaa74ac3488e9aa0a201805cfd32ea1e89f13e013bc93df5a256d76d46a1d85642478db83853d340368fc90b79758824dfc8ab942eb1efc0d312645a1929dd1ce51b6f1ed98863e95a42d20487fdafff6efabf15fcaf2b54ccf04ddae0eb6ba93e3c76fb8ec36ba03ef7abd1aaee64627c3d5b3b52a35e5b83470cff683c0b6e4b4b1d5853c175bb7bb588f490bf7f56eb460bd8b7b9ccd25cd54248a9553f804ac140a5b58daf3c00de8887c743602115681695fefcea0669f8fcd7dca30b67dfe6320404943c2a0403caa85cc6f3d3be9134d88153d51862dfee85032c7c012600bd6f3afe1c4c939b972792a606bf127c62b0d4a9ad71eebe01edbf8b61e4f054353792c8dcc820fc9d48b5c71c75aeba66ec7516a9cd3ecea42fb517b4e491dc42b093b5fcb91eed53d1eb06f78be9061e5fc9443859bcd7f105d773420f05ba794ac18afaaf8fb80ab33f5079c2438594624e57a43535599e34e4ab6c3592aa0aff07381a6ef17f1bf558c78fb3411d7e1e778bbf9e267b8bd1d9ae52c6bed3cf8936e0f60ee0a6b79e808c408900ed82a89a63cf054471920ff2cd51932a381513e46d418270c9e48c5197a2f2d64382f0ae882e67d67ac7a7f3de60cc335af33f56157cbfc8549226e22c8231f04c1c69ec3a6c39a48ccf9e0ac3d9e1cc36a833c204879077cf096973d277d45679ee5e67acacb3805b74576ffd8454881c8baa3ddea1c93dd44078efb0fb143c9e98c75945715d7115289b4909c075210e5f0eb2da9405a3906306b48e2c8cb61f6c90c86cee1a14ae2cd9f4c0acaf0a0f772e8d2411041257b90167d721301db61a4ffae327ab2df4d540ba2c971dd51f8dc041554fb2210b93ec7e1005592649490f9484b788f3c7e7aa6a2d3fac8a2988d0577f4d82cd2915a06bb37880ccd62d7c7258336455026fd6e76fd5b647828fe697681f325f9be3136cb8ee0a96ec32d6b5d78f26bd74c254d1be5e90b713bd4c3ea366eaca9146efcde73ccbfc41c40ddb4aef700b11a8a5e039a455cc2281ca0fe869bde729f42bef38e82830cf7914013f7d6cbfc0e87df83f1d694156b794a96f1c16f70c07792c02a475c2ff3ef4c5c3e193afb827b878ffa0416a81d4e58474dac1427042281445c7600c35d9f0a5497b707396ad2f12a4d5723b63e8ad5ca5cdc98aae97855cfcf7eae293de0e9f8401f05349793810809350b4cb696d1f003cf5c21974cb38e93511f190ef58e2d41e11855f49095e06b60a72e833d925316f91e767258ce8197cb1e7b01e7a64f29b59916640691e16608657f4b062392db08b1c4dbda4ca9c77997624e31c13237835bf9dfed20e781edeee61d99e0b8fe5147c0aeebfbb39e654cca21b32653392b146dd2bb536f1849ea1ed42b7afe0f84e182a6819bd1b8d275f3d440e70cc56e9778566accff85ec10fcd74451588019ba59817b9c0eedd62ca8bb018f111343a89bb9cb7eec1e16d1b154796438a57fefd521667ee4b00369f761289828231b98c5a7ec7033079f099b87fd5f28bba314bf93e4b452b739c1a12ca9871f7f322ade1187d78461cb578be46ef5ca416570ea6d6883069bf9edd3b3f665142ff7630fb3ee21d2e0129484a56fe8964e8f7d53c5e5242bb630a97e67f89c501245b9e0ddd742a8cbebaefb778d0dc7c42f55442a19ea87c28869c6eb00c7d28fe9e356bc348d73f21751c6aa9ce1bfc652eb8a7038179373c981f8eb4330a0ace17c0fdba3340b2c4904e83b8497b584e8d495e675c8e8a58a81eea4ba501ad23f1221cee67a57f5663460587caf9f6b5e633b887238fb0cb8eaa36e5bc956333912d69298738df47d6f7dbb3221d8a48af841a33f53f397d3d338054b47d7b51921ad0589d75f2af59dda3a63c6d2a27b2b88b343a0094acf86027775a10963904c8053bea3898e515d23f4e85e865ec293af29763bd962ea07cf6ec7ea1762f08caf15f39daa340f7e73638661e2fed4a35a1b3441092de0e37d0a63204d618121f5324c17526da3b210079fbff0ce5b3bf3456ba31763dc888717ed431f65e1268ebb2e03f29129522f3c42df33cb623f653492dc8e6c4e6c6782cda3106e339227cd3ea7477c3f476f48e70e89c7674af7f01e5b5d09dde50d193d80c6c13585fe429f08b4b0fa0373cf5da8aaac7ca8da19087b8154cdec06104f16bac3d1b4b85e5fe285c3ef1c29da44621a239678d170c1f9e530d5bf1d2f2702d946d937563ea926ccff2749b5da5c11e742eaf657d9af8abb4729b1584be7e31c848f319c9d20bc1352d172cd2bff33af585886d9268edaef66042f35c139fb97c36c381618d37f6ed9f3ec2718551ebf681291f5726a608245a04ec1faee19bd5974bedc39e230c865901f65fae76c6d8a5b37cb1c1036d9a8e6abdc3f2357667cbcf8dd9101038931d2f8cea0a0d65e29710b3ca98996702f3171f04a4b0f77a9239e274fb95f3fda5a30d5a37861a00e6f8977773d0e7a337272af63df0e92eebf122a40dd599a54dc98ac66f1e37c438f6b43a1c21e862c65b7dd6ac0f9465b9c53764c957c169eb55702bebb4c6b4c77fb0a0ed0f2bf2d02e72b2dcbaf16cb0bc19992fb6e4744144dd238f5055363765a12d95c09584d622fd7cbcae238c8945216a9ae2b261f3f1a2420ffd471c91a764eb257cb45215c0d64cf2b6d2e06ef4bfa91a3befafaec0a2c2af80ebaa9c95d9997f66804a8adc17e726f51ef1fead21ba5e447f08f48e9a5ddab90cea170596315f535d08a2fde21883b1577603cffb65c86a709288764a7498ed79bf813a3c619338bda3b811b7229599137e4c10308cf351efa","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
