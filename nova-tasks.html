<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f77e6781dc98b96bfdebee3adcb470e53add9a5cd43cdcbd3f1c053ab12fb5e909616a2da415a00542c3987c35f6a2dd40d34224721f5c1e41d4a97ae9af09e8cfb5dc4384a24af0545d65297db14423a13fe743111ddb01180cfba38c409be031f05f0c0a61df3b1a2f1e786c9f67cf445e652fcf8bfdd817a363cf7a9066ba1f717eedc584285b99b8618b92dc06e8cfd376bdbbd1e0c2acd98a5ed214451304cfdbf7555f80a7d577ad73263fd1309c1c433c893a1a9c878ddfb81b72e611d1e713914072ab0a9e3c0dbb14c907656cb3b867582819ea1ca0c38e2fec43e06a258371508f36d4c5b9138abc956f6fa3910439f774513069fbaead1d4473fbe13c5e7782f5ff9e2063409424b3da940bb401c5e96b751eeb49b4fb4eb09faef89816655dc6f370ea8aee06d7754ebc4a25fa31343193f775c879658bb7a37360a52b026f901974b36e1021af195f3ffb503b46b6cb3935b83f09829d307a0fbafee263e90dcee1cbaefa11fc4ed6c35afc9b608a2c69469785d5494a5ff89dcc125f88a8f64f22ab28ebb744945a5f081be5fc996b4db9cf207499db34d10511ad3dfa8756d868c66c9752dff41a84f83936d984f15779f30718ff66aac39cb8223a65d1a4f098102a2d1a85cf4b6c9fe7bac0765e7b0e15d1e23ec8ddfef5f78d977dabd4f639cd8935465404cfb84ccc487b89f14650346133ebe4cf3ffc410bf72cf2ae7d78bdad15f2da3eaf5d385ef7b2d3c9b8687bd0159bd53e99bb934763d63ebb6c7b65b682b50ce0caf3b156f2f7e6b67587a9620d49dbde7e75b0b7a0f86dae90e12991bafdd001c1cda86e831d6c563f271480917738a94043f2b90177e1d6d57aebdafda5e5eba8bb9096071fd291385c71ada66892fe28e31564228597c83f82b390196cd23ffc1abefa701d4edcd8dba7c9cef87787ed62cfaede4e9892c297dc35757f66b3860616bfcb60fc97bd56bb7598858014e1a49a9459bdcc069daa65f03ac1b72cc1c152ceeaf95258021bd976150ccf689c0cd4271fc47c9bc4534d0949d8abe51fefe0eb6c415decac223aa80a3ad7f93e19048ba3d0a14ae248963f9b2e72808d6373f93090eee0cd8ad515d98c6899f34a0c28228b111f1e821d6c04206dc70698d9dbb658cff08c15f7a74f6cb11c731008f14b1cd796148b50f03b736a4633a1b5b1d78b98b5b179b1ac6bd3ed3657d402121ed8e242a84b8d841e4b508d396bf6ced70f4e2834b4527f137557b05a06733f0a7086a61aacf46c7486b0dc7d6a528caf7a82b0e448262f7a9f15f5e465bd74e735dfb8ac708369f94573b1939c1fc13848b05521dc47cf3d3e26ed1921853b7264fd0e8094c5ea829a5adeb96baec87cc3846c3cdffa997a65227800d9808ef34055ce0c134eb500cbfc9945c9832a7df9d031b28a8883ceb72e10a12008a5887a0d3cc06eac803c4a883786a63b3fde3c8f7448ee03d88bf2f4b3cadf4eb47b8efac354e750c9507fe8a1142e8623a6afdaa4de551de8b65da67d4a90c201c05b45a2f8f4edebba642c35ccc31ffec2892dc24f0ab0ca6d6d81e0fee497089ae864eb12496c19df0ae48cfd7abf22c904a00eb7a485be52350365820f4d34220fe02105a99a6a317e2e1b512887875fd81f2c046eb888a364e63608f3df1697ab1767c773a816b7ff4c2ddb160c58f2efd8a5e370f66cac3058daf094e857ff007fc648bd2855898cbddaa267762e1a5ee2c05551569860378bc53ece78b2aed8280937e51f4a10fbd980cf1bdfff5717341f61da547e581e102e538d439bcab69207380c7f2f1862fd73cc84b8bea213b6d5f75b958b5f2271fa30baab6fe61c80e5483bbf51dc8112d58397fe38bd1fafaeb643448c5461c364297b4a6a342fd70ebdc7268876da97ef6749dcd84940bd8fa3c53dc9da6ab7e78a85980432618fa651f723578599cbb28e0739e40662da65dc303af2b523ea78032f7fd709fafd6fdc62b80be6073c40873ee879971b6924d6e2a1c8560484d5d298a833c45738f712c948392ee7621ad175eb8ca741d27948c966da9e45c98e7cc876c49658780a678487fc016494f05301a90ec866d812c99e9624c74f34671af3bacacfd379ceb86277c5a1d00f4bdd99ee41c2babf9665c7930d59adf4e0d8e03b1cdff1ebe5ce2b1a07c982967e75205eb8013817879ca5cdb26ac9d515b8bc07ca5c7266388ea50ecfc3c757827d7939e1fcd88cccfbc4bab9518b4a708b587642eff19d9b354c8e18d7cdb8a95c880f0e4401ba51a1eac958f32cd8273f43a20025a8b8afe47dfff3a3b633874c630e5227e14cf613c9445e1985b55a4d1a0da619e410d551f1ec77495def07ffbc2e3c122741bf76e22c020b568142934d9d49e21f7a780b632c34cce51d0c03ed86b9fba4347b41849a5dba5e4a7e56fb46464c31c1229de8a1a709d66b407c4f76d5b0af9481688dc02d6277e7b4dbe6caba11cb5166ab208a0615e5007cda6e65fcb123d0186a58ccd323c1dba4bd064e82176bc518e5192646d16d1d157072f9888bb9c08992301fa998737340c10da6a62820dbc52dce2770057661dffe6ecfa73bb31c259d331f92e2099c07bdb8814362c08dbd7006fa3da153ac5dcc6ad9fedaebe1e5983c79f62a01d3781a2a0d8835030ff988e5669ca13ca48a8ce745f0c4eafce1240e5adc91e456f6eae5f2331325cf8d7b6fe5c21f3adcf47af8a53ae43ede8454502f9f91e8889a730e6ee8a306574b215371f5bc26061fe3246a45b31a4cee8f235b2a463f8a3fe794661dddf51062e55acea8c22200fa4b0f8f3b695de9302d1580617a62bc6c891d7f451ca4022623b68cec23b83384c947d5299887461bf68bdae1f3a03dc61cecba84c03bad8fe5af5c6b10d7c8956b253644de02209cddbcf211231e0285135159b1fa9148bd4427a180c1f51cb8331c9b5ef8607b17172310a4e5d705a58b5028c6bce5a6101d0a785707d3a64607a3b8466a080951d0488c3814d83048d48f2c69d41220e6ebed2c1501b01094ae594a515f778acdf8f8778d9d1835d64eae3a12050123f9720512c22a33c52cc09e0c74b7394ae52e6b057efb94d2e4a72c845fe72d6a123a963808eeead2718d2fb48b1e04e0ebc48760e5a924bff659908d594357498015817292c474d445c590ab26986448f9fdaab3dc0541308111008f7c92214496fdfbfc811e947ccc14d28f5ea561f72c1621682114f31f9e17dd8a56f99fe20fb7e1c39147d8fb2a805e9485fa8390bf91ce7ceffa4e031a3d06b4a456d9ef5f6dc68fa9cf9c6efa7eb40d52e6596d4b123f47bd298f0b6b18a708a8e0290ce299e7dd611eb3b29cc57c2484e0f80cdea82a36e25ea075807c12154c7dfbc3dacba990b434269b48a2bed5c079966491f89e60a6c71372a1e6f418eba48ed5ae4a0376f0e9323f3a3617948ac9b69beeacab6ccec2dabd4b8cdc240de8ce14392d377cf569a1ace59ef8533e7361e1fbfebd09ae77c64591606d2eb9dd5a787d2ce27f367c2cd917459611990f44daaab6306e5a6a78fc889099dc7393f6d5842b9488c65736878bb279c0b9f2e76c8482173b3334fcb808e458cc4e78a2ea0ea1970073c0e39acf3d23edeb0f98da113d4a40fd08b15cb0adad5c8949802305d27cb30f2c265923bed4f0446976df828861991fa92bc6c2fc6c239a44203c70bbb95cc25650b38e5c662c94edd5b6d634c3b7745d779c92602d8f0da171bb45c274b58dff6434704a8e6695224fee8556fe65c90950b06e6570967622e7ed5b7f092d398243f05e38f316f1d85cb86165b5714d9f0c1257543c8055e02b02979d551538aec31378139c7c7f32a6b4fa4b1e8adfe43dfd514d5565ab2d799322f1e81d2666d922f81d22bf08873aed568a449e9086aa06f19d87e861849b48c4057a14884f238087bb8de3c1ce1263928d98bb14928100f19d11238798f0a4bb1c762b5bfb2e8d0b41bb4c5fc436a85ead918049ac393a06dbd0ae39adef471a89d8d62b07fff98feb8edf4d23195b1007e8aaa3ac52d10b8367a73db758ccf7be08343104211e9da5e5f4e09dd66da95f4f699a0e24bcd6516c3c68b7f6ab1a21867ad46c4e8ca63bdc715d2a115ef69bd22d8477532d242bddd3886428c364b1e439d65bcbde2949fec099936ba8decab82a7bb365c4f5895670f6f1212b4140f4f4de74892c74fdabbe9173c5a7c2fdd3316c217591350515690ac6bea22c8bf8a62a1bd80cb442bba909e0dbce43a705aca9f00d96e889a020e6fb965c30ec43f43e485d9491dbb31dd16c991d6484628174a99225f0ccdcb4897acde28dadbe8f721f1e9d93ede793001bd7c33a5b43196b2d69f9edaf6ec4be8a90fe67cbace95e9029579f409ac7cb7ba02598cf19a7b0b4a7b7496065a0408d8f9f516c2b326702c28796467a82803292c4d5b3973a71a40192ba60e696f70484ba0b05b5727efbbd7f9952ac2119c55d28835da6f6d1ce510acf26b02ac39a07561de297877e938dfbab7c3fff9c8fd036435e94246c444263e13cd01d84fd93e7cd73dc4afaa3c97d5d0f1ba0542fd5a98729461f396bf81dd69ca11834219a5f05bb0840859cc3aebb30402511a6606c1f5eb062fad376ce03b4ee571f8c3357651f539cfe54610cb23dc924b9c2072c3aec98db11ef498dd7c98825520385c7da261c3aca86fb0d5bf6cb9c2fba2dec7d800d8171d2f03934c82ea22771578382bd4711d54c303f3811069985525d2c81f7efc4633731f18ea454414e8e03a0d06fe2e47c4dcf31d2458b3a99ec68925c06c3457d9f5d140b5abcf892eb4cf6085b2438dcd0558a90410ddf82bd6c91ad2ca95a57aab529d33d8aa11d4a66d86f714dfe71e1a235f05caf565baf9e85160e1b68b90ccc24a80f972405d14bb8c4d45f9362019a210710b9de512bada7db5fc8c6e67343c07def886455b8b34ce78faa09804bfefcc42b5f79cdbc52ad17eda502a12751aab4ad6dc669c02da48ffd8c8d4470a410b46e3bc400ea74816ed6ebf136ee839eabb5e5032bae0b81c62f381f47579a26a09dcd5b4629418a92b29ae31fd1a13c0d5c4f8983344759cf605ad00aff37a72d318cae0f6af2f50c14b4b1b5748c4d60231e763df9acf0a0e8a060b7c4646c1d70a003052c63b9efea0945a8a6afa9923b4fb59901064cbad42279abe83087d8285929217e8c30caa60e0c5e273e7e82b031ef9e409598847fa574b80f60a55b01f453fd114f485d16e75384e2848fdfe67d777f0f154cb9141a87c2148bc9e3f969571243d7b4d99eeebc4d85a8eea33d0a42c153da0a8a0e70a0671dd806d7fd83c1609e75822bf4384bf549ad1ddceeeb74d1f3faaad7a3062d16a982487b69dfc30b82addc4aea30553a5f4ff49af117eda58fa9d7108a06ed64108479869aefe0eaec57ce1f7ecc1b353e9f060ca73f0381431d3693cf35a6c6dcfd6cb96f63c979f9f68d47c33174dae9d7bdecd9693e16c847eb78db59742b9262d78e5b1ffcd2d2b6af69310af6642195c7b581001bf28a7b5a61e7abc710d30b595d719181dc2bdeef9a49c0b646ba00a545c31fbcc87048e11c60e12e32b6d0d100717c4c20ad1716f9cac6f844d2505fa47cdfece50dc580f10eece52ce45cd0d4d09bd04655bf1153459891c26b219d2c9ad03d94b7c1c7a4c99bb7b12802fd18b6e88825a6bac87d05bd5c166bca73953ff88b96888925af87eab875af7f0fbff3b0d1f6e055509c473888f7b623561fa07ec42123b7baf76c331538dfe247ef9f1f873abec079b4fbfc4397ed7927c5a2961067c943704533c8fea4cf5512c0f3cf9cfb21786c2c5f3aa48345ce8a869fccaa72046065a58a0c1629661ac24fabcc5ce257fa70b50747f4fc5968f9389f1b8f293a9be16f69be8328fff78512f2d35d7cb5ba9eb1cb0ffba961debdd1050246ce984793285e107259182e8c4a931dcbb7e271b88d40be3d24a9b8157fde9d51a41227124bc175f68e6f2196b9b4c42b0a7af70f8bae2269452efeee9b99d0ab1a1453df79b53ec8b30fdc1a9b3fb931fb056edbf54b1baec832d4e44eff200a3ea1d4d574874daeda8daf9e945ad6475fc5193ca48c49fcea833359cd520bc4846a8787d001e4b173a4f169dff6da9a44fda11893738f434e9e79b0bc22465cac32013b04ab9f20345a811c108da84a45a043c09ed4fbece9739f113452a53ee3409d9531faff22247859aeb6fbdae4e5556ac63452d6acd39fcbc5e48c5f61f876b5c57da2c5d39da22e814f5fc8be053cdc893d64776a54e5b2bcbd1e75e4ac202bf728df27fe74af734e093ea6af614d63c23e2ff3e640c59edea57d2bf728fe56b0c5a6f092e335eae954aef9226d06613390c7f96758aaa66be2f2f492bb2356431f12cfd3051e3b595b84c4481bb92f5cf5e87ef0bcda9b0519f3b8ae21f3f869ff815787b728923687046300815afc40f113a849af85158734d2bae878ae075bfed84c93b5dcc609a8db231c914164703fa3185be6468aba9429aa0002189684faebb632ee609636696e378e4bc981004c55e15c3ee6881407ca698fad8646cde583520ca7ebd9cfdf3a8228e00880fde2269a22ef2af2d6fd4b3c03961f61a6e5165af4dcd0427db0c8e00f03f09c71d901380276257a3b25559f9c427541382d4cff4c99504e59bff615b19bd9af053254b0c672beecae3e5781cfeb9d50d447d6b83d89d17069256967e8508f88828a8227c51ba90dd08400bf2bbd212f2f891a1a2662185e51c9365ed9137a48d6b8c6f96da5713a9efefdbd1a19140bf269daca7f6366828523fe96c37c480d86ddd853d6b1ce03b9ed46a939f3112d6f74f5399c244b5145e459f585c207066c144e0cabbeac336a0caa6541f950c58a2929f0458c6dcd3191d57d243a9b9e298bb29af0b6ea0ba67ddc63fa911a1dd807db21e9f1430e4c7e5d10055e338515ad8d85ec28cdae9d9b6bd44bd5c6f63e0a062e512a13e4f7c44d4bfec1521b0c5008f29074219827bdf698fe9ecfe8c6cd6b7471c1ea257cd604f034b4245bed8baed77eeb9c5108b7dc03340a531c3b5e564bf7c116420642fa862ab12a8e9c0c9fa15b35b7fff662b2e57097060fc41b772a0ccd9cec212cf75f0efcf3fe9512d7c6ee0b7b123c8dbbca6f4dc4d62c3d64c0eb0ea3ba97f1b9021a4309ba6da004251d3e89ed2dcfef3e26f7e766e0f8bcdce05ce9e5f668d0fa138cfccbc5533722689be5312d0afc1095f6b16fea0e28f1c414ba4e83de1b07ceb6f96cfcbb189a2f1e9a26f0b774bdad09c7c33c76676ddd77042fa7f2229646bc02305ab5e825723be79b9613bd622e1f41f9467f4a4ef1b8a6fe77bb6e436cf640f53d9129fddeb184ef57da76c75e10f51fd9f281496a08a7e6a8156620c7a405c9ae90d2f1fd761849b1eb0232edefa36dab85b2891aa8d4ebd26f869b9854a2172f02a5381e2d2814b7204cee89a499af8bd84b9f3809579d18a089a1041325dc8b2f356d4b3089d76414fe1320e97f9507498c5ef8de389a0681ee6fae184e8011f2bba70a40665f8fa2765036273d0c4b243c881d31ae587bd77d75e12a6dbb2c48051d4abe85e0aea4982f3e2c68bb2d5244d5741424272c300e6bd538634d5d28698d343898e7cca8e9b16bcf17e8a25d1906fc4220b70527f8b802843c443309e66c85607e1b25b8a611c1e996f051d70874dff9693b03b4acf743543beef84e0365b0c2d6652fe505ec3da056f6f62f2a1475242bd49a0db38f8148d0df74a0916b9b24ebfecc08b30984628867727f77e2643d2652264329754d2aa2c2e1f8d19c292e118fc1005186c0375a4a2568ddbbff537cbbdc54e3d3830493398e9ccc508b0e30ee065877df9d56d857984be8bea623fa6c95875b53e018e94c2cd794b214eb4477723cefc289dcc7fcc2fe909c6030cd8b754f5eda3fb815bb5a94c818b1a6645ea827313c7baf1595cad6c966cddbebd43e734081e56acad6456e8d1a6869de28a8d6831352d79e71e0ffda7999e47d8cd8e3884a4c73ae7687ac853353acdb4602ee6322a9b1a1971719f26b453379b6f338060f02862f77c480a8b00f27d2d18dd4e539ac5dabff9e0112099c80b0c2963027cf3d58a6b5abc1c8b5cebdeb8c9f71c4eadaaf2ba26ffc809fbc644fef434e03a3204f0590f08fbf8db3a1cb040f323c3a97d4ccd248a1be05ddb0e11e1640d5005d58c225c94b7a87f4ec511b02d292b04b6064e7bb6944139b555f927f379d3548913ef9724fd624fb240df6c268fbf6bdf2b66154dcb349886fdc86a6e22b34c2658ad4a13e3ab9b5eec0b4ba91dc05f4b9a1422e402e16e1bcb3a457d1b2d6797b61b9e61ea701067f45dc02c11f6a52bad653cdb1c6291afa37283a659f5e9bb4edc82da2b7d02ea3b237eccf50027c4eb3dc0481f30e81df97231985c3e99bd5b98805eabbfcf1802b73086cd3dfe516bd2c2635eda7951da2942f6cca327d65fab76f1620ffd954a7e4158c50754687fa01e20852a8c444f449cb3e7990f6215f6058a3a0319f2ada7d63bc39610a5f04471e9ab31ed6093ba3512c3810f3e914c50aac40547a7a17897c94532af0de39579ebc974f9918828e9fee8afd54758de34beb621ef1368ad11ec237ede408c0d7eb71d3e94fe328905ac3c489f3fc541025ca4d5aa31c0f0a0dcb9cc3822bf63a308d351c68b95b732a0d49ec5590f4ead1469e6180c9c8b6084a96105d8e1cee825b07c1a2c328e8704de0ffbd6af4aa561e6e1e7538cd86e4356c53241c1972d3660fc0550f71007a627537579d06ad9cd46f660a7f6167c6a27ee9077aa95d82c19baf8225fae6d01fcf7eae767be2cd27ffc56560fe55c0d8612afa4cb225767caf0aadcdc04230dd867cb9524dadb2ddb87207fa72f4668fcf8007efc30b24ac7db8bcbcfad68c06777ba9dbf1568346e8f9a4570bdb6a33d4e8288f8b7a615721b7c32fbc941d29d6a8f6167ea127bd4f773f0072b65fa1a173e930e9dd1934909fa326cbeb8d52ddfd482899791a8896e4b4ff25f795fd6adae26ffefef6a1b5fcdeb051ef42731beb98035a03595f41d9fe698f343336ed9d811acdd1b41fa039b858882dcbf12f6f59afde2bf96fc5991d0500fe161c5356c4e831dd6b4113422f1901b1814ea29766474c96271c9fe75abfd1b92a2eafcfb076500f235c58819d7ed82606f930063a68bae44ef8b5b227c71c9029f2dfcf2ae352cee97681d0dca9f002392cf87c5773d30cf61ec0c1555f588b002038b446f73dcf4c6a84ce1b7abdafd84e06c0e71b6e6a8c083bd42b30dc509efb780509b2dd8ba84da2ab2f3d0700c7007951a23db30327b0e7d0ee728cb868f04ebdfd14a2f38370c92307e8346e493f59305b2b9eb662d98b98746f4a88d9dceb27f9cb946fe3a3bb62789de1ec4c9d7b59b4ab9e494209a68906c020f84d587907e9cf866d7e334bc79434ff862796fcaef086994adf33607d412e8846435b40c9828152f6530cc941fb3afdf18bfd45484efd97e071eff5a90bfe1239879a68e93f76ed74e27cd1437476fa5311958017dc511a9cb3673943d437e85ff2a502d3cbe90690ea365da3dc5690275e2168a218e233971aaa58771deaa8dc898c2cb7712c5fafa32f9c771bda13f036d6b7be45332da4265febb98c854ea20b26a96c5ca43f0ced7c17a5e72c30929e6f21121198206d679dbb4019673c412a78af1a4db6cc33084faf3d7fae20d1f9c352d675ae45c2bfe6ac2be32806bdf07d4b4dfa0c3d7b6de936228de474c880162c4402c8f19d0d023657af82fbd013db0a6e6c16a88739beca718ee9a1712042c51b0e5a2dde4fa6ca74b827af7858da7dce673f2788a74d189326e6c6c3bf6e98ef839a25932e5316441eb27baccc0f7a13e3a080ddcd55d90c25192b6e7a930f707fd4cbb1f1c60428b52a5b88451242daecf12d67581b7a2e75bc6d4bd9171757eb2aa4208b0d352b299b34dbef50aa2ef54b46fd09c520c2493e0affa92972f191248cec0b128ae850deb835fab3409f20f804e1cbcea6d7a14f3e10774e536b309e54f1424537f91c3a3613c5a77ad892eb39b92ac7104a2f7de81badc342888fb1d964a8ffce8c3e2179174bcd093766370a142b7ff66fb5856eaa4a46e2dfcc4a2def1cb93a321213deb5f5eceead53db8c438ad1d5a2d56734b9612aa73bd346bc6daaa1c85d581ebd84d40b4218a9559f63b8ac76fadd7922bc13f4f0bd281b3e68e49ae5a6ebcbc34d77dd3e42f235fddc87681bc33a316f78de77bde328f754af3cc307a8e06c42bc0eb787d7bb889fd4818cc4fe293209f021a80e277fd264c35061a38f9f57a5f66f049b49861a64c9b806875c668df61ecab2b61c4996c1b9a61fb8116014b28a4195a540ee9fb5b7ad2493eecc21f8b761ce59491f84816bc07bb10f77cdc383e23d750c6f641deed99a51739b2374a70c46c35bd05f9788ac4c74c1b37c2338577ee8f853afe7487599916568bf6fc2202c96ede0c483c51918ef693f8d1882e97742a43c9512199448c6687bdd9a8c8c402f965de5a0f358582eb11847dd566c8d2deaec2f8fb3e3faeebc1adcd761b0b0e443fdf26ece01cce83f30436200cc7f427e44460a2b8311680b096fb8c658f257dd3afb2ff097d89141a45fab50aa9a59f1044d0aacd33f9e881b9b9ee569f702fcc3afac93545cbbd0b9e3cf48acb06605e2a399d7bb5684a6fdcb922e73aca7d89da570c9da61fd211519e1ea47fd3bffcbde995b2ea3748f03a77935b5e235dd710c2ab72fd60369d7a31a61217aa40448c6878a0e0ce3f3ec7aa37a97054474f243ebcfade6ee519051fe1d656d98c6dc7e883ebf0e1115171fa327901ad93e63289f9eb25705d798a846c8ea78ee695e8816acaac3295c8597525a1310157d2fee505cbb85d21170e9ce3d6b01dda716e5021482822b6a6b3e1a2e151580a35fc57b2b2701c97dc48339e5510853adb089bf2660012db91a8e75f0e39c71c5bd4ff6f451366ab496fb7987e53e6adf762bb60e8a1da3ded237e2dd0839bf766dfb855a3e59ac50467fbb5a9e9e0b8421ed881772118b57c5415e1b31eca6829d1074d7cf8ff23db3ac152c4d48cf4611a1b2d6f2d7da465d9b9ec8c5b8e9fd84ef60f72f6c32ca3dc0ba4d29f35fbcd37416d6281637af4d8bf2a9b111376ff8aa27dcb1c3a29002a3d9b10e91a0f22a5b14182b88ac0dc91d765214cdcfc90d418f62f7cb9ee0eab7a6e50a1097a1fd72b6ba5bf69feec2be24db257863e1a8cd0ee7b187770a123663a577214c15cd8f231257174543e406d1a7c0260da6f59c42604a1dc4a1752d480bc687158c16e610e7463c4a75f665c0cfc6caa7b9738737d0a329c2fe0394e51ebf9d3c0b59409d90279aac486191fc6961dd37615157c295bad4a54d85719c09b717fdcc2891db6bacd9b9edfc71c6d787d55cd198e3e540a013023d5912d8cdfebbe54369bf7b0f86b412ad0ebcf0dde461a5e19c5cd7f8f052aacd890b84dab77ea5333881a4f428129f7ad2fe9861793975063bbad21a9799b5513224afc1083e09221785784d181f34c0f1c5dfefbd111155cb92b5b1e1cf4fcc5c2613aa554ec2f24e179cca87a20e15f2ea7badb4cdaf0185f502ebf540f4beac8fb8d31daa937cc5698ab3e0e8089976d6a4d93f76b1d0e72f1c4d9588b747203228a5c900156bdbf6643944b9920f088c8c2eac4e1176941f4e790af646d239f294bd130e492c3b08b7509a329307cfe0899872d72db32a0e2b0b00de0f5266a037a5cd22463ee9593ca53c02ee1e7aa1bc83719db8791efc6619880ff8ebdb6923e1447a9e92eae604f98a4ef4b8361b2dc103b0b3bf80ef89d2fb59a0c71d7bb30cc7f4dbc11842173adfe35397df402c13393452615ccc99595d9bd45cbf542e6c11c9803026c8bf2ce62e1cb5de8dba1287b8c0e423d67add155be0dc5728c831f68d5395d72cce4c874416df8bf8686a9799d5e157a477f8da9f7c26b1284239cb7986d22e2d3ba4d313e0008c8ff6aaee26ebc9bd8c29f476d7fb68f565536420b97ce371791833248b3daba46ca9f2d68fd0b53905ff810cb49b6cd9bf10c2b7ce3e545fc57ec4c7337115e5222d200200414bb0b89790151532860ebb78764947672ab10f02301313e214d0e4dcdc52392f43fcd6c22d0a9283e5f7f51aad047b3a893e5707ca37e0a53f6b37a55e607ec0a8d37922f81fba3a03a5d63c24982e93a22fb3e420a3cc1c32e90a05e1d4d75030f85735cb91a1d090c983d6ff7539fb474d3216d4d2426812a4e42e1b7150d80c4241f8a31d9e32af011d4e3f4f05cfb8e8c22b30d041ce1618cde90191548aebe7a9ee8120d34928fedd512b8276f3b96ad369be6d069d8d34c4e38b2bf9b88fd45b110fa9305b0f1c9f2f52bc2a9737dfe54886faeb104a237e414fb2a6c2ead5aa448614481e8dcdb2d520335b01ef38ef3a81d20b7c70f19dc44f916c6cbd3acd9b11d9f07122abf28cc1e675ab3f10669bf237c89ade14a96ab732db45a8911da01dd77f02b70aff17efb9438464b625e352cdfe0f71b503286c48dd5d23497260ec7e61df2ed83ac8fc6c305f23a94f3148dac0f0f18e71a7b018ae47e1586fd5e8eea7344d9368bd6590127bb86270d37d896a29c63890e37054d5ccf38259638ff15295a9bc1abba700d13534907f09944bc814aa2984027d3c8530b3155b677da8b7dbc02d264cefde0afab42d671d2cae21d2d4d424aaab8e5e3ef3e7cd57077dd0840902c9efb2e22c464ef872792844bea50621434950402317bd0ff3c4a5759d8c5c01737b622332214f5c5b12edb845a803ca01828aa20bbcdaaa7d12c86e90cdacf2f5ffe731145e7413e9edf2bbb52d84954c28b2a383599bac885855143881504320b7b5e94d50e3bd52c8a4b08cc00bba5b2b069f698fd7eb3fe16306d945f79fd9dd093c42e7e161ef9141c12543ac2c54e6cc0ad414ef062e88ad2f7249afb8ad0fc77df5109667f927aa30cfcd59f979c8e597fd431485dc843a1c2d1027de35f7103de4d3000eb5abecbbfd95f045470b05e8528f314bffaefecc052256410d63de86cf28772df114c906fd142efd82e2ec2a6557c888409d1772522cb5a2e53cb4fc995e41c78c155162afe4a62edaa33598f162e7aa800d77a13a0fa8bf9d59c3001c7285128b0edb56e9da6fe7605f88329f1596ff17c73623bf145b5a14665422410deb58ca3bcc8ae5adee9ff4bd951a81ecfd68ff6c8896aedcd78d3b0dfb7b16b489ff5bb168abd5fa91510f21f846165d90f717631c49a0a9db0e803aafc4265686576683dd11dfa074cbe1cd5e0d27ec9c0e98fbe1064c3cdb9273ba2f0d0211315a4a8c28cef2b083b72e8ab276fdc52b96dfefde30717eed223e39361c7e5309e7136e346d00d116a6474c6e1d8f1956f712fec8e5638c53689912c5a3b94f73705dcbbb917fe23a08b9aa2db6cb0ee4e00a68e6583d412e057c6793c596ad4c161e589f8c066c43c99c96d354e64ffeaa86fbcfe9325aa3907a05900e7e5e8f44203b118977cd3a140fdc34d363c34de6ade8b125f1139194dda03d60903f86250cff9054bc9311d548c3cfe920909bc6001937d1888c4890899c8a7347d640e5c82f67df816ee467dd79f4c0aab5753f268d05f6922aa9eb2401622df864861d5793f9ed38e2086f114a3ae3e899dfbde26b890d7fabd1f064f99bcdc3736fdd9ee92f66ad6a9bae08def8f59e26d7198d71ed1d656f3c4b20d4d36a07a08851a4c951bc32c8e4fbd934692815714877f7a0ffeb26789b6dd9d888be83ef2dd842b12644382a7fc78a72ea68f5ef56eed2cca6071efe0fa62732f5db0ec8c7432908b2017e77159c5f69e9e35a7a857af2ad2e56dc40c03a542404a487f22681f13f5f766fca6121f0ba308b46376b36cc43b89a29fa49f47b0586435c8cf240451379319667e09a3325e1d8bc82d527b44eb9de82ee7b06de68aff4e9115aeb8cdf12c36ab29438310e011451ff05a996e09adad3e405f6882d3a85138d2d5841453aa4a2ed967404b50b1214ae1841f8b9d128cfaea10af31609a46db796ea20042beb4c2c8ebc66b5ad4d28fa1cffdb340b717e5fa98b03aa5f6e783c39c11f42aed325474dbbd14071ccbaf157a9c3d9ab3d52f89698f4285042746c6ee7f8c3a8cd1e4185af7ec605eee567571bd1ac98e10bfd8f2b2eb514edb3c5438fea96f3130cd55019e123ac8910183e9991cac96ca23db19e5c9424a89cd15cfcbe84ea487d6db2e52a0979ec1f65b163c8d1a8ada62b2c8af716f0fb05be31a06680106b5a6dd6746ea3cf7b3984126f0ae0c2508542c0107f196c096991d6","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
