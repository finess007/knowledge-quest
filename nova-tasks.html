<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ecfdc4e7cc64ef2fe4a1127c88403934a1b6b3047d8d0be76d510649c8de96cf34975b743bd8e25dc1c1ac678454237e43a24fa7e79e3ad09b85a531ab1955b15e68e5338eb1d111522455460aaece33eff871cd2e5b139c2387abd097f4f30cdeaf9ca479060374b20b4323247b428552036986dd245b5a315d88fe1b25b43790498afb13a0962f4e875c88f36116b4e64a5adc8d6e31e17177e42cdd908fd018e1e6a074c16e17a9ff6ae7b4d29cb7eb463c87da9267206b8d54508b4e36beb46b16256a238453c192566744b66867965e545f077321f64eae446b2a468f11dc3e0c9d287daf6f8fad78cbb5cf4f9a06f99eb2fb7dbae9a7ec122a28dfc91f3c4470f677c7fdb03131d4d4734838848db278865c85d4e9877de50620a576acf047a0bacbe4affeaefa47585f2d112417c739456d5b49e229133063fbf4c5b35a91f66d6538d68c72e8b7ec87e2ead2be28140d2aa850671fa5ca82f9e84a163728c212da59c3f7ab6cee3c2017a4dd0025871ed120c59815334e922b8af7649821eee872c63422e81c077556435fc8cb6cfe83d12bcebc3dfae310bb1023278beba39346baa6ba91b6afe24fc18747fe1b5964eaab3ce6b39958714c76de964bfc167ee31271e86c076b4fb1c99d6f0814983a4c6263e6009488c6b11371327db573d9f58656d0e372349224bd85362835423f23b3f2a2ac7356c37da15fc366e390a632bc37e1e865025f50ad388c05703c48b8e58736d53e4bf76c60f688d73a8ad110b41995818448750bc69b2ab5ad0e152e19516116f65adc4cc63186a552830a88237ab144d7538b7fd71f4c2a2c5adaae69aa873babff180848790cade2bae035ec73a25015a60320fda0f266bf81fefdeb604337dbeff5e0135ee3a60e20c6becb978acf58d1340a65de0179b6fa98030e90306817c61bed17e0cd7bdfdbb462370a039f6823f94c69484f7c2234a334c3d90317695f0436e968f56059542335123e555c6816d8b38687748ad6e45c532e2d769450aaf504ec798010bd6b4bf3c299c5fd4d7f0b1eb033ebc6bf5752a726084a62db35be455faa8050b6cace61dc8e9a36e343ae54513bb559a613d5e7a4d09112ea4b22b4c5e85afd7f9e2fe91455f4c75a8f41be1003c48316382cf65e0317c0fb0096eb707f2ec7d367898cb2b092f74d7b3290fbba9e53875547c90abfcd3c06ee00d09d919b0ffb4b5b7d4fc63ca56996201276760715482304dcb511be881cb2458c43135e8428f3c3749cf43339ee15efe11d53e2cefa9f0b6401324bf57180462993933bbfbd7a5a050976de45f973b469600b488529bae1323f71b5f70d5134c6eaca6201dc9943cd148a83e1e3a865ad22f6f1cd635819ca305dce31484f2098efe6351f4f269a494c8e286ee700ba84746bcc7e216d8b7ef10f95eb35ef562854b80ee2e6dc0b88f5dc7efe9c180837da949bae148747cfe7e2fbdcea9cf70c88ecab2400ff981263c7a82147dc5ea4a9ce360e7962b21a2af890e8ab1e8622966adc34645870bcbe775330d0ea12f23b064d6397109118073dafb2005351f7b41ab963bc8eee26482232a22387e9fe5b099e9159d385453d85b3f6b7d84f7177bb8de33c1b2d1fc9cf658cacd515b0e31a41e02aaa8c0dd0f28874703343988b2d0038745afb2bca92dbd449483fc41125451ddc03781b282ca301579156367199b142611885874b7f6822c630bb49fec71d2db4be68e084bf73354e6cf0483f940ec6f805ea9f6d1409614203fb8958a15e69b39df83cd2323637a4c0845a5318d44941b311f65a18ed9912cd242a557b5502d93d9303be954c29161dd253ee8cb8d6e7032bb75d1c7c1a0d44c9406a61030ea3e70dd022a81a7461d2e93357cf3b4d91128aae079b1a545910a9cc2a764a09005447ccc5004f9b503a90e6dd6bf680b541561d27856b992726db902e64b33feaf92846dc8acacef0ea1735ca2231c3d5749d755e06d3d62728f3cdd4069d6842ba5f6bec0407f59a347cff20405093a5e065da6027f5072366a563957306ac62d1288057716c336c54fd4f0cc9e50208c0cb96c35c59744c3a79fa548c49cc09bebc6cb218edde8d20e91191626115d31e05852918da6b83e19e835205d7efbf11dcb08f9c29e47ffbf0709a51a1c09abeb0694e5a32488b2a61d0246ddb98091f5daddee840f528d48fed59b580694ee431af3ee04b2c3de7eaf645a804482d89ac945f64e766c99831bb3b8e4f1ad9ed445c62b9ca21cab03b36e4b7fd353ea11fef6c1e08b43a1f199b57b5202ec319f7c1eacd2f0e8ab9328033a0736b22c451b879a21884c8fe2139e42a975fe9e7f249d0f549ad2f8f12f4a5e26d46faaf1da0da7c6131a3dee37e7f6d26df379f6e6ceb5b613311ae2e39f4d55780c1b87efb1fa0db355fbbfe6c5cf539e67779dc99e6ff8a55cf9161caa4dac33e0409115b2d2f8006fae737cdca6cbd613d5749715f2fa12a4fdf5d7739b70d2e7a602e5a9e7eb14701bbca8de44c3d2b4576cc5405c5114f62d03cdf92f08f9d630abd497a14def244dd7aee8812e695a049ad227f3efbc06e5154276c7eb4e5a96b67153a78d2af1340d2e1c082f3fe9b68d8249ad9a707605ba80470df51f3f0cda852c0ffd136ff63dc052f4ea8e7f943487e0ae1555079787fc15632d67568e8097a517f5e16bc1e9b6336dab779c11969b5c3e2d341933d9d8b27087d04be0398b4bdf10e0eccc600ca42b0e7c6321e70efbb5b6469ee276bccc6fca5a97cf1b1839b8973e8fbe75bf0d2e163b416f62555f8a435ab31ffb7d01e10343874fb0a19368fd8a02eb651c7b9d370baec55104559bcfe0d6456116388ae0080005c8de4a642ebc7ddd50b840cf7090d296ca09f983280f29896e8e2fae31eaed688622a6868ca20f6bf978c65cefb8185ac72f80d0db826c339220b6f639d9729db9ce896ec71f867f154eba5b0c98b094fdc31ab6401b88a5c7c55373823c9a4980e51b2acfd225b327c1ec7580988bfdae49f0ece4fc124612a1a6962b1900d7ff3d5a0fb13e8623bdd7c8045d476237016617d65d3e4a464ff9a91d662132316b9fd51ddfb066db85077d0cd78138792b3bee0f6f275002ab2bf7f3ce8bb3db58dd6bf8d6a96444eb1b222a4473c995ae3504bde3bd92d4a84031381027d984615d8bcce1cfe9ee572c9b3ff11261c7a695076600e9a6c4b4655a2b538948b4eec0595577f3ef2b830f6b2205affecafbdb7843603d5a6872045c7e5734bf5d0d767929dd85bf193efedb086f9e38886dcc774916a7482633b14d100e8d6ed7de7d3ed64418298629dc60cf53539018f122138b0d7b78b117658f178f3629704d7cb86ea34f0e22fdb775eb2edd0ea240bf11b75c1521f0927bce6324b863cc3201cbcef46f7e8d21399786cd7376f58f81aeb8fc7a00b6fe8f95408a337d46d4884be4420e15420e70b31c59ee301b26074e918f4103ed8323d74b27d6b7e6b41941a7ba072aaf4ae79a9684cdea1abf2c91d4c0788d616a6d4623019fbdbc0fe009995df01f9294c5d9f69718945f208942fc5d6ae194c8f11ba869fa253d83a1f58cf3fd765526155808a125ea71f23ea42d3d1a669c8f309ef1937d9e6816c4b9792aaf409313a2dc6af15935e7a07550e108e481be1952c31e5504a285f8c55c97842b1ffb6b9366d62f2d5941c4daf4bf50f2a0b17c17848532554e24c9446117d6d2bc74480f25f65e61b2f9665a935ba0d3419e94c186df80804230b8390979b0bce7c9dad3bb6b1c41c772e3bacec91200f5353ab9af1a222f1b42fac3af8e556b872aef686938d776e14003942f9def09dcf349b42adb4b041af334cc545415fc4d697d8e93d15acbae5c665acd6cc5a4c8cdc3d22d175dce5067614bbe73b14172ddde4cc9a6ddabda2a4e8a29286a5366771b4a5315402bc9caeac8b1ea1101ade74146dd6f279a7a65c25491166856ac3885efadadb664d67d59b943d14cb005a4d3b24c5e671b2393354628215320954ed4d79917b7207c5fb1845a8bea48b230d2de52803e3b6ebdede4fc2db8e740824d9957fb765b830552dadf932f0d3e819e0ae3f026f2ba3d56114d8ef66bb58a444e37ced0bcdd722362fb94496d073d3518433c04a9991dfbf6e87258c6939f7f4f21ba7494af7d7e84e1c20db8457d7d4f7676de621fc07c8be7fbcd433ead17e05e1531262090ba23b280b518a72b7f53c5535f766298a798095b53af79fa96799f878723d3618cd5bcec1f879edfaae29389c285874f826bb10d86ae7f5d55fb0486eb55d7db3aa2141142c7db37a0b3fb444e49ebf4b3d2346e2cea0529652157c1160c3061cf829d78ec89ecf31f326517bb7cf712bf2441928745b97fea6a0c588418d60a673324d5763055f8914bb3b3cc3b59387b27ab5160f80a2f998ba52ef7932a587aeae9cdd660e99aa5eb43cdd2d591b881a92467119ce5212b23d669c02351eeba838049383869f707d076ddc1065d18300743659a8b7e536be7a2b82cabe3f584fa8bff5bd32e0e3c24f81b7943d61931149d73f3ea907c31d171676aa096542b3cb14c5bbd2421daa5f6d07505528b20187ad92eb08e7ce2120576f981d9706142a5083b9cbef94101b24e8d3f6c1c70eb90d1089a16189da11ffdd213aac3a99cb27868a10a42e5cfb13e26533eadc7cf0ea5bc59b569e12ff8bca5d4e30f362d513842ff88064205f635bc4381506a1c9dc10ac3aac4560e0537945b9974cb8b9facbd5893039ac64c35b67989edabc34db83bafbdf7266e2e45d87221278527aa801363eb211d82ad39c65243c263af0911fcc191a34dee9cbec7476f04aa01123230c6fb8e778aad462d0248f570b050b41ce94080e7f59538a9ed9e460ee71522840699931c42c8ba472c542e362a808f5730a592945f2c18f68213910222fd3a6b75275c81b0c847fd0174e958261e53aaacd7718b7c277a8192f59c3306baf3738d423329855dfd0db3e18b9a214ed07777ad6abc02c81621ac74c85b05fdb30c6db9cd71e4f4049546209aae8c9ec1b10b0d95bc40e880e955cf76401b7684d1dbba47dcb3ec76c984d44077cd78c63021030289fc6ba442c70c09059c2855c8d6895e28d590960f751f19668a7aaa5ce3e38e77dfadfe33988aba4e413fdcd6d8c251628809a92df2056589e5f04534e4af687e1ba2a0ee89c17ff04dc0135c01a4c948982519405b2b632c9a8acbd9f194b90d1ecea36a2a6384a2f8b58f47ecfb9c76ffe3dc5d27af77519dcf6a1ee5b177a0533806e91045a9a656e9dc74c1835c2ac82e70acb26c68444598d373275a9f6609630667248d33cbd26446f1dab5866f9b87e9ea8aafe3f7aa43b42e2431e8e747273e5dd2de933b0946891267d9f7a5ce9b5c2e58b9f3897329052840ba8ec2dd79f97d45c5825bdd1754eb7a012286772ffe33bb3838c43957e641b9302078b7e1424d1851e04ae54d3f5287d7a7f7cafaece1d97592b6e8cbf63e87cf1f4237b2bc4640e25e2f7559570bba62a2dadbcfb42e5674c7f013fc9cd2dae769155a112a93b8efb2964922c09d55b0e5112619f55ea012d43ab4abd23887240d7f63faa1717e1986c87e0349dfe462250911a9f1d567c67d3ab317109ce9e6eafecccb4e09855fbb02e0ccbdf83e9b7ce50a40da078b5b2d34cc962a2017a59217c481e892f2f591342419c741811c2324688c11343758a8dc24ab9cd7e84a43bafe1d9ce9de6d5daad47fa7e34964e9347b55b0ac896800415cbde25ade6ac26894dd0f9943aff621e35da9f4352699df0a75e0dd1e882778f97e264cb65d94ba2a2e6d3225c358bff31ab64862fb8c25651ad8eefa505c540bfc4f0dd8f9e924a92efd10ce04bd8f26a4db2556bbcfd88d181b84f39e741ae6d308443cc34e809b5cbb325de1a92fb00dbc4edd26226d290f09b96a98c2b23ad885930ecc6704a1b9134823cae7f44cf32a19da5bc1496c633d31f613b5b9106e8ca8cb0f4a72a421e690d2797c61dbb9c841532ad8924f069472a4e248b801562065809deb90b8efc532b1ad180279b2f876fbfc8f9f3b1ef4963bc5f139051f09f9318f79b411914b8ee590dfd828938f9511f449c373ae24d8774fd2cc8eef8b7fcc1e379f868c919164a879b807b4a16ae30f51dd1de1e23308158b484fb536c1a63502109fb28e930d11df9e44b66e34991bf136ccbb2f9a2cb11b457efaf8aa8b222616ac0e603cdcc9b902452b8261d1835c371f927651dd20a700c1d91e689e63e40d01a4b5ab1c648f924d28e893f5f4198385d33f0ce5b29f023ca06dcfbf0c30c65653292680b2a35cda012498070f21e8252cbe847a391208e854636f952ec9c9b7c14f73270b4624f8d87e115d1fbb54067c37ef166c2350628fcca9826a1e021c016296f3ece6a7707aae0ec49c614d53f7945e1207861a844dad4912b40ea0dcc3cbcbf2c486f9095baacffc4c837bab64d24b51ed1f9d2c230bb8a7a720f7c11d646c638276aefbfd64925b3284ac3576ec22e9f8b872e931a3d5a25bc1bbb31cbdcd76060e6cf20dded19e425fe8290d220598fb5f20d4faa5240c0a9e0b286bfdbbcce274a040a3a7466085a6f8858b698ef7372799117cab88a363c672c0ffdf6d2bb9697975439d6321450cedc160fe4ee0b8e09fb43d679f74eea9339c698ffb83ff42798858281d726e1030d19fc86daee299174cc48a3972615bf8be468de493a35992dde15796cdabaee0279f25a501c2bf86c3f60740afaab5389960ad4d9f56ac8d99be72e8273540485e220c1fdb8b96afc6716ffe35521d2b14778c752a30ea45272fe2fcabeab6e38a8f5fe2320fda96febb8bf634c95656b5bb08306beb47e5472afe4f289c9f8136007f85cb7565fe5268eeac3cca1ef2a5a50e5db7ba1182e69030b3a7fc5f7186615622bba451dd201c8867f16250b9f704dcd9e1f906b4fd5eb35acc50e52f4da5644d3c06a39638ebeb6d12ef0fa5067a4c701ad8d27e55e67bb0b6c822ddefada11828ec72c66f5dd36a65c63c9f62262f3d38336459d1b4e97deaf3eb88ca5572c36e7e33bac7ff18becedccded54dd261504f3276517ddd2559608ef46811a7845aa70501352ee0027ce30d54a24dbc50ae9082b8d4348da4b53ad5f13daa27a3b9b6eb4d4509639e7e68f632577b51637b2a35cc9f3072a0037c6e9edfceb60d9bfbf2d695bb0fa3cfb5b4fe7c49806be7a9ba412a3411e659844295bb8ca4a144ef5c96a0f2fef41f720a367b32550b2eb53318d8234acaac71ba0ebf16a7f8da9161647f27ad0bfee27bced6e971f25cb4f0fd70dbf83c03a638590d2207ebf03f5cc7b3ca4b33ed1ffbefd8f7f30f43fd758f75420f01f733881ac0d414f1040af8f837a0a0acc0798bbd9289c9a058fc5c964dfa7b2b66e6bb81854ea51d5627d7cb89dfd8c1aa772e249c9b5deb9ee48bb75c55dc165990decfd494e30892665c4c350a0038274ea05f12cd57e3679d363f824fa466d12cf05403276b9afbccbeaa7a7986ed81fa9e57cfd1c7c3fcd5bee070dc695c331c28313d1aec33199bf39d004f12f35419f324e2cbaecea77b7429d8bbe7f93987103896fb15f7e5aefaa5d77a6a8bcbe593b755c98739b61ab49100dcf64beffd2b175a6f3340e89e7e4bce76603501d9cf2c608dc02789554854aafa20b7bb73df5c9df8c20fa0f6224a603f5e246fa57f3dd9b89b19080c9c8058f5cc9f5ec3712815423b53a62087182a6da63a6c2ec56649b6f2f53ddebab5b369a74534ff80f9cdf033ad66682c1d4101a3520df941f4b34880aa16d919060bdd498f9d36720a00aea24ee14f817b5cfe8530769504c209932ed63150e30b1d72ffa3de08ea8815d83133e97d3b06cace4b6c286e64dd2f8618f35723889230719736e77d9018c874ed4bee3951565008de702208bb5859f3ca8cc30f65961630ccbbe15bcf6829086447411e209ecf061fdc61d5412b8d13c4929047f7adaa2ef03ee0fc83bb767044d4e440b5a63be2a0a9b1abd37f8987e6dba16222d5488de026b0c7ca4245dc3ac890f904768079209350dead2310cb01f3b281f05cd0469f09ad96fedeae02e2cc7c0319123d29a92ec19de93e50cc40ca2267ec17f965661042fe6dae31a3e63fbc7cf2ef827937171adaa82716145881b3d8af8e156aa642628f21d54a7fdba9e0cae25f72126dd758a6f5075ec669286bdd1e79f5eefc5ef65ba39db48227bc72a08ca833ba924be99a8846e79ca6c282b0f62f94d4d518e61688abde2c3011d31e6bc39f1daa725ef41f53ba2e766324c1f790776d0aade73b8847f84ed40f1aecd88e72fea0fb6b8896bec9b420b76ae8c5c20799ba7a691b52001600fb4865b226fa4a07777dda52cfc53bca0df80cf5c83750aef9b5d5625fee231c549c5243c02a6300bafb0fa1009142dd3476050e06f908a4783e875c78e9aaf765b20efababfb2af2b85fdc0c53e17b414f810491a7e28bf1d50d92fec6b87f3221678f7cbf208b49915980cecf61b42736181b56883a093688c524912d948ff7767ebb27c3e899ef0386e24284488e44097c551b7f8f2a890cf9d7c7db69321358840a5853b514169831effe800dd4ead480a8bb444bae50d81dbb19fc9ac3ed0ad49b7f0677b834bb8c47acdfc7f2686262e50646297568ce9430184fa30a63baf14e03a34365f26478bc6f1e00119aa5b12d0c7387fb4c8974dccb5cf3e684c111230c32523661499950c95e28f80c5da7806d5aa50dd37613caf2d59f126009f58138798ced1ae24125424ae21a62ebbc3e4d08820ef16bed319fbf9334f671463fb4efb904ebc43cf2df4e811a68cf1c548cf7fb70bf83ccc0e9503bbdcb9ac923d6c60f048b6ac98a95f58ae3297401fcfda37ca28b078592cdcae07b2ea4321df3510055ddc3c6c803fc6386ea9091db65ad7225772a02855ef73d96981596ffcf0cfdf4bc04211cd2ddf5aa7113c5f6a573952c1f34ee4878084dc72f6f3f3485ad11e662eb1e18d396082b6acc55e9a64bba7ab86aebf78e331c8414d8346fca7bef255cb3ccc27bacb7a1aa44471d003fe9bdf54542bf77c6e23b4dcaf6502409ce4f6c50b1a98269a027a4490aa9e5cd63211bbb892c0df4840ce486d855c762044260f556945171a4f9ae310f0399d7210e2f65a0dfa0bb77b09e235306c5635caba542d16de1ff9c3210246446ea1532c472af65f6bbe7c27e5fcadf3cc116d8bed6bb8355c79d6817c371dea4b2e9a00e68431caaf97bf997110b4020b73c5f76f01f87369843bf502bd08d28c488cbc6afc0b08ce5b0d0d28e411fc42ffffd90fe581ea57efaee9f09d127104c6ee8396381bd44ed4b98fae5d2a32d6392e8f4d70927f7d68db525f51166e37cae0db33037fe52fc61546b1653cb488c20c34b9eacd85ce38e9d6d40c933287a69a23ffb7fb7896ab15baee69828f1c6a4bfbfc6a4c087a515975058f0432f8af3f1fda5ddb393932b145eefd3851f0fa50d4adcc151bb078486698a4d904f84759cdd4198e80b92fe02dfd032524d652ac63df747a6d50e07a0ce0b15d06ddeb301c3bc3a4b8312032ab23c2ec9d2e508258ad9d005f57cbfb74883d83e4819b91022719b9f439eb9d77931a9a00901910de4eeb92cda975877fd3977cd2ccac06a7bc9da96bb8f405c443d4f5ea5fd9c88ae3d58953c6ae920754c6898c3fe0909d5eb919c9d6dea82964fa30b33462f589fb537cac0396a488b503db2db7c3277d27a152342582e0f757ac8ebd26396a2b80c5799c5e85e3b57c5305e7186a2e66379cc6c6e6395a89ad11e784572b8f9c9661d8f02fd6e0fc3be7fb591d814e75a571eb6a287a9feba1f44a4a6bb5747193d976733732b0cabe11a7f8a4c37baa81c2dafc9c64063692aeae53cee17a2ffaf80e7b54dc463b1d2c4dea4298985c4fb16e5db6f87511983323105318dbe0ae1e22dac9e647672f3cc79be51bd79f72513c8346ed242804ac800622f829a4f4c2982cdd0ddd275b00a81d18d38e40bd12ce85a1bbff5e1396ae5e67722b0b866603d5751405ab51a71b4dc575e3292e08c449ab3d95b3647bcce6d15a1c62e0140364629d0e01efb1830dfc191d720387fcb8807edc4441382738fe3c448801c3033faeb6419c5f1e36c1385377e5e4a627348105234e96a9b5701bf908101cb0b812cedcced3a54d463954d8922f7336fd6aafa7342a362729b637bfb8ce7ab5e5f5c5abfa3af920b701521a18c750cae09d3c9e48cf23fbe60701f36c26bc8c6b5cf911247fd1858be2a95782a49b094cda15bb074899aa9b9d46f97bc1c8da108bc3519140d522357637d1958cc3f55dd57f9a8707a6b36652f52af50c34680a7c1dcd90371e3cd07011b150cdc8030f75d514844586d8c68928e58f3427eed105318a98ca3164dc2e7425f138f626b71c3dcf5acaf68eae014b6d05017cd79e78119454d54507a7972874b9494a8d4ab26353f3a38943861d5c4749ca357d64988c1be7845db19a17d0244143f977aa7f19a67b0f0b413fe510489357e5f9d3a6e1d93e091942e4cbeeb73fb860d721c2df111845d0ecf2260570b4e86659f282f8effd8003ac1a6a4f0500ff072f74cf79df94ee8a10769e6c161098bd79e27759a7008f31f05912219b396757677d00b4a470109322d0a09ca99075ce99d78629602613c6b765ce0f873f6adff7a8f77c80e533b1bc58d55baf0a5a34dc1437e8dc8af29f82f18d6bb5f1e35d0bdcc1aa9447db55d7a7c0d3b9be66e94f232ac422bf7f9fbcb6e94009f4dc6f39172bc32404d62cd224b65157cc8823b3aded4d9de0f7f39d60634b4638e0a423463d3205a9de3c7ef191980b507acb8f45ffce508ce2177fbd6f166d9121a02463aee3e354d985604576cbe8950ebe3235821c90daa4fec5642d2f211329b4dd9fa2b6a6e49d3bc1b881cb40efe86675a72110d92f9b1c151301016cf9bf949b74011f441cb490ab010da14d85ade19e1fd604460435c70317d9a42a43d5024ef1cb7af68f6d1e50d63571b13b5530e6c1d70ddc5ec0858dff4054ae9f2d2bf1b32934a68d85b40cfb13b3219c5fa2b486430572af8ba3ae8150af72d53194af60f00f2abb4d54a1ab8f429f7b72da30d3155a5e7429b31e60e81dc0a798da526bb08a0c8c37625050a9f8245cf29ed18162c2111451185edcf8a9c3165f9e7c2bf078d2b81657601f16f27d839c363542f32b8b832dbb6e0a737dee59de3364d9ef4a3035bfb7ae6821140d75744c1b28611c5cf32952361e2f613c2700388d514ecd8327b60287a08ddb26c8828c1afd90584e487b3c3bfe2b4a7a19b86ee5e525aec9bf669f44dc5f0f115512e2f7525a2765b0f55d1cb548c6cd3e415347863f435a76ab734c497b735738e602956f1a019ac14c38a7e2f68d44cea189a1f1c666998c68186479ad3a952f3a3a2c4b4128733874ccc5a4b2ce054ca91051624919598d2a9ccdbfb46c7908df5df93b0b92a0e182a8fa0e083188c6dc7d0d11032442c075489d4d48d15e6fca7ee5db0768db5b3fc8c44e9876a30750aaee8c46c9578701494f5f10ddec9d1e2e6f7f2d7fc8a0452d74c99b640356e7e822a3cbbc94973e602d27e742c310e4a1a2a0e9ce901be6e3c91500c3d962e9f279b36cff72e37569e63a60198b58c533bb2cc099828ba579d2daf61c778a4da33825193810957d5da0bf0e0c36c7876606ebe8a81654a830ce2b20bf00542a096219d787b2b77dba13ed2383f42ede162e239b43adea57f43e678119209d334dd827af159593d9f4fbae9d9ef6cca2f0b2666f30beb6470f10975cf9d092e7f632c5716e22cb00c5cc43a6dfb45bb42aa2b5646d0eba426db670fc343e077480dd0f729003aeebbd9f20429d324e3f78ae26b1699ab3ff00c640afdad2e4a51e4502df2ee91f4767bf40e5571fa845cd9ec12562dc3ec09d0cdc1f25fb84e0d12d96afeb92c79f5b9c98265ccc7969fc00f7b631b378c1919376528369aba24aec049b9237ba6dd0192c98c4b242ee4fc502a3945332b2a550ed31c8233718b21455fb99b055641d8b5294d94d41468a9b12bdb63a29252074dab99ab5c4c0e35d239d2ec3655711f8023ee3e8362a6db5f159dc61c49f56b63df8d364c4c3f02578447c9674beaeb221dda73d85fd91d28d29175dc3b1c0537060472ae647943b7bda219f8475a350597861f5aa2b618949721011fef0be9dee5ccbeab34feb5e5b32085360b16b0c45a79c1468948fc229ea9ebe7e7de5821753b077bcb5f9358c522039a236b01cfea3ef0ab8e9cf6695c24824d81f84242e86b80ef518a41af6480389a59123ecd1972928aad42c58ca220895c24992dc9d693a25d56b23b009614ef2999fc970d290459a1af0134daf85f01d77f15c6a8273826b478eb68dc92441f275d3dd883a5b0befd312fd7c4f85d1765b6482f8cea1ff0c6f32f28382ffccb5a1616829ed9f7b7ee6e8006508dede96ec35d2a15fece70af564dab1d224255fd3c737dacb5930928a2514c3bf2bf1e21abd810d94380745ae6b80e1f0250063c0ef189240c6548c0d308bbfa726f087efa02d160b00ac014a5e9f5e0ab183980cb6d982e69423bac0864417d9e2f83320ec3052d04c5092d0f3058805a8000e6bd6bd7486af4c15cf39dea11d7dade37e0ea693348c7b80c5cbf3af21989c35100838239d895fc381c89d17c44372ba89f39180545bf98b9164da4bc21b901cca585541e65b177668321622778706a7ba64f48d63f321e613ac7b1f2118ccf83eb2d988e8d25bbd033216211473d4b66076942981d1fbd9e0aa69969166b2d08d162dec5d8d3d51940bb96678ded5dccbe35d7eaf3940cb3e664b587ac883dfad50dfbd10a01f71a8de191ae700e1fae3e5b8bbbb411bfd5d1603defbe9a265a76020f3879b7d59b4c59be4ca6b12791bc91c12bf4c67c50c8699676c1fdad255ff264a5b8aaca865bce5c95fb4280d60acf6a467cc2a41f93b62d776f803775eb1ee9cbf70608fc282b2277e2ef5ea4d6cdd1edb7a71043faf41163438e0788e744b7b99cb85583f513b73670815c92b57d3f68a60354d313aaeb8fccaa65531763a3fb0cd318b44cdb87844e5e59bdca616cd218ea2e0133fd1b441405d102cad338858f660e1e9a62f65723c782d984cb8bbbca3d747255dca1f60a88122e19a3b3db841a528faf42b1ab05806455724fb9bc35746016ab7211c984c86084d4cd8ea2032233f02c156d786779cd95a2b8f27d8db0025f2e58bc7b141cd24d792a45aa9c2284d2e9fcfb23ab3f22010bbf77797b90a93f9f641500444d241f81cb6ec78be03394d612d903fba8776da866a4ffa977d609cb6dae79283d08c233ba8ff15ff30caf3197f68a83975a253ab1220bc0b75b7a1dcf1fe7960990328b81c8276af1fd2730e804aaaad19c329d4afe9c5d1bae402cd97abef5568bed85487816c87eb900ecd63a4c647a62bda7d0028863fbee8949c1de97d71a2d20ea178e6878bd53d178ea04314bc1193d55b8a7a130ea69ff62dd2c75f83510393cc0453e9a8251b3e3943bc111fea48c40c7585442e5bf5eccc2f6f4143edea09f03c6b3a3fcae064c174131b169ffcdbcf35d26ff79da7b56b123321cf67c909e8e9309d141db6b4cc0e991eb35f7adc36bd58b12e2df41c627830db7058d3b10330f3c735f844d537b7967acd1f5efe166c998b646e87cc6996b458a77618323a2d89f03549c16cf75094cae5b0c41cfb0652dd85263f3e26f27a0fdef58e1fb845fe7f18bcf307cf7421bf9565edc1af93b89651913b1e5fbdf4ae5826d772fe69214637a57ec31502af8660f33a5abede408c24480d903980607591c5eb01a079e093da436d6a48e3c728278f36daaa296cad536bfaa955f1c163db58b368f86a2fb37ff3bc7d146c3ee005206ff57188e72f466d064f21836b554cf2ed522675b39bac34aa720c892e80e78291f861f72041157bb2e33a2a2d6595bb61e68ffad22cb4dfa3c3e26ed917cbbc9cf6951e6d1afd492246e1eeb83f4d0feea6a32442052ff397f2ac3eb144c19043fa6ba5cb0370d52dd9849bf89984a8c11dfc0158503bd7d2bec0803cdb2b335e7d476d9a1b2df2519cb35b996efad09d42fac54bb1761ce503f07d9147b2e2e7052551eb57615c63e92583164e4fabf975044d76a0eb903d2539a0e5298ab1d3272e671e95bda7971534c2c2e5dce46f3b87f0411efcc59e1dac81e3b78b2c8eca97a62acd832d838f1f0a14c231958fb82461a9167cbf6ece5e8ec08dbb8c6270ebff03b548603f61a9277b8158e54aabc127e892cfe39513c5a247c4b7c12806817984338480262f5f50bc19d3f3a84c43f6e3a8a5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
