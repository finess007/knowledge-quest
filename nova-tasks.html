<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f808ac903bfe855379020eb8a4c92d05efc3a90ff5ff928715be2b5a96092e3434851345193ccccdd58abfbcce77a3472773f5322776e9e84faa41e6d7da4f91ed27d655269cc238aabd59f14010be07cbb86a910f90976591848121c56687829bb17170898611858ebac1b1852d83baa5dcf5078bb3cb0320e162cb0f3f0ebe6ef9f925244979ceabfc0bcb15632fdd45f7abf8f65746736409ce600755930bfd4347798781609140a6ebc70585f2e21ecbfe7194c8290e06e0adf440d67da7a322da762edcc1d90977def36bde76f836f8009afef902a536b005417edc4db392597d09d326a74692b4f083c3036e0bd0d3ede3bc0489f4d1ca0ce93ece3838b4e5cf0000b712c813b6e6f50f6f76c11e08383eccede39b694a7aa219fe3ec50d8653da5faa1c637cb06c5bf9579cbb9c905877aeab1c19f7bb62a02097d866ec77a3720f7a36024479361d9d5e18c701b55fd5c29223efe1512ef0f7dea06d057529078b12d9a0d320d46c8655e364c121fe6c6c7f62174d225d97adaf10dcbaf82ff486f84dacba5c2ca63dd9b37ddc77f291d314b07e31c0cb831d3c6753df0d7f0f0a56799eaf7a62d72189b032b30d81119fbfe20e90da82d78e27d6fa2a95021a633d0dd6789e32bd729f64130f673ae38fb3dd198990580df81e5e557013f2ce7befe96712da23866fe27551f7b732c4fa98601208ba577236bd1f2a50a91cbfd0ee5cb9c35f4322760e8de158c9fd9d1ee1850f272bd9b6b989ea00e69fcae7be7edd0a76442acdda85309641602a5404dbdfb2fd30875720315063bd922a54bbed9ad4d3960ec1fc8efb0476b7246a251a4692375143f6d4aa412183f202b66797bcd9cdc7d774d23a797436e3ff1cdefbc62fafb8d572fb4849c291a22b6583c0fac88db6db6f7f1efc15bc06d06693599d0919e0eb9f216e26ba92006af36ae9f5dea7744da509e1874276e1b56ab3a7516b7b8b1ed1149d7298c215f09b3f2720ae20a820ba27f5ed4323ba1687e54f93bc72e0a13ea7c19e873bc4edab8880c0a6b5ecbd11dcb129c332dfd2b8f8d27e55ca3f128acfa3d6e637abe2319f1bdcac21bc2a5ddf0bb4b4c35b3ca6c9da1fdbaf5d04c16f990cb067937b12c6c0a207230ed4874ef2fd9bca9d2f327926c41838155d9df0fc35a56de4e4ad903b06f06b5e442e184ce5d329b36cdfbeed372505c051e5a15145e3213470c3ab1ce77c9712f7b216c8bb40d367e829e4470f51d755e9680cb131695c214a5c0419ddbc71c6f08490dabcbc5a54ea9e7f86211c163349ae13cbfb80271c48ea270970b32fb83360a984b16cf4c13419418f2d45db2ed09e16c4b3dd1ce76298fddad49ecec7e00b6a11f74c936846fe952251180a08695293e8ecdc074e641b12011a5f6ae3e90a9891f5e1ef4136838cafbb07c303f50f5eb60c5d85ce0488e69ecc8231602ee9e8e102466b2ad97b43c44883fa0a2bba93ba2bd254a34343ac06bcc34701ff3ba71b46bebc4aa795b974ee3932e0464aff70663cc1e7127f7b020c8be0b2febb3b6f25e4aff66a3090cbb0621f097ab5d1915c5b5a32d887f1c2551324f334584a9fdc1c0a23bd72912d1b153d1b5cc387b7d6cc26e87576b3648faac72d9ad994d31f0d6734d55c686e82572e236b3f6aeb5eb2a16e5034c31a0c2ee13139016989aef1cb7392932bf69a96c1687388906ee566f62205ce2f0fb78e4101dd3df1b3909a40e6ec8712e6e85f9447fbb0ad6552a16ee93d66aeb3addd4bda65460f181238eaa36fcf927d0703cd8bec9d3ba2f7a2d0e3d683f898264b242da2657a23fc54711fbfa44d1600fae42230cbb7f26e28d75e946ae1ab8016f6640473032e00b7f92d3108fa7883036d937667c3c83ffdd8ea930e1e33da2a20e7eff0aeb7232289302d299070f55eead69fa67726868093bcff0db35a2c7d799a86b3a2e14399e759e5aa83811f1b20c6ec62ac31a80a1b1a2e7dd280300f58a588551cd85bec40a5c902f6d4c4cc213fb7a924cc1cd29f0462ff10580bd3a16ccdcbcf5a8afb113630e73f0991544bd8e944531922629eb9896b4493a02604607f3a1d13fe907804e335c9d1944aded3072c26ae2b68d9301bfbd9c21b558037f248d54169e5f71b0c1acafd625183fe73eee6e4356292669f3feaebe82b7677517a7b13e7378922241b6a75d5970f8ec3817e4b30cc735523867f2f1fd777a65678195384fe77685a8eca940d87322936eedd617ed956adb99aa819dde42bc4341a6e858be4b5af0331c4307d334f6469dbdced89d1674b07a8ce281d230c46b42a5f1ad6cea7694a95471a9b9294ea6532c289aa9869ca6cf766dd84a1c88ee4f699f2fe079785bdc6bb526934167a247986f9cb9f4772a2ab35bb10bceebbb155860f350acb0a3b9f0f3af3f8f88ec6f88c8c94575f434134a5430eced6fe38de5c40ef92c84ceb3c2bdc7503b531c4a9d9c8310e374357e76379af3aa5e38e16da3da3cd675f50e9de3a53b1b18357f7b800379b61d45f346cecab117bff86265f14f11636c934552a0b618339925decd7bd6eba9ec8fd7b62d8032ecba352bcbc649fb549c2b992355556cda9eb2b99acf562a6137c13c73dfe7d13be5150aec7c162c8e1fcde2326840a53e2892bd5ecca613f1da21a7c4256c3ed29189771ab6ff9f148beed59a738e7f8c210cf5a6233e4f6666f2f7b30639c5f24decf8da6953521bd2d898437e185e452e75616edb5e523819a2ee10ee38b1e13eb8fb1079a55f2817c9a7fca6dfdbc923116d3fc0d1e054241ea15ffafc519c41b920bbffed2ff73a0f388c1641a3229e2a9679757a40896f3a13b248b3bafce77b73126acc4b9b5d76e9726b1b14953ece175a21a0941c730f70d60254ec6f08f8d33e7be50ea21ee9a848803870414c167db1bbabe1788d37f052c9afe2902abe3fcd2c58eb166af43c06c6b35879607cf99431e3fdcfd3d0d765d59be3ce975408e20be1f54115b771a2c86a9339e977a21d39e5bd8b6a65fb2ce2f02ac5178eed65f0fd8a4c6c3ce34edaf04bf3e02abb15b7a798ab02de516a585c7f5a400aa29ef8eea93a058de340cb71d85231ec201206595c9e8753306cd0dae3520f01d8636b45b7d43bad104c9fd9cac2e5099f8581527e3847fa29b214dc1aef9185975f89cfa528c290f86ae63fb91ef97bf93f2194d66e09aa7e02ce13b48111b631f78a5085e1cd235138da8ab603775ef3dcebb672ff87211e86e7c3d3c715e436227f3c09e543552b333e07c116f0d47926c6a21bb447b70955d26f48b31adaca180c1e14768f38b3959ca61d2e5943da8da67ceba7f7f050c08ed323143b4d19a1675684376a3a92d384bb6fa6e1f3bd82d4d86492cc190e995736e4d8c086a909c7b16abbbce3ee2523d351970f3d59862d631bb72d815936526d84a0c32137ee037d18917935e3af9e8d525bd4fdc6ae22b78a6b2080060641058bbed1300c5d7f7d4d8ae385c3eb33b0d681024cd02308d38d1013a2cddaac87af009f493914766e589beaf397c82d5978fcd1f5a20bc691b4e47d85b1937fdb59eb0ce6e3ee8c015223154a7c69e76720c9d9e862f9ddbe320f136ba340fb144b1258d465359b44e84858f11ddd81af624b40d1ca1eb77495e96dd1ed631fb33c1887ac016e6b662133f164f0c7fac9d9af862d67332c12c9d3cede2d82714db1eb6ac9192f3c5025ed9ee16eaf2fa4b42c6a8bcbcb03359a07070c98c928783bbe35604ff5a5cb3564d55b5878595981e71b4369cb9e81295e59b7596af502ab19188e8a3ddf1209c7b44013b2ec486111623e0c78c2ef68dde16dad1c63a1c126de38d42c530da5b5468ffe5e55b0e7775171092e50dbc51553d0fad3a15c72a60200ad65277ab0b3829ae52c6281168751ee2b80722a5885f7db3aa0564eb1c5f782fc0e0acf796bd711b61b5f1218f3536876ae2e62c8b00516bd44ac8d69cd4f969ddeef6d57d8c4d05f4a7a746e155e2592bd70ff57046fe823ab28e3b2d725c1bab2c05267ec5af91ea775ad1592a34e0ee49f0a67114018a1a92525ba5d0fe03e2ddc13c35f1cb47952e6e2ced400ade60ee8ad07eb04d4494679f59637df15eb404dc5ed38c608c7543646b600386fe8a4fc92319f90be608e3596a68aadea72858b8ad48cb076ca0afb837b337eea9152fadc27e7ef4d02441f0afe9ecf44d991105f7214ca2a7063509ce7e92f8632706effc9a59ab946f4d97ab87a815668ebc33004f8df2d4fbe3aa9c6e6555465ec68be44cb776abef9141f077467d45a47adbf6a8d6508baddefae937b1f639409cc97d12114b7056f1b750b5b1302c65c454b0a1bb80e8653490bfbdf1f5dc2b9ed9ba2171dbbf55c770480fe0c29dbd8ccd103a636b048f6a01fcc4b4bdccf97e72ef69497fab827458cd7b086c4135735acd43a7ebcce4e8963c07a3173254b7bcf0a4048d8bf27d02ec872da274634635a613a7db5f6d5ffff622ad8cb29cceeb5455f8d0f7cb59067b9b5149135cbcfacdd2c1f4c722eb36074178e8c42b88772ffaa4cf26afce2da667ddc600247805d61aec2a70bbde087c7b156aef2060f296793b6b627b94d172a4c49a385e1a027c3b119637974a8d15694976e8d0e87f5de9ad666e028406e99c889e416166ea5366e4235694803bd650796ba2eb29ae6c013ec65db89c7f808b5736790932e460eb2e192c28f487da49238cd06a7751fb3cf103fe12bdd6b367364ca7fdf214d78e56015b0eeb7adb02b31a7471d26c0eb661f9d313685df91d07686506cd85698727ecf02304acd71f45ff00d5efa322a8bf6eacf6ac04ec95174de74f9c176574061a84ba586024b1d8bab474e18388fd02d6c42a34606d66f52bf2127b8991145a22bded228dbdeaafb8c140819d0d7ae8ea904f6dfb0b729224d11f3556b9cd62111ae1021c711261988bb89ed0a30ef137f8109f02a85aee88639e07aec86b52bb2981a4de1768f403d1f0f162b19a766d1abdabca6862c2e1eb35d6c3901139203b0bea13dee475891a6e173397b0022c4feaeb4723bc792438472788cca6df190f7e7974ce5518938c79d8eec7be02614b5c8a2fd8da5dd7e9edac6020b5722f051e14b46b6c47c6bafcf78d9fd2f8460e592c06eb9159bd71448f5a16f45076fab088821e0050d84719a1cdffba0b25a7ad4f8a012c5d0e4a272a848bcadf5908e51f7dffdc5378a4a51c65e2f3b729bef44fc3e0390e220a53c69f08fab5860295d7ffc4f1476452a39ad7057b0b659e80e3088e5f59c3fe68d29a296aff320dd31bd43bbf0bb0a0b8fcabeee77e41568df5f35d0d481c16d42b17a26fa121f5d8f494376fca7436e79274ba99a47f529ee94cdb24855d11a197f171f5c407e59af1d7f78606173036ff99e0202e3c0bdc476270656a5e8db7b270273dd5a86a945a7455caa0f93d5c0b54e15775b3aceb7446849f6ff1262791edaf49840b332907800ae54fc04bf9dcb76f120c2834ee4235073ce8099fef07dd4d33145adfdb51b130047180a6a891cb23724fa30fbf58f3913e42306439e2fb9d2acf21d8c04707c4e7699451174ab885263851ecfa240a580aaaa0bcbc46e09dda98e33da25db17e6f16041fada6aafeb28c31ba354a34d6864ffcc7a5bec0ce0d3a233615110c2624e0b5be9ffeba81e1fb53f531df20f7441afb22f9858790e59f3931c4331cbb06331c96afd1434ffd6ff3293c2dd48769c2beef3061e126da0ba5ea31fbba9f2767489470e9f6ce10b1ab65ee03e4acd48565c61dc12b1dda5e416700957f422c72590cc3342a89f4f77ad819910ca6e5620670785ed74ea02fe63ed7930b9912951cfb525fd14fc13a661d66a0c1b20f33609839cd17cf1b236b8eefdf61f587986c3770a0f5de0d3ed4e1910ba38c8dc251cceca8fc2eecef0a2fcb4559418e65b01f9afe1c901de52b206f36ddcc234b1add2212edb062d0613773046ca7223649d10a2a733c63bdf0769296b37175747217668f51078f507fec01f2526c06acabdfefa83f58166d7306e42e8b34b83a0bb7135aa4043aefb356484d67dc5614992479e8e10bf983ab3a9d0136c62ee47c1c09cafa6016924d1075c3a20a477772e61b4e04605be0c416c39fd1e36841c9c9bd65162e99ee6f61e80680aaeb2f7ff44b79a3cf7e55f54cd8f46084583822287df80e7ef6d0c38ec8bbf4448f6da958acec74fb771efb79b29824347511b5a688f2dd04c8efb3ebf0ed38bab2a022df435c9baf3a5c8bb697f702716eafbc0e4fce2f0de433aede5379dd75e0cd0d1a215a3687c78be43dedc91d0431cd4a39e4b654130c519fce8c1290e702ef84815a88c01d9cc257bec41f01b11ce7124d34d48e2465efcf8bfbc9ab4581842ad6ebe26d1bc036b25434fe7b3b22d43823e582e015b57c221907f66541eb9f578331f972e32a7b622ccffeb71ea27744c04d5646ef948ea95f9ad43e83719034499c1eb03fc949791f3cf09805bc52da65fc43461063a23a01dd38cdd60ca90ed4fff7af22059e909adb0a89fb985dd9e926a42f6848da464acb41179ee607b83b0382652d5aafcfea51666aef4dd739551b692481f0c8acaeaf439bd0a980db4579529f2aa299317701ab660ac5272891f9d1941ec791d464f85f71f617f43b7afeff92b2fa0ba05e4f045cea2d1c33193c6701d63147aa397ef851341296620646562b18a0f936dbe9e473a8972e31e28c93aa7c5a1f5fa412995cbf1a8ccbe59b2e93e4aa803b5aa5bc99e2011478d9d5f73053d77a38596ba906e6f2ed1b01981320dc53300883e42c3035fe517b77cabf2d9e4154df917fd5c24e307df2d9c1dcd8ff5524ad391a97ab61323ee194024744b6fb9bd27a50271f80a4ce0753eaf9fa73223b3f69a14b906b7836d65f6c782c489f7c6f6081a3c2528a33b61e0ec95890ca2612fb2aa79886a05e4d17b36f598dae1a5d74f73295864dfc98a96b5723d69bf4d2818dd8a24dde1759861d184c18dbf37d47c67f97237d025a0b8cfdfda56f7d5ab8231de5c1d5d4cac2d9e6575614f0736ad43cef5841cfc1dfe74315f6e9417bfad507e9a1655745e7d8ddef1d7ca276032031dc6895a5199fbff50f6c134456f1de04a003f27ce7dcc4e301511bcbe8e12a645b94d07e6041186e42849ba5d0c0a325c0546e25bc03330f5dbfb886a8918c9a110c7ce6bbe2b35eb47cecda08b94545f40fd5b34754be1277307eb0af9149d78059753f1fa25247a002fbb3b7186b049afe96827d3e962eee3a1bf7a111949a26f718a61e3ef272873e7c8a1434331fc8854fee36e815f67541c9f34f437faa65a5fd4426b0e2f18f41f608ba42a37a8b28592bd0b17eeff65091f4fa9b29f09cdbc4c8eceda285580b0ad094065beb113bf72153e5e3f11ea78aa8777e634120b94a43e3c9972f3c211f16c416b020879169f1b6e83a63c6e8004fbe59a7824550481dbcee5ae4b2a9bf0d67a2ef06401e046567f0ff43c51839c6225e6f0e4b582ac1fb7a05fd8e33b2f09febece90e6ec10429a3dc5f394128eeb5605ca74c9b6ef7650fd6770f9ec5b9d139dfda2e563eababaa3d1f34852aaf8da1d55e0f02704d0468a209c58fdcc3ee152e67df322789b9ca01461822542be0d78f7a02e7e1837b6f4b8abe38802602fdefd9dfc49f8a00c6c87501197e7b211f267c985057714d8c6e816f8730818956f62a201b3773236507244a3217819e66486c7e7c074d66519b0bfaf3aa93fa815ca16da1e60dc5cfe31f730726cfd8218d37954d3befbccb2b9e5932e1bdb2d60b0e816cb13c6285d47ad8b8192aa319d9c1cc1a187a1c54356e93ec31f15ed37b51cd2a26b1512c48b595524817f5499b9ffcbc289dc7869a174ca0c1b0f65b1178d7bc5cda8ae9f72ffebc75f0655f3f931b56cacf5be3870be5c4a6a31e1d2c09473a205fede0d2e804f5a3e736e7edbd48f3a5b68108b795babcc0c1278c52159436350181d4ed6f17bada6581f0de93dae396bbdb8340c0454417fb12217c31f0b4ca58680409cc94c0e436d7250ff51c8d38442e9cce87bc0248746da66e80b805cb69de5147398cd20a438dd6318e0f32647ad7466ef1defe5da5cdab30dfbc417e9031b11f516c8283feb7bb64a9397136633b999802c0b87491bee69242b6279775af4187832465ad188bbc1057c51cbd913ea43ebc1c417e68b13e45f6302d90389ca96fd6e3ece002882520a4d139e451098cefc3941c9ef023dbb9b1821b05f8cfaf5c75c79fac7dbc4fe629822c344b262b94a10d3720522ad1f65e01e793bbcb254a1884aa6a01fd3e04fd05f67b671a3f63677150d1b0766b36c672b2f571f481fb2085f387c8aedd548167d7e11cf7fa53c95ec38fcbdcb1d8c63090c369ed99269d6718f0d58128ee955b6152f091f650c0488ed68047ae6c206b67f5b6cb47735fae54f0efe183f4366a28280bd1fa562256a5024ad175693862b9c66bf44badeb0ca79cb455c4adc078a2f781a054f4518ea117625382ab53fce6539581200ba803eb2706eda28de28d5573a078f7725ee6f1cc13a8125b8bd33b943aa96d181a942ec8092f5d9fff713267204d690f87c5ec397c14b770c0f94f6b2595b15199fbdd84ba0030e8b7447da74d0f525cdfe6497a98729000e764dabb8ae4da969f7ff457ac724415349e86666e016bef45da17f0b2d309ebfcf98f376bca6ab961bd7132259c28dbcda8d874561e24f53777c68095b2c8c6d49006c8dc1c7a1612e87ac4203d1632686cee0d7291fc24015210032fc68feeacc4e4796372f4cec1f3a203024d11aae884f7001b7acde50687ccf5797dd6b8fb88f224efb12eb2555bf53ee5cb81e9f210ff5b0933e841235c95570c2115148da4f30719414c6233080e37cfd65a067822f5d8ec1ddb16b4bf09ae82a4fc6ea5a0caa8444c975fe8db6a1f1e6ae95378cd829deac5299899b87b53a4911f513a099b6054c4e689b0a90e5e104bc80fe2783619739b27b498f211cd5076035e902ad6293ec3669007fc92147c396c0dcd0cb3a315891cc733e873772bf47ca33e96b0c214e9f67a06934a219434be77698dbece57ab37dc7b5125d5f9644e0b6f514c2af8fd36511bceeb745baa4b12b94d30b07983d41191d15cfb924a38d604b2d1efca09588fbfd255d46d1956e216a0a75d0114d5359e9a215371832a651773633f4948b11e7a8e9219f995cf76a9a86b13f8d9e13b55fd38dca32128ee18fa2bad3e4f15e3db4e1954b1771f8b86a5ab0f432320c58411717825dfe7ad02c11f18943355357f4aaac610256676d48e02338f3a2e0db34c763f9a9fe7ead7a0a26fcae082a4a2a47d2313a89ffcbe5d4f25ce9b54e62de9135706bc3f9fcbb4bcc605b4865091ff5d5b7fd77c0000a970bf404303da7c615c09bdd227cd102f06ac5408f441cdbee7a66b9e6baba4d70c5f148c85cab03d6083a1709f9c40bdc8b55350d4ddfb11d3e41cafade3c9ea29a2dc3295eac6962fb6d30f8e2b8b344cdcd2fb289aaee50077cdcd8b9b245fef9a0c005b7cb9e91bc4da09a0a180220d99f1e1e79db97666c1d57cf91b06aa9fcb0745c1ed805564e474229eeb0d0a2cf52d768f6546329d767b39a0b5a8a37ce7dd84782f4c3b921893c08cfcdbef7a1d27942585c8486856a0f13b62c9f88abae3c85bb0bc85fae31fffa11b35f07dd554b7d701ccc917298eda091afb7131571dbe1b22ecf4b36feb9bf75225a416782b8965de539074ad2a40c4df272a117e01b1d1c799b1673b1c128b26b4d1808b29442af7eef84ff722fca9544a262e71c955a5f8916fc588741663c3dd83d217f0c7e5d65e26bb8f1e624e2cb6a6551b75430f16825165f6618c2198421c60a20262df8bf6d541a23723b92c238f647bbb80e2067e7a1127755e5757b9d2289e9936e1cc8e9960ff55cb90882b3113318e66856d6b4d6c24f596aa5f866f75e25e9e9779bdcfc5ab559e6017111b34afd4ea8fab58e542f7833c308af140451cae978dc8e51c005737c87806e3709b3c4498340e422d6003bbe392c3b92d6622794a67a77d9b687842bd9d0f6f0668410a90aae6b52fe528cb0dd79f8388333a4565c4b0394b9841461d01934f5b2a353455e322c3bb2c4a5b5857c2ef6bb4242949e7555e3664e0bb7ba5cff7148b7a7b7360b51f7b7370ef45b730928ef86fc0ae3e1ee8a22b1aaae049dab4e0de3158750580391042d5b934fd25bee700b6432d9f09d406a69a3b1f4e908a4c1963ea307f89ad8188fdd81d07d0b1193dbe23a5fde0c4ae09d5cf6dc50f92eb0fbba36469a8b89d0db2961e41a1b8b8c9d525175788c09e9f811fc55e9c2d8054e41309262eb5a2042a28c31ff6dc324098486ed358881956dd5e7dc6e86c4f93492850b0e68f0cde0dfb091fcbd59fdda47e7eb09ca4f938fd8e5bd6f72b74cbcabfe3e5ab3fd762105f8d4714ca8a4b270f6d2bd6cb342c82cb9a8c1a4672ef00fb09b59ff7e273d7db94b978608e36c13500f830afedeefcb4f8da1905cd5f062b4edd9c159bcb65eb0e6a2b8a2e5c3eb9c1954aba3e6e5696b1e91ec2a5c2a9ffc4ce652a7e03b31375986bd04589573a73feeae001ea50d1a11a7a38393011705f9e299f543da4a2ed24fd9087d9771521679bf256d484de3918734b97c1bbc53be02cb194b677c1868d52a309aa21c1c587f1b4a8b186a5c2f7b00959bac1d481d125a38ff7b52b2bdd93a4eb0d019f4e918a39681b39e27f959e84e06de7cfe0133a5676efeb6ca60dfba431ec85dd9a4dada54809e71035a0227922398750bbdb02bfc1884dfa83d72c736d5fc38ea21fa9bf1cbfc7aca224831ab5989ed7614a9dc1f81fb0ef12cfb844e52bdf5b13cc023c8e16758af55d7b8a4362dade26b7262546e81e009ee0f39acb57b871eb8792a76120a95f2d27e5b5bc3e826a8a7dc7af9a01a7fddbb1a7a1dc3d5fb33a6c5e86621583eaf008bcc926f9a08ac6ee76f66f729f001c7ed87fd395ec3f48db87611ce5cb6427d8b8cc48dd54927f675b802780b052be96b9bfeb891dfd8823c5b91fe72467682db225c388dadb9605269bb702435c2b0ae4cfc2c631dbffc1c0935561ab90e057e2ef00ceed7ff3b5ebca019d45df1daa679c45876a93937868ca07638e5d1a51e6fb843e11e3536c3c12f9561498572d92a98d06649bf8a048f85b1880efa831e3f00e81641d2aaa2cd4c23a9f5b17ae217935c647f446ef9247f50e40b6d088a2bec4baeb3a19383486d01895752a6595c4ad0dddbbb2a9aa780a202809b7d0bfee40e9ed6b5cbe4161ddbedcd95c7c2be5e1ddec476310a155c6bec3c56354578b316ab2ee6286ae5679b05c097f8648a8561c2b2e4950bbfcfa1c52f0216233d5dc9597eba59a00f1a7f303cbd4cb670705e59b2b01d91dc22e42c81a4460f0255a106a3cecf1756fd16dd7cc7fcbe38075c0228d544730b48f0cfde37450c07dc80ebdf9de9daa80c7b3cbb7f6df9227af7c89724c421f68f4ae14883def30076401150916003aa6c07f33386aa9ad1b013e769f44f2db0b182e43c3a08617c413851794a44b286a4c032a2cc0ad818cf036bf2e9b46f1abddd35ae58e4f60bb3ee07f7107883f7259de50980a6af04b22ddbb229d5bef784158348045b80f50d6ae1ed409bbf33a7bc4773d7ce3658cd23ea94b6058a00d772f610e5b0c994f09a7d9a8b143adbec5f49363396c007312a8e5486ce177bdeb2c669203242be8c05b00ca171fc659a77913099c6b6f182dd42fd0c68ed51cc31c2fd4727176d340d1297f528a633393c7825f3ba262cb7dd830b04534f955a480d4486387285166f607980225f80c3ba4835fdcee497412d5e49a66e4352dc556f0141f52ae51a695e91beb96514ebd225c6dc6257d8d8f5e92f8bf1fefe9d674b1dfa7dad02d309d69637dbd81a911275e9d4e8353c6735591544c0b2c99730f723693e356e7ec7c31aa45b14c3e81cd7c76e76bd4822903d8803055281885bbbcf8ba9c2a179f68d8fcb5a8cd286857e853c6d1eac146b6fb7aa59b599350ee3c4e6c53e0ae2cf27e9d9c39c0536a9d45b7f932d5724fd2de5e80633318ac2f7500caa4d831638e9f09ce3d04e2aec0c9db42d342a641421be26a212b9dc340e09595895bba45290dd71715d942f6127e9685a5e4ac5a8d0225da01343412d6068158a6df80c52667b7c01e53c7c129710cf006546c445d06d8adfe7374b1ac5019c15857d4adcc0762f6e837b96aa1e64364535fae17dd65a14899f8836b4f714a3fc1092822aa06c5d4b17c8fe61f7becff85c1a910bafc23e29eb1581f0c6d86e8a5795690b95eca14db01c5ba6258faae3f48dda9ac042af39b9a666f00891b62154ef1c018a8e0b3afed2a11c7e63aaa5ddb40ed8f037f2a7305ad78a670c13695cc3f8b91ddbebe695d9ec898c6536bb0daa1e53580de4a6ff1878533aaf5187ee9357bae0f24d0b0788222c5b83b0f78d49d8e5b6e62cfddaff06d958ac02a4417eee4387a887a0111f21bd84051fbf4e91b120a55e9295c732224cdc915e8e3e9f1092c65daf446db1352a5a8c01cb254d86a62a58377c0b7fdca0272b934caacee58006de9d547b41b7a0fb902dfc89ceedc85894a545b95b82e1aace9eec64bd369f2e068b8378e37a8fcf4de6fa9bdfff1e705d7f788590b5efe2eecdc7f8069c96a3870b9650e59f4493e9ca00adfd1a605fcab9112642f93b4582b24b372a79c1c9a8082436d0218c207b5f50b9f7ae05374ab9429401f74bca8868457299a586bf7771e5917dc982778fd2c52a359089bff3392ea1cce1cbd6b0d0a3695a6dc7b7004bc0e9e968a5a58d9153677b96f878ea2adc39cc98404e473266d063ed156c5616eb56b4a6c76cc3e755e13808859431d98eaecf913d0d5971e72834a0cf0684f143b4c11c5560cfd910bb1f7ab4b8705f327fe06614a904dbef9b02a7aad9e6e8590c68caa99d85de8d6b23f89f7b47dc48560e5f69a0c3e7f69be791c6e5abca446380e3fdb8aa3a5800704426c4d42dfd74ac10117c10810893b1a8153cfce34e6c5353c4ffe2a6493e48a986f270087fd51d421497d37d294ddb8023510f60f6ec501d701d0701cd343d66af180015fc2360bbf66bf53d2469e3bcc63c1a20172c29ccaea1e87313c365caa3e09d761589959837c531c03306c0a13a9dd8df93dc3fb6d829b50101cc5acd6c575dc9e6925c87f0e6bb9d3f43bd6ff6ef2ca1a38f8238c4aa868ec41cfe6ddfb797172c5a4d920032990b6469472e17975734d2495c0c098ad2c6f503d6c5efab0af3f8b490d8ac18acf108910a382940a0411189584938808dceb4e691c50967fd16393e27e6df0c415c58d72242d0fbd30d95a87ae18108bb16a195a6a3ca5d64f611ebc1099608fb9f76c47950de1743e32c5d639303d8319c56c70f1355d9c8e7a18879a816e16ee91281e9e1fb9fe53184c68569e0b12ed9d397a9b98ec130b170f66163b92a5a3d8fd542e158c960edbac51897d4dfa2500d047916fcd66670efb255d834eab8bed6538b07eb5cc4850becbf1a9720964cadc7bbe1aed4bccafae8fd57d7ee19fec0f9e1a36e163fd1732adf3942b16bb45385212828eca043001681324d89666af75090f01d240373f8e3400eac3cb5b331106bb480696d9627fed739e9b3d484d917a199433fde7a260f7ffb29cb380317f79b74a9d44772f86098fa7116885921a48708fba7e2e7ef57a8768430564a63a3b92c0ca1e75580ac898689712489f1ef00e97a6da47b4cd60c311f00f606bd913ff774e5f1d12cfc13da635983b3602ac3a8f941f300a67f31ca8c0aed672cc7a600ad745b649bb50a5fe212798555aed955ba71a1ab0951e5e6465c6df9ce2e371317a1cf115d0b17b414208362d109f64a60733c2f021dcaccaab500b26453f58f1d0c74b8692fd30dc8f45af5ce6d4b67ab776df753965557f7b88f7f2e2ed47587ab337cfd47b13a5e8d2cc147ab9e0e9780545be7e205c417b81132fd8d68e4c59c88e4a3f74a81c11a3d8dbf65673059dc69c8e66e8898cd2e23c55c3895b21ce90b7dec638c9a2439270681ab8a6f361f291b39e0c375049778f099a68e6830e771220a263f84ee923fc862b03aa85353032f15963a36f59ae24359e7d52afb42bc0f78df4b6ad1f391d2fa10018749f6ff60f17dcf5fb273f84b23ef2c2d74227559a620db8145dfa10a211ca09691881fd7f5f41e4872dd42d6170bbe6258bb98458a654bcb585eb3255857dd728c232191c8d13775b37100e7ac71849aa67b40bbfa0b498cbd7e80bf1eca1db3d4f284d91518b7ffbdf57559f9b3423e7eb6fec305ef106fd9365dfeab4292311afd52b567711fc978f38","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
