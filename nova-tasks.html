<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a4be3c32cedd27de6a3a6780dfab4b3c27883eab664af16aa0431e451724c38f3acc216cec4df9fa650a817bbce55eb36836e05dcf80d73792f3479c85b300413e17fc200386204fa7313805656f22c936d663f37a87eb28b9f1477ef76cc03dd7ce3e33d607924bab1b3891bd77c0d979f83754f87bb28d97e9c72815b5427cd3139efc6759532536f23b6ca02b22caf6d6e2075d6f139fa48b9dfaa2ef8f2ffab922b5ff20bb6e014d9b3947995a8848172e640ca9e90627b5d42543f1d0bf3ddd68a71935bff276de9c8f3806cd7b77891c865a16e90fc48700bda25a87631162664e1d9465359dac5794663dbea2609d36e7486be4b6b177f45b8226f357c39260f7732924a77ad5830f7c4084442520cbc1da02705f75c9a859d92c01755398c2c1fed3d6080d31935cc88e0d09f32d9f85f80128f2efd238ad955e8a73eeec899a471a97d53e992db4180455403738484cc9fea839625a8bf2e769d2c219fa298a67bd6f7056d3482d544fd88a68cdb797d6c41f5f7d3d27c6faf7c87e76d364581ed4e26d3648c2062d47be0d33713940c96f67dcfe4f188abc62a181f2f6bc2bd69511da2ab3739624837621486defa83817367bbaf6fc3237acc51e820944b4d7c67adf221e9151c390b90f0b608cccd9211d97b1d61b667fc4721239a0b735b6ca177db68f867033bd469c010de2912f3a50bc717fdd5817fe71da258daffe580d8d3d1c1397f85ae6e5dd9b307c3793a48f310b8ecca222d2bcefec55737a3e0725a0d781f5d84c94ed4d34dbf1f3e69784f56bc9898059f7258ff2f9c6594c2f115eaebbd5abf1c4e262418474fa1fdeb9cc3cb0e435e1138aeaa31feab627ae7ca10f3a3844428f854c4b3581262f37c4133a1f15624f7fc352a15813a8ef3f469db8e15d48117e251fcc3bf24be1c363f2c8f390b053a62b4c33dc03add40d1cea1e7aa68d227e6f5a127f44e93314c7101dad395f7b7e39d9850eac8ffb2b9f85a5de7a5dec5b86e27a1509872ff8b85152dd320632020f3bbf3e622f793da33ab7d7b96c208b5cf70ff1cc2eb6d2ce04995007767b2db46dff03a96f173f75cf89ac2fe855394a37ea822a4c04dfdbca45dede39fba1241660067788d0b963076efc6df889013f6e0636f8d83ba2a250e2f80f2780d48e2af2d816976a7613ce7b9e998968870170b217a0a7b6a55d93e6df2cc7c9f31eda4c6a871f798feb98393f7ef8596ee4c1548b61ad76d6220b715c1a50de5662e582626e5c46d53302bb4694ced5c48eb3eb752d364db689f1803931263a28180ec0e5dccb41562298e0bbee3f0ef5db051a45369630afc89d0980f4ffd7aa5579067094526f58bcffe76004cc58575a61c7482aa5f78ccbb5dff45a5ef11ee438acf1b7361fe149564cbcd3c4d95c80cb0c5919302bffeba565ace6f99db97e77e6535ffd4c0d2b6e6ad485dfc3d2b0d74851c21ef349c77cb286faf660a64e0b44aad856a227dcf0e7853db87306874613e21029fd72b04634d97488c3652fe18899fde41558a7c777e42917a112e75283bc06a0952ce7a608058a8b170c55446a094dc651868652e5a990a91ae3205a15a01824248fda262921bd413c71466dce23cfe42a28a82bb3cc9e01f7820d8719fc03a9f91b01ccaea13ac989ab436f24faa83f59421ab887c63f9270a2083b881a2df71bc550977bb848db7a18d6a73148821380b1d5c0a64120a6f56407bb01dfb5bd0132d4564498688a63738ba0595f3df18b5ac9b8f9755e9d806ec7372edd8a5fa90f25cf01c7a3b0027880169a4516df4db2c3981a9d63c4e6c5927b2dcabbf50445dc414f4378cef069394e2cb47e8ff203dd86e1e33c8c10f579f182984c9ffa057c641d36a2f4a0c5ef7f0735f806eeb36145fbf32cd5cca3a19348df0a2b66164692cf81609f92a5763d7da765b61c03f80a4b7ade75802e9bcfd98f0ec183f4b6682808775c9475bb41a062802243d4837736456f369ead38bf82e0ae39cc71c374fd28b60faedf94add49298bcbe0457cb008bfb38f3139bed50c089f8159d11dd0a7b718fc2334845a23ea59e726fb45f7fa8139db28763bb5564d0eca5440843437f9dbfdfe2c5ace3f58e27678d9b447a74e942657fcd869f47af8e5172c5e4d25588812f5ba797a75b4754a566c5e17c40fd298012c94dca686c75beca09a9a3c0b856ed5b9701cfc770fc1dd6b29b5fb533653104a96a0b417b08be6abe74fa434c663645919683b6a3e9b357f32d79001c3024aa319688caeb6e920a19dab6681703858f704637ae70c297bf6850e80129e4bcf1103acf64456381be53345e7a65766bc5ef0e878d17aecb0b8cf60d5a23994d4901fcb836f214fdff0cbfc76c89aa3cea79f9c03f66164d03b84a3b1d1162fe04b7e4f0dea7161b2cb25889e66d1c1838ec4277e3a0d22791c590285491cf51904947e253cf6568597b8bb36b0c46b621563c3f1f488aac35d241f68157c637720d22da9c40cd36cb62b0e227e90e30df029a862be96eebb3eca90b2ffb0f0e81cf7d58e8bf86a91c104d9b397f5185898eed51d8ebfbb3abb4211292124c9adee2185f9d607b65d08f2702c76601f785ab55cc52825760b67d57249989047625df8c350b9f21249402dcd16a2491d0c89a5fb0fbb7b2847488f0b0686fa6bebcc53f2a69885dfb88f30d13497fe9ced194faa683e16c9f9990e33d70e3aa8079b97e44f908a1999f86e31caf94dd3a748a7a94f4e3496dba85a2356a8d682475597be7a992900a13303f9e1abb2115b4b28d0942f0981ff3f2577a62a8a34cbf81ee6658c6c7456dc865d425f6cfe1320f7cdaa4ea8f79b14ed0eda9297d3f8d728250c281f7739ded7261f8bada162f91b04e8585dbf214027b0eeba8b2b60568370f147c65ccf323907eb5230c9c20bc83a50b110d98c71394539f300d7709f08e5ee7fc18beaeccb00013278c8561ea5930d762d4214638150ecc8d9b5bdb60e6600feb35135fe024cc6f625fe9169b25f44c2998a91d460704da04cc09ceb9f506650ab87a7389987c94aa1caad78a475adba3911869967b1b0dee0b08338abf9d52a802a27130e7a551d5e8e3e03d078af797ab314d2dbbc411f429166afa12b70d35cd41a744e0daa5d474d600c009e08cbfd36f14c7986ec67aeb253a04602be6e4fc1d1f61c59c3c119dc8489e61c74fb020bd7ae7adb72f1d9278c153fd2dc3942acf3715c5a65e132f3f019d8d4d2fcb81c8c0ec1c5e1e0fbb146d855fbff4d63acddcd212dc7a23b51741327273a02733187354925e288b0f63ea3688038552126d3cea238c52d141d74f2ea5f1298a7c6fb4a03b24d0c8314a6b9431f9d992739e8655d38919fb57d290049e763be7f1a87c076ca77154b6c8ba9fbf0c8d39002f917bd5e78e6522b9d23dc67e695f304226c69a79b31be2c1a27902ddb78396019b52ddea671b0c711fa68eb2dbf48a7eaa6e36d5e9436422a72c88426b302ecb1602f3662c8eee3282ec6a391e5ebf81dda89dac85cac1067e7c83aca20607750e723e4a42d8f53b76fc580a4d75aa4f7d81bd5daf538c2983ad5c8fb066dab6b37302c5a73183b79f62e47baa18478c932fa22b4bf096aaad1192e0b69acaa524232dcc5e140e85e6c82c26a74cd68aa268d28f7e9ee7dd9660c2d2ea75c5e15def67294a40f9c7038bdc38a05d6375123b7f0ed8148f45bfab2098a2189ad2e8fd1904773a7a02c93a625366c327f148b11146acb777e1ac6b3202622ef8680a26514432fb14b15fdc0709d79ffe3a836e0cbd303db0480c818bcf6840ac9a45e28013acabacb89a00f467542f5625de51dad9b98be6f16c1f804d3de9adcf3d1206a7b4ea527fc6bdf1ebaa5ad2a2ca86f6d19e3c6be5ca2899eed13a8c2b96198c5e8ed846713f0a5f1929c6f6fb89d68f907b385b9090dfb7df85eceb14a32206419ea6bb1fed38ea4b21ff01f87eb12d9844726ba28dea137ff2df2f28ab96fd9bc99cae68a240c1954d5f3be2430a8b5a1e5690809fab7b3b453976ef4b51339a77591d0b883b4f17f331438bd2f7ee7251503595b274bdb1e83305532e0b0158b6146ee5c3b9254d32d4d4aee2f61f46914531309862de4309d37d62ecb305e644e6789b207a75b1634ee91cf540a8c4d4835826038373d5af797b93a65e89963d1a6a40ea5b606308791ac9711ae8c904e0444e06147ab62ec79457dfa92e5f381dd38443cade56d3924744804c311b75e74f592df11e62ead4d630178dcb4d82468c051d817426624d63edd8cd3c1bfaf060ad3d54527ff6e0b22fba9fa5106d72c5982cc9043a660fc308b19f2d0ecbece8e5e1a094534af9d9b9fcbb761ca913b4a277aa7fe253c4daaf08121fd4749c45f791dc54ab3f745be1a6e45218c5fc5e1016a2f41754a15a90bac2e3a6d319d725376a81c5886572bfdbf10c9ca5465430b110951b31c0535bee5322310af6d57f8601a3406359e16382db9816b369f7cca7ee522388518b587553853cf9e6dc8427327969ad56572ab4f7fc7fd08ad5f062f23fdd010d398d6234bb4a8726f0e29f771882e3713c3985de512db433516e6d2f2c10b042041cf892bc1690400335c7a6a06f351ecf8b7f7818a4675dbf031a9bbde463f58e09120699e3e0e8188c017dcdf37d9e2047023c8922be62cb9bd771fba708dc5493671785d855b5a8a9e1be3c3bfc574b215d109a5612400307f0d20a4ce148fa167821022a461f23f5a879c580881d361086d26adf6f36850584fc08e27c52e04497cfac9687679bc0acb08cb3100d1f34f42252f807eb7b9526dabca2e70ddc7d8d21d5a6967b2718c5b330c3cdd64f2e4543ade3170936659438977c8ce4b489c735d189e2d0630539a48a292daaa80c05b5111085caf97ea9bc379141f01872b686ff9432cbcdff45a6165d7a7cfa4acea80e58837e368350c66c00e3f1e24130f067f94e354301515984d0a33af5c321c979d908c072c8ee84928a4ea3656964284f9e9dad7606930aaa906caf2a1fa45a1a2ba57bb12b445bd09dab427be86f89807ecd598ddced91b1714eb31f7ab1bd81bae8597612c964e1bd293188652399e27a06cf0f3931b171eceaf4a0733d075584cb970fe8ecef0f6a08eb2546dfe94ae3baa615766d4c9f69e70bc2d12ec5890680c0abf8805f008f484dbdbb63762fccc913736f4966585ac7bed96f9f5deea01dd00d1cb01959f0aa236aa7796c3c9f03fa0f9747fa7c95ae1bf02f70f03f2d004b4784f8f9f891942119fc44a3ab345fecb929de72ac09d267accba9cea4fdd6ca75dadd45369f2481c200c4a94d1d001da7500838a1a2d441aeca9dd47e79aa101e77c502caeb488def34a05dec29531705475cd02c5428ba70946cf11b96f0f5f198cbaf62f880c26b8b03b1ba4d48e4219786643e0f90287111e8c1fb7aa1392c44c6dd7b273fd2fbc90aee47b7ee457a72ee4b6e22891dc155b3e80ab0fefc30aefc1532d7b251e45c9a2f2a3753041a3b733eb71de8193fb0edd0df90d793091236dcdeec9c0e7367032b16e5328c6a5fa04a59b7ad6770560238f861d6cf9234e1b292258101b2ef26d9ab35e2ff9baa4727ae0f685c021043334684d7ccce7b1ccbe4ced6c005eff06872089fb156e1243ef7dc469d5f0ec3db233737e9a26f437450750ea63e27af55737b01114058e1f2633bd93d3f9346a2b1194a38894d76784fa05af82a0ab575c49b9b0165c3fc0f91d9af1ea505c9976738e66a26fc89dbda97243137f2114285366263caf1237a88c64a703d6ef8560dd92b24b0775160c105a4a93408504203d3c5875c4727ae259c32ba8a68efe56ffb17e7f68976e4c91b9b86a86d4c2def2a1014831c8453a1e89c32ee5d8cdbacd6258df36cc26aa4f28177c8de138837b131527ebf04a07fe88f48618432af0d4150c4c13860b70026ac7f5aa8ffc1506ebbf2aa374984215f650244b84265119402d0af3174fe0ee182f684ee7b3dc47d2a46403acf8db7248b27da232ef50d32bfefe60bc1b5f16622e377f83017ab57212a86da59f9231ad4f905a03fa02d0be4945de918044823dded4a936e9e9a40137e958706d4d791814e87bf98234e183b83229dff292ffcd4757e11fe34775ac575bd9c77257865dde3abedd914e41fc549d4563a7bc62d472210a8a79bb383ad5d1e837bade6037c2ba2353e4f4fb05d1d968877396451e0ad310ec1e392d4d4d5dc50abb612bb936e94e1cdf8d954227a9112b24e5ee7470ba24b1ffa8bb412e5777df0c3848fe793a38a4f346977939e0435757ea8e91cf2fe2f0ce27be08419e7a6a48559aea354d582a356a9083bd33d13c7b36149cce6cca6f976748a5e6032554aae10631b0ed2cb29fa628ceaa54de3de88befc31ef6cfe0f7902287af9d0bf7830838af4c50db12d76c91c9f240dd85048dcd964b0f63b3aa5dae89bacaaef2f682a02ef1f197bc36f67029b8770e9f885f119e982a6c141572f83227d939672149f14f26465ee93c1b5f42dead2eaa9744210cefc9104e6d5fea89717266a0c2fd0f9771b37c0966dfdcb0f89db5a580b17bc981afaec0b4a978d159cbbc7df1f05d211114aea82a0103cc0deb30ee8dadc4dc19eb986a68ceb3fd108564f5943ee586c6522d16125e8771ae95db7201dfeb782a7723b4401aa9129064f713728a69dfb1ddca3c39b1ed6d80b9a93eda4dbbe3987a29116dcf78faf322e7c8d5f540c2230c2734d23f72431c795ba90b8505320b686cc26d42898461a0c25971171ba508c6fce64b63572c58cdfbbd8b21dbb5ed64c0d2da9a9a7753e5cb497cc7728a3f9d9269add3287023d113c67f55fb9e860c390c98c3304a408d93043ea0bbd25eda906d792442c0b3de42b698b091005578d5662277a535e2b967bcfc7e9bb20a7ffe2c1184397ba3a7a35ff8c3a32b1e06a4e08d37671106b5cccf2b87492c7900f109e95383846d9031b8301d9ee9aeff6bad3af92f100fa3f1b81161a70158815cdbb18ca730f8c022616cfd6599f753cd5b123e97a2f2e3034780548d292317ef724717188c00690238901a6d41bc18d3221f090efe5117d185d08d2e31cdca67044be8dca086921898714a4d2b81a6dbdeebb315d27dd701f31a342ffd97360a9a32697c9e84ca785fce449e7ef368f964c871bc4c712e2e3a2c64b69a23caf5e6ae1a4445b91d16598deb2fd6250d5b864cbe64df92175ed98eda5d703d8f707609fa4c35fb1419dc17294dad2dfecfc90eab6d7d5f334c5d98474a65d6a840618fbbd32b9e341990c5e95f43c71926d320c56ea69e2b93778e1b9a7edb3d05fb7d56efb3131056feed863061a811e412062a31d383e217fae1d7c8608c3a17f8ae64936b127e69f995bbb0e5886b364edb81f241363e99011bb5e35863cae1be8c99f862f534d59d5350a0e88ad56e625c489e62ea2852d2f618518cad74f2d20b7a232906ddc7d3b405b8e27252a43ec7153b4d02f503835cf2dfd4f01abdf56e1e9a3f3514abff079959898c498a1328f940c5ce1e07ccef8bd60373cf16c955cec33afffd049444dd3ddaedd38ccd729e3c4c0e56bd5e985ae7889c62d360ecae766ea066ebbe9bbc3f4bd14c740dfe0b1b9f775adfe7b697ee4518ffb04ede11f32e329bf1c0030661365e200c67f3317c8d16ae8c24dcefba1b06ce3f103d8c57ebad18290099f91406acdfa6b75a90d720d6657493b99b18575c2a4d0285ba7954595434ddb4aa5b6eb929060ebf4ba9bddf441d6d2f8075564f7a371f1b078fa3e3bc0e93ec87551d464f9790e1dcdd9deaa5c93a65a243fee2712e874742c893a1cdb21d2601e0ad708768eeb1415e91d54fc2a2e3af0e2bc5ce31633472793e7def5d761443613af4e13856a51f269f46cb3f72911fe7702d7793fa5fd6855fec4fbddce13273fdd04727d585e609cbd8efb4e005144640b8266204bf9acc144d5ef2f3bc24b93c3f326f37c7008c28ce8b25308ff04c1ba6094fb2407ecae757742031c861148671e944df765d8e33bff0c6057ff76ed1f7fc2f0ca7abe4954613d084d987cc7a6b780a5f95b209d5d63fc5bde1ce27c303f30fab34d5c2baa39d9ea4b50579898d5696f30d94e484d3ab4e5927781fcd91dc43cb1e2af613da2202c0e4e04970a97f6d71d2ee4038da363f33240dd2645c3dcdc85cd1afab7bb1449ddc4151546a7a42c616329117b9b7c485a4dae102fcba75f766c541da682fcad0fc868acfc546abab4ad995e70a4008022f7336ad05db75d0d0a0811fc342a0fb7e4512a24b32118e09eb3193cca30ede7b9d072d9837884463806ab6817b1d526f828e6d4f358a304a1b2399ccd7c4e1acdc3fbff210e02ffe838b0f7f62be5f39b054569b9d4cd8c30db8408ae3916b2282e430e47e94d075ff1959a56604acdb9a73a8d1cb96dd468ad0ea32c84efee5fa4eaf514cf016c6cc5c88fe5c0be350308d2695f066db0d14a3e807839c518fd59a8ba841ad7a8e635222afb2afa55789c0b83664c5da6a66b5cdb20753e821ee6f908d23167c1f82a07f1e4fe436422e56df8d8ffa04572584ad11dc75412fb07a0b58eb4f493ab33f792b97bdf649931365cf555ae0f19b7d12908abb4c475577a937f3ad33ff6072a162611037fe521fba6c76dd593b9ca3e420d158e52c459e5bef88627b0635614e181784714713af4f04c110654247c297063c2580d4d40445df0102e1a1654c5ea3ecccd69d28ecb339109778b645af871ba5697174f6a1e821d91439f620a664b8f7ec6d8cf77aeb090b90d96cad8a7cea410b5779caa3e4907a144e58b87619a23223ac76baf8223202dab132ede07a375a887f22c40873c92a4d8e9b813396d6110591a2fd8b021c0c710a4901e21261cc09d5f664e9d555f6771c30cba4020128c2f2cbb4f3048f3b665380beeee792466f84bb117f17a2c3daf7c0417efce49d502ac50b54766e59f812b9f6d8f5c1694252ffebad54b83b8ec91841665ada0be48957903e5c026cfe94341607d673b4684e73261894397d77638080ec43ce12599834c441c2228b3addea0764d44fc0e5a323bc3b39af67c9ed52f78d79ad43a290d5cf862c9c1f880a67ad0f5bb995a45cc232d31d8e0fefc4dce05fca96590eb92a47ba0bb91926543b752222b932366e2730a5d4ea96b4dcc3149603c0fc25234d267c301f8ffb4e6a5ad706429fa5839962cf915d05cbe6a4a9e7ba4357eaf631e18a7ef380315a42c11c6b48c9847655231d3d911f4716ee5e370c43872d21a3c0158384c867363bf80e2d0bee83f42694106af2bb1619cbfa8386ac760c536395a67c1e282b0fd157fe5242cfb9f83c95c5b83068cb8846c5027800d44d1557971ed2f86391ec2a3db0d5fea81b9da8ae16b91393e56d3399a64020a7702bc2c2957ad823ac569102b1341203b17f563a43cf0b8233c2fed4cdc167b076e0881b272b6c9cebc5ed1675720a2dcfb837d3f9aa055db8917e967ff263d931ec927f417f10ef961b534fc80201b103f34bd289c3446d3dd5d5b4f234125eed841cbcc6b3e4dcb43c3c2518df59cf89a2787fc333d05abc9bfe2fa4c2dfa534b1fc7e950d17370b23d51efac138bfd7540afde4583755f669a53041a2ead3c8f1e293e87fe5929610733fc58bb78abe940f82c9b0681d7fc0e6dea321a5d764c4c1a09d5ba788af7119daf7ae50c3717212e800a34647a912caa3d713ac13e3e594e09fd7f0d62cf75e68b4389c87ccb47d20eba91654d6921aa774a24098141fe8a1fd779e06b25a9fc247bfb736a9c9fbf9f48cd2105747b948e2b99d4e02fe883584a96a97c148363f5f2a39fbdce9bca8a7a5a8bcd9a6544e67882da67394054ad2654e79550105c26ed462715ba18fb3d34d7fd97e09b57b31604229f62d8b8728962e6abce3c410bb9442ac5bf03286c86bfb575fd92cf8c04dfeab538429422b9ca44f1fa1fdbd9358f148b0889438301506a55ce169558736b6ac99832a3e2a322bd4ae56bb22d51664a09021f63fdc89e4efa3cac93c7b87bc7a24cab2d8376fa14ef8e662f3f87308dda0dc56ab06dbab155b9b25fb77aa24e81311410f638e98e29d9058cf6eaec27fbb4803b991e5ccc2c955a3395ced7d083b29c4ac52b7b94289446fbc0ea1714ae926bc1af9c5004c1a75aee22c12db332a9a2114daf6d2e1a1d1ef5c49c3c9ed8d404fd297aa97f6205a8eb669917fdd15eef72bb367bedd8bfc0f004ca82cfc509243ca331d5bbfaba8a219e1d942eb9bbcc23e410810b286e29d1046ed8c375fd908e4fd6286a336e9e933591883955f05497b6537c206948a3fc41fbfc1488d6465eaeef5eaae104575018ebd67eaa0832da247f5187432d394a74dd364417eb33e6d58b5e2e7d2aeeba164d3abb140804174de6a40624e087313320734444191fb619f3c8d882c4ed5245f6aa5dc91a1310b86ba26fdd4881fac2173c8d4930ecfbfba27c3d64bb1cca3481b15c8832aedaa51b609f7de9a3160099c1d29a5da21689fa0adb761b1f544dfbbaf32831158199d3c7b825a33286c2d791334b0117e99ee5ecc2d26dc2e6cc3417a7f22a8f6e3eb40d411952253d731fd2240e37ba9a85b7f248dcc63d84b218db54f059087a34f7183680b59360a0f6419c3ecd8e3133537762105e2267e20f207899747afefafc78db5a5b5c82a41ab86930956def8c61bbca049f9e517f32a1c4c8a0ea0f81d2a57b446478810fae0fc90f87271e9d9dd4065f73d4645226408acabdf1cdc640756dcc17d78426a85738c75ad18901558a997f60bc0e2ecf4f43b8712119e3f27fa2eddf96cd53f65743d327e095f94681c404b49a00ff1cb3fc22f26c573274e2bcb67cbea6a6ab4bcc72d2c638997e05cba0e5c60c5a9098d35669f367e0ce1c4ba76596e8fed4899fc959c42378204a29fce7faca0bc5b92a5a981d0917377f4a59758a02750d02ad37aa087d77e7a1a0e9e38160fa9920f653ccc635118e446db54848e4763e9c1eebb973aaf95e0d3d556f0cca92404631cc0db29e2a46986ff281d0c656a573987333f944fc7c02bad480ee9e2f01b35257f5be6b89553785403479fc6d1ceca275cb79fbdb45a732fcd236806af730672073eead05c6d4beedd10aa80cbda2f0d3b18af237a4243f59eb476bf9dfeabc478f41ca672eb67f4dab137d47386ddbad0698b407ebeccac30be43833d3ad381f5ddae7cbaa9c06d1b1c2c044fd02c79e0708ce2f738ae057b63991adf0076db35141dc3e953106d28ef4e9ec6c002b3f98a95cb0ca21507dde0fe31decb1816ba7b209f8d6ba1a0e70aecd101d8dbf913d753d676e227cd43070cecd988e8846b973f520523496ad5cc0e6d74e2798b6c76bfc0010c5b2f488eda457380a6ce43d88cb739f109b34cc457190a8cc235619c37b5b7a2555cde889b1729014ccee7dd3fced6d9895726a3137d48772bcd4926eb53f76c9cbc8fab37117e6c9e9707122b5facd3dd8ba5c12aa3924f9cb59b26961e316d0d1d24a2b89d792e85140dcbba1079a3ca8a76e03a26ab309ec505dfc900fbf795753f86fe4d7fbb151e6ec5b1216d0f22cd7a72278ccdaa3e7a1032637691da9f3e3f43d68192185e11d78cc9bbe7ddb183da8be3ba786c3782b3730462c16eec50d22a960533ee4fa5acc9dd51ea7ae3031f9157acc9719c54273270e5f1f1a72042effc0d8d5c171d796ed7914c3bbf284833668fe4e7f3249bb7130dc7089edf05c92eba58950e924b76b56beac00de6db57f1622e9267cd7f33582bc32de858b1ef99bc3571c8709ad1372d2368cbf79eebfcb19562ccce5f8c4285dcdb5183bae0e164e0e795c55facde0df30560cbc509ad4c87fd3e112d2d3d4858f18d3a930b152f88ea56fbd3c20c6d481d61b6f493dd1fe9851367d5828afe0de6820069c640179b7c9268b18648c5e4810beff327ca429e48b5622957258135cc2d71e316fdb8314035efd9e29c7d0c50e6b91795bce936e86ef7d924b9812c78c75279f54ce4ecb6606813b6a6a12688893a04051aae450851fcd7044bbfc1aa9b0ccdcb56e70b4bf7ff9ca5e126805e5bcfa703defe696a711dfbcbd9e3edfcb27680174d975d4f76fc289dd6c607fe43ac411e938493dff019ca7b0694103d746b5342951485703b8d572ce369329d253d5113034fe91e36b6966797a2df862e45e4b8238ec1c1f01076fdd857cf5e82f1dcf07127d125aa9a9a6eae0214d983226dc3df5bf628bdb1ee3238081611e150f634e1c7e73653e99ecef657db9a051d42dbf204f7a52fe29c4e72ff328223ad4f2f7ec1d6b0a42d41df720016cd35fde273ddc92524444833527dc7ec3ce3ecbe03d4a5c8a9a7fcbf3902c1abfd641ad4601997b25249fd449ce99b19ab0ebf5439d25e1a7ea83513540e1768d24994fe43616e1f810c8509bbdacc4f52a5b2b7c396c1e2fb39df6f8cbd8249d45f5be56f8ef405a45140ba1edafa876af89598fdd2b88788555882e1b6c128b524e60199f8acfb2d7aa707d1a9380117c7328b5d3af91f257e0818593d61933aafdb1f2b65cb2c70569f7822a55cdfd6e4d1ea0f788c5ab11996ce7b6f89412a1434248a0d597f1b574b0d265560ce673bae4bb3c160a07b00cdbd803398e250f418ca059b185a8e594dc5b16dd8cb2e6ea90c83eece0179fd35e3d4ca817045f06907aa24a0b50d2441c6d3513a4f7960afb8a27948620c100559dafed00299fb92aa0c7a96f09a8437e8219053ce96f2b59800c4fba06752f61025923e7687c8593e5d341a225f512bd2d935fc279f6782fd621b5d49bee62ba6ee06ab8a572c5b4286dcbe8ed0f857d268206e035dd65f5f4b280fff5cbe4d872b23c8c9d98dd7395e9db46a670c9e261addbfb85dfbfba3f6e95cd37eb8382f3c496c70a43280c97a1510168f974d7c9ab120661846573b09a917a65fbf3d110868fbae8e3dd264d37c7e522038fbc2a06c881ea11cd998d609391f3b7ab32936ae137b94f27516b86d591905bb6b967d98c65ade42867beb691613ab2b87f1e6cf9ac45a38b1f52c32d969e6cfdd8074b604a261ee01d5c325c178502f849e8e6556b796393e50d40d9aff31993616a900a50970dc1bdd22fcfefd4a6f0c59da652960156d31ee6fb0be8c1c4e1d85048efddc54166b0c745eabb2502ee59df03f0f0018d3152a15f35a78c9123cbfbde912b9ef9bb7f373bdee91cdfb229cf14b76b208e9e274c1708fe7274f67935b5abf505e19dad1713ee719a2b5baf516b7a1a06d40d473eaf27aef0d2bda246d9a0ab867c805b1166963ff29f37d248dbb6ed698c35793d18d40cecd2803817ad2903cc0ad95e1bd8d813e45bfef326685530bf56012f791f4ab1d00d6e62aeb3208fd55434cec6adc4ba8a43dc151ef24cc2ddc6a398ebae6d826ab1fd3330f86638dda6286cb728110d3989f608397b10a86cb1ac844b7b5187d7da94d5e5f3d8902bcc4324045f0788426e23f48423b6badfd7f1013a91af5617e2d7d473eb1baa24477db1813a61fba15eef8a7b35cf946cc6ac0baadd53a50bf48012c071e126f16fa9f07a7494abc1e4bdfc4217166d660d470d6b05c3e18b2eadc8bd37093dfc4d204f4d2ba8969eaa9f748dfa96ea4d44d04fd05a9ede3b071ff23b9f06bf644e336a8a1a0d556fc759596552f14a4e42835fe3b0431f20a63cdc74e6850044775e5af6a837612dce3b1d231dcfadae04067f8c05990d70edd61f2db07bd08f385f337ec37da3be959f132dea81d4e9f8d0d79a6bb4a99aba72136ebe5201484f5ee7269054e7d4d3532de6510266509ffd5b58c512a70475b5f8011d21c07e3d81e35251b52991979c84034a942cd6d01e98a5a281be00223bb1610b693d2dddce2159c7ced541b5a21b6f021aafdadd8a6d8609abc43ca600d178245c2ddb4313371e3172d9778c367f93ac911ac2d1cc6ca18ae7ecf685fd918375ac360296021bb4b2138b793da140b67751f994db4586da7b3fcf8a3adc4d08dd3ce88da018a1bb8fa2197e4c5ffd33cd2408b95720a19e93ef3f5a7a580beb8857b4ef7227b68bd7b32b666aedcb073bef827d203e805e1318449626687d13cf4cd7eb6df76f698dd815733459e0dc48831d6e2bdd5e138dcabb4cf539a3a81dbe0a31593a19e4fa6cd94823e4f5d58a769ee5837d48dc4c9e6bae2faf6809760cc71fc7376d55f9d72866880e0a106fe49458d2a3e9d48924bdba6d100a8828efbb7c73ca5f87ec18ce55d621736e145902ea22a56f3ba01ec48e844e8b1e149463b42f29bb64e11104bbfbe9216f5e97087aeb3801f4e2f17a499a5c6db614cfda85a5c11d57248448029b344b394abbbecac79f990b077bf84c20c95e60c758f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
