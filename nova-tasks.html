<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"611a32c5d2eb4df0a90a8a5dd726e22e5c5def6f29c6b745ab52e4eded27dec1a8e503f1f477f6cf3e3cff8ad6ff460ae190680a901cb88912cabab40b8489a1952c33332abb9de340c931313fa13ce47d118369dbfb468df400a82ebe32344dcd618609171a926f11ef84c35b4753a9b5b6c7eda3cbc9bab09fbd058688c2b86764f645a2fd7ce03f7e9109e7b00bb484f71b76eaf79d03edbc4a5cfa5523f3a29897db531c09b9bce43f86222b2ea7f868a8134003336520fd5d3812c073c57513d3aff59eeab329f0fd246cbf005f1f4f03d344c60231469312f7f4427e58525d8f67e47e31ba9f283e4e15cc379bce710514fe483aba64d4800f336883d7d52ad97809be9d1f397be699a2b0e91e3648dba1c549084973562ac2f5e521dfe4ab0c033ac436c9de170411b0c64b7c2a5ae05a8f7e09ad0ded64bae2146f0743d9bb9a421384ab6fadb9217a672a3d7581132635d86c8e5f7a74d09fe18cbf8ed7948e560f605774fb92940e74a04f83e3e2f2ac809265bc36ec3dfb610db4570da547e2e7eaf6cb02ad214f729d14ae81df9898aea72ff0a09c551c42cb0588a4ac9bc0957730c13be51980e0ad089b42434e08b6192a3b4e22f95bd6256f316e1bda3962f998d1e2a477099be249849c5674a3e64743e2efdab1187264b98f0a09b110d442a817c12d7b966091a5085abc7bc2c8c521b347fb47f6e498870a99fc0e61d665505b9d63af47f6c288fce778a1fc27014f08d83eaa60e929a9bb38f3534d44a46e928129416eaa47044a5bae9489e3adb78408e17445804c66a39737dc17302fddbc8aa2bd9b9a8459bcabffd03e4f5be9ab4c1f4e04fcd1590afcabf422dda4317a267b037e7b39daf541e483f04676aed5c7d8d2fc1059f3de80e64fe6cbdd4822c3bd3b82300a1fb0746bf41eb41ae966e69ec7991251ac13082c2b823aa40cba41d5ea221159eb4d858b9eaf160ec918877d302b3a962513fd3febe6e9e2e76f5385a4c9c980161bd3f7f4f9814a3d0e9da0a48d75e8429ece497c99ed4a7af9ecb306360f4369f7ac122506795ed0373e39b2fc90e168e031fdb8472154c5f99eadb4a75eae296a7f2f198c54ea40a52685686ecd6ee718974aed888bfa1c229cc362d155245f9f5280e17dc1783ca45dbcaeaba80f90263e719a8b8f1622faf8c6f3a7f44095ff7d9ab987d8d5627151ce8ae3f422d45f9264f2c26162cd51a3ffc521fbf37635aadea74253041104b4322dc73f4bcdba255c16faebfa591496701b0e6e51818632497f38428adfde603d15726cee12e3ca167d97e71f6968b5e771720804783a7c4be6ef0dc54ac2cee4a47bf0a50a99039c95e170f17c8b64a2dfbccf9a214bc9a928ba0b5a71a648110c2f49fd7416fa2678918b44a3db78392b77b931aec920c48d8c001ceb099df7a393163fdd6f8ab63e3c77b93a60bf5e276108ae26d854fc0069d24da61022bb434abc492645a127f90200ec7027fc88256c8232a3323c2c83bb3c6f4ce9e107972149ae5af1bb1442b2c531705d5d860a595f5d9d7e1c0fc06d77cf0cb7e4c70aa10cc4f6536cd263a7d08b36c76f26ff488eed542e07a1fe313417cb4b626291e490c9c5c594c02f5cfc944ed30b5390ee3fd6883824ab5d87f10d2bb9f184b3e0222d856e4aa6b48cd8683a20869ddc4cb7f3bea8e47f90ff2f48c58da4b33f3a9acd0865eeef54fd1d0e8d73056436ba00f7f4c02f609531f13b52ee115a49076780cf7315f179a4ea49cbebef865a159adb81df51c4c673ad2dc3f8f4b662ccf611d05a9c4be84618a05b2f029ee7d417e3052fdc9fa633434fdfd66f20032bff91768f21c6c629a2e56277d73fc929029b003cff7e2371f94758704d1b0238d76b5a26dc81e01ccca5f64e4e1088a181f38a1ab94fbbed69ab40f60c72a5e08d99530929f40c05ab92575f22325c2bffde5de7e334277959195fe6acfb388ce18b8cbea4280e188cdec4757c0919327e186b15395b0821127864d84667252596cbd7bb516b107b79c6dda617236e2a95513f9a86edae02c3ea6d048dd05776035a3482868f04dff833ecc46a4f10c8668c5a8080252032f55b633a6ae96eac2cc01eb615c607cf6ece2e7168ebe8360d6c534dedd5193d565f26991ad2c02bae1916c9285ec6457b7d6a20667e4acd636c4901f1f8759a30fa1d41aa278618df3dbb0eb7b2145ebd5033704b65b142a7f1fb2077f32d40cf648fb02eb0b16ccca2b64f7753fc2048823da541b37886a94bd208d47bf1715b7ae24dcfcc536d8ddbbf7ab7af044f1b1037ac90efb29e6106cea77fd11ed740e4090e02c8539f7629f37880e38b2339291ff5668a84d921fd6e154e7569c0dcf7fbf8ec224d5ad5d9844dcb2a85d4b9afddd0440d8b6a53c29c6ea0043e850c3c6ac359de4ceaef699209d98c914b8dbd064761a8e84b932df9785010f161fc203a32935b627aca08f9cd3b1b01dece611215c40ee352d17239e48877809053b2a98061be71f85004838519906caf8c168a58b8bc9bb1ac2272016512d9c60791afce8042084367d217561c65fc7cce19a1fa78fb09bca915305579d05328cf0097f59cd2808444dbdf81eb13a20fd0618f3e61c74b970321cdac85ad06711ea07d6caab888d4e6df3fb324e6beef5dc39d5d3b7b880032917810ed928ebb7c2455a1e7b77a1f16d587987d2304bd9d687b2ece5dcd763e8232ba9bce8d6fee3d733817700f8eda84dfc817313a899c37127b787a53bbbf134385553ac03ccc3aeabcc92d2db1871946ff3efadd54df223c4ff18b04a812ba4844a54635d70b54746343d292065e476ee07b453f8fc8bb8d3f5850a8d920cadfcd205bbacef9f24a61e3be4184e8a26c4cb2dd4aa2687ba9ed4e8077ac47631fd393543d8dbbe4257dff3589c6a777a7844776eead9c0fea0c52160eb7dec37843b5b66fcef952bd305cd3abca03ada063ecf6860a202fb80338c4b87762dc4efe41237e92fc0458d7c611c6294c184563c78b3b44e70ee902784a726c32b8fab328efa5de83da4ff9a9a319953768a01b831403bac77a7761dff65bc1e83fab626ad4b7fe478faf924ab6f6e2f493d71a939eb97f6a7438b0693d3ea3dd8468e0f0627f7af93fc0e875d2b299b5da657a51be73e18e27f43220eae252c09e77eebb226481e0562bb22ea3d59e9487f973e894bbf69dfe2febf536b9906cc8250604ed25f60fa3ad7303b857c01529edaaf61a5ddbcfd9c77e477526bca2f5e5ce60e4c7d6b12590ee59bffc8dfbb56fea41971a1f4fde64b8bfc413e178895bc1e31d5933b34830bb2e4cdb87263d0e337a73053e07e204a4d7ad1a82d598b387615a83063fd5dfae67e283c0353a640ed25b496e78096fe14059ee88e99b731b963907c3f5c1345bc9740c385ef98634fad4fcf79caad21d7c6f3697c055902ea5102094d361d6012306c52ef56cc8cafb470b16d585983296cb36166a9c6dfd504a542f86f37957334ceb98f648110897d3f323ef2f32b9c98c1ee2c24f398924235e6be65a64fa1bf58571469505624eeef7277d2009c0fc9de34c1ab4908303e4080deee165f44037190d1622707e0a0bff503ace27ae37f6dcb519d13f1209f790e929e9b443509a2e5e00d5987c963aeb61c9ddcf3db9beb411f772208226a339bf2f87eacdedb029ba955c6a696d28b0f59ef835d3ec1ae2b39eec900791b7aa9a0804a2d4e4f996289d722a7200e193908442b4807653ba887f639b0afdb7f2c4dc04caf6d7c665459166e6940be2e269b8a4b858ee6516340e5a2ffcec0f417c168630a4cffa15561e5dd58d766f0e7b95e2af7e0883d11b5fa787a9897222a367d970b97cad563d59d1e9d8ff44e303b732a3833ad5317377fd8130b8bafc9f17134760ebcc3981236f36cd9ca87a969c1d080cf95baf8cef3cb1aafbaa649d278fd7af9ef16bc86a2364bf6b7631d2d3e3ccb1c3ddcf00187fe813cd5e0e3f5161a515f91ec09183566555233db631051935539fa41e624dfcd8e72f51e64992f57e80ae49727b9560ce27895eec71dd1fc4af3c98b2b42fcda7f639a1080e324cac78c31817b036ffb0f8d7fd844a24b9fa33fad9a72ea600c5fe76a30c95ac8da6af2fdc7d12ae0849e0b8f8c7e49ecf1ad87b28edd999d69396f6076375bae635311376f8c210b4c51d5ee36979ca07ec15c05e63288ad36f50cfa59b8fe5d258465885ac08fea955d911803e7a9261af41a83d738e44fbbc0190a0da80424ef098a1e33fa3220a4d52e1717a1ff8ddf43d6a497fe0725dd0f533603e0abc431e9c91758c1f70635b61eacde4aef32dd2e99635bc4f6d8a55658bc971dc4cbe2ae5363671282840ce29757237def812be01742c4afa6dd6922ddc6c672fc9ceddf521c25f7425806e1235ee57724d276e11196de194ce4bcd46374472e543adc420e515d9afdcef49f95105c4f10a25591a962d2ef1681396d93a481af90a5f622598a710c82746b41ff30ee7720599f46ff9b0ab641d01b2ebd31aa86c8b9a8c735e296f1d2a2389cd4d0d419082dba5d9c04bca8b5f42d0860d526180f38b76f78ec2532a76df2d353b1e7aa781e0d111f4e9acc3bac8a0590fb6abe9f15d9c716141f92c73e9f2f047e2993351e65fb2c12b4f1bf10205430b47ff05f0f9fa25ac56405d3a8f59abf0a9ea36a6a551eef6dff1571cdf7f678a48b882d5320d2dafdca9e91769dc6663e16ae50cb0c4a721846b5f0c6363d3fa6b028948b295cc067b547205b8d3ac7e139e5f07ce0f4b1ad2ad6ebef5baba8269773c34fd0d6b1fae2d2ce161944677adac0dbbd2eb1420a10ad4f01e3288515a57703e21ef7f70252fa78d0d74afee8d633f2c073e39d9da55fdf582c4d614a88644437f44868782a91646540f33814aefb7951317fe199e43bd178a1be69218176dff893d1209cf7c8a8ef5aed36a5b973dfef3534a202ff285a774f23a1bae8cee485b2a2019603ba0629bcb993b8f73c2560795811457fd9f914742be89f410ff660341d1b60de54861d625bbc7e185f7f17af0c20dd7267ac2dae384497f631762329471e8693cd04189c9cf1e617960ff75c76e1b5b6e8dabf6554eca468e8f5d03ce03c644bf6f29866df1037cabc3f50e1632c361579ce01b1dae3fc3074bc0c3932a932b2e367219b2248335daaeb133959c7246d82252d91f030ba97f1305b4838570a1ed9ba0ff73997a22b8b3626fd8ba618db4053551212255552de2104c0ad0d5fe430451436950c5ed91abe08461bddb7dac47d4a469cebaad6312c7f29f1c0836b8cd36f7caf8730ac09b2ea597a8734a4ac182be47dcd669477265d539c65d57a3b39fb275d28340b52f9d16e5359576aa597e2f7ba3ea2de982bddab96b6ea96ba3f940c892d1d57062c6fa50034fab1bb260e8594c7154af6d5edd5ae0e4330e9e49a7ab96198a59808091f7a741107babce5fc16804249cb153663044fd2757f01b8bdb0c88addd2fd56953a021a6c0ef43fc09312f37be41c24a5313b6b67384b946b4fe8641f7d569b6439b0f3e73b3c48ae1472602252889aa5ffa7773f187e33ad768adcbbac2b959d64f8c6c74559d26a509c330f13efe377302450b9d7cb35fed0f85e8b1c8168131e5ec0f2d769b92524f23583c2e8997412cb4c00a27af32ef156a5dc995226c1e0004edbf78004aac5e8369e2a5068e07fd85bb8f778ada38417bac2ff1ccf2ee66605ef1a0d2055f80da3cbaddd688f67969bb113650f243ae12d866d2f557efb32b795a5df0c38e0ac7cb221d5795a409ed04f4a378804b53e055d298744740ae4d54293419a9d5cca4316e7d4ba2931cfc366ec5213380dcc6951d9723a5d264f10b6267e44a2fba31f67a545c0852c7f7883f6694705a75fb5d120a183e17b2221551e336b2d830f4385d01ac537de35f7e941e0c43d22e33a250fca91f741fe0d29c11ca6261e23875fda19036796a1872d75558dcd2dea8294b8507bff33a9dd90be4ef4cd551965367d8a0e9ade4cb640020e00f26061b5d54f7eca0393c76310c5b268c5fa9d6fbd824d3feda63d39f2fd4f0173d9c4f50965a810fc55dbefdcd8b786abe46661c457b195dccd6b6e9516b242ebb24cfe3c322390db6447f0eb0276268555ec19267912b12731c4b4b49e10b37df2bc662f3671401b279647a42e43783d1a3e3dbb6ff8180014683caa41ec2de9cec6e1b9983e40186121513dcbfe2f11bd261512b881f90293e254f56061161250ed8d69744ec13ca4a570535d356ddad2b078a971c3ae6efea9c9fd089b26b074fdb6517b8022fbc1b7f3c2372143b3cda716aa53bfc8250168f213514a45c9c7bb57c5f3269f023d5f6853c8a4f3b38d570f7d12f074a0dfb632f564ea70c1b749918bdf1721bbde0856e9300464fc01c1237790d4ab154805a42a433fe9613f62edea0fff412696c023a3e02ec70ac751c8eaa995a794dc23117685bfe84481963ae509b893728b39838bdd6fe1c0db06bc870118f1bb8dd29f3489068d43698d22d15337d6fce392687a87eec8bbf22c2b776d3d5e66288b387c9f4333544df3db99ac03a70c6db284a5c122f3dccc6ca7d9c64881fa9f598155f74a77bca14ea43bd2379acab7594d34d4a759c8044da533f614662643778b0acb3cb9d19125a44202577d24acb6be7915286660fb150b4698f06ac6e70330c6bb1e6f2035e2059c2885f4df7991127c185de5e9091bd18913841ba0a67acd92c1406fedbda8231b119ddf1293fc2950760c245bb5d5a006421ad322c0a68be94c7768ba42b200613b913c4489258f27d83ba8e9ab4b47683fd6afab2d3955070da2f52560011a45e9a14d74e7c55698d4368f6d143ddc415fefc7954ab3513012a1e3dc47561620d6cd930ac9a9b345411357c8109fc20ba2622ddc3c80df29334350f3eeab2d46dbe2764d9bc1256a41ec8570ef4847542950bb68f18eeb8146f50cee946183e289d060f0efafe0c37effabc30c64e4c1a86ffff38fab9124ca55917e435146720dd84cc7907a4d4edd75d936d74956f9a397ccd20e6cae0ff259d4ba999048b8f8d26a10d2ebdacd01b6d5091d4d24a474d7836aec867148db9af164c5db7a2a53eaade4a39b5d95b03d290e07bd268a01d72d39e683faa5b08efd5c5192c1d2296f7140096e8e7c93cd27b46a913655f8e3da2f093c06b56f120f3812468c5dd7b4ddc5468f8c6a6ba904841814c6def498df4f2ca887c9a39c50448f8ce7315cd2048f3ffae84dc09333b03d862916188b3bfeefecfdfa258efa3b9758253cabb2d145e6c17a190762a5f2a7bf8751d038a21c0e0ebae0758fbee7e916fb2e4b49276c21a726ac05e8102186815d825ceea7023d76da01f213a2642429cbb26ebad33bee5d7318a9e6bd629e81cf524ec3bbb73178864b0077fc8bc1caeb5447a12bd89933136a04b7fc59175cfc6410e7dd8afcb688e411cb9c26c6a77c087a74dea54ee422e8d6b0fde02aa05a1977a644c4cff5ec6b9bd19452a1883efbd474a1eaf196c2dfb56050d72140d9aec2f8448c8a4611904ce186c7b30784b8b138a498fc7fc703ae26a1d29f2a2019a975158640435bd1eda151bed306f59d90716aa17203f1281298537f0b2fd81cdea992789a4caa9758f7ab1184054ea7c1976b034a97d1da2b33c82104389ba1560b336fed4c66b27c17ebf69f5f04ebdc79b61103b6d3b90d5dbcbcae5b6ba91858b9ed750f4d467a43ef1b047aa45dd2dd63d8797ab1e1390a6af6084ea744d41da84c8d2880da63900704fc678485abbd330821e433b945fa13036f941694da35a4b93590e0a7f1f1ff7f9ae0b09eacc978ca765fc5aa35ec222922f70eb12657a79d6469f47dcaf4e286ecc0a46702aafa8044bd040cf5b1fd54b3bf16ae00a77d4021c4377315b3516e8198a8746f3a1742e443ea9adff332ae82cf2e65b0c2dae8c6f46f624d50b070f8b0cce2b5a41b26b992fdf55ed79ba1bd880a6589254a52b68359669a599bad16e49f198075d80e8ccdbf521ee90628049c20d16679cd5955c9a6ce6dd3caab29e06292dddd4ee677f8cd23f19d0dd7d3272bdd8c28826eefdffd42ff894651df99d26f1c0f57828d6e24ca44b8b086813129dc379e90abd492c791fc1b5bbf168d5a413b6f7cf330581c229102a99802a453db5bca4e3f22acafb799c9be4168b5a8d8fbb427f71d04224a1a9df69f965c40aa52a959d5044bb0f93a32dd0633c80e987a78e781a1bf49be846b569499c755a61dc878c570fc000121ba9c2a13d41ec1b7d62ccf427cc71423ef47b5119ed166dadcd91f6841ee6153d91ce960c5e92b65cf1cc1855f4cbc424e2ddff503ef46c143ad248febff96c28acd860a58616d8f305d82265638e9e761d347f05bcc51f99e33c194026b07413b0ff03f51862a54cb23db4be49eb9406d9a24a60f2c7bb958b9a975d19dfbfd3c7adb902ae01ec0cd44fbe9a8ec6eb3dea9218fa78e97ca4a47d12407f9282e41c8c9e8ab787b981db9ecf303fe2eff516552d11428d60124bf187946507fabcb8b5a6dec7bfba454f19c866b66767b526173f4d5bafc090f15110dd131d8e4269feb867c4287c2719e2ecd6a1427ba903ee9e47f6bb454e20c741f7569559838b95506d66afeb1dd991de62c2da4609d25bb0b6767a73a36b32c6ed8a416a3b30095036712c9c958577ee5f9f7a5ff5173860abaed6d1264e72c42686054785729b5bec77a5a70d65ff94ab89f44a16f652478fc542929a05114e053860df7b71eeb44289c72b867fa7815725712f1a7bfa292ddb096928f8ed85547ca11c48635f120d1bce4b9ce9201654e63bd121c454bd5378f2061209b24d4034e4e7c06c2542134f428d5c0c7b325a09c16a06739cca7541b455f65efc8145416384f0966ee0df46027067808130a8036781d68c3c7dd5c218c191c54b1c1df579a4d300107df89604458ae27d16df03fa84a21ae5fcfd08dcfdf44fc2196855dcdf978712c05749b67d2f2276e80e9a06a2cfa15a50ed06a0fa1ba9bf1f5cd95e626017081c8770d516fae6b4c67017979e64bd9745f7b3e87a51886a540314a8822a9179a7378cffd997127c5ad639c7d222ea2c5b6dbd42f3ad1b791414b07acce6c285df8eeb0348d3a353a83bba05f4c450a2f1461d5a16e1960293dcb5f9c93ebf0c59469ad43837b91453e53966ed9d8389990526e7616b96edda059025d27d2e80f64593ed3f484a2952fdd0422d3b73ad96c9df5e56cbbf5d9bf36fa891c72aeaa78eba333185aa9ec7668c00bcca407ebede7b85fd9d77c99172f0b7717aa257d7a6e1cfbb1ff7c629d34cbbf5e4af56fe0376c5166149bc975e9d103a59208c84b328747148530aec4c5a7dca300cc55aed5be3ba6c2348ec6f8c12733f193b0f1657493349b045765d36ec029ee2b99d9646eb8dbca60841710ff3d586f5974403a7733aadd44c85ce48182c7f5c9b2ce6251187186f356c2be6bd37eb90eb97829b4136534a4181907b26caebbd019627157c9849a93a3ef463954f0c71a1e2c50552d95b7c9cbf0328a5a6c75385f9f13f8d1e673a03d880f3d22b06fce9cc1b7d9773eff71b891b3af6de66cbaea2b82efa40a388aff0f2beaa630bc9460654366b8489d8c523b81cf5557d64b442ee33de553b9005e806aed8d2cb6455569de8ea03e4b7d29efdc91af1f20e1e8e63bdf51eeec27960ade675c6b7a2afb27cd8ef9f35898ef74c235a4f3b56361c7471ddd44a906151e449699557f5922b864b0e5ce5ba1bfd7ac63ab401e91b6b84eda32d4719a61d3c6251a295810724cb192d13ab79b39a4ca9f38050a3d27115cf81ee7de4868284d8959949da0869dfc90bcadbf2ded364fa942d6381e0dbb75dde81dfe4ba09d55747ee44d1510c9ce7ef857ae41197be4df04776db1b51eb3a2918e9708a87324e28f37ce76ba6e894276487afcb039c888eaf02b90246d52c6b1bcd9a0d4b0e77f6a6a071e0126545a6b03d5c735deeee7403a87fe63048476308570f493120c5ab646a33592d0d564ab60f4d020356517390bfa88d81797a2c03b30ab04b6eb8a729182c390c9f2d75ca8c0ca7d93db3f5c910fdf981593d9fa5d54e0f5d795bcc0d5042c348fbf44dc63144676a86ec7a9ef3d85f50894ced5e39b9f1fcf19f8ca1ef950201a6b4cf5e1537c9c62240ec031ac5c5446333b0f811f60af356ea444130fedf212d2896c74e60946c514e30517f0664d2cd8e554274ae6019fbeaed864b545dddb52ccbccad1207903dca2156c9ce44c5c2f6f07f94cb03433eff081ac6155cf88d3f3794e1c89a209af0978dbae2cd1a8a7e7f88b30cc17519c4bbb8b0db10b108f1b2172d9f1964dcdcbbdbdd742cf8d5591f04f42ee0f867ef4130d45232d47848cf601edfd149b79aa97ec7802379d0f3ce1d2ca27c0f055c5fe9a73d9f136e754b972ae4a8eb1989551e4c4ed0bcb93af0242528ce352dec8a6db4de5b3bf57b8f9d14523902ca4aae6d97cfcc40026388615dbd2daf85ef53e9300d89bd704d35fc5a180fa36dcbab9dba8742f9f47031981fc6a5bb734a2ba48f47ad5c78d887fe4794c5d71e52ef43abfeccaeba3a91e84dd466c752a8ac3369f40479239773793541e2f1a081e5518fb7fcad08a725a91e4acaa78fd2b65da3dc529d9bef558e64e432d72a30c64741fd8e0abdeadb38e6ccbbfbc3ee7c2e005e676b0ddd5ae40035010a2001e734ccb9d11f1a7b515720136d953ef1366bad0a9b98fd3d7b435583155a7d55bb305c8772988a542e112fdd9fb2646f4c0be872ab120bc99bb7760039d83f30c3b45a8539f281d8738493a42318105660d8d73596c6a1d7127c7d12d79f629d0c740b6550c90f4105fb231019d0bd90ee81a4ef732a3fe846b67d32d73dd23760f838bf7fa67abc0fb0b0dd427e30f57ca40b244e052c2191d7286af04fa359ef744b76acefb57edc332bfa5280a6928956f53f2b143c4eda17305c2d444cdb746c71f1d01e754b8756825424f339fe7008db591f8f9afcd9ad8773240eebe5e0f6c2d3b764d20dd9c5c4e4c2a77446aa9f6502b1a7b87efb808a6a899529db94f94a83077b2a83af55dd7c5c2d12a64ff5f08ae4b703c170ddd5147dca1a455cd3def30306f0a3ab1c0eedf3bc84c63dd72c36a81bc72ca407a67e9bcbd0dd7ea53843bb2ad977ee44b275f244b65e7057337a5227da3fb58d43672f846fadc36637244736494821901110ddf6d4c1d1aba4f8333aa15a05d862300923399cfb721ed4c0f292e5c268fc4ebd3205ae2bb9309493a3f735f5b6bb2199876d5abbcfe9af3c2d48a3e2173113bf84e781141a253ca8b4039f9ff0886c08a6c2990c84163fe56b5e1ef5d43aea3aa09b32e03aeb78a54cd0b53efce34d93df9cccdfbdb310878dd2348c244f2e793a224a0832f9c9423d14c8807084b9ccf5efb2eccf21df1edb36d0bf45d76a707a3f74e294afab805380eab58c85db86f85c219863ecc738de57d88d3513e1163a1229890f6265a7a07f893d6375bab7fb78d4abbd51cdbe03e3f530cb43b8d977a2167b779f51968024c96add6813dbeaa153fe6fed83d480a99297d402d4e41bfd7231f63c7a980b0b69c41533a3a00e62655496c80ce0a6c6794ab167f7535b18117f2581a6cb1ec1be468c1cc7e2e4979ec6b7c7effb753f6428ded3c38cea266fc0eb5e6164307160b5d69d5ea4b88b632ea13978f8f1e2316785abd1793a84cc186707ec6421c881d7a813165beb737444701b18b1282827607a6d81c60123655747cb2602f4900486420c404c085f6a5c37fd4bd5f41a567d8373b2186bdc10a80897668d82d4068c5c0117764deff4d2ddc7175c8c8395b515b272a056f4daafca1356b6350e79014065153a5f76cc6ea06540c9125e96066cb832150a2bd530d432acdeb3ffb5a92352a128836b44c7f2f0958f4295fbb45bf7aa4459c352e625423aadf2bc30bd5d8997eb980d74b75b6e0e9a3e00463705d6c95028427df75eee49c6f9cabccad8cc0e0f08521922697e6b579a605a3c2f9626a2a30a3d5501e65ce1b43caa266c87d4ff5e511568029a5a44fd2eb5af4156bb34f97768e94917f00728e244095197946420cc2894f1c353fdbf85c3501a1dc21fc60c96a60936b940ae93c3d78ee4134a5e98c5a77a5b340e490d57ce9ffc12fbd75d140a25faec9e8e355677d61f550f6054cfcdb2927d74fe39d60d8fa6bf2c9b8e8867d238fc4917eb8371fe258c0a9b6f6eb0c68a9b5001ac9099e97e756acee2900da00bd458b8c018068116d7b3907b08ef8aca9fb1282c5ae02db5a0813c6db4a4375ef0190c96fc86318745449e76ba28b7e38b5ade6bba79287e1ddea08217c016a1edad1ea7a164ea6e82aa6d3a7ed7a118ca0c18dc3c4805f71954c4f4ab1ee009cd7805a5a45591c51e035a83a1e067c78579a2300b7167bc78e4a9ee9f8e3923e6c766cca6210dee284096297335f1d15c967db7ef67e1837c82313abb9a0ffb520501f56216198da760a0bcc6a4bcd06fe8ea7bc8c9f817bb93813bb1a52e0b3e94df55cdc68eea0d10017cbd622eee8b441ec885d49637077d4088855bcf2fe4bc5411d8d17b16a870d0f11138bacb8f1b12247ba8c5908b5cdd265bf29fcbbbdbf5201e79ca4aa44fb3251a9ee2f4588e7584f68174f233ef9d0ea957318b2888766f374de042ba673e3b0fdaf8b035146898f63eec2ceb858fde83b75021f5f395a803990565082f6deec7199907edecf091326808f5ff2f7c65d78ef4262d706adabc3e42cd84ea0888ee0f41a23283d118d66fa7358aa312ae97ee82d4b15c613660b032f573ed5acb14d54cb945445abcf19b35c0c0a7cd4b7f28a482f398e362b0e5a6fe77460514b2f516af8a3d5bc2a1e0f4d245b0ff7cd9895810fb608b059f1fba54c049d53445432a4e370a0967eafb873a4d975c239d4197fb5eab0bc33a65cc5fe61ef21373c165127913a45ea5155742464190356d31c2f2c76e894adb4a89f20cc1f4dfed7c025ea46d3dbd417b8cfef863eb88bcc7289ebbb2c8f1f4f3e8e6a23e25786e4876139c751bd28d0ecc17c7bb3ca7fa46e6dab6b2643552aa225a3dd8660a8529b3ac0066d80e55c8abe7057457c69bab93c54e88fb6519a14568b888c6ca4ddfa92fd53243097b1b7cbfc58f0c3531dfe2ed723b2f3b1fa66396e02f65c797df99506fb48e43f86127dbf5f327e1f1670c56adc9a291063a43aa9549083142f07e0e4fff05b355507ad6257550f409b13a37d246da78243fff77cef5093c007fdea92684a783fc3bd723287c78da28b6206c51e9f0f24f60687cefd67be39f1ea623e00c90e913ce13d670dc9bba9d7c19f492456a0f4e7908328c03bb44d26e53bc078e6b743e284a162830d7c0e8938506ec7b69658a41d2a286c303715a5f2099174d59468c173bf1af3b2071de2bbc97978bdb5b1b3705d5c777f1e57fc95924ed3263f7d811817c1dc931027115b84bb5a2442e1a43d03c5c5edf76c09c37b5b8cbd87d0d60cab325b68182b60d930e4eff6808eb9f2ef783f457b340c7f3be004dedde0bed206531b20e9747670c9dd3c207483050f8908f56f82d7803ab00777141c4764fea7688f4bd731c7be82b85be968293285bc35f0f9ca1c0021e814a9c75ecfd9c19e8bf18dca3b461e716cc6b06d7fb8f081be5349be4029ec0799bf4b5230d0fafa3d912d31cd689d0497aa95833bdb242a0167aa782724161113d4efaa0513d9aed22d1e609f5a2413a86435652152348d3ba789592d1c705a3e234f69f020e7484974c1b25e943ccc3b5fc1edfbd9048659ce20a704d2cda29a4773d88699055d1638f1386175e4c676690c07c0429f06ea0f9218fd85063959580ef32e9783e211fc5f06cc663213b1f398ace090d4cc379b3160e34a121bded921a5b89c2e1f446fc64c81ba6f8e1f32d060a5e78110fa09a0be3dd70d3135ad46397f9e2996bc716370c90da875393e6a91de1a863a5971981f925d1156c5376db64b49a3451a4658fbcd612599bbff4928ac85ea442d448f964f4050c25b5c4871a083c1456997fac14d23f792d71877812070ba793257ab5ddd2ce6ba64278fabb26ed52f8c96744e6f49f749dfb2518e24334928c350163504b19cbcf1aca1d1dcf578c93e7f237e80268d9a278e08837cb59dcb90988413088e876c08a4a510bd40a3d859f5c67da8c8622928ae4a464057be4c22862fbdda8cca22c96a6024bb6c810aaa0bdf1ce8459610e64d023b45bda1a8f108258355a7b163ab6d81dd63f827e57358df5fead5dc8de956c1efc575d6732762884244518570e622d77018f64c6160c06d2ba5a6e2df8dc1b0c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
