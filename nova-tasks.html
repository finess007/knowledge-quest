<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77a985e5336ec4a4d0329bfee037e37a3f03a364b6f44764327d93cda4821ac1d22c37871ea8b4bd71d331b41f6b4097fd931922328af1cac975420dc30af8553b355d8dc36686c6b9433f08164a59f2700e9f85f380a59433a54bb7f71722c45e11118f87885acfa87d313d89ed13464446b4521ae9a832de1063b368de92a3af4455fa9e2d6848739e66a26b13d12affa85c433b44dd08e7a6f9f78bb22b536301ec6e68d69781ee54f5a127bcbd9016eeba53c422334041b8c8b364bd68ede45510b479549168a87859654a4e7e0be885ad5e7da61f032e10f56bd9fdfed3df4b318aff951d9a019fc07971874a61616da59dea4e0a7fe68f5879185fe50c02260e38dd6ed4654ae69433a13d502201fdb1cbc5130be005f79952df252588924f6a9e4e5eb057b64d838ee28a783db2ef121b2c907f3c983e3e1fd3e8db4662eaaaa3014483fb457e2454c4899670715e71db9b6e8180afee279a539d22cc59b0e6f730bef55f714a683f3bb3383ad22bded25eba2df88b0b9989a3ce3f5680b490fc95d63e8506bd6526ddf321b1acf2a0443ece9ab0a20f60963d91e616054a27b0566f286c4400bbe1b0a7ddbccbc0f8cae278d515efed1f0e4cc895c561f7ffca8219049ad250b6aee9a1872089b878b318205c9a328b91b6aa37cb1cb05c7a180a5a3d07e5bf6150c391741ce2b3dac020b198009a5e710dcf8a689ca48b370552fa54e0269ceffe7214afe4c3c3fb92f1a272166e8ef1e6ef962fc4e80f16fbcfd4731013e793938872c82467467f22841ef5b0e56782689bb42c228c938f6ea668e1986844fc4dd67f3157ab2e9ed179d01fd344c254f7393687b4bbe4bd04cb0871f757d988fc56ba92e58e064e81f9fb73a3fa943820e117ef363e78461d0386e7a006b2b579108c3c7aaffeaab44642c0697c4043967c74ddd5e095d5732d7574a989e3ae677bb48133ac32072a9dd4a3e5728ed121ecf266b4a614927475c10d5437f5f4e3c18b6539fdf3713c43b9a3332b60d2ca487eb6a5529135a98e329bd922cf83ee027c093cbd8901b6c215f1a85d3097d3e2d07ca15540fe0670c8b06eae0edb45af0eb4e7f9ca48844647491c93b05429ff5bc8f88650531c12ebcaf4be101361b1bc4a82a9d52ae62fa0575e8ff1dcc60423887f38acd0acf118d7a45941ef278118b0ff0fc36582568ecd10c6acf352fa7c6ddd67b14358debf5ccf4de7f2feb7937169b2212eda89356c75304bee95dc299318cff05c20e0dd6d2e79f800398aa67dba332fad9cf4592e6545dfd5de65f6b7e56ab25045a2689009df3ec0bff07931a80379742877c1e18b86b5d6b13ab90585adfc9fe597b82d0c766488ccc272d13caec15603e6b3a4869085e623ef360d5f8b9bba65a8ad188fee6dfff8a5d8bbaa62db3361bb2e727f2d30bbc3d2ddb42bcec30570eb55d0f377e7bb252454dc55d2dad60e226ba97946937076a22d3ac54ff80f2754ab957d5be35837f1e8f0107f84028f0228eccaf8dbf84a793a2b276c90bf5601d8eae5f85382ebed4a8495e95b0d31e6fba74d13d38d514311b15e7657cf4c41ba47e86b98f2453df325d6125b95e6b3e77b5d69bc5160507355c6850abf794688317bf52936f42bb6610a77c27e81a0ed1a1073e1a7652be2b3f3d652f2a941e090c6d7ed29662cc8b6d32a245a5c780f0eb3140e8495d25da2d3caa32f8b47dfcf00861186836191672557c625f13eebca4700ab2642622e76101c3563173323113adeff89cb778121b8aacbb48fa2f4611ea1fb4edff56d8248f842ca9e12b1473caccdf1c5ba2244ce418ad17a2533a6c4f3b0eb211639a3807562be7dc9aff31d15a63dbf26a706b4ac796c76aac5b9a19e45db856a6a53c90a0e2a0949a4eba1d58d257ec24860ab51660fdb74c004b14e5e3aa94fe559173a8be9cb55c9610a710f751943b0fc4ae66a49093c484132bbfa445214fb41c2c86871896d0824980f3ce0efc70ae39fe2c4d2820c3d9ed1293ae811fdf0035fc26c4b88c3f60e82dca63d2e2a791ae58a0a993d54349ee4fe72d427cd8b5fe21533b180b2d7c6cdd3951edf3c8fbb52d9ba394029810c0f104325e321ca25e519316c347c56fa9fbad803283094f63021a47339ec67dc5eb022fc8538da3d3e93fec8da29b1cc37d6ba96cbd8fc4e68f8625abcd97cf949c48b7032a13058671b9865c3d57ec1999b0903da77a465c0956904ca9392b5a3931fec88d3e7b46c72fe2dcb7f98fda3d419fae68811591c64ae8a8c713a677cf6809e292dc45db4485a8c568a8cf2924be9e6e3874a67eab6d4a14501af007f735f30f07f52e5ed1071e3089895a28a3b619d1a70085b4ead3278fade5d183f278162df91ac098d70e2aa5cab8c39cecf0148b7cefa7c90d6825f4200c7ce97e20746d78aeb827dd82d3ebdbb07e44ac52ab46a67b741987bfdbb56f1acf78bb9d6b38120c8477f502b9237242182ab564a52af8d1376cdc336a9056d87058b98e793ae671b2af65deb8bc22b165dc6d4fa89ba34622b6bc384df48403a51cf488a8b0451c1f095cee66aad83671d45295d7bd7c055471a84e0ad2a866bdaee91f1e821ec71422e27d6bfc863700504579be471220b2f231da314adf496875b25f8c78f86832f1646aa45e07c86bbd71c98084295ad6d95740a55bae9c49a6fbcd4c5b1860114700f9fb6e4b7c7e473a926d40cbd1c4ddd048d2eaedfa963e07863050545677a58060884c597f930301ff2d3aa66154c23cfe518ffe7d5e611354327d41c0433ff7251acab80b94ac30bdcc33267eebbde1964d477046e21a3948d7add97277504f3eefc86dfd3e4682993d9466df89d9d5bc4d43ba4d7f36f2a8f9b6d7cbf9a0a66721bfa6dc27da65340d3108e913ac777a980491a82c9202d6826184773df504a074ac777a29db367a8e007f770070f57e6cd90a59127818b7b1a0ed7252ba831a10919d6e7c713998c71a644821225552d08c34dd5ca512f4682a31979eeb2ad26de0c82b44c3a80eca6cf725d7148c36f42d79a17c9e7357b5c596eaa41c329edec2668457ef6605fe87f8cc7ba40faa683f44faf6d135808b02e987f4393e03958adfe1f04d980b3d0e27be8ffa0aa9f8d4266733b5d88dd4151b23cbe6f2c9acaee1465b1e496221b88568adbb2729782e21c7c8898344ac11b48f26a1d82a2923d9a2a46f0e477ca9e3fa81c2650bc225fc9c5a364e3c3983201d5ceb2ebfd5fcf311c6ae87c0c70b1930a7d24e9d2d95e4bb77614ca407dc30ef48b175bff0cdb1bcf7071ca98d51864816a42c69e894955dd3881109a0a493eb7e9a7b1a8e2ec5bbbfad088b4bac1bd320cbe5befa08cba0286112d1cbbe08a276278894f145ec3ff638eecadc12e91610aab8619f450f9b52b3010b08213673b8ef99ef4e1adac12f52d1d8c0756ffdfe0ac23a8a863d15912cba8017f79994823e5b72195b1ec40b0a583c39ca7327fb4894f3ed4654b7001048649957ff8bd651d0e0ce8c5fb3633c6b9a3a87731b2a5709f483f05fdf165d107119ed96e40a7d56779617a0205ffc244cd7b36674b2327b3294c7908fdf4ffc9e82a6da380163cced798088dc7a49b81e5a2c01204c804ad1ab4f071fdadeda1aa6728e3abb5b711ebe77701c76f413f956bb38f823c7662b4ca074416786b3a947a0580237dfb05de77b8aff23e3a5a1a43e42319fd299f5300a7d5c93d0c49862a072b720e5ec72ba1bcf8a3ce2e5fa7b9b10e8ef1bfb10c9eab47a439111b1a2e4e6950719ee456c550340bde52f732844716f5373e1ae483ddfd3be86f251ec4120473162e22cd2e3fdb1c701158259664092a191ba7826442e4470c5aa4f3d22acec54556e767c1741967cdfff56976e0220943ec1e375a42b6d51be8f0f2eff1c0be54f0b64c9787a4323483d2ac0f1c5d3ab0d68700f061bcc4ea281904317e11ebc152bd6db771a3b9153831e89cf80f885fdb8a694f1802a89e4cd4dc4ed6403396a918b614c493398918c5de05548ad470787d802c74478d3a81f28d0988b543232f22555cb612579dfd684cefca41e1df5003c8ee97e17a94738eadacba65dfb352889fc5d1529d03140be3eafac8878ec75d10773c5a9ecdcdd81cab0fdbf5aeb9967a5cde708f11ea785ab750224d8ef210cb56c4a84dc1afbe0849181c9d53db2d69b88732dc9d524d41aa59f324863e036833a0bd66a26b027915788f8503a9edcab1b023f39f8c96c3d1a26aa330c62448058ee14906f9c2d6720880366e2d29d8c9646b9974aa2db3e419954b118072b9c492d7492471e126a401b83bb8797a0e3bbab4bc6e85de04177319544678ef21f23b5755e9fd75b3eca8553966aaa809bd3e30c75ba23df08b70b54bfc74b958a2e0f7e7f2aa493149623104d65b3e2e5828b661175de0da952c2fef23be5af6d427b5349d9e12b737c1543f41eee2969ecbf1a95678883527b04561301e8a5d74b4debbb8268bef148d2f33c218f075e207f89b3af4a4a26afee8fa7ba4fc2ed1ee9336f109578c47e081a16241f8cea647b78add2b4571999b44ff3afd6d2fec9ed9b93b8d5bf494de2cefa1812f66f01f32fb347ddc8cd930a6ee59bf5c6b2dbfc2af3d631d54ac2d6ce2702a673993a4d5b0aa5ee2a48796557ec001fba19d2e31ed09cb56f222e95aa07a6771faf09fb0dc29bb6ad08ed86bb142d35d85a31e2fc420fb0cf524a21112b1372380a20a9db4f726de2fbe9910bfd7cfaf23db74ce00f452fa73756d09f79ae8b93908d5eda92ccff7bae225ecfc13ed65634c811e1de69925b9b8f12b98424b10ed23e6c0a482516ea81e6de803be75ea30ef9f189e15a3cb0d3c51f32f6f83ba13abb2bb301c79fce50e184b6636d86ccc658711a30d0e44a32bb7e9629a24023bd72704f51220946c3dd45afd0dcfc0705a6711d55f1d1073b390d529d1a5f15dc3f6704b90cda480588ba4ff0474ed38e01d1f0f7ce45f6521c286a1e6a29cef98722ff7c093570e33b79f135ba41ed566dceb1cccb97b42bcd6d1a11e0e6244a9abdfaee5b7d565afcac74379c0b27a188475134b8e5379b6739312bb551750dc8bc548f3f4dd090389dcbf5290b793c7773df5d7f861c784a445a13479072a4be0420a76205a87f2810315b62ded6aafa2cb9ff006d31b03c0f63aca239b95ac2ed22a7dad873c84bc8f1586f043aa224277bb12edfe2c4a27963d64dbe77ee627464bdece9af9e7a573a3f4b7d2d963edf4c30ea3fdd4172047901a5521ef8133292af89918423e073dee4fc188d2b5f11024e88c79ac0098197d92cf12c8397bb08864f7519b1d4ad61d00ff1612af09e298af54b229372a53471d6ce2809ddf40215b340db90a6c53558e681a83b9f4e51b0c8b8849deed1eb7733a132cad22525b82caeb6c9a8fa4a5935065240da18334383e33c525a1033967c929cfa0b3da5035822b591856bcf0a73b804bc5de7ea6fbe332abbdb208496496856af900d5bd4c425b65d8318df04ba78df7f8d03c953c5ad9233b63460827f4e9e81af4a0ceadeebfc71ceeabcead6bb741cbc6d22d5918b56b76a3bb91e25f883daa945c4b41dcd032a77399e8764c6c9cb919e432ceeb8c63330a4c78e923a025241c6b5cc37bee7279c64f6cf9393bee385e1103d9a1b6c5e1655398aa8e6c76e9fbef34fda6a5f7f853e602b7edac69757e8402d90e48a11b4c0e6c207e1625cc0b1261cac463faf15518ad0495ed9222009964b40f370be93113fa24dc355b8dc539c85fe8cda19c2e73691599eb624ba65abbdee035b68c0322269a2b2cdea6be5d3b603a405c5d0427f62af56b12071d6d9a0a9d5de0816c5bbc750a5459aa7e4c6a30d1bb3a83abbecc9db8522c6ec25d3c68f1e83ccaf116a82de5faf0c91f581defb28a42da43b9229f764aa57ff0d63f6e08a691b1bb1496944ddbe026d97b66e1432b360ed61c336405c53754e412bf26dda51c86f186d0a5421ad1fbc6b0290904ea67cf738f43fd9605f3026e4e86ae2783f44b4f51b0131f0c95afdd45468901f1108430e599208f5bf7e6ee0fcdcc7e4911bf67f73b7beed36fc62320b609d8891ea7a3b41427cb648cf17426f353e2bb638c125bcc7e5a0713706376a97402addee30aa763da925dda05f00fe1bfafb9a78853508d2c44df7a029472d83622361ad3385479e4b21312d3fc29968e3bfb5729df8384eee13dfcba42b3552c8608ae61f23203c38ba27f237c8c77d8c99e8cf74325d4b51c5766ad0eaa2bc699ac6274cfb546f4c9363765c178e73eb1edbe8cbf470aca7f7ef51ac3d51503905af5b91c93c5a970726a7078f607598a244f97972b5658bd46709b7770fe049964d3ea45864ae9346431e20008c968c8af03c5709ff788f0ef950d5615adf1a494e861deb9c361a071889119cf9ff877b31b8622d189159a0017e5762d281baeb244975443a645b8aa2d30def6f9e6e804c451d5c06b562a69921f504356a103cc2ea30141b05c3bb0951c571a2ffb83b17bf4055e98a2eb33107f0b554c822f3317d5aeced5ab0371a150e19da3f2e2a6003afa2ea08178ed3097c08e5e0a66c2d7757977a9695d076a2d5655e5fb9a639c31594a469fffa2ba142fbc8bf710e3f3ca2b41c8f59ab095f900c15e768f366ba8549b446f52011799389b1b26d46bb11029ca5d2ec25429bec45df692f99cf23b8575581f4e531d3bcef2ea13f9f1444158ddcfb703bfbf88d53d9465d5d53fae2f1dc08000ba44771e6daf4b01e36f3b20d7761c9a48621b3d79881d2da2723a55a3d5512d2c5ee5bc5432530e5152bc4fee30b3661465534d7492b491a43dbafe8391ac641bf3d3a292b08eb7d53afc1f19110d860eb0612e7085420c04aa9d2394109231aca7a39ae286cebf024c229a7da87e01b7cf68cfd2fc9678217ae7476658bbb0d85dd6a30bc6555535ab731254bd84bb79256fcb5b5342788e63a577e9690ba90824336d10e870b8c1e048194270c142a8988c998a1b741d2ff1455213a2c25a86761b8216982df42bf7e7a765cf548e359216bdb9be42e6f0021c50b2071dc1359ee785b2fa29420eb13bba587ea01eeaa1e713696b7f41561cce9a11699a457c4ed86bb4a07fd5300621b96d2f444b6775e7453c4eca89fb6b7c1cae20522afc17ffa3b562dece9e253e635e3f2b5d4603dbbe53a81634cc6e5a10a1e7361210892586e3c85e889a956b6722a784e5b0fbcd2a46da68fc31fae3d6db41ed577dfd404d6513a63e549d3a22f4feef797d063c876b7109a940b2001933b41689dd9c92697ddd3e45a1e70b86a14b5decac913905937123466fa29a7d10ad5a21f645cafbd1f24c063052a0939947e4a75c51c7a231eac94092825ef8e073d115321759d9b324e968c3ad2f71c0f84d5d04ed3bfebcd92682aeb542661510e9151bce9578f56eef0b4ddc40541fa9c87d056cc30965fe792c8cff52abbe5bb321b9393c4f3b9c53bc93d3dfdd2ccccc6dde92257a689cd1b4b4542574e6b89e87f0023d125c4bc5e04652582105ca8e108886f3f5e636e1128febad71034f360380b88e56939ae1594ee843a44ebd686435b4868195bb8af4c365ed412812f07d978e7e8d8dd1930bcc3f5556f38e5299ed929c93bf5af95b83dfcce97771a0f9f860117ba2e2fcb0b1fcc1cb605bbe6cb04225b854aceb7e34b5359636db6f1f1ff3c044345e3c6c488bc0386b86722cccab16fa048f1db292641a479c62162161706dee99deebf23a6034faf1b6ef0f07df787b3e1f2a4749480b09c2d0ba9007b88d331c3d88dfea334308552136ff95fcb0695801dae9de15194eb97392dbcc05b6b034dad0f1ca519e5f86d332dab7335ad5f3931ece063c6355b2a0f49efa3c544c32e9ca040c22fe724e1896bf464b98c42280b823976c7b649fdc3ef6653544a90992016f4f1364f99e272d463e1fb81c064aed28bf8987e3a09afd864bfaefe573ff71a0c2db6fb59113ae120f10c1d384672c1a5299b5a5c3a8c12d9695f9705bec89193d038f8a95f499def95c5cb7bf297d450fb4c2f100be9ad6afa2bdc51430a63e1193d9c1dc17a4c8e6758978a265b6c78c9808d257352812b16e214c3be29fc4fe0d2c6fffedca6db49936bf4a4047590a1f41ae5d7376f0c1724f1ee0d5e9285c8ea57ef0c101191663fdeea5df8651e948a65f639c17d6958c7eb977b20c335c52cb3d236281cc752840f9fd7c5e57d7916cfef092e250f46173266eaac191a7c40cad10c14b0929149d9b5a1dd85334c663f2d19159cb6b44925c1eb48520cdc56524806c4da37bba937fc1027a643d49bc39fbf8fe3f3b649159ab334b5dd41b74074ababc8fda6020f70c49d3b8905d22201558544b9fab98b411fc93ec2bac0d2e48af5ccf52c0066a635228ffa5bc0b3b77ae2b1a5da1cbc610153df713364c46be8c275e86c212c5775321a35499e71981be790314c76d66407eda90583508b26b2b676b0c9f0f0ee41dec7d3aca9d637fa06eb8cafb55d05d5d90eb54df5d14d6ba9c4c3fc78133281911203d8b3f4853d905e1ea42d078e5010f023d1933ca04f014ecaa1a7e61ee363424d450ff13c842c41b72fa98ded42fc96f3e7c71af5a1fab9f7df7436148b35f8bb2d8ef90434fd2d840d55b5668e88599718a0bdfc9a6f0e85c6d79c4028a83dce8d16c549c5120497eccf9835ba7907297618679e78ddbcfa4ec3415dcc279e9b95a6a9a8229759582931d46237022012fb0eb64911bfd1f18ca35f272b1b51e064a4df09f2081482341b5b4b6a4fd7f33e1cce5eb1793ec98fda2f31363a8fb50e903257f8683819851c073ea1646147649c6b71a296a0c8c76c61ffc92c07d2a9b87fe5e1d6b01d999d4bf6023a2d19a6e968f64e1e17fb4d369b90b85787e3afee4de66acb27298b9eb64b132c8b8cba5288416f722b20b36ccc27fd5af995f6b26d0bf2cb1b150549c428cf11ed8810fea42435b2a3a5ea411ea0a1cdae37f76dff0f13acbf9bb4a20b2692290be68e3efd93dc93049bcafe5b4c983ada4133ba46d5642ed67bfe68c121db2be8f63a10c4328533f62fb8b2183481ac8a64c09da72b70b33bffcc368633291258dff161693e8c7ea15a62b2e950fbcc241a7da633a2baecf38cc2a22b2db0404b89f36a1875eaddb660a76b114216d86e4142d9dbb7c104e2d360a6b5f77d0adbd3eda058dcef52f6fd955d0e1ae0a7e6f5227dad1ddc7141d4574e19e57283771863438ffa4e9224217f0d7b01e2e512ba288e29534c02f40d7e56151721f57a515e83e8352573ccac9563c2f987365e6ed378d927183c4048b03bb8fbe4090a14e2a4b1065850cf548a42672a60fa6e7595e819348b17623fc8a7d2dec6ede0ba6412b2b72821477dc9bc3a062b4c2f5b7c5f46f4ec156e7d704ba63f5a6207c3d315a89e96b7fcb784d9a42e1f2a6bdf9d6bfbdaaa7b93a147cd1016ec03f3e2d77e9fe4582460f8c8763693085ef08361225bfeab81ab0b853e84af45382e2e14dbae5b8e908c95499ba8eea1c15f5cead580e44fd80b062ae627567114eabda31cce63e910a3a8a887ab323b3a6712044a782fb92ca58d38aec58c377a9c165fca515a6daaf145cc96b37a6181fd03e69e20aec949bf301be6e2b12c9d27ce9bcfb64e1aa4ea634657c4a282c82d917071c02ef54125d43fbe06c7fb0fb31bb1a792bf083824de7f4a9a7e9589243368987b72656702c0f9d0a0fbcba1d5db241cafe2601f7db2839f058c7f696fbe1d25fe899b45dfccce6dc1c9127e38ae09f3818fdf10a06b69a8a220a140ca5d171126760b7957d0a6f63dd7114621babd718c114acd54a80fcc460f1645e644d72bd0621e79c9387458ff50b80c3f7004c0a74cf77b0d6f343786a91e9e7a14889d542eae0e79cc4a2ae82ad8d98e3a8c974883921bad92c294a5b18100813c3f3a9e3a101db4e2831b148b0f015b80552a410144c31afef88cbc094c9af1cb7bb290d47bb67ebc40cf873f1c8264f6ee1dccb365758af4107877c4d568e0d960e78b74c6c597a546854ab79f3bb2b1587b1f5d78286c5db69ad41fb915f55d9f6729176876eae4e2ed1d675ae5e7252c9804b7580ef6f8b1a11d1401a03a1c89b3ad26f3ce2de732c38f31e6e7b530e1d051594d131b5189e124607babc3aa4d2334ca9d752704d0830362a4a7c95148e38fc69ed983651fee211e4e33975b2749836392bcaf0d9248c5931a940ed5a361c052ccbd634533531881e37cda33a319fca69cb74bfd5dd2119735c260db69cbc5d71cd2269f8eb05421bbf8a27ee5f43aa6fb1f9a0863983f7cd9141348265420ab3ae3da4d75103d88992e049d075807b2e1d16955e006d9ed59855bb710a49afd55b65c48e51b4a3f17db416d92375667e15a0d318791917b8939f515f0add5eb5b2ea14175faecbc73d111cf47721a5230845df41f25359cdae90a603e830bf3e957fbf379b727fa5dbe3d1c905e7f504ae542dbcc7dfa40c9854679c07a532d83eff07db15aa50f6c0bc25dd697ab293c4a9f78cca42b7ca59964d8a0319c0f161c8b7239d8a56f5fa3183c5ccf9701d60e01ea2a63e215b19e2442e49364f3e377bd8cbc0de8e9a8ac6806c8c23aa53293397ed6dcfed92e55c6e1d0ae6a7d96419e9bc426a46cf38eeb03e206a29ada46ff8251e843f081696e61beed589e655df52dd53f60712cb1f46c02e04f91f2525c538c64f98fd29c420a7ca5591366d5316e16dbffcaac26086bd5d4c0eee66b0c6cd007293a687c42d2176f1f89a57ab40f4f4c5fa82a9c831bc9d0f3a7713ef158fb82d42d07d09c57e38e7e555f6fd82bce60050dfc92d60141d4d680d4c5433b59454d4bcd569d92c32e98ca33b32abf8ad05cd85b8ef1dc7f631d5f7290f68d8a8504b117ed36f30b5fa706f6af017f90716dd390f39770efa1f434669e38175c5bc7fca53336066ff37f44f24bbc000fbb69d74564d2f0a5915b37464fb6c6d9d1327adc9c373b5cd8aa0117088e41920ffc7f088f57351dbeae7c5b0a89741ff8e174378a6ab690cd70f18e6ea802fd8505d4bbb877f679673f9472b0ca84fb47ea40edb4eed57f0db3bffce25c13f4e597523f2a2c319f4cd60391b35c7f8afc4cf94a87e5d94797f3d7e17ccc0444929752bff02233606aeeb4d7c84866ffecbdeb8d9b4a2fca16c06715c545bc444559b5f0b00902a06f2fb3096f5e8f585e30bd32b06a380f6ac9f98348974c41e458b42460209ca32a39fcaa4e3926d58208cf79f476c4fa85ba411a60e3566328e65efc1c3d81e2847a71c634be6b0aad3d2cba62789bcc405ddbe12063756620fb5623c8c8da89c69b377deb205df1753597ddad76c73b931ab2f9fadf512c3e45c3082dba53bd6e9bd096e4910f87154c0f39a2f833d68c562698223524233f11f2bec2a7dceb753d597d084f094a3f6bc1c2c289cc694aef1abc25d28404051c586ea2fb497f58c49de75c23c3fea7da6017ebd70606e753e4dca85d9b27a5f0acc9e649918d012a090db008fec8a77ea51fd260f92ace2982dfea0ed11606972ea6fe799f45c2dbf6beb3b72c3811b18efa23c7772e7690ad5fb75b6e0576202e5cc1f1b5bc5ba1890058edd7a9ebd95d67dfae6f9a86f71c6e7cafb575a1cfe7339d92ccd25cf0a5741ccfe0d6b732104ea5e33e3947d995cafda36c5da614dc53b979f79660c59078df4f5888f6bf0d522b4e4bd8593ae317250ea2324158fea379bd72dc22a20c97a65ff67ef873e11d2e5ff102cc7aaa1108d9d83ffeae7ce10f447195164dc58731232fc3da570a0ad88ee0b4628bd7e0af8a3a0d78fe0c5fb33db3676c855542c08eddbe1eb7870a94a9a48ccec3a48d784a36a468c5a268001619e7f98dc01e5c55c858da97d5526431a0df50a418022c5bd2d81d4f5e2b58d7ddeeb8ec790c58e808b9d530017d1fa0591c57f41dabd22289be1e8ec18258fd55741014fa55306dec87579359d45f37f6079f666851987735616b4d7e31a030ed7069b2f155b6042e8bd54ec8a3d42ab7e04918f10326b0446edc2fd0fd80e51edf0156dc8e9e400cd0eb216591e17b09135a143afd7482b25190ca147e3c398110fa8ccacbd8c573faef4ddfc92b3c9a7409a4cfe3d817abea385e48aa13131d586138fc17beb836bd863be12345d7fe4cd00fc18e6c7d51b68176cabcc173394117516aa1d6ededf365908d79ef9e6e0bd61adc5e24aa703988e2988241f465ad2324ec51ef569be3c96e4297803005861f675a46bf0d370b1602376b25a5aa86bfed4168788d801e573f51190a03a287119bd3200c3c96eaaaab9ae2e08bdf442711289b960f0644d4fb732f6d64d6204175b8dc4af17cbcdfaadcd21afe5fabda90a1ee45ee8eaf2f733bf3a83cb3bea3aaa150e7d01c256fb93eb1ef75e51f98d658de4351dc205c9d9e1eb24799749d32b61a358d7fd2dd8ce7bdd92f01984f43b3264e8cda79a44847f8ee17cbc8dabe2484e77b3ee9af7fd3960180385020eaa3c234d8699b919f8ef7748873e615ce363665c9ce585579546aa590a4191818ae2e5fe574da3bad847dd9ac5139c7381b8328d80300c43d5720cde55cac3bcb21c1d921d790a107a50490004fe6f963085f60affebb77d4a2e0cd8f97344a883ed0c03009e470f8e7e66c040853ac7f7c895bea35254fec5a4e013b48580c7842cf6587e1dbde22515774a083afb28010e6ddcd8a6749edf4ff1a196a201b4045cb2c0f028d20f5d095085749c79d971f02c83e1fcea0d999cae28e58d1db2cd617836422feca2bb83d7a6256cc9a3c2c69cd2ec6c30c289b44c2c38b7e86d96ca09735ba4887a3e047e8e85ff04e82715018ffe0686a645b3bfc78d8f238192a4569cc4087c95edec0c2a3f862f746296807f79cfb5f0d28913d14d5e5e2f7f96fdd0a620e78a8062c8a0c9bd118158ced26071bac49bd83be7dc8ccd4945232a147ae338f416b55d3cc1b3ba4f41131458a81f76189748e95058ce2a7bf07a5b729ae8266a04716fad54a4e6f6d5633f77bd6ae1a291b6fbaa1f28f13400025a8a81bdf97453d33ae4753ea9c007efbe6b90cad0b38e1beaadf2d74a5f3df3c4d7cc5df85c7a767988871f61cc148e6d7cf96f2c40ac3eef707685cc624555f9e4eae0b6540c3c6b28dcbfddd01e23cfcde362ff5cef0a653fef671c9b2d6be9ce8463a557c03cb4b38f96932a4964f76e58cba2d77dc8cf5b3b88d4e9c99d7b4741d929f0adaec5ff309c263485ab922c3fe206724bd6682a2586a3bc66d027e13ff4ba988afb6ab41ece6e0ecdfebd6b78275b95b61aec45677bcfc069a9c885b5ff9a6918bf2aa59dc037e9040f62f0ee73fd44157eba747c62c5f28ba24d193791fbf8a04023ee5242859f39fb3f60901fa4ea0b8405338f0854e517f19dbc955252c8c69953e7b9c023039c2dea49e6a7d9399e225b39b304d416a2a3bc9797a8eb3317460c0c7252eeb6ea77311c89f3ee32341161bab736b44ea2152943f62fc1da189e3683fe81d33369c3441c3b60e1bc81c1dde3dc1b51de22d765898b834ec9f2979f5aac82703fcf386da1618ce150299923ef8894178ec80671b7ff1ae6fef03ab0b9bf5ded81d28ccfae2fb2f266311eed2ae28df061a44ac688b7edb91fd48e3c4f3195e0af4c35ce9414201b102588554414f59ae3ac27cfd01e1bc313711c3c05daa0e263b75b3bc031fc40cd9838e33db3a844af1f01dbc5d700d86e571fa88f2e9ec059d42b60453f68da446dcc8429bebd593f72a9c7c906648f43ccf819370fcfed1ceb6fc2067267467a63feb2f7ca52e29eb0f39bd0892c12baf3ed7959ba20f7b57b7c5d3b017349d0f9e0ba6b1b9a105dc7a5d876621ee825a3665dbc9d564c0f5a600a29bbdd2b0da1a66548cc2326419089ed8355f605c5aa6cdcdcac6e14ce689dcfc1eba85a8f6c20f99bd87c319302f8c8a73940ad9e9a4282332f11d00fb051a8e26cbdfce175a4b100558eeba943906bce495a46051b5c813bfe97141d1666b7b4dfe525ac562ce66ee40076a90af37da1f86abc175a0e4dbf6f838251bf794765a5bb3cba145024229e7445cb734126693c1f353cb2110bd439ec79ef3afce6080ce37ff3ad0dde92a4050ba274e0b30cbc47d118e2ffd96ac2b04ea92f4135256b0ca41e6e63fbf030bdcbf53341fec431e57efd9c33c59ad832579b471c95ae2457335e6af4ef25fb84cc64e6d5f99d91a40c22dd224a0487e9c17981dcc0338d39a68159c019351639672ff7c39ec915bc4b4bb18d7f8f5eaa0ce45328a93c6674ecd44099310de63c848f02a707f4c23ad23d8b034470f5de1e859baa5f6d7863f8fdb41a7c8ffaf703f6c439ba0e4a77","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
