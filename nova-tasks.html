<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73ff1753e0732d31a84e178a131b2373efb653546bd7c3d2680f5034e0e5832ede1094026adddf40d0d76de3d17642ac0e864bfd941d6ad419de0c7321383ac542e14af36459954ba88190f04c34850c39081bcbe259fe35648c89df7e353008f3df57985ccf6fa91377db508362b1f8f55a2d3573ed4739f67dd884fff062e37d6efa27f3a3ead322dfa0946b9fc894a0281acc3d5292f14b7c34999e797258a6b93a5051ae7c39bc554c9978eb3b93b168208de292b54a199cfefee43571b2369a9e21ab44dfb003ea6211038f6f1bd30ddd5fee288edbbe85dd041be7d6b390ef5af73d8e857c23ed9f43ee9fdd9f36e2c32a5d980cfcea4d0f542eaedbf80ffedc9432a4510c78058aeb13248ee20bb5e4299d1007a1cec7f4dea81c5c1da0e75b4e2c1d0613cab99ae5f13600bb595d136cdd402cc57797563dba726eecc8150fedd97dfa2f30ae668ad793d290b40d53f6e52b6efc7a77d52a123d3402ca15b65b7067b2d7509febd8ef68fcc0821d6b0383d895fac316cd766cdf9c767f35eb47e8062e2f90aa6ff61385b1e6cbf208e838d38ad0de7d5c1995c13ebd29e09a8fbfefa4218ffa7b10512b4223c310c6fe2569e2847cf097c153fab044a12f29031e98721457e10fc9358b52b6832abe1fa2465901ced98ff101d089b0ce1cf661e02cc7499199212414af819c81634c8806aa1109c18d94595caf598a30bf6774377f15807698b9c379ed56630703bb61efd02b7ec3e676c45a4c372ac0be19b96723558e2e5193f8fe88d86718b9783eedc6025841aee765a2185eb8229501adc851a084749d5e4e6ea6dfb496e2312633938e479917b7796e155a8c5a03d228c61a574fd2787f1ada3a75ee522c320c6a66424e1373c10c5dd4d0d550feed592e8a94c9cb336b76c2596cdafedce90d3378bd01ab1a31916fbdf79b6f9ba05660de0e42b20688564f2a7c557949ac48f9bc0ec7e5827d253e8ab5ae56227de0cf41c395b0ad358eb3798e82dd66e257d3cdafd0c55b4973105a11088997744a18e1ba499456b48a5ece600f63aaeeec47473b64c6ae693b168d351a4d6078fba6236dc92b55b1d0fe36c275275de3416ada17c8f9b90c17167cab9bc778ade2fefbfeaa1ca108764fd3ae060b51609a3d7a41bdaca9811f02a2160d0a4fafdab4c9128bf962861e26cb193a6e6fde1097895200ff12b838695f1669b314ff1c4f7b1e06c97aef80d244a630f196e9eeb9b4077b983fcf8d891a1767894b8c253d65e72ed53c6f4c730af52068fd2e76efa16dd6ae127841a7e6865c578d74f9c1ec8d9866ecf7843b0c39f8ef50ba676c3aee6f520d87b2dba7a873e90b7e6f1bd0fb00b5790e5db83299b566fe7a8223064d12a3c94c1d1b94e2d9b5534c547efc4913aba27bb121089b3db5d01a0729483ba9c36ad5ccd47d84406e8988ae1624533697e9df75ad62f1740474dc8e949e74579c0fc01834c4f85322c0cbd158aaf00c8b1cede742b6d036d14f81b8543d4573c93c4769803c4750aaa533c83c46fe2c78279f8bb5b3b9142c2152bc00382fa27a9190034bb6dc042c761938f5d29bdcf4fa18f0a8160fd03b00599b9285918ab1e47989f150c06fab8d26fc303f469c8d74723b5e525bb47a47a278b271207b2e3489c9ff41fc5ca1b813d262678cf80e84f26a65251b601e445e88650b9c489a531791d274654d7adbdeea42171ad24c919c8c2d5f732269457a4d0615e121710cbfddc9f31f53519080066376aff45a89cbe12e22253d3751ff40dd025839e9fc29ad557f4a9f15b56861cc82a9100e70fd69a0219a38450c4d78ef9183624d3fdee3ff78453eb3c6f69c82719ca8fe0945ee1081035249590a29dd325fff7b373a307684c921a0dc440acff174633d06a2fda525645a83348da50e0fe546e19b4c11722b7e30495a4e234cc404b0906e346d238d0fe229f483f657d3880c3fbe4ac6566b12bd298824d2229cff5a8bdb60e08d8abf4efef099aa1612e5633ed355721d2fd8c1f274e0fd62d33ec8b90f707f4e34c633b67d49dccc7b82905877161be00dab76248e5807cbb41e4a220d8f7769fac5bc21fdbc938bf7c126cf407adfffafb52629665bfc7cde910900c602cced4f0217e770ef3d496399fed93a6a81e2b690a13b2fd8d7d228a0c1d4d43436872151d4db536ff884ef491cbb2244d651bf04516dde5e62250eba3fadcc6611929ef1b20fba1f333c6ba97b24af5c7d74973a650ca5948b44455135adef23b98a6cbd4f0e066e1615187aa331b4e4c8bf76992650dc244cacf57a87bb69e37b1d3b38c870be002b10823b896c6752c7a96ce58deda1d53f2193dc19a25288d87849511339f712d8a0e5ee833593a6fbde35ad491af568013f868c37e228cfea28bfba47fe8524332c8b7962f8b14c0ae9a1e1f9f9fc64f04e8488c440c0c64c1c57df4408552c229e3300e57559256335d3203ba450c20b5fe28731b1d2a0571d919251ef6c6268de689df4834940e04102ff6961021b492830fae146412f9c092877722fca40c49bac42322705273712c6c94a01c2cacb28e3232ca9c517c6c2ae79f6f31e9c1b3c0556a3bc8f8753865187ee51885a3135c4ed46ae374f876ffd95fa9e22dd66dacba05485751477c63bfbf43a50ddbf23635936006f43ed067c5a9c6bfc43d54b420ddccc690b3ae021bcf1553741c71f5cda67b60e0b53cf4df42602ae445ddf68abe2439da1604c9ef1195bc72315fbadf4eaa4b6b08e42c42da5f8294c5fba1b610bf264bbec333cf5185dfe9dd989c5ddc1a49a2f7e955519388a9936fabb87f518c711612b40a7300ab163966ae536489c4b03b01ddb183c65c0dcdc82f31b206b1b3907d03dba2dc61e7b73f187a90f2f935ae90b7520d377a09cabeb72cbc86899114cafdf0ec347972c703313fc40bc43ed889693150297fb5909bb938b81dd2e3c28c1cd815bef9176d595092ce29217af5bad2761d5342856946fcac453672147e0ce5e231aec2c3ee942f525142b56fc6dc227ed88c274bd64e38885ec1434afb90e59a9474b899fc77255956592e7a724d2ec3633dc812ef634e5da6962d73b21ab950200fceac7e4e675fb9ab646dcce26fbd0a3179888fdc20b5a07134f32be1cd4b68e46a088a8423e92388561e73c950773aae54c425b3781ef73e412026b2a87d7ecdfa7ce1ecb8ad3b5bc5c8fbf7cc78c9cbf71d9eae50cfe532a4f53ea403e6d813a8d17d1fd8252c06382ba82f798d860c4cb3c3ce48578fe87e89b96dbdcce1c4c6d816009e36f8ebc3d13f112599050b3e9f6a04bb4507d985e9611e57458494cf6969ddef047d991aee1226d73df9eab0f2faa68901b33d9ed9214a2cbaf29a004108edb6f429dcb07c1c99daf09ed4ec5c1febaa6269660230a6b20f35cc0f5a74f25b22af2d10c1c443c9c78470a2cc36a6e7d4d18720e3ea1ab6f81e176c1e7b2067398b9d270224645176111b1e90b4ff3bf2fd2a79c9295ee2841c72a3f60a143ef7e75e637c540809fa17243e1fdd5d8268b0170581c8e4720f97d55f6a7f8ca362a37ad6b4f7036d5ea02cf2577fd425d5742b2df27d53d3483481694af34b02de9b4c61757d2f8f31fd38ff39c4b53bb125dc9caa2b9f545d18e7de805457e797fb2465801bf74098c807be9ffd3dca8dfecda90a91bb18afbc70d4bdb2d389090efe0c17dd62561eb307b8551ed456dd694394af49aa7922cad345de63f250eac4ffa0c9183f8378e01d6f4cae7f79298e470338a33d148689609b64ce71d46ad0af5ed6bfe683bb175578430682391081274b1c59b55fee0513da2c43139b26b09a989195c3c11ad6a4675b11862ccccdb798debc9d1f71382a529ec9dde596b47aacb6975d384f061754a92f2663d1bc53f7571fa4a40583b6c679aaf6d0a17f5430d3b5847352690e65d03517067647ca7918c51b006000cb22be2854af0e2b12637b3d24df9e6ca67e5a9dce2361b986e7a68c0cfe380e70ddd49d3c2ba4b8c75d523aad9e4606fb0ef59fdfc162f0a076e99dcfd509014a1a329d9960be30bbea2c4d440bb183aa03a95208bd0f984d0c59d60340223a09e25b86d20cf39e93348a690b079b443d553d3954b9ad20414b2b8662eea9c9faf22361ac2d4f8adac8b1ed39a29f27a2ec4efff68ea27599570882a670203d6f370e1598243940fd21fc61424d7f147d4e74df576936026408132337f691cd12c264e88ba0c4fd5a32f2a89b126e0875105e9271812c482095e50e7c8c3af7ec9dab1d397947471e75a079cb6548d461f6223aaaa2f93f689e944db6e27c76385c0ba9d9f51a27eb4f4d7138e43f91e5d7cda2651b1628c8fd75167fe9c520b4d844fcc0068390044d7eb814755860d47ea11edfb5a0b1ce124ae4dad04dc42093204b2d465e28079e100d74a20ecfa80a9a43cb8eac56324e28dda23dc2887cb85eb9cd3a00eb2b95d9e31c032e5224a92a949748c6722911c2ce206ef4246a8c3a865ada22d96ec56bd0ab05acf106c1e9dd8f5345628d6e1eb9c1fb6ac005d19562c117e1dc4dd2b8ed5e0ae0684871f69307c063964e7c62738bb433ecc7157066a5181ec89a01bc88f707a5f000e6a2787f1aab88a593009015a27d966359ceb93ca4817e1488ca1a18e126b4ba7f595debc30acf3a3f1e2e7bcf8b22b3ae06ebb8900ebbb0505a078483c082396518a60f19f9332c637f304617147eae4e54f4320cad7182b7ccd4d1668d6b7d0ab1367907373dae69b9cc7b8e429d852650224770103a930798b0a9724764021975f26ddbaeedce3dfe279a91336d613b52cfd913cdc22ca2c1fcffb8b59b7fe61d0993905b03e954ef4d93a2773a39bab8ff17169caa7280c28f5013cbd2f77a2ed177340fb92f100bd9fc9ede12303eac1f62b528be2ece1bf74e9232ac37a68f18f2471108a1cbfacdc37e43e417087b62d0d40fd670196f55d4c736e30d84f123fc7f81c4ee0576cb4fb0006550dab40ac2e37a203d6e41c766a909836eb2c372fa003a3c6d4565189a3cdb07fc7cec14253fffbeb940b6fb52ad284c3312ee39ed34494de70f7f43c9d5e067e35c5bc28514d45210ba16a6dd48d1d41a13cafcc05bf7f6dd8a62e892dde7c750e51a0d84b32e35788c8ec4b9c9487d0bff2cabee64f60dc1d5ce30e9f65ffdbc902c95c1a5528dc92534bb6f3a1e5eb14582b46fcc950f82cd163c9e653beb9dafa34ed86758f892aabccc84c9dd593fb800f9429cd2914505188c27f3f5d25230b069fceafc7ae245658756299183f9270649bbe3f85c02f3810c19a770cf991381c7258a745f2c15186ff12744ab954109910f4a59eccd99640869575bf1182ebf3c754f80d4ec8e991a4f9bf2e897102570d6786d4ff373b45958bdc61023f19b5aa103a630d121d1f3ca76c328b8d0eff4bb90e5bf6c3cb58d732286941531557103ee961307ce5f9fd8e3f5c8340b4f4ca00daa4bffe7f29904867ddb43dbddac748b14da0e1f1282b8768f925c49d3fc567da9ab9009cb09e5ff36a581dbf973a38c1adaed32589156f4d4691e01e2ea681da40ea4d365a8d84bce0f0f6c3e3e2cc0d90c899f0e1746ef9fd62920bc8052b7a25dfb71b01d50bc383816468d9566dff55c7bdf5d1c138e875c661f60a5fdd9e890ee7e5078ddbf3068df3a1d0f70d865e6d17965f8b19b314d3be6a651179fbbea2cd0877fb8ab58227226a2d5eee7d171479e66cc0f136998bbe2a7e894de6e04ee6ba5a30e29450c47ece7b36aa9e7ef93ff174fa0a75be93d33aaf1efa487b868e45405b382a4b851a1ba7d496c83884d348735ebded8070813b96daa29395d302b4e4b06ddcc13d2452fa9cb080adc6990a428ecefbc27cefd68577d0fa4dbe13f8e91a0c41c62b7e8d415f49030d6e05193df1005b6cf2e3bcb6f0f89f1f738577697da7a9eda68c9bfeccc75410678d9a6350711f9ae0cc8974da893c24e813df0c2a2d3e6eff39dca6a3bd758ff5eb9e50d3dac33a97381c8e4bcf2b2b42e38e4eb678b1dccd7ec995dd37bbbc164d4379f9e297d8c37cfd848fadd77110dca7f5bbc0640a010249a3a155c1eaf8ec4368d0306c3ae37806d44a7979d9f11afd1bf3a32efbca64630fae5a9e6f8fe7ef07b6be8fc345ff2b33898ab4123d8f4b768153ef21b6e7d480cffe8628227e1246d3b9901c9621fe357df92bba5e798830b4b8094c0c3ce4551c2b3f3292b0844a4db1e5787cf9da49b9aca6094ee3c2f212d4ed2dd0e203ea6601273632d0f0fc524cca1e3d46d3aa2245ad88ce4597131947376525c748f59385ef3cbf1f4530d578c7afa9f996749e96ddc6c37327a85e5c10b4feb3dea46f72b2e0b8fb416c421e91972479e961a2ed0008f70ac04e886de3683fc95a7488557fc653ba6d7e2f50541c5c1118cfb2922a94fe0b359683ec16944ca797c40e1c75e71df46d84bace70efe70730d4837fbb61ade7e3581af82e662c36a3db098d5cb93a1fe29f3bd86c73ce1108bb4cdd39e6d9c8c9d006155f05de3889318ad61457c8561229e6f3dfa5ee505830c549a5b96c7ec5acffe62860cfa7a458f26baa9f15e03a5958268b054db2e6e41b9703027917dacf7fab91536d63a73c556f09b2f817d2d0e7cc46c6d0b36e9abc6f51653ec0387bad37b7177a176a9da17b53d65c1b19b2e71b9ac95510e4774ed33e2a3d65be906a2d5822ff1de7cf0d8abb7e3a942bd56f0d15a4da2f4190504f92c489747944ba76ca7db9fdb75bfc9ac0c74ba1af4fa49c1eb08feea94e8343df8b710f61db1c95f73bd7287523f286f62d9f14cbb708f1a5d85cae8f2fcc1d863691fa2d1a7aa0ee999a3db72fd8ec9623d71f6a23ac0a533b8650b7e215e6a986a188f161be69ff7053559b2479582114b7b818c283d015f29d324a605e3c36a4e4870a52671ba352fbed6ca25f0dbbb0a9cdfbb35ae1113198704a1f03f6f07cd1c4a518c8228c7b6ad6eccca2ac109d90604b18c29ca7ce16e00337b42637a2381d981db63c84fb397ce8d97836d05c792889a1d574444307bcbbc5e5bc0811872b7c16b219ec53eff688fabfee9ceb8a3a9daa08df9a30aa1f7e07eae12d2453325f3082f494d62f561ef031f6a51efeeca549b056b9f6ae7e44ccf5c91fc76521568737f45a7d09c92dd533b6891f2b436e7dfda35bf925b11dc55875c438414843ba87fc000c34f296b2d8cdaedf9e9d7d56795e2a1c77cfb5bacdf2ece2b7bc286027c940aea052309d6668bea09d211bf8378c689b7cfbc2ea6affd61c72c7e505babede2770f2ba55adc50c1763257a84c3f1001e3be3010018706ff34906279f5aefd359157f36cdc514470aefa375719035c2d00344e325b502289f55795f836a8c1c4e18030999a2e13fd7b64eddf7384a505952b64f103ed75ae288cddc0957c7a733d69fc120852f3fcc413831b2cfc151f031535c2e96d09d2fe1fb1408e11f8f30c6e684b78271b09dfcef6b52d58f4dcc48011513cdd46940d1b8d22ce8a7ea0e52a0d9e22c83e67a7e746d79f917456b9f5394eff91f53adf4c5abf04c3505dac060468956c576f6473231043a5bf4db06f934f49a72ebe7a77c70b89271c036916e208553782d783963d9114e45e5a7ebcff6afcd90c02478d8d3bb0e639ded5625021d4e8254739cb77d60637a11768514d1625626a554a98086f014161bc98a788e3244e2fc99b5f4ec803b4afb6a5f619e70a1e5aa427a8a795719d62b7a1b1b1adad556ebb578d264b2a609630e55016db8e93b238e180247ca42c8c4d362f407bb361dd4ff578632334b5b4ccead659a9fc7044dfd0b4877533486f7e00a7d9dec59d4fb18b30dd1b564c9868645dd3e6fe397e65fcccad9fba0aa330c0135e5e47c254ad528dd3cbe05720216526e6192ae98bd8c65a16a7e18895e9181caae5d54b6070bb919c3c0d21d445c02564645f75b4f1a8a11263f90587a084cf72a1da625a5243c3dad080c07978dd9114701e15fe09ad9ba6af0f2254ddc2b2aff4e7fff0b1afe1e0c5a194fbd5817b040f8cf380826a355dfcff7478ad7a16cd4ef483283327c6173aea6e1b3e8d5f1f42e43bada72eab14a3f4f02272d0a2031c613dd1ab39cd0181a627bec4d8c428232e681657a9a563b9a12ef4b657bb2b85de6cc02551662895cfcff3fa0d3bdc3ae4aa6135aaed4c56b0f730580472b9bbac8928172f80d5cb1a539248ae840f418f034917bb9163d6aa667db09885ebc922c7dfc9085e2a372c21ba4da6e0824c642d79fa92b19ff2c9fd91096416b26550c62563ee5c7f884a923758f54745c9588952a8a5ef16008def473ec8faf783a72985d135e2a1d110f74131d95f5cdd411ab92d952700bd7257f04c01654d15254c470d3076564bdcdc06157c54e4776a598b59061cc88ddd0f9374c13f94cef6a43f052fa4b93224d427bd34f923ee18f66108b3c9ae8ca65eb0fdc8b923ce89cb0b73f39a9ab744ad988d1aea94a03943a51e796fb05ef8ff18b8d6d79b3a1ab652ba3b1f535626a23cc9a23a08fa138ce42841c03da69d86195337bd03c0838d5ba331ac95f7ce5c4d978b7ac00095587b44d78c270de748ae619c1c24f109b53733b4f85cfd6839716eeb882b71dfc0941cf3d4bb7ca754017cbe9cf5daf2992bc0649653b98baf47fe253c00788eeeed55b7de1585fb21654bb913d93aea77ff518e30b9ab893168acb0d23a4cf30ff1aa51fc391dc88c2dfb74a5528c59be8a1de942d02a42bba9712fbdd2b2197c8d9d8bd7b4597ae883ad5809b2a2cd7341139197cdaddae611d2818ee79b09d4fa7f716869beb92d78fb0ab4caf828dc5e1e2b2e2b128fd4fb83723970276059b7d6731a6f61acb461032bfec614fe331d0988592263639730ac4807921db81841bb7bd4115fa38461f4b4e2c5da25cc255af3dc690169f1cc79f72a627960fa091aadcc386ebdd917245cf55ab8fdc0a6b10eba813950fbcfd1277925f49f2baaad64acd741f6521b3f71badf0b1875aa471e6048da54d1fff2af58fb1c16a8c761a9c12b4b44c12358719afbdac007ec2e7f8df45cf65913447fd25b9732931060f99c75cc866afa3ce634d858916643d021c657488edcf7c4e18735020adc09739fa1771171ce3d013b633d53d8c7fa08fe4db374941106802a7007ecf37ef7a28e0179c8ccac0c2ff6f645db430ef962da744bdedd58188638174999e54c3ed6c4a628b544b1af9939e6adf8f4798c00c03728383f0ee38e1e218e9085992b576293de02fc5fdf03bf306a579bdcef652133ba92b828509afdd4b163a326206aa769404a5bc4df123e743d816ef74aacc6ad8d6672efc10e4c675227c7e93cfa0c2454a4a925310daaccedbeeae7c2e377ee0ff3a7fdeb0e6259a8c637a762cb8f4d6e8467a15aec225216e3e512c6fc70b905d487fd522e4b5c4c75879e2ebdda1ce5c7e65cb6b0adc0408a97c0b2f00af483c45fd62448875e2f04c8e6e73945fd9e95b118eed8e34291ae13c228bbd4626f986042239e7dd8f5734aba60f37fb17fec27d6145d0ccb35b11321cbb15bc751cb777935d188150b723bb36f736c63012b94a283cb40e03ec1916e222244d5b1e0e830f5219f662420d8cd04aa86e8fc18493ccbd8953a77221b8a71d449128bb8b3f71faaed5ffee4e11fde5e2b0c051b51175e1ff566f6e5d8eeb0df5510ec491fcfe7b1c4a713c0ddbe9807f42ee8b67a24921afac943afa13d02e793f11f4a302529492ecccbfa5a0bb06503d464bcd6796e2a58754b28c1b480b8b02def00c28c74ed393b9b2d762011d01a57c6dfa0b65a9bf4430391ccf383eb689c838d93110ed1a3b0759fbb9b074cce97e9dbaf003d14489b3a10a924d30d5341d3e6eb0bcdb2111bed66fba26cbe460f5eda8f0dc53d9ecab7454ee1a2e2d21ea14cab29429b6f4e9f7b9874ecdab98e777f251180efe80aa575ef4721aefefeb7327e90aa93dd9f47906ec0d9e8993da266cd21c8ffa516aa6b5538b79497e5a34c94d6956dde65fdc4882bf180c2798e4c4a3540665eaabf2a1ac761d6b9d95ce3aa7e9c9c3667b39becc4a13ef8874ee8214beab9656193921cb30b084155d9568c3491fe208b764c28f3781a6169f6591588ec67e32cbe535c88883ec3f50e5693a19c6e3a20d934b9a41d5b255db805bab62968e8a745cc9529e33a8acc891a07f5c03a79d5a467f822f3c4ec814094f0ae0be9a3e6ee09519b0e13e19d0ce6a977c7fb64314f7620badf66be2a1ef8e1d5c5b52bbfc0022a27eadcf0a3ea2f9c3e7dc150b3edecb6b6a483615bba5f75de95df2a7375c3f1779034a8ad990743662d7cf845412b8b5c2d90a523e7091e40ccb99cb7f0067d9752b290253c938b3629f2c7dd7a0ce8d1ab9a3ce8abe2be73b1cc3bfb98f54a474c642ed63ab3b4de2b8ccb41f1c20e3b6b1043776cb56aa02a8b4f2a730d2a6968a5394ced1119e3c100569b403e5d93199057e7b54dc6f41dc6c912b92e018f803e6c124f5a0f8f316c0521b2a848a57bb9e2d772c8492a085f8c95c45e7138d19711d58c4287a1dc7d36b299b66a37a9913081961d85f479797ead2316e37f6cd934b46aef3a44707a7fb9a68ca4f23f39ee78ace4d4e77bd81ca504ab0f725c55bfc62431c297b14219e48fce34d2de6a51f0ff91eb3c9fe8dd92c4279dd1603fc580543c3188731c4b5384fc317d117d761aeb1e6a06eae7f6919b3d44481ea7f72685c8bf00e1d4035753df1609132318c55a5ca39f4243964b109eddeac5bbec080b49b5369059cbcecdad4ac003d9d26798853383780450a49fbbac5cbfa689348c74519a6c987a82caff16e7b4a76575a257998ddfc18a4d37b12e8654d683e3ee58a296aa671c2b3ce87f91d8cc9e0619f846b4e894e149526b1dd87ce8a0a06bcbc697612263c14878447853a4dc917316bf4a07cdc86d91a7d499108342618c91a21f4d214ff803418c3d3c51170ea96150932efbba8d593e26d5621287ea9b78b61718ce37fbe0516f140fd18a348f55e824606147f045b5acadfa9de86ffefdaeb066839283f90f7cc539a83a51277f090b44de2e5e07bafcee4d9a8fdcc0b802ca42bf1344d6212b0ccd5098cbc99b1df692f4af52bf28d3ab93a4cdcb08c7bf888fb099cd06333c479e498fe35acfa74cba026b02d277ebc3a2d7c7aa2000eb6be9ebaa7b8a523eca147ce153562ba98fc1b51476f4e4ab26fd3e6e4b07e05e3bc33a8497e366d7179e5e45c4c5a63864675f7a7759b17631e0eda5dcb973aec535700caf8e9a09efbe4badba2c9257e4f5169923e9075cec5f23dcafe189aa0ce03b8b7b641650d5b8ca5708f026e7d3a74147874190401e582c961a167583e7562bd0a4960cb82de9d6878b44383ac2d880513355d973d1d7b0449446a410b86171acf08285268fb05967034e961eb7882b3aaab96d0ea4d5a3569dc02a74d5e9b1824833227437eb3cc7321e848cbdaf1c390181f9dc81e0dfe2fc19b34cd8a5613af3962fdade2dd73613d4924f2f13c239d4dfa7f9e84cba25f626bad8168870349caf96086b526c9c1a00ba033ed232c82fb0d1a99d569e6661377c3a22000b29e6e6a61a77b5e3ccf5590b07c453c77bf65eff3b404ddc3602931bf25ddbe7fd66f156023341615b975d2326dc5df4b70dc1401e7db805fd9912afe9f9f855205ee6bb0184ff8d654ccd9b84d6860866bb935ff8d8f7d4bf988e099dbca037df6e22d4ed96832fdc60b854a81479b9a2edcc5492a5d60b9dc14eb8d652e77bb24314cfe154aafb37ce000c98ea5d25d804827ce3d23a6ba3675f14c043f12a4ad7b426161f1c43d55d3864fea7bc1519e6735748a608f60425378fba1e4c42b070771268511c3919d77df060d1feed6fce0e27850b18231fb57d8ff0c1c31f55b7a3281c08a6c935b86a831ec47335f54bc3121440391e719fd127181c7395a0fe1f56bf857c49f50e11c4664b1d51edf1fe87f10763b99e5d673980e2a7393c1c86d168f8cbebb2bc1193d251fb1f345905cddd676fbfe2047a56d7dd0e0a0434f3bf1354da6137622230846ac6a8b4b9c30c763469d42ef407c57995a2d024432ea3e5da3168a64a656f072e6933c95b68462e4ea0df6deee913d048e5e45986675ddb338040ecdd37d493fff2604868dbd58b3840e5a5a28d01f74aebc2fe069cc3b9f97e6e836bd573ab61bb91ca239b5cca55a3dcf254c28ceef4a3da5b847b1b459b76bb85f99915716ea91e98ecb36a38a2b2f00eaf427d1e93201e25209fc9cf6d4677614d7d94cf696e2b1da499562e6537119c921112e09fb39b3bd7260be3aa678d4efd2e975d80efcecff1452184d701a0f3e1e7f6e0bce954fce2ecac3b6453ed28f8d0fbda306a535c49465c27b6ba4b7606c93ba95285d7e579c62a742e3aa670d327e9d2b0096cc4c4d5a8e0e070e3ef0f993e8323c6a2eccc073361ca280346e92d700929099ffc8537b95c51a17762f7d5f6ff66093bda389f303de7fa1148c6900beb86a343bf75811afa5fdd3c0e2edc7871aeedadbc5f25805e78a31d159c7c9293521abed8419e5ebde69a8afbe1254e4358654042a3787e5d33b3910572ad3ffa4f2cc58476adb04957b99ba7f0a6c3bb91d990ee652b81d7198c95c7f42e259842161c0f4c4ed5f088728b571226f036ee1610d54f2aaa0b449b2a8d6e3c1368c48a0c480d0d149e3c1a5551e021890b50700d1db7516e86d580dcf2ffa115a5b97731384cb35dabb1f94aaabac1564009d91809e7cc699d79fc4257cf41f38a358b4ec9155824e260f2caafe5e5d436911130b8801e73bc84774c7e3c5e8574bbdbb46fceb2f0fb66e49421ac0f027b756faeac54aa6139c668b20fb58a826b83e34faeb952d161f1009040b68ba5ae53d8653f2c249e9f0df037c690d3842b58f9b35bd2c116bb549af462d86b7acca0e1b41e503e4677cd808e52ec41d37516a3e32842f592dd7fdcb80aba06444273aac3c6c940e0722376e35b86e6654712b49e43a3ee855f4dface19eb17f8e18e726c3693e720e9ad54b84acbf1a940bafcf6ad3f97e5c6fdc1c61ff46a2ce3bce2265e0efabe3d463afc7e86f8a0fe47af015d8f7834960604fdee5cacfeddb3f5757a988a1bf7074b2db7a8a9a7d64f0992e3221e238fd59b9ae442efc3be0e0561de4400bbf6a4fbb5dd31b97c7f8e28be0ac8193feb67a31a59b76aa61d1cce9e1c83382b495592f71e223a14ede458a6151f9b8795563a7322af6bb4e49a4e6ea5d824e5c42cf0c7191a101a15a825a6a5179e090be8e1313d8bada2b07d12a88d558e9d75eb55a26643ce97414c2935137c36f94a0a7ff5fa05d318097a461fb854dca0c9716e104534bc5451acf40549bc94c06db6736f03e34270df71f3aad96280e0c6e96f0e78ce7ffb4956fd6d79bd56869f6353ba3e811891ee0eed3ab6e58af0c4b075af906ae3490b68f471a6fb85651313e2b2b03982d63ff3206fb9336e913ad04accc12b7e5dca27bbda4a519cfbe26d1e833291a90924337431043d22b7b5bfac364102f67ae73842c3b3875d5754646667a3c477a5ceed414b610a35655091601f4a1ba609988502a962d6d7841a113864325051167a989565cf87fd7108dd677c60b737ec5909e075742d71f18863e6f4a2eadf579dd0b04313f3184e0d8de96a0e0fd93a0f2a7a9cc420e4033be5c38fa414a2b1c41f450f7887d777c4f2653c16f8e4c1f36221fad97e38c2a078a43207f7005ce152bb6b70291f2dbdfcea3dcfc660d315bacf087e4cb2b9c6f3ce53feea280af2fa7fc9c99c88537c38c4f49aeab2907991e9f41be1415bad3336d2c263fe4d834ea950f7cd265dd45c2546305a251a2a92892b8948b80a8aeb1d129c15697c2a1fb3c374de387dc8375418a13bb7fc336d66266d3137461fb107ac00632e8b7db83f4bad3fbd01931165dc6a1ba487cead081c02b95a2d420e69e15c26d0bbc167417d220725ef924809836ec19d508c2f58ca405d8291df84bbcec87db1aeebdb09da3b92f87e501781b6a552be1d4b43684b4e4a5f59da6f0f2227a7af5c64b422762dd055e39ed97c2883cdf05c0b6b8c68df33bac76edffa2300e2609a4870b50a73c0258588ede29f8bfb44f3502252a657e8fd8862fcaac740eb3d2cdc490fb62fbe672e51d2a00838fca6a2f15dba5c6d0c48eb1f53aacd55427c22c19b68233f6413401cf67c92417cfbb928acb16e35ca51f09214cb71d12d2c7672617bf0d14ddeca4bb0c2631e900f25f08459f4c24c8037f137c4536113d1705ae8277c80849c5ad3f18c1de645d34d78b543c00b71dfb9f001cffab958e17a78e472223557a2f33dfcafedce30f54405e527a644628c8","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
