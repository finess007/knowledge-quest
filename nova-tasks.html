<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df45b1ec002ec0fbd65688ceaac76819ab7541c342a3a2e2de11bf81c00b6c1e059a3dce51084fbe21d655ea0d6b72a9bf679f48dfeb938365d80097ba62636461c069111a8b210f540224b4a4e5cd80a84e23283601aae3635f65dd89a57e163e433d8863783ffcd30274d0fd054aaa0fa6fc2a987c037129e2164ed4b0edccf74c2d7e6144ffbf99358e30cf3a09a44731f2e6c1991c0d9480ccf1d3431744381bd7cb234c452fe07fc933b66d0622bdb81c239c13f2966050503a00e8f9995a7b000353c6b24ecf71f90e73392bde301e56086b402111effb7ba6d8516505451e3b8f33eb0a1b5145b69c956696a36f24fc418e811eb70389bcd2e341bd549463f777ba3107c87df0adf2fb1615b99121edac7383bc650fbc3e721d000b3c6f793c05415612e1fb4c194bfc409c318c8ee205a15bb06d20fc9c04fa309e4418d6ae625006188d4473bdbbbd661e689128a0dd195c322dcc34aa76a0f6c46ef787d8e5e69256ec8a15ddc631b735e3c2c4bf734682d207dc5ecd3375808fbd22384fb50ea1de888a4c8ef1aa7434773b7a2180a2ac44730a49bd246bbb6c9c9a8ca3b270f092a1627c500c7b0ca340ce7e5b612ed14c2e454ad440e8b3d99751f0083699ef2749189a5ca14a6dcdcfab35234b05cc10b9376bc57da06f735407145dcc360d8cb59661cdf51e6f7d9ca16abc9f864f982ffbb92fce7eb6d93a77415d5713ab183120e90f3e202e7e49cf6ae7d8ec07a2abb832d5663e8e2add6d5080048ad8ea00eb2f3849f67911fe73532d1a1b74abb38992c9d3f8845e6af2abbc23be9339e017a8fd4a9cf81b453c9f3a6e48a51c0f2db629b5e561d3cf2668392600dd7657befeb4199f4c1c0ff2f5b56d53bf1e00d71a453e6a46605a92d383ce1c1b5bc47736cd5dd6229bb9bb25ed94fd085a90cf80c6efc4fdf46da38a9634a876b8668e5d256cc7f958e231558f4daa9df161f32686b0789b4bbe8f3ff4b2f92b64e72782fb3ef574673b148d8af3ebd3589433b160aef878bb53fe83f451db41afa55ee33467300ca14b95b4a37e7a75773d470b571a41c3985af7a03458a3a1bdaf14a81931d351d7a8c72eb2483259c190b1c67f3cd2733ac0d0b6cedcb79bcc0a47114418dcb88affcc5feb2f1af5b7d2251243716ce2b731603d2fca55192fe29916209e4deb906f1219df7ae77e4aaf0fa2f22726276291fc12e5748002bf41e2b5133e30c3865028738402ee23e8dd8500a077378f7046ab6610b53506841170859a40fb38eec4419eb51b1d36c56411d24789425b44d318a3517e95df5f3f9185bff74c9702e5462c0b02acea717567c76dd2c3a636de1817248b1ce909454b8eb3ec7df0fcda1097fe64b651701dc908bfe7c4a59b693e0bff1a1e92918c0ab9ef368b34770840ec31510f2223ead0a61b9087989672fdb9300a5685790a0c92fca627c27487eeba5147eeeb740686bdccc014aa7ea545e090ae57b43ee89f89ebf21667d2d6d1257af288ab9ce961432e216624b018c83a37908d1acd3480884aa05c26607df51e0bd45f4d605c79c1441de6aafbc672ed47e9d56310ac780e85711db13ef6f1e4c2b817c818f18952d6831247c3cdcf8e20a043aa8feb68819b108ff760d7d66b9b96081ff8d561fc7603ac1ff8f70f6f018e5b2721027af7ee486779080564b60386c073a460f324145f58a8468d0f8acd432afc31f78cd18e693caf8a5d3e74d8101548b2650d6fb950e1932725e98c3679a34fdd02d775b4c771dd80c1c6a7fba23a3330f3535c93e9ba6a110edea098cf80c375405e3eb2f5f9de3032a47e93f9d7cd804d5d05bbb268626c5d6a7facf825106c1647b054139602d495408c220328b72075d9538fe1c5534dd05f2f1663e80b83e06fe4bc487cf02419d3b5a1857632096ab1984efa78a330076280032278d95ba6ffb55638c1be51e428a14d7f3e2cd0912c6536004a1a9cad5a9784d95ddbc68c237cbf5ecef993c5077eed1d5370618a0b5231f07e162664d292bde06bc804deebc73052cba23374f558157a752ba89710707fc81a44b1a1f58309f01df847e969155b4242d8c95687e1ab7526378b441b1bfb6a25a0486d56805401ee2867931e16189e8177d3d0d5c7236b8332049e7d6958e1b15a3cc3affdfa6f44aa7ed12f6ea7c9d3c95e6c4e36473fb880bfb905d17721c48bb6ec9ffc69810cc6a36ff0b8b94ef4baad5ceffa8e7af838881f3383ab280815107a6eb0a79310a6730107bc1b31411e77a09e8bfa46d9ed22cdddb2c2f1fcfd302a961375b975ebf78f8952e978622ff5148776bcbe39af28bcfd39cba2fc06fa7f043b498ab59ad25ceb5dff75683d8c5a06708d52cb91dc95e54366d2728d461ff5b69fc8366ba8b9b1a300b5ded2b05da1ca58edebc67d255f9fb98ad118fd0c14bcedaaf3a0b2b2f39dbf3ea142fbaac39e5d2dba50dac6e84a6c7b160f5343ca42e2f149459573cb640d08d9532645b539b0b4a464a14d13b13339fddcc9d088333fa77425c5dd909de74f9b196242d0d7f2eea4048107f5998c58e7f3b47324222fe3de9b8aabd5c063a970e83d3dbedc66eba5ac8347277eb88599324ed5c6c97080d62dceb73ac3fe2d4da06a1df045142cc8c8c4862cdbc1d1155831ce9651b0adc94c135cdb7e8bb3977db6896fac9c08704525267f685ce2310060be5f8372ec6f7af68628dea1d36c8321632c35665c767803cd688b00b02e65beffddfc9d5e2c44077ccea99817d17e593978ace47c9c93a93fe0cc97fde4203a9e31e88fd147470c49056d9f54394127814a3b80c66df63a54813fafffe8977bdda07a92db6e3a00bec4ad3b812040122b0c77563e3a888a27eb59e17777a77a1c0ad8f75e6a4f65ef99589af83b81a869037e04dda09439e13c824cb0b6e734159e2ab4ab07352175d526bb2a9009759d892e6bd99c16ce8045e0cd55788275b75cfe3dd1857a5b63fe2e6b0af27ebfe56571f61a8a596aa431b459c84fb594cf3dca2396b47f16b8d2557308694c1d82a1f6382c9012336d552c6b7a6ed23bf243d08bfbdcccd77338c5d64c8f6294db5986b56de2269c93699d7c2d3cd68bf7526b7d3be7e45196491afa558544914a8834d23d41a04ac669a703380a7478bc1ff486f7bf34ba19edea49eded59181c94d7e7e3cbee38121f49e94fdf28825f64b7609caa5ace6cce74c038b0d5b4fa511dcfde20ae85070da1f710fcb8c1c88ecbac6de716d39ba020107da7a1051ce568bd314037a7af3081ce586b3300253a76ec45ca70d79ce805c82dda1fb0ad2211a93d513b3ac3f18aa4ab45d72520801b144ce56fbec9ce5841ef7a6fe25b18bddb0fc1c1a00bb05e54b514832c0f75b8dad36bf03b9ab8511d125b3c7f9606dbbeba700b6e63a3fa5263623da5c95128c04d1152bedfce511dc9d8b4a744240f4c5354526d356a9cd6ccfa043217b2793f2e1e5ee278c4ea135c16366af29a2205cc01db742fa1578e50c029ac71b48a85b146fa017b5794a7eabdd1e11fa61f518b15fb6366e2aca63d393afa23a96d1677e75107d01477c327938e615e9e27615766a078c78f4306f7644fd7bd7e6ec77ddcbdce8676572e921dc6259e47d70c0c1da3579eed2e1bcd274b0375f62537bbe95959fbcd0b94f640d0eb51f1673199e2205a131f85a16a59015c4ec4d3608cdf74f97b91c13c11e82b87606b773059f0643414c8a40941c8d553599c782c309f499a151adfa7fa0fd420a02a5d0a970e3cb84f1c8829d79813d6d885547d8172524776b8ff8677eaa180a4f472f348ab3cb4bd82ea643a7b024a7ab2e56d144d4fbaadcd82f255f11a3a6db13253aa9c4c6c944fa66689395d46331bcc410fd7f939783f4d9e16d8408a92c4ebdce688119f2c153f618576924c7fe5f8307884a2e94decf1f22f7ac37257c2c83f647ac8aeea96b19346713a51be8b7ea7263fc652741d33a61653be1cc9f136a1978eae7ba798f958927872ff491f87b0e5972b579756b78340c753c82141aea33adc7cba84f7799a1dc57f1ef94af5b518ddd1faf7237eca0f604c8e78b61e24e5d11255a0069a80afc2b28dd9b3a185ecbd49f81f64e0f4eb1333a1f8cfea26dcd333e79839f683722e90ea0c4398515a2affaaa9a26572d3b306c7c78d892a7ad6cc02ae8b36a2f7dbcf2d2854b7429c5610cd2af182394d4f57c039f1e11400f80de915378948f08ebab2bd40544000e172bfb201c0af9bc132e9a3580f78dede5732eeebf4425c7e4bdfac610c523285aa70e9513c50cad7f7dd7a0770ca617c3be20f788a3cf8ac642196c2040a160b6138d124b65a6dd7f7f0b2649f55cf3dce1460a1d37429a1e0cd94517f0747950036bb73cfacf062ddad1da0bca2fc6e374de99dcd4f8c772e4831aee83d26c303e84d5425c5493691013aa106ba7b3eaad833e0e232feff31fa672cbb5ebc02bfd2a0bbbe752c54ff3049bbdad65c1a55ccfb86a24b23a89a893920ed1079b57b8a58b9c086f3745ea68fa90d6982f613fb15ebae1f7bdbaa05f91c0db012fce16fd1966a3f491ea2fd943a7150f68cdebbe1173bb0370cfaf04932df4566455b8a35a1678d2022632fa763e3ee5eccfff7f95f824263cd222a86a06ecd405cad01e8b501972c34e2289322adb070dd8f777f691f0c4661d44ee46ef55248305c98d21870bab6fe77a0c4489a62429c223561205fd8993c0f155cbd829fdfda2c176e785e594377afeb10fca78c2ded71b4d0fe82666165915e44d4d9acd7918270b96a3e4da6acc3f9e26f86434ac6bc9c0358120af22e7cb5a5d070ff959d1bfc8632aada97c1c3c0889ed8948f6359555e477d0a0062d796896543419d1bdd0c21549f22a551897e23d1c758f75020b4c3fac3cea555f5d216f6e92005a3b89d3c0145538143d4289989ca747a41b4d0606651c140c8f5cb8fba59b948770efcceb5f140b7d95fc0bd19ef59fe08a0dd6aa7af1d6daacac92db33f2c30045cbf94bb36d14740bd85c6df1d562a5242adba621e4c554f98210b3a9c06681f2f4132d43bc684b8843732a09c1e87b7cb96bede18b15308907a1dcea7435b16f20faeeb9a6b6d3874994809afeaa747dc5b16a0c01c70e298bb2ba137ad96ded24effbe4058f31c2b49bad6996d9bf709e331f7aa756bbcdcf2c31a6286da92887ee4f0b67f0d52ce10688abf9e6af73b9fcaadf361c4b8468923f1e83f9c653ea792173ccb79a1e6741b1a9b06a95fcde033edc4e5d6812486b50a8747cc37bdfe3adb3f3e4032c0f42495e97bb1057eeec47330ca57e2a739646ed3690ec99ebdcdd19d954b206e598eb79642ec5b458aae9ade57afa739461453688bbc667f780ae760acb8f485131ea6e2d098881f6e3346eecefea4de3b418a9c994c9a05841c1f7230ddc6885e5c28e3747deb371ced5e3edec4d67d06ffec2f549925cdcd4c421fdfb29d94280cbc37fa471aad7b1e8f54da69c08f338ef058aed0315ae6dd965c2751c49bba0a6fb3b757e2c9b9f3ce4c828342faf0b0d2a804d22957201be9b0ac26f6dc51667ef601dc70177275927971a12e534d4801fde3857ae1f84c5d03553546601d06157e24498a826ba22b4f8081fcd30491f5db631fa5db6b41d0a14162d84d3aea6ded1740c864fdc3f7706042e4b2fdf0d8b9652f64e3e70d114bee06d4d82b8147fce37cc4ad4d59500bc796bdf87bcbfeed5503f3acb2cdb0cc61c1e2e28405fb8ae7a70155e14d64f6df0741b53996746a8fa807e8ab2e6ecd9017005c2ada13a48c60ed4b12003056b6e544367d34064f369f5d1b7d18f4d819ac28bf4ad90837704fbcf819852a8ddb79be8536a442bd75ea428f0a09d0f28c38b099f4fc85333181c16b418dbb4f28b248889d4dd5837e59481c68d14093610320c2e3d61a49d70c5efdaf71eb6b9b8fc6966c1f214847e60705945a88d5933f550c654486a27e51b65625375eebd96020745102ab70518548c20d1b48a899af51c2c79f9d2d8e96af6bfd53420f44f2eab5625d828a4bac76a6ccbcb0c723711fffff11afa4f0fd62e07b1da6755264dc1c3bc01d2d5477fd227521e955cbf4f127a1b6ca868d16044910113f84b06fd95b60542c2c630896b79f30fcd2073c49ae68d9ce8b1fd367e014fcd5a70c00b0ba7ce81bcc73bd9fc3d4c90fa35e6343aa519df84d495e82218189abc44a8b7edeb5e18e5872869bc184267e6377b6417a5e58f77ad3245b9949d70b174f95a92304dc20c000c739cbb577d4555cd283cca47e3aa942f9160e26a7adc376ca08ed09ef74427a3bcb1bd61a7a8531b9998c291ec04a08c3bf7c2857711a56af949510cb6f04ae5d14808af35c4c9fe09031028f549ff7fcb2b91b6c61972930869df6d421b341720ab8177d81f7f6d9eca52c9b287f5f1025cfc30260a88cec41bc1e2dd4d706f7cd6429002bff350057a573cb9a764bc289c33e54bd71f8fa309d9200604059b4e98a071c355f7ec162cd7e3f0778fee758ee6b81c0540819c5910c555c8c9c6de21562d3dccd2358e37a663baf9cf22280e582f23690c7118268bba285554c634396cc1ada719a17b2e4932f23a770456df384779a926f640e41c650af91c0fe7a14d3ff1265167e70443caf0d47e09a8862cb3b5d7b548b4ad7f6e9c496b6eab077f2e2d6b93bcbcd9fbca6a09fe91298a4bdc4b703e5f92203c28f3429f20cd171d6955ffd3d7558f33a2e3e59ea25b92b5361c9ccf6359383f2f3beb9ff1874472feedc7766de2188849e9d5a5b4d657f78a3786e4baee0dbf8c7d0fd521d8b8f60b8087ad05614475c6f94292aaae743e0126f20385886cf81c466f56bf235c44c1636624b809c59e12854c9233d56a0e7404f78d455f994b58c0179ea71a0931edcb33bad8ffbec34c15dea6c1825ace7159a39caf9d84b7fb7a13ac22860911a6d78df500279bfb15fcfaf6e8fafe31ef3228fea38415a317c4158937cc2ad256b15909bb7bb70ebf31ddd6a13c88a54d8ebe66a71220937d9c62523b0f6dad2bfa566d9b4cef634b362f1b22be2f60955f329ea8c84f7271d149a166e3392ed180c1cb98a3e1fb8399b56e0fb1f48cd03a0d3dc4a2529870cab6f74f200693061207592bd1f2bad54734dead85bcaeec7c01bf33ebb5caa3c6d365d88e7e56e44827995c20d7878d58e949feb18adb0a5f44a02e51f2ef92122dd3267a42bc2a645e7ece96b6d01e0a844dc741ec6bdf441a9edfec44736e0a6883d83ca4dccb9f759b7d3d9b21ec95681780a77909be2ef35f1d0f47012d3ca022aa8c5dfa59c2391b81f38d69268b13fb8a2007377bbd0837447a507c39345dc139465a4d5953db9292bb7b570dabf032c12a0131fa55d7bf795f5d548fa3dd40e79e895bcbc74c19543e749c443176ba77ec9dd493131c24411a386b6a92afc1cf6ae89d971ed7f0420a530189d3f2bf9e4cb3e8f2b10fab1a07a675b243dcf8c4ef45e92d2c542ff083a5fa3f2a1c0e9f405647f427b3f525d4c34d1a873b2d106ed3358ec8fb8cc680648700a4a32f209e47919e6d97b3d1634058bce9fb05b8dd46c72eef8de3d2af0caf6e992c6a664b55bd6872bd0b4dc177af2ace1fad95c38da089cb01918b40f9da81aece4c19ea8fac892080dac541c32fd737f83dabdccef00db54ac61394b96282fc2fa06504308f962f7b66e1b6b4ad9cca18dc72b261e5313589964eaff9a5c3553c9c0373fb9922baf514f36dbcb031dcea16e89af675ced4d41bed91acba6732fbde1ea0cddfc5967f5a6418bdc0e10bbae8278ed550fa235944f43123e4f73f3fd5d6f31c482b357cf579205e1d54b0d063e75b8ad078a4d623ed267f531d101505ec863a10c34031a75680c03157631f37ab50a60e910e3b0618a4e33fbbaf23a7e5c8a8f857bdb0ec09eb8d44a0cddf96c67da1c8b198835f10ecc4b3e90f10c00317558accef15601c74a457175f7f192ee76b7896188710ce2b3183c64f53b9e31fbc4992d0b0c6ce9cb637da2d84e9197db8fde1c79dfb82188820a6031d2624964a6cd8b8aaf861f95ba68f28621e7b05afb50e855394175eba9457b25f62155fce668389ac2f99b33ed69649d31e5e825cbcbdfe86bd6a59f3e7ff5c439fb7f915d8baa106eb6b4954b97f3d6d6b470d90c55ca5bc3b60b282213e9ed18a4cb7628320a18e19661b67b4ad3f03572f3c6601b2bbd47c807c0b209285c05e242137515256e934175685f085dac67e49023498af6ece1252ac682a1311358a394941cc6e539640a5807b90a19a4e17adcf12b0c35a1fa83ec1180b43032188334b0c6f85b64d366c93c2cb2959b49c4f975b564be84da4f0fe8531bb06a1b47f7de56c2c81bfcc7e59a4140f3d12068c3400be09b0bd72320addc312e00390f08f1469708579a0423018dadaa62c4359ab520e3a83b7e27b54483c566ac62dfd2721271f070c124c0e5aa388c747e70685505fa198c60c0d5dc5dbbb8b1dd7104debc893ddd2191b835c97b1a174592791a11dd475ddca4e25e71deb14a33c2899a8e7f8b7fd924ca0c91cb033ff233d45f4e324e07c1f2e235bc2eb04e45392ea8a4fe4c1804ebbaf2d535158fed6d1f3672747173114da0dedb75accb8c8d7fbe835c9acd162d96349ed5f07a8850a7822e72efa1f1a27fbce279dbe3bdf19e1c63ff6413c8c55d5cf7f9b269e7a0062f8fb190934f794f484f5e05ee1c7e1cb238e897ba3f2e7754ee2b4b75048f091947b58b23c9a7151d7a8b0d17a0ab2658e097d29eac8282fbe900fdc25005fc02d5c6da1ff42d3ed459f46d0510392c8815d5028036c96a12d4cbf60287be2aa60b610300ffd27f39f7d8d6c66a7c3bbde6dc6d0a05af273107145deb3f4fc5d882d441d1e7c3f8f474c011c6789c392c7608056bc44f101f8b6d59bb0d5352267f44c93828dabfe0b4e6c7b0debdd4bcbc4f7f9dfa8968349f25d67a7fb7d09928bd8f52ce35061af778225e1bcc08d21951f0aa9b69db05c7e5724251f08568b97407e7059f57a9c7645bef7aac00e10bb686be398e2d960c902bbbd6a1f505d16adacbcb8eb1719b89eb3d0fb1ab70ade341146247619f5b5576723b5072a8ed85d96aa3cd034eb68516b47e17328f0ac263a4d09b073a1c325c042f9fac93ea3c00d88f975653720e24b251850b27c7ed9f51f91a17d7b24c515a79b89c6ba37eaac1783d3f37debc7310baf0c77605e94725a46639e7622ae2549953826bdfdc7af08937b96e89e054b37008a9c633356bbfdf6fa2f9447eeefcd1f21671dee142be77057d06896f8349ad3cd392c86169d436352decc6ff23f061b2bdf1df49c9c742344baa5f9b4b7345774a5d90fdf7409da08c79b4eed17c520d2a97724b44bcec958df85ae97a481246d7bebab0827b83d92f469c8bf9d8bf671732086b806fc66d7b48439a4922def988c3ac8b2d95e9474242b751af13f64724461e7eb821e3bf73b12ec1317220db8fb903a4687ef07bad0e2c903c6d224f44cb79965c1ffc6b30ed17913b77230ddddf4b46e1cda0251a881a03640e4012d31fef82b73231c13e22341c02b5441173e52f2955b543d70c8788dbebed18555261dfbdd2c45f8dcdf9b192bc77f152e2b9c9c0f1e473c7ea7c4a3503c6464d789b5548b0d2e9989e99b714b39288bf4ab94d44e8b444a09f109a94c9d24d4bb00332f7795cf53a2f8785bdcc2fa244b0a72518eaf1afb048c80c72568ea43fd4512dfdd84d4d4c039f4077f3e0b12054e6b2bb972f27bf42be46ccad4456f35d5b9dfe4e5c39067a3c0914dcfb490b8bca1acb98bcddb6724b8e1129644340fd8468fd21defbeb7d2aaf40c28097458dc6a143cd4de78b8abc9cab3d924d187d5c6733c486dada33d6fdb3c69723f5e0e2bbe20a5e2178e48b0e1f1c7965ccc16f47b0ae53e224e8b31c11992961c5aa28580b13d984393314015b88a31bc8376f8d5bdb6264e39622a5ab65554dfdc05208cd8a374c719e664d703ef1044d955e1eb8cc6d7a1f9912da10440052fdbbe637ac59dd7ac9534b8c672acc8f3f04ece5019750d3e84ee7a476b7da6a3906d4178a2772d379844a61515471abc45ac23b548f22e14ba5f5502138f22dcfdaf6330bea222ad2cb7e26734f70efb5531f9f958382727b0cb62574e3cdc5d2f17bee21b49eb143258b7b58b4bfda1022400c9334e17c2a097cdb23a7fb111ddbed4283a8995a48e46e72f3f9caf58231f7ff5b9da8e3034b0b14a7f2ac40363776b92554a36c583ea2188db3eaae549fc0be4a45cfd33328d1211b790c655cd31a7d03cf6703142e782a7515589630119e91e53a42286719da8f37357e227d53ec35cb2a27f8d0c942368faedcd1b4d321fddd431049089ab8e95d86327cbd099db5cadc6df9dbcc4ca3aa309ad4bb4426075617d50c86cd79155657b6141e7b10fde19d50fc893c0fc208f3897375b4bd5dd6ddff1024e4819af92734360e4f25a9b05365d3a2ba4cc8f19a21ddddfc5cbdee1e1476bef83fdf7cceb40b1981762cb7d30b2cb70392a05222f8ad1de250a25b1457808f8e0f6bfc3e7073d6abfee5693166d28398efbba4d859e61b752a15d263f89f7c585b5f03654913613c88ad88d2cc2f91e56c83a705cc27b1c73c2ab9019f2d871ec308603a84fafed3da8af0d7c7b456b680206a3e1f749ab786fc400dd48c1a6adeed578c0f27f5c812757ac9c40e866c0fbb74ebb07e08d5c983385fffd14a2b0a41d1b789de7efff191b15807a36ba799178fe7f477194b4c2ac379eab482fab19d02b32b2db5473af606f151789463c4e6490389ce1f3ffed9be2847e955a2e39dd8a17a482f6673f118e2a037c3e49ca5e104d47827926cca46fc01a74903dbb6d668204bb347d6c9f50feeb64e9ecaeafb774868b436342217b832dd5f9758440d8ac833baff3e567754739feda1b9b5193fee9eb215b43a105af15913be7b0411e4f0d216c87afbb08445ff5084d810184df894337db3eabcd3199f8ff4ea293f870d6293bd14aed59a8b3d943a05e6c18487d5ebebeb8a278b2fb83399f63fc35f962388a3b88cd7d0da3d7076c4aceff3402cb9066fb314a3cd71213376831ec74ff94668c15e184aad739c8a55ff7f57100eb09ebbbf42b6e44db15238c44db0e8966cb933f798c5fbd49e85692026174b0d95d3e64af6ad9d0391049512a05e800920b548aff1610bc565d57424b116008d890be46f3a612a871cb88a26eda73dab9a3ee4aab156c18c285a350f94845fadb717b01ef17aecef422153ed5901ab68f3750838ab9c7858ea72d32be556fc08ca11d8d7b1b771bc959b908aef599375e1144f6b2469772d68622818a82efc3cc3cc27a78f49227c08761eb1bcb034e7e1f29cb5d86ef52532b3a8d16f6b0dbb8592ae1a9a88b471fb75d5957d1e2144e7816eccf4ac90ee92e30734151bf6994902ab450055d19c4d3627b64c1658ac5d6b0e6d9c0a55847ddc778fe525bb40a2d10c395f20a132bc292f86c19731481c9c9011136c0042b45aca267f680a41b513be29e9454d5ac05aa2c5e2ff4e6843400e9f033e06d2afa8c7f25565989a8cd1f831502e3d9d293a04ddf10f39b2990dc26634d10e6c64f2bd88a6ec787d5a9b3b804d21be72d66e1f78abebccf14e25d07a368eefda933b646981ce9c7df9ae278ee821d1c5881b96465fd4a7a22dc811c828d80994b44a53de60875dbbc740317670647b42653800063118bd7ff637cfd6d7a1cb8b6b8c8e2eea12506993fc9021b0bd5392622dce792af22dcf10466bfcb7c2181c3b0dfb3be225e72c54e9ac19a3430a62a441033c8e457c3739fafc72cc84fa65c7bbc991688f38ed51a001f433af45662151421f429577c0140c2257cda8b1e00391d590c23fc84e5da32f4fdd325080ae88762dcd5145889897ae06bce7a4f14743811467a1fd185f0a857f902256d6c4773fedf9b49ec39a36da19f03231de8ded7f60ae345eb26e58ffe441a021114051c3b9603e312598a35a7011dfa1c19e09e863f6119927946dfd95d61c4ef58b1f52448d705b58251c826b428202a4155346c6dd1866f8199593e29a05a3635fa44df6358e33995e4feafb007ec4ff93038f4ada4a75aec9f28aff019ae6484e4bafc872c3bd99cbbad73cd140f6ac9cc8a871e1064df2e50c07c99271971139bfb3e33ad38f7f41d956a9bd9da1f51174741ee40ef70361feb1869e13876d8ebbd397b16766710dc894490c0c4034e9ae0c32f14342693285926ac49c0abf974e862115c8e94f2b40083f813ccb1c97919ca85608a446f9f237d4f732d2c1f261c85a596f3be20330c3b61c570ef924f51313710b925afae3ad36139dc54a2ce559498ca99e824574d9c99a301fffc588fc2e5899fcf134c640a92eca12cf426b71af5bc1582446fda41febd06dcca8f191f45afddfb6a13604cb2787e955c1d39d3e754093e057c54a87bd4350b7d765ba36e687b2c985d72965f1571f186b0c929cf4d59099cb7c01101dedf6cf545964026f531164e8fc92b6d22f6065c220973a1af5c0a7a363e09c075b3ecee94d23ab522eed928788f7b6331dfca6dde5fb4d6195d832943f2e82dda831960af58e86aa24362dc55960bf3fb5c06946fc0d8456fb52190fb938f281a1261d41f8d506b10c1224136695e9844d6c78638bad9b077798e463b213d16fe61c30f871df07706e9064243ad63448513253d34673e787fb54168684ce879db82db4757dfe471c0ee3e4183f59bd508e386633fb72c9ead8074e35bf5ed26087d50205b10295fe91d38c5b267bec209180bd53d7970c9d3bc015345243e5680d5f23dd04a6563d5c84a3b763b0a1252b8ca15b8d2031463dcaa7593bef8f4ddb430844ff3423ced8124bdaa24071ea8eedd59a4b2452de1b6de7c3a147225c1fc9720fa616864661afedc61802bf304855d7fabcf5c5bcb871d60b1dc7749c7579f74650c2db6ad341d66aa3c2c103566bc53ff8c9d6ac851c904054730237910dedbd435884065966f6e68c17d5564f2fcf553e3d05010ed19b5d2bc889fee241f650c9c1a85c6731a9cdde8334601d1e3fafffd41d8ee26dc47d026fdf0b2c5d4383f11aadd26f10d4d1e10803df44fa0b59a53f176c71c3c8f5eb7c4ff754a0885dcb472b9f4e06892e9997983060bbc8fc2acd5e0d4726c74e88716b949936f4698554a212aca905150134fd509d1b3ef244f172cf26941a88f489ce5822eb807a2642b23f5eac34acb869dc216bfbf16ba5cb1428466c0b91181845e147bab758ed1b0cae26a33db947441494f3c6011c35e2817781f42df8ce56700bd946c32f29e25d7bb4baca1a4276cf8089e1bb0f71b9d65e048d638dc72571de32b45f30ba6ffb18d54d0cc91edb2ac39b31490393f8d2b663b83cc21373b9fcd9b36dee63569e62040f35e9bbfe20d5a08f6809a7dccff7a81f906eb160ce53175b51ecd0b7a39c31b503f49300b1716c4c2a7ae689c93eb1406901ecce6ae9964ed22b319d72d3586a8d570996f79787e029d45ec26bd650c2529f262931d38ba7be3c13fdfda1cb6f8a60b265b6679214a23a4b9fdfeb7313ea1490223d4cad26a862920c8609d34cf674776a02467b1718da4778808280d6717239771b9426a5245b10aadc5f9a54da3026a214ba360772b36fc62bf87337991cb326ad872dbc9c0fcadd8529092b8842bfb5ed141ab9f2231e3442a52837298b0f7a31a3176718888c5e5d52f55203e2f6a5f79eea5b702c77e9f517046de3999f7dd15eed75abffdf22b9c4a7d4a756d6da57998a2cb2ec2c0b1338edab88058e69f8689590b35e22a677206ca217e18de576ef920da01ad99d81f22061db98ba15351e3df7db13fbdd1fdae1882330c5018aa20af1cd8953f4497a68b0f4efdd67d383b42a309468b707b8194667318e59adb03f132bccc664b59a80ab74da999fcdf2e0658c1997071d226f955e750e3d765613eccadea525522ed3b7003f4b9d980ee444272e513356fe720ab58e0cca82536245f771242d7397c4840e107a0b0459aff4a2f8ee8ae522c34b5c04dc4f250c49e5a92f93b593d36ba2024a1ce97835414939c97db2d472a95e53f3045957026825a49d9c9d2d1b7bff3c6eadfa83669b95c55cf57f9293d3d9bad7ae4fef4c5a9e7e66a34385f01c8afdf685c816c3492088a588f6374e859aad12437ff093a4bac63ec2638a624e9220fc7295eccaec4edc7b747776b7cfaf311176f1cdf9243178ffa3ece49d6ec1724ebb81bb14fd2d63a5281e224cd0934804bdd34ac64253e6c6b3a20d050ce983e3030cc71280ceb9292b75e4bbe436940f6abd6e066887b03409aa7d5897c4c23cb52c995798d8b9665767a7ad7f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
