<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81db16f00aaab7d72fd01ecbb9a53465cb1d5e399bbe217426e47dc41eaf020d94668e1666620c5906ec9f849336d92882dd33b4aaf0409676f696651dd29b4b95f46db3fe00a678a2431834e15e7f5b0dadc643fdd4a2ccfcd7bc03c5256c168b37b657dc994ea66317a95c4d9b231dc210990f00216ab139bad857553dd217a48122e283afd168a55b45ea8b215d54f367f49e1705d5193ec0d1a93a935cca21c123db79884385fbdc6b5af1cee2e1968e520b6d268951c13e2131771358ed9e343de0fae210dee8983198e0679b534842a3920b940714be94e9fb74e77e2c997ca174bb5b98fa97f2f9e156a875a19e453c1fd11bb5be6f366dcb0c25e253b37218c4b22fcb2d6f3b420fab46d1f8e80fa5add74f0eaaf495f4384223d3ced426aed3d1b14e54ae62afbee47e750efc5fa028a50d54b4ee98a1d2ab666f02189eff7a780cf92e2108efc6f5e0c55ab7204aacc6460b123f6161333a691bec5904c49d6b525975ebb12439218e6a886d220080e6004aa834fe8d9e71ff1c1e38dd3f7c01fcb9dbaaa97a0f4307180361508c3f351ec22fc0892c263d8996ebb25c8b7b53bb7ef13408bbbc22eb2f6bdddc76ecf63a1f54da6102c363a0184d797a76118e9e5fdcbe3ce5cea6115c7aef74d2fa4a2e41c3be9ad9dca298b77544917cf64cdfdc5ff19fd6ae912d02ca1a126e8ba91b33c6c8155f38090612d73e8b64dde246fe0ce08d3238af82b15b1b94f3c98626de357e71a9c45cb8b4bde7982c492ac58bab573b7e9f000c29c4bd74caaf47fff7b51e01bc68b41d0f2c53b0d1bb3f0398fd506bf71327a5559d1e5b92035dbb3c53e043b65fc0d1d22b0880c13d4af74cd3c4a672f9c2a2956e3cbabc2212a87644bd7c791272d1fb97d890674be9e8dc33124531b344f7cbc86b756756f7872355cc94c80f86f0eeddb71863f13cbc369873d0eb9da16b43e41b8d32d6b0251bc72f69891620b12fc5383caac136fc7da93a00cbdb5068356b498a878a0c6fdbce9a331c28f61328c519b85642bd140f196537c88ef9a98d06e15826bd5da220a31194cb7b784f3155d9f5a3f916e99a31df8ee9bd73bd935fbf6c71da497629b00532b648cbc15976e3c4b51f793cc70db4b217b645635206174dd3e10c4e9b76e9696b49ce9d86e7228ffb297561ff0ec97a9ebcb8716f7d3cde43445a39366224080c6d56453885f88cbf983f6acdde5f34d442a8d9ac8308c33b57d432bd07d9a43dcc595c07b862f9d916947048326886bcdd761862195f8ad543db8fffdeb97047f43dc7c883f2107830a4daef721979509c21fef5acb26eabb4d085f667baae85fb914ef3362a7f5232c89852203154ca7316dffd54edc84c7d6dad109b69e4fb16c682828e2d72fb6d34918cdccd08abf9380c53c9774ea8db08aaea98a0f63a0d24776e29ddc9984cb63189de4389c743a88d2a8b1392f7f41b3ecd54fcc70ee553de63908fd4ad46f34bbb96902d2ce6983214b94cf87d1c86bad08b8d23c6e7b52a8b8bb3647e668535770747e57d797cd71dc6367a63a996649f780207e31becd0a9598555fbf72e0ce2a25e661fd4d530f33f8a51c3a37b83688137237c98aec5ab1d7470c633aa573d504eaf223677363a65dbd07af1458ef68d8aa3cd0f5dc822b311fde35d660c428549ff08a11b71b1090f117d2206ccc0001921c60f37f3b4d71ba0286e507cb2718fe1451a4c8f2c4075acc749e56e9a6d479357075f6dd3e96fa42704e911c2609bdb273a711de3210ec347d4862c01dd6fcd80d2c986b0a54003edd7509c5fd84cdbd34041fcacabac67e9c841d5d86a559793f8480c9230b01468f8d8534a98584b76a81e69c045dce9eff5edda22a8502523a57518f36df2b5f32e71db8bca71013243e5d73bc524627aa6c98c3975cd303a99f25520b19996102aee272c2865a5f904b781ae1f8ef9b46746aafe9b0e8504b0eefe49f54f82bbe666558792c892131f8ad0d28e7d4177a2c4d3f8524a4d06e8b9900b0e4409aa3bcc70cbfdc51aba94763191dfae9944cb62c8c19e8c3fca54f5c9d12fb8f6212e78f09d756d8f8472f81135dcd100e11642b60e690fb1c55c7ad0ba288eda76fa60916447d091caafa7a9a797e261c3f7326b3760ee8a1a59a627ef869ab826b50a6ecc28acc72e1f8888a69b876b15ef33e6a755e4f03848268f948a5539a46dd585551ad5b85234e7e750921330c82624533c8eda50875302e134f366b792e94576c1e801386e98842c46e15318c7f26d99abcccc7fa3bbebcb9f8d3350f04b531bde431f83a1a5167320b1b0ecd9d5ad433a0556a17a2c04d8da0a5f13003998e2faf39527f3de0729be985b9c0507b8eb73b0beed113c1c2061c2152ff0513dae0933b6c091a40666babf1a31372ac4106801d65d0ec45560576ef0548efcab457778c7374daf9c0f9dc7f00e65ee39d8fe869b9d1864de62280cd96fb9c12e3e0bff09f88f6bbd0a5a74f828b89f2a1b532c327307aba9f1412714ba59c3fdbd23b84b567207dcab463e33c147d8f3d57513f9ff3f66711b2c51dbf753f0eee35d61e18a63e1d9c01fd0696ed831593e3ee6b25f1751925e5da0707432eaccb2ec7dee961be17516b870d7d1a70c3ff3e44ab283bcac7062d582da2ceeb0f34c851de7dae94784da46e9ef107af57087cd5b9b48a3ac5fb6981633c71f499dd37722053b3ce66706bf018f59a86c179edb313b168b5f5ec1cf118da36ebe5a9f3a096f4a9a299e507639b0e06217f6e1c0c430d57284360f264d50c8abba36d2242862494e5adbfac727430cc93e7478c7d81a0af9866a8a2653b545d1dc3dc5a80f7b20f7dd494740327f21fb8d05dd57ad68c36be88d921648b98881b1dca8aec28a1e25b823d00fbfbd5b5e5008ce997778923bb052c3dc989318fab29c2636bc8f60231a17e0739cf8c2b4f540106aabc03dfa75f878c2fe50477c5619d75e89c218e0a123c4a35af62b52aaf5163467052867ed8fdace523aae76b42c8584f830e1eac001b7bd5b96e33dd56727ccea914e5c9ae0391a713ab74a068b49835796748468417d0bcb37e9bb9e409ce6aa0626853ebd6a911b65b19d446797111995dbad8dff8bee019b2a3f5bdb7bb900cbf6842302a861fd8ce7db0e7a411ae2a7e390d95f42d338c35f5a492905ec81344d3fe7964ed074b48ed53f925ae9a33dd07978a479a246cd25a401fd888753e37493bddee243110641f753b82916133be136c23dc31a09302842bf57f147a28b0f63d792786e6b89d02105b215a06c6532f27ba0c5ff30e22c583b39c4853bb575792ed627f1989402a3d1fe56650c481bb09e24da28dc1040990851e702483c0646384d20af14697432921b02f0c496ec121308e5991322a700217b5050c910d17c154d3a55f4568835377d70b327846773a9a880e530c8328cb46266248eed2f0032a881b3ef36adfa199530882a8a5cea6c2f10417181847c6952e88ac754ee5149686b55c5dc0aaffc613cc13947620805ec957c887abd8451ff4e9d006188e6f218b30da82f3a5079466a7150b1c12986f700ea3b17462b902c5ae27371626dfcc8b593de9983362b3a1b7b4721942b45406db194140011be559bde5016d449043eb58935f494050ee4026f7f20f3a4ddfb3683e4e223cbd287e15456e9e04d4a6056f60b069c6784ef1c78375dd8fbfeeab44e6ee6722a1ca068de7f75cd36c47f6d850e271dd344efb4e2e1a636e14febfccfb61690ef4e76018a9bf58f90185eb4b386c5399a15ffdc19b57e928df2fc5b5247cd4fd58a4901e674d09513fbb1d1cec8c4f68b57fe07d350cf23635ed323c05fe8f7b1392ca08a35b6b0fa6e2e726d9d1019e694fe77867d00f75f3d706f962ed95f9ebb5e2170a578360c6828069d46264fa6993d79c707eaf54d522f9c7fb8b53bb76978871e7196921666e8f6469ca73ba985f8eb0830f8a0eebddc2db2d72f8dbc4f45c2575ef65034c3d2b18b32f3f07158685be2d9f590dd495f3bf04ece848a01a561576a7ce39653c05662ee9b199ca7db25a27fd892df4592f167cce001475da69b2444186b3e3a9505a11c4fdddc795327e9c33b9088fb21f02900c244cd6e5cb3e0a72c7f7a9be1aa6490054b1748663fc0b29b268635854081f8d6b18a41261dcf08382079ad9d6102a9d89adc170aa97975bffb44e51c86ebef6c4fdfbbf94c67468569f63a36ed256428b69219ad83f250efaf365213082960207031e64ead1df646c71fe66104370f4a12421939f39ccc85adf8a1c6085100edd370e238873a55bdb2ded63fad259ecd28599dbe07d8bd95c7167a156040967687ae56bc5547a4eddd25bb0ce96d21745771ab3683cfabe79056898ca65cca65962b16ecdc03b4cba60a2bbadf36db01a10a9ba627f6e876a52b63721d53ac832721a9e24d34ba643bf1770f9b9080d0e852fd2d32db369dc42ba8a716ba38a1aba00a87d76bbb3d6f32b11e5d4bfa368046bbf06f39a96e6d7a1349d777a9426418d2078b4fa3a0ef0ef8092dc31951447f8c3f1d32f587ef7656d52297e490f7c10bf2a08a101197b2dfd1a62ef1f1c74dfc2d76c94351fd93b14a76c0e3b0621f3b1ae9a4538ef43cb4e58e194b40f3bd912b4551c34f1f9855fa8bf84284f46cc49b1e76df548bccab441394146afe6af1081bc341eb8d806c07abbde40d8cf024e1c248c7de11f6ed7c006cde1cf26a7060e9af88f5d16bcb25648b1530c433441ca973c2b434dc38eb8b1017b0a3f8bdb0add9e62df5a3c2a7492d1c81702e6f2715999d70fb10418d0ed506ea5254292626b9a573df9dcb9ae1bf2acb1a6c523e4fc54e7be980413e7660a638d7321a257f657ed03c629242129082130b12e6a8316936f72b1534ccb8e75b0d396339c31a6e997cfdba9e33736ab7fcfbf5e6e4fa477c8121936d73535e3b2baaa0eedca66c32d5cee8447ff76ab399f7960b4814fc52fb1c4c12063817b416f8aa93036ace496c66e4626ef4e80fc1d00885e0a99d0762a7d21ec32b31264fede2ecc4beaf12908e98e4ebe5aa295555158224428b8d370a2aa1a447ae220e1a74043058c811273b751ca4057879854c8249ff69df0d65cd8ed4b8ea6d01a2976f580c4da9151716535b55bcde768b5e64b54b44f734f7a291a4965e06306be9fd9cd258c4e99d3a5b95080312f51432b78a6964484dd335310e484b152fda08db3295134e76f5ee0c519cf2d6f1ee600b5979ffa1b09246be223c11641cd2f794754a6d888f140e65a9883bb549257c06bb35d6da127f2bc0fa9eef43ab48530110e53684e1964981f5b687bae282391b9376e47e85f42cc5238baffe00c2a7418532a287da79019cd996c4bcca50d023981c3420f5dcb2a88be8bf475cdfe5fd3d068c92808f6d37135505ca5801d5040a6d1da7ac1034217636b09c0775677ab1000615b46f576658ee2f8aa36a6d22f2920acabba92141f2e67f36b69156e4fc1427121a478d50de36e8220d30bcac10f0b4faaf75342c98eb1973de367dd8f17349f7bd0c7ec59a00fd9a20718361d6ca95d80c0b309fe423ce3132af9e1250710d40f39ea467188932431c82c64e828dac19edf6b6a22624a241a786272114aa8eec43764a2228b584f53c0e7e07f542e2bee023d1bd18df68d5cbf3dbc0c8045044c8f92c9f8251f16d15d560b80f89a1110fecf1c8d88ad2458b6478ed47aa6edc02ad22d7638ae4e7d4f706743d924aff5df9b745a8987e85f1796c0886aef97ba18d4744a7811cbb102fe11b2deffb9d0cbf179008ee723d7c88b1b13319de2b0dbc54c01f45bc34ef63fe70606041d1d28d95232f9c8bfc960bedfa1a406f19003de4eb3ec54e4c8c145f7d1b85fdb04737ef388aa9df228997b362e3222b6f5c0e5bbc930b1d29edbb1797549d7202b4fa37a9c4792cef0db8402d3b869c0ecff3461b95485acc94a03c2e2863d8db3c3e7494c955c464ab8d436557299e50564e82aa5706e76e1078b0779f3f0be9d29156787e6f1a61de299280c3f8556e85b10ad038977b5c6aa7b04ad582f9d2c96c72593ae01da68b05b34461487f0a5a460d7993bc3c1e61cc4ec212beab817778c421d2acad78bc3e3192b7d65a8373a01afeadc34ebdd04dde8ee14a8a5d5075caae2d37eb358763894a6a9c62a04b041369b679638e69834ef34dc9cd24ac1b9920b13eb810797921657991935e387bb34c9b97774078340cb0798b4181276e0ea856f3b442ac767630d4a3e42563a62b029b7efa6de860c2803f1bfc0a51f05ee50d4450112aaf50d428d62088acf6c402f1f3f6e9f888c078580b0343c8a2a995c94d840f5b2d554809300ec6b8e7d1c4cf15d9e192e742ea6233fbd2d2847873ba984acb0954e2d3f1830ba4a4dd87e494755b904d3a8e54494b1da02dec66763df312bf3035d1b21f483cd44ba466130da444fb6b1b90eadb9956cd02c46691e6b42d8bba98349c6e313921768b9a9ee9bb8038411e113caa4bae3a1cd1c74ebb23d82845cc53ecb3dbdd7d9b9971620831aeaa8b1ef43515617d05ba1f6c2f9f758fe7c974780ba7ff5e1ce728b9077f7e3e0ed5f3e783fefd092be60061d71a8bb2480c74a4750758c9d78da8df73bb1be529450fea352dafbf1bf20cace561131364396ac1ba71c03940433855007791a9a87d67d47151d09f6d1c8243ca62852e87a002b2f81d46a935f833b2930e4a4a25bbd2d9e918ba93237fd0b8de11694224b4b9d2dd23a2fd4268f0092396e20fe67bbed84741b84bd0ea9eafd43fc3c04bda670c55e9801b95239d230b7be5e7f3dcb6a7998bf2962dabc144e6e3277e9c7f4ab7294eaf686a027e78d78c4c1921e263922d733c2bccbc7fbedb29f5e7886240fce9395b7ef5f088fabdfdf7949ef7c9fe0160ac3fc2ef5e779b3ad79addc885e25c9081b6533f43ec41de7f96422fe78a9b3e8c725ea0aa40dc37a5dfcef50be40841efc74131ee7d293b1040166323effb6dd4e7522213aa867b713c640e18df9a7fb27d389477866bf78998711c8760d489f9bc9b3055dd35505c920d3c5e969a9fe0806a646f0d75d18e40e2d1bc1d5698c85d621773f7170efd5a5e5604df6687cef78f21ce54e26a53132d0764e868434d218aa95e9f60d12f96fb68ba5e7395bcfb41642f67e26da8e6d5b353c88d0fbf8d9c160732cd6da7b2adf3cb3a95938b7e98730e11c4fcab9ddf655b1d76048332c1eb6651845ad66970ad3530113c981ca9cdbd9e84dc89b63dfb7f46c99f9e44b0b0adbf949a52e66676435f509dfce5009e546d8a9c5e5067956a1520b23fc15f20827c2e9a8242c66ec762bf99592455b9596903d5e546e134fd1eecff5bb0678ec04c29fb2989643b952895769baaf14e8f0c3dc62f0756d8e4f2218e6994a4b9353396fc1bb757b150005a4710f1b494d085703c10482d3a68595083c2d6560064201cab814c6509714ca06700ca35eae2c7bf1990369e73595d6b8964a1b1c34c7a79c2af9a1334af0e016e97753f781ba3d2ea96bee996ccdfbd30bcb94a422e7ecbd6246f90e94c22e2fcaf3daeb47987839c7678797b23230515068418fc5a1ef40616efb7f626370f1b200b8c0401691aa17037261f89c33a69f16e35effe243a801d4a70b794451c77eb0d86370e95a9eaa1fbabc02577033dffd9d7c4a697fb1826dd28756dd4352cf6f05aac2e7f842f647e3847a5fb05de6be638f8be73d4f12f49dc81925ab2077b70895d04b404e0933844de20221a963020b67877771b86dac4833dd6fae69f2e25b742551e7a6f16318e74f77a8738f97f897600fc83cd93e13d59e8b62721877dd967d694eee35c87b9b9b624227a80d32359302ad8feec43c3605bd9feed52c8711b52f96662f7212ddc76ed1b6160ee4d70794b2469ca9256b7ba94e4719be4911a15c8c9c532d9a4f60de52ab5afebfc847dc2fc189ec988749dc395e6887f465a9fb16fcf40d50049833af1e72ed66ceff804509707d64128f08e0db6167fdfccd55589ab3f6308409cc16db151b472e55c4c4f7edbe312cf7a21677f1a61d5a78ee0a9d3496fb3a65587801b02d560598cddff2d1f5ac18bd9914f175329c6c11ad013e72c16c628aa7f1d3966c99330d8a4c96fff63d5e0016770e1bbe8de834f4a52c7eebf66308d5a1020728d4bf7d342684360c8933b595acaf82d6aa618068c9b8f03e730a478de0bd56748895ad28bbcb431eeb4df7987383109087fec7086046946d4e1e0de26713b951c550eb369d747a1fcf7959afdaad2ad957a1e68b5d433c6060eccdfa2b228df1daf779175a4577dc89ff8e5f1698be44690e4e42cbb4d2a00582a54c6639da6fae313abdff23562f1ebd331f2b1c9a2a2ea0501f399b3cd14d985c04509f5abc3c1778e054a16e643151754b689357c948f8e20a3338ffe2d10dbf2889161df473031f4e64f1a9475de195a798298d4c7a2cb76269efb92a3a442ad1a6210c92aab4271dfcf3768d85da55445f9c1e3bab9f7e0804986a1174e1a2bb281e402f0fede457c2070a5a756fbcab8f3a3cc2d2014ca4f39f82d7d546bef7cb15e6981ca33365fe2eb5d59abb241e8c0a06e3f9154f16c85f384650c5807e8e6a31751d5d668c51f3c37562d0106b1fa56fd79b5bf1227a351b16d54fc87115b5557b6fbdb6efd8793cd40e5b09415c1e240f92eab094f63bfb24b572955e02942fbf7b31f1493f13428ab8dc7e83f8c0aae9049442cab08e8174fab52df8bc4c5723f2a008158b01a1ca7c37917902797f28e6a866665d449157c9f83bb98ef4f685a3d79f5368cd88a06a3cdf6a45878cb75f30bdcfbc2a1bbbcd9db1bd8e3dc2c161f1ec3633dcedcf1d1120bad88092051520a0a4f7811f6a09a7e964121c917472f8832c7e9527bf76b70f3dedb2044c54e159d32434ebed565b0934157f5c9dd229bd5bd2fb0332597f1a2d91ac557094b2adbb615adbe8b7d3b9911efe521ea7a6d3b5b73a35c544d395fa0d50a010f1f2b492a0ccc76786bc1efcea47f9157d9e74cb8ad6c9a5748c31435e3bc626234895dd61ad0b1b18ffed718f3feab2eaeafbb65e9a56a5d0abc524c426535acdbaf224a5f07b6825eef2a9d16225b81393fdd6b2166ebc4b175562d0f3cf8c44d6cfd29be267f35c3f529f8f054b0add99f89b6767374234a019954b657f3e69d1ef95750b0df207d8baf57598067aa7eff26b56807a002d62ed23a3ff3f5f26f17634bed0c13fee6fd14318f9552a1289ac240e1dcfb238ef0ff45192b618a2ad1f4d4b265dbe51575dea2af50f7db4787e7e24002f229892fa5a1117595954fdba7be77eebc7112244e03f8e04a6ee04cb22438713b19f92aaadc1c266c1849c9718e825fbb4f32a4c8d5149ae97fce061e2435f824c689a7d9d338125595b73eeac7f3393671d671f33867c475b202faee9e4df05c0d4afe7ce7563b22a781a8f643ff7a7e1c3d375e80cedb7a292c205df9f4f68090bfeec1f75f6d386dde364a392ba29d1022ffb7577da4063dd5416ae1319204b95128beaef1ed0cab3d69d581d4efefdafd46eea6c4e9a20a976da9b642a75acaebbf2f76af277e3a0d656cbd0ea9c37829b42caa02bcf68aee75014ee5667d632ede92eaad1d0ff174930685d436565da99b9cdebd777db9317df61b6017d5decaa8ce9e34859bf26871d1b71b329f6468fc3a2f23975c317be4a2af6a3e82662129b2ca70655f2cd858c28eb4b7a5aa8309b657e00d76fe8a1202f44cef9402876dbbcab3e5e76ce6933d289780d432ce8b4910e4be512d592b73db523c75aa45b0c5e10d92e6c84e08988da0e65b2ce2baa358b3a464e0bdb5f0bd51519aae98e0185ae5c0831a00733e6a2d350ffa91a66fa163cd9b1cfc46d9aa7036cd3a327b3ba9857f693df474370c8a02c99038a17785e3b03351f6df9fdd5c5a60385b777e0009d823f4406e2296d9d11c78538989930b2393a361cc618d697b04b91ded5396db83b01b4613e8553afeeaecf46bc27bbccde432bfb326d6b735fa90bdd270b9b922f858f0317566f7dea8df109911716c475374a27410705a965364c88e4ec391b5208b4bce2e6a1b8b194306ea022ed32edf96aad6b0402d88bbf66d9645d29288bdebbebf77f8c7c5d2b13d1f2f4b1944c092c5fc215ee1a6903213343701294a7c86d056d14f4e5b1a036afcf4b6bb59c40aca7f4f648ed8fc195610fc033de4aa5969fe6601cb94b7b9008a3b64c88f3442f9fac99d07191fcec5225dc6774f373550a822ce2329247f017939806277a0fe21e698d3c107d9cae67436eca5e34c8d7b70d81a23807e91f5db245c585c61ab2d468903bc8afd97f31135e3ab2794b6c50ed0ef0c5d7ef716f2d7741957be4058b2d717ce3bcb98f2d0de6ddc5c2862a3236d53746ac8b4641056820842a6169f6ee01ea8cb5ede2106c94b6ad49042837be2b3b52993b5f2243f50bca1b337cc490f6fdbc3f3c1bd36031880775cb4f7d9959df86acc4e11a7d294b56487f9b41689b3870c4fe4a6cb76cc0c4d357a46d9bbf6c6b83d98ab2fad2c0949dadf475533bb5fcd5e9591ee70e9f5adf31fe62f7871704b74a30418e8ce5e35f4c7ec9f7a620f5471afb16ccd1b98a693677afedfe52f3a837b2e3ad0668619f2276e0529e600adbbebbffe9473e2eab2fc58345847f2dbe5099ae0b2ae91c488785098f5ce977dd6346706189edc3545106a7360149610c281b858ae22370c2af709d3ab9b311ad6cb74d09530535ab93e6997facf8fe376df0d9157c192b610470a35532a605d33c83bea131273056e02788dd9f329b7fc32dc09bae02731a3a3c81b5d7ba065859d50603831ac72d0f925a5c10edf499061a50939e3afcfee173f51e0300a1e08e60032565f62cc809000c0dbc870bcaffe0a930dd688f4a6d6543dce29feb6a61142396f14900a2b149247974acf106e51fce230059f56878eb18fdf94b96ca703eea10d0faa81d11dbd91c0571d19260a1e32549296cc95323ec937fcdafdd7c7382c0a46852142435bda2433c09521007264f240b903ead2221e37aed8ab07ade9a094c7409bbd0047623622c5ed2e5a33caea247b6bcdc829603a35531648fd48a17c984c5ed44d5f9acabe7ec080bd9c4be482a6be173ea23fbf22e6f105a0366a9a93c6b9999d5ddf27a823a953a0bc44773c14a96a1388e50d8770b87b16f9bafbc03d438b6be04f365044225f4d7ef89032399978a74ffd8d37705cb5a9727c2a5fde062a75ae10fb436bf146230c08e9d299947c995337978f85e023653679c3cac274843289822a621f39a8db9893873c4c00a68355ce4e280e488658041ecfa2ba028fc4e7c9400d6a3f7c5dbd89610e1fbd2c7803e73627e28ccdfb8a540a6d3c9d489f69ffac4e7f29517926bcd3c6b1a3766082a85e2bfcc45bacea3333906ca08bc9e85cec3c6ab73f447ae7a4a90349e6ecfc0850a815e720b94d08a401f62deb719ed727dffd6fbb2e73488f8e33e49e726b26d6628dd0f7bed38088c5161e7654645ab42ccce6f259e5166d3f94ea94988b73b9293a7b2ec9cabb4a988d70a457de4267bc0fe4a2d1451c942d597c481b3407b8aac36b59a430cd1ded6d5676dbfff9fff8221edc419cb2d0ef72f7df228fd21c050c6344d96aab271f41a82ebbf1a8ec14788c1da27949744531474499c389ba08443191a1bc098d82c8279158c0700e6f40392a2e02aa31ee6eed33e5b275efdbf66162a1ab86337969c508981a986ea34f22e4470782818879386b5ecdf455a1a7071a999a93baea60622ba9092b3b2d58d3e82045fe21afcae28fd19232a2b64f5677278aa2514f29d1a813ebdbdc2028d2b5c42af085b1c3dafee9a9a18ce913b2de1842a0eb16ae175b780e413218980829442f6776ddfaa792fd9dec020cda98a198d78a748be7b8cd5549dc872735c1dff6c2d7e8589ee4007762ba0c1935ea504ce60436202f46b154c507104c1b28f6a6511c666feca375605eaab704fa179f0477d508615aa5742f78feccefb42e105385be153a6adfcf2a4101c6c3ecd2e07ac78247ead719cdefd03c1a4584cbefc842e8ccd1b2b16f61bb5dafc06759c9251ac637766a392220844ae301ac506ab6c592240d87b4f61854f1bbf56a0bc7c4f35e9506dd33177da4c9bf6286c236df0bb63787919855660528d46f2f67f135083a8ac76c4bfe0873d2772674a9ece395862a11055ff5255f20d83ea1a6a7996aca6def579d26ce700b202a0a7e5f4913e994366deacc0ecba856e55c75a912600bb49bdb75d3f39514ad84aa97e699e3f74ca9256106e5aa8392a451508ee75fa4b70a2648843221178056014428e286ea52b80b4def994ab935aad78ce7d811f473a504cb13a01ab8fc8cfaafe8feb6fad251dd065ddeed47f51206dc9fc11a8e267de6d88177cb6c29c0e1a59e20ce9388aa108f0b2c042af86988997ad45213732aa478237712ff23174e13271aacfc37e60aa7d546206c34ab9a8f20e492a942533fd9e0fe04beb5bb6387c9ecd98cdfdc7ac69a978f8d2e82dadc1933a0a74ded65d1391d05acf8ef478a597caa42e848d0c1fa0f4397287f2ecb1627c68aae9de0ea83c0eec74ec1fe4763d63cc64b75d972d61fb48da5413649f4bbb905bd7ec0ae1a937c36bcf296fa8bf6d98916b6bcec65a5b43a228d326d683ed3c151c7a7353ec92c807f0aa53e14003fcdbab2c20a6dbcbbfb33987e689e8117028e1489cd52b0945eed882817c8f30fc8cd82b2902be3bb0184bd9d4dc27941832df9017be47733fd577e742695c6f1b0eaa08a8517bb9405e8c42e5be808b827382ff52144fe7cc9a953958e22d345f18e8644b00eb5909ab2f2b062808600ada4a277f53b9298ee56711e796721963678dede8f7895eece4ee9c53405f335981abb1830104af1cfd07263067193345d5697af332ae058183eab40bc44a427bf897e829b5cb9602cab2052dc19992c67fd85e3aecb59b52e6e0e7d76c46115396fed13384de437928aeb1495e4c4676ccbd48de0876a6f2e6fff70b34bd88278413044ebfe2ee4eb5de77f2cf2d4840d61a3a43e570577f28b689a00b5417f33dde1f0aa8d12e1957e0280ea17c349df8185ee307228bc503718930fc1abf6a971e1b9b930ee5bd1b8688bcebb2f571d85de4e6042fee8e253ad30b413339baf3156000d6693b0fa273268ac935683d5aac1ddbcd13249c01132024104add233bb38def2e968ca1fecf5dad6fcac583c84b82fa3a8e62fae9a97c0288af3bece37f74c7a505fc539cfc1bb8fe2223c600a6c97312f9f19f42adaeebb7d653369310d8c78f1a0ba7bcdc878cfff59c9aa7041b01d7cb426fbdffe5f77874da11a21a7740eeb1a747dfd3391cfe83b12b3b85275b4419cb3b8801273806e38607f5c1b014ed2efcf9d27606de6598ff8d12841e4243a4f8467c60168a923218e80f6e360b8be04690cddec023e604c02ebca11f0c9be7706de069bc21445d4f25b15691367bedae94f75a6a8899c74de06a22b13b6de8ed4eae6e6bcc2f1ddee9ae96fc35a33c747b62ee5641c01eb14955545f1aa003dfadeb0a4db85dec9f3076cf90f43f799bfd9de01fb09ddc57c9b35d225483aa9953302998fcf2dd74ab71a06742c150f9fdb7991a43ec2dfad274709235fb3be0661fe49239a1474cd61878e58f9b3645ea05ae443f2602cc1ebf57bf4ce506ff489e5d2937444be0bfcbbe4aa52fcd3fc50d3ca2add1733a7a7e087bacf90b27e81f09b54d6cfc7f9e09dc1eadc3df3980b510cd3f2bfb2f86c4e8fe973b176103745e5278779e665a634473363066c25d00da8ee35e09de0a667ae3251a46ff47e6b9b07c6fc5b821b6a09814c4505dfbd200e56a1503b41a9a5ba6a312107fd04ee88218875a7bdcf04b61e0137c3db6e5a04d8f8a1f707d231e70d3497540d8bfb2f761b71cfc0dcb11eb5766e000facba29edb965a2ba2e57166a7c9d495251114f48b8cff7833e053df2a8595aa062158888224560a585a24091f647dc8f8f8b25dc02fe2855dc9a76aa295d5951bfbe116be77601a3ee0d89a4e97fefce9aaf2e4b2322fb11956c7959f2ca912bcbaa5c7a1eadc693aafb2c4ad4d31a1d3ce5e8a5b678f18146418dcfc0ea5a0ea5a07653ba57036c7c806b4d712306f2e0c64f69c3d2eb2d2de3ba5cbb25da18c25f4372d7e7a3da6c91c38452bb5c9789a3b06198d6734850706d95fcdb20b2ef9dc5d6ec7e65162d32f7b499ecda20c4826f0e92e302af1303914790aef6baed6b285233b10f23653585aadad33da5c755c10e7e4e98d480d9404a4ec7468c0eb52af4b068d0f015cca53d6317e21b3bfacc1d6b5f902828","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
