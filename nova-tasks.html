<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b4130d50208f78c6cb49c617a44d41bf29b4ebbd84f789440b55fa31116426016fa5de3fa95a9ecdcf8bc3909302b94989f4521dbcaf07272e1bd6224da7d66c96aa5ddaccf82b7c4613b4be77b5e89f342f1d6f89c1cd1b402c88d98a045d9054bbf6ced3de41262b5b5fb51907b478bdebc3164297c78f686d31ff2bc5b9dd33a5123bf15b76beb87d5cc66faafefc171b7f229d3c306492d8249edff435906012eef0aa850781168f0b1b9f9016338126043cb034aa51584df5376b5a6755f3a3cfe0fc5d46958bcc8b9dac18ecaf1550ee44577345233d4723b151db4ac043651716cea042295e99b1cb1a75e9a5cf51c13a7d6fbac24f3a3ea20deae919bac4d967b8438ab76ce80a07d2e1b6a131841ca75623f4107f731d674b99aa830dd75688dcce4f78a61e28fbd79f5fde5f0e0d0f9b8b4d028a3ac800072d83b98e30d05925de256a1c3cc9872193acebfcdddda26debb4772ce879f60270477c04d91f1b8abeda808e1c471c3b2377a24360c85eca39c3ad0b447d4f5609c06b80d8ba54f79b40757d6a5078bbc9cbd61abea12e2c8a2bd11753be986b01ca076540939b31813db9a050d53a7bde9b2f47ace7914450eea5a62a799df4cdef24c3a9b00f80fab4e0d1386ca9973c8c4adbdc1c3d9b366fe1e765c2aceb45ed1eac3a6285bd4ad5666e093d92976161739fdcb9ea14508acebd94834f3a1155ca7a3ba72de9531064b9c8b29c3268a9114a3da6240b28e19748f09c59967efc40abc89068993a37d77ab60ca6d09544cb3078a33b06906c01da7f135954003741cb49f3160ca91be199785c401e1694cc66c43ba9bd21d51ea93a6a227576a78e2309188b7321dd0067c4fc7ed9a496eb2162003175f2aa7cad267164463eb620c87ebddccb4d5b1f44a0eeabde63c87d53d2193ee27c46eed63ef520358efe26e165b9bd313c55466d2e7e092dc9b900541d191d41ab5c342a614cdde9cb55ba9ddfc86d12537eda3e45a8e23dd7f60d49118d84914f54ae688e48f4090693f1b9ba45ad05174a428cdde058a6663a6f18dfae6ecd2eb9080180473070b37d6c2a6156612b5787fe213371efc6c009a911f40ffa095053b64bcdad1090bb86cf2d9cce5ba96017771d6229363b0361146e12f428a698559b88e7c887c932f14d3e75ac3cbfc4ff8ef1772e74c211fac3e5d5794f92fde696ad524f72980b1956de66941ed2ec5fc531a2c9957a27161aec3d7100b1264854cb95d30bd53a4a9315291352771b5917bdb8c21471f6375a42c306ebc5286806b1a062be4742352f2e6959ee5e66bfe9c94588fefb8f7e75b009f35a5cacb5ca7c4be7530f9dfdec3890787e0115159d47699a968b91bbb0d7717269e3f71d3a4ff695e1eaeb3addb31a3fa8f9cb164911ca1d9b24de0a9e491f075ed0e824f8a1f205bd51ee54d9e1a7f4c94fa31183ba21b69fcead6d73503d4e7e7251ed77cfadb35163c6fc1f2aae5e830113ed953ad8d8314914cefdb0280bb2c4c28f384061be42f16803f65c3f03153fbe9b491faeea740301c7cdb60bddc6d84c9aff76cc40f9f6fbbc01defc189435f07c2f1264b092cbe1fe7b039cf9eca9e91e94519b60330eccedb0a4b299257cc36e13463cc6c7892967bb6eab6aa2950fb39e2f415fecdfcf514dab2ab9ff3ac5d9bff464c3e630c283545c965f5417fc668f2e3aa2a41b81e14f5d410fde65922857caddbdfb5df27d13cd932241951914051898539e6d68ef57dc8f5f49bc52a925f3cf8a38e70a806a5f2f00875d2d7c423fc1a7725248330660146b8e0d11833b89e836c23790bfb4e4aa01807f61fcf3be90a1a8ee805be4a036042d94e5a467c39c3642efb2a53d404a41d9462b256c5cde03ad691e5d6ae9b543e991e057ea6c399aa035be83d9fc24939f49371bcda3dfd90f0ae77dbba21369482a8f9fddec218674f95e488792739fc2aa09fb6b51996dc603294c16461a1af2f279efc0053a5b176f891bbdd4e332d85826370936d148e6ada8a70579c12186d8b3c521eec5e1a12bfcc0e257bb214d6070898a59b9944aae3b1d701fe59c83f2b84d084ed3b75dcd4604179b037ad6f3433c3d33c09850c5f447867ee60a739f0f6f4af58c84c3215c9e9654c1e23b1800e6fd466d69ec30fced3936e8c4218b53a9ab786c89b2e6b887a44a9672f027b15aa1037b5f6db38c664e9404c0736dcb990e6493ddda5b70be7bca23618729809269741ec787a671363c52563dd064526c790730a34d3bb221574cf6765f2ce528fe049a0d63e28d317977acd5cabdabd3df87aef2ca636bfdda8676902fcb246d767f69b7c1a2f9aa9462ed927f9470c834bdcc841c74d51705f6ddcfe17d80e55784c34692ea111997167dcb3a15e3f1677c2f70008b767704e55f8f49630f539416b23cae727043eac902c3f014c775b390a5bd80945a10cde11321cdd2a7eb6ae112575fb0af63b7ff6ee1f103f13cbc31ab4f779d8e975444a358fa327de1e6514b36aaf3dc12f8492312f2267e28d4f2ab0bc641f5e768fdfaf9a55f29987cdc0ba6bfad663677fb56c4c63cc40eee47714258ff190ef0af803387543ba2ddadf0b5bb5be41e0a3d7b741dcbb04818054bec6e5569ef414249e12d10ebf7efd66e9d015a299714d207c42167fc0c2ada85c5329a22c2764bb81e0fcb3c84632e80d7807575001826911f633fd736d5b3d07b455712d273a132e37dc8cddb77a52c2e3f9a3fbb524f74c53089f1e87cd108f1414d60279536b471c439df88afbf5d316304b322f7b11cfe8db6233b2410ba6c729d744b92f35bd7c67e0abd2bb41d64af03d9196479eecf06dc94de356af26d80071d50bee7571be045249c3cdd65504c22ce71bfc004fe60e27dee31a60cb5dbe099a82d0dcc1c940e784c9ef7f7142efc4a78b1b2dbed88024fc3eca27361b44e7cad7e4c22372744e2d7bb064cb07b5e22d6e11ed66ef39bd1438b45378e8f98eb76358108bef220d56bcfea580d7370964d320129617a2538665cec3d408be2b5a3ed8688803e7de9381e4122e7e0008582da822c38626a7d87e68f73b864a765cbaec935655e5b93dbe29b0f9d34f49c676aa5227e9ab463845a5a1f8c91def44b9dda027b25eb7b4261729b797d6f572a86039144df1ac39d9ce26c3c03e2821b6bf9d970a76a1167f91748d1013c81478420d00d2737596f2440ca24f8ca0d78877ef4507488e530245dbb6521dade37c053cb7c2241944a9f51fc2bb161f02ab0d5bab6f60635361b31adfc83b687ef16b3f6166f980604c0a44b28bf43b79bc5f2d4db5941377fab49081ac55eeca21386e069aee5ba8488648ee26e86e23d00fb950377703e4bc9a5b4e07ba5ffefee22f5e0e68e305d9f6162408d3d7de56aee33977233890d0461864e79ef7088d77290be007e6478fd900bf4a3f48549eb5d6429acc85eb1f31a016eab4949f11edb0d78637eb816699d02c848715ffe03d45d33017b93acd4d22242f9949d2522f2f2d033aa419958ef40e632824fcdf6acc2f0d9d7f0ad09bd261f807de8a48c14bd49f1230ef5ff99e28053c80b81c5b3cbad78c0b76936b21cc2baf5736deb3da42850e34af9924693e150328ee944e92ecd25dd73a6bb149c4c96fe58f4c3004da05ed70da43c69a757842f7a606271adb919e19b8b18f7a991dae99cd3d961ba531adaf1019de05c71ee2ed51b9fa03674f7539f39ee6143226fb85ee084d82b6d7b5079f5228bc3c9394fabf87a836dc5a5966028e2ec8c6de209b334f983fb9ff080b0a62d1f38e0804762c7cf2b5dff136c37617a6e5ba5aa1185adbd237f836b1fda48376b143713c0964301074f659fd5e55c918fb9ca869e7b5c5675de44954e2d197ad5597e82793c5569bc5a9b9960665bc1cada70b69dc22a906fb93b1ae9efc0f3d49ea730d44eb4c595e2af50cd825dbf304df0300f7cb1b02888ef9dcafb453038256b7376b07e27a384eec958108575129827f841fa43724024f0000fdd36cd74cd1c9ecc3be3dbff824be4d422c848272b9630aaf38e02f2ed62d9baaf5bc45c81e6b65ae9c922320e107b771a47fc16ed133a23eb51e379166e111c7adeaed9702e0f1dae8f80668008f73d6d6c3b336f10225a58069b6d2d7bd8b19da63ee21bf4f17a964a819aaacd01953394be8fd29a661316a9156a47a10111786c4e5ab1e52eff5715500f8b561ba921d79845f38dfaab1b7818c715102e0bb0ab226dc5ad92d78b2dfd8d33ae14f3cc2dc6bb4b8c4293a25948102cb5f365126d5c8244bd9fd32aa7b1487077e420480e6f7b4d398618ee213b1a5b0fcf590ffe5de62a7cfea823b2141f603132f6889caa3fe9fa93dcb1ea6a68f353b59236d9d7e443475c2e5ec6e464fe6c95927cef28aec7dc6fa131cf2ad4e09e858d1afe3c1317d15f56667e26ccc7fe04b1fa3a476cd0c2b058305b1aa3a1161e0cf55db533af8a3c7cae36616058f9a67b0c05c1153e5c5be872807809c9000c4822d5584971a134c603282448f13ff8d0dc45c559b4acf055a2069c8e129dab72cfae661854f8cf007881d7b5430799119fa65a1822e55bfc0b5947b31ed280be543e4b2c9a631a9a5a44d14b9af087fe29d3e2d32399769f5f5a88b2d255bdf3f9fc8650138ffde198b51e9334f12384a016cad0d12ea34ec85ebce40f191e3942cdaf0db00052c2dabb6732a72d63631fbf47b212320b005ebda60804f6c712eba04c8b24a51abe187ebe94c04e5e1b5296634133de90fed686d29b67bb568cc5726dd2af6d76cdcb02bda411a8142a990f506b02c129833dae1f0972e1d1d9a0f90de663dde0d2b90c2020ece2c677d3798064d49f2789963e84d5c05dc5350668ab8369e85a7fe85bab2d286c92a94516b14554d7a8fb26db73e91f9132c4118780cd63be47b95e9d58382807d5babd8b10a460a569a282c0c02973699dad4a589713156b59eb89313ea73dba5c729bda7c7c525b92a0666691a9fd18bc540362a355474880df9814ae3c9ec5786dda5d19a448a762c97481609f9d45d1fa6294ae6c47dff5280d03ce3f607fc932422e741c68b19435dc258e3901938dcf7b7e1e28a9fab31a81010d33712ebc42b613cdbc4d0594807c7eee63b93ee4adaff49dad5ef27bbc1a3119aa9d848daa7bf996ebcfbc6806e395736013fb1a1cd11bd12eff779a16407c560084750c691a1f8142c8d3e34e4d6829ef58104c3e0a001a88ece95a4f6ee6d7636c74e0e4643c7e994d0a7447aa540df271902da33cced49834fa3ae2bc7865a100a5c901c4e7cc39833c61a548dd3b94f12c07b7ef9274d1d02c636234e099ded99a6028c962c23dd78b8915d6957583f0654e0c251e1ded8509cea5fa432368c291191139e9a2ea17c31a91d86bbf99251a41e1b47d9d77df251da6713409e6c4a3fbfb302820083626bddc7f2c0c171f6ef9640f8cb70422c2988a3632a6c5bfe91fd8d00f907d4860b58cda46b634b955c97e41db591899b4c2e380e89dbd807ba643672bb23a53b9d036df6f5a9ec026c9406c15cc7a0714c96e4499322d682c2eb7d9ea409801bdf976d168d44ea41dcd0622f179b07f697a5529853027bd670a5a84f5f6acf2e49185ab548a957ebe76a8334985348da6c9b7c533623bf7ba855d331e4b2183e54dfc342e16aa3eb9e56a1be2d7fd17a4660753c3ea56540866e6a51c4622534ead8764cca36500bd0109b35c4a1ad6f8117efcc99bf194249f569d974593e67d0b71fb74790d6096df885367a71587b754db231ce00fd4c75e4067ea5759b7ef9e28df920242908da184ea3f26631771baaf1bfa46d0678538e560021871498b42fffdc67df8b8621ad21fe14501530dab06e39349efcf0f73299d4071989c2d6baee43ee6103c59bddeb74f350f9424e6a0fbee8aa528c7af06db6eb54685aa4b23e2efaa2083efa1469c3b91524c749f238605d0bd2a5d44b0ca6336a441e4e8d79dd60cb24429c77d4e605bd587ae28ee4a77345a6a3f937b74fe61c4faf8cc8bb384a34e83e503d9a74bdfb00cde43a845a0a5864e1d6de1c68452f526f244de68018f34f1ecd59032a7a1b61ef5c047ecd8e27a491e04cf6988c594b9453ae4df0db0d53444715f3dadeef94f510edf6d87fb927517432030ff98443d01995f36948b571616db71e8799c5cf31b51e4b7a04f4ebf4826e6f23e0db03ff212c67336b3438189a0f690c01e7eaffd782b4f5cbee82156d9b3b1febd755201c98ac234b703df2536da134646d8e3b323ae03014cd7bc497e29f91e314f252748bc68c171c5968191f88602460f01f5d0d693a049a8c7741198e5758125da5e1df0fc078b5ab6fc15f539549ec14c350c84beab5d0237e13c2e776e635f11643b4a4cf1d8a119e2e7490ccd3b3ab734eefe71f7fd5f6fb688589b9d3608d080a5f6c7bae55500faa38808f599addf79a8dbdebff03762a7980ed9810b4c8093984ea25abb44b1cb9b1873e7a81525f7d3320e7afc61d0c59cef30e5291eed23570b73c6a2f315c29d89c1d4a6b1fac4b342e06aa118cabb84e577e58f51c165309f0b3c4bc08d8f158c4dbc7268d32a995322d25795e7b6b670f8b3df36074f6d147a3001f0f57410d20cfcbdffc5ae026f45613f52072532cea5c938034d135fb91f326cd7266ae51148af072a709af215bb4fd4e5c82526f25e467f47a9f5aa8b657db2eea69524c7bc3caaa4bbfa2c94d2887cc91e4097d4544fbd9fe515ca69f912ef5661f4c8b3d9c080b8604463b34bf542ca2f7c0dc854d9a13c641ab5808b83936e82e454840d4016b46b510e161770edf7be0d91a56c4e5e02fa5d3aebf1bd64ad3240b4dcf125cee31978b02984de0eb43c94658db6d44340ef629dcfe8b620701cf99d172feed7524f79660f3a965459249c61804c7eabef0ccbe81198be6dc31b3a6584542b34f2667d35443bc42deb488af61f7e0a11f5d37c50b9f13bef585fcf896ecfccc52cc8f71dfc8fdf7f581bdbec7d07382f3d02519057812dad5bf7b75b097714676d22934cd4aad20a62c09adf1343f25cc94e2d40998959fad8788caca6f5f1853cc455cd5b01dcc10cf9093fb3530704937b184435bb5fa90a4b9c0fda43c3fea96a739c7b620f8dbd79b72d497488bca6dbf012624da10be8595e4ac63ca25265204ad12b27b410adc8d5b7ed731dfc7257412e8187d217ecbeda44457944508a648a1e5123b4e9515819afd53bf7f1d9e31affe1ed3d5783545c3f6acbda7f7ef62ec4ea97a4794e25402e4401cebca7741e121fe4e9dddb29a325d543d8e4f198024e801210a81d4a4ac13e62630048452d8fb64de0b2d35f8b8a257fdb59a11471b50513f1af2ae967cbfc120914ca3be0142e5ea043763d6a0a36d04c18172a13d19420e599cefa66208ab2ade5adaa89b4c90a5ffdfe8edebfbb445bbf81f8c52d177a6440be3d5b3a7ba4dd40b1bd8bd8ab6a9e67a3c1aff39067efadc70941ae2c0ae110d8bfb43be2ae9827321eb36f5dc0e4a56759d0e9eb8d2bded97aca4566434fd4d6a99034d47f97cd074ac5d485ce02d6498967cb771fad31ee1317be89c6c187d0fa0688136f1060763ad12fda0a73298bd3eb5a847cc8caa97e2eb6332894ebead177ff9b1e2f5a58b60f498116503d0ec2c133d2572fa68651e9f821bb3c4a952f25637d603ee39c239dd796ccedb12dc510b888e91529ed9a26014796110c6f2d617d261ce4ed5bb53820cf5284adf9e4acbe01527f8c1cc945bfd1c1781495a490565bc55566ee0f9b53db79e248c8070f46af7bfa00605b9cbb76392ec2d60845d9c864821deb0a4a4af0135ee3709a28efb1e91bd0b5c298cccbedb28b68fbd13c4c0354fe017d4b6db1f7228ca61aaf22a04048852783752a5adef731b089a12259ec5fd12d0d2d57f13c27b6dfdfe4664a90010580c7771c10feab92cc5c6934873919e3621541c55f34852536d3d43754738a7c7ffb040be7feba38d24105357f173a121b69cbfe5f1be23a5fe426fd1c5be562650bd7f52298b59332f19c0ad386f164da73a34b19e9c9e1d608c48398b6cf4aa092c42176ebdd090bf3d64e81be1ebb34c715ebcfe85e121b010cf0d600dc62dcfb70ea10e009b10d47a6d3b7e7c4e4e669b2ba580d3dff5c6da80308564359cf16bbd3690503c7b4ca594014c3708b2d1976223d2b8efbd3c8c984625b4d524eb1322072472c3b83beff6fa4466a976ec6e56a688e727c5993734376c7f4bd985eac418eb56a9c2b36f16aae10bba46a501a53b21ba269e59c92aec210104cd5c63750e155b1eaa1e12c9c1d7169d782b1af8e615ad2d779dbe4f2b39680ee0367c4c360fc2120eaa70b797a5fa5864a950da81d33f116e0e83a7fe8e2055107819dde10a39d68052a80422988649abae371272fb378d83bf8596c8190b6ac19e4d84575cc4dd1a15b472b0c25ebb36d10acd562fdf3e642ddfc12a56e8b61190f1f9a0c647576c8ae1e2692325f0825c7b59dc09d79375eaeaf678c5364e63ea867e8e551521684a1356a2bd3a5e0112c524fe9b1108ebcb476fc2702cb40f773c6bc52955dc97649fd88d1f8cc62e889098d4e6ea618ee4082175d370745e9e7c18e6f9b12a64f085d4245908c121eda05ae10bf2d954ba250125ffa48dc639f99bc9ad93f6f0aea9997f762533cd13605bacc2764af7542135078dc5d419124320fd0669bd5358a0c66d7fa333a343bb4436f717749da7b75a5405422fb1e2d864892c4c3e03de2e479c1637e5454abdf270cfb9001052791a95c7f09a52cb440cf75ca2c8c2ced44b4a099fa2a38e471470e00b8825353fd819009d40278162c9d1fce69f52bf7707eda1a06cf48143f5c7be6ee902fbe2e903ad78143ac99a5aa4ccc4562396936b73acc45757fd7d4d082273c649a054a6ddfbdbaf08496b260daa5785b03ae4e2a75b10a96c686ca98f85a1f8da4d7ed593271aacdadf648eb9d385eb8f8fe43f6abb6c3e10e90f9518d9e889002752c6b464eb50f5a07dff1a7091f305684142a65b397d3c991794aed3750015a04c497887ee8175c04fb128a4bbb0344d61217cfd12c96c5a2a0a1516462320e17980fd047f99e55ce4865644e2d6751f67b035aa577ad7e1cf3932cc3189d539e019291d4f4b0a372bc8505bf865118b5bf7eaea78c0a5812bb958799e4a8eeeb008d8e73aca72ebfc61509b29edf9dc7388766e1afc728d9add51ec114ad810cc5de05ece5ed9672fa72404ae8f90f908d26b8bbda2c7e68067043b11ea1432814e73a9d201d5529e7d38551d0719ada6f6819260e9a1c5d81eedabdb3943ff8470c7c4a150221728684f527c6a3df051d552cbf5162cf2313e11cb02fa5e9f87e40ccaccfb9edf5ccd325768cf0f2ab121a06c5b3c076f4566d46a2d52c9db23a078589320aec94cec16c74393d4057566902a4f9bedf6da8eff841aec9c8debef84af57d90f27dfb548492c7afa9086bf2bcf91f825be534dae0404ca9d46b8b9bd8a203c874774c5aa6fb5cd4ad8c35765c889e040f7a004c9317163a8ec79d709f2e3cbc41e9ec79e06b1aeb5a7d19cbf37fe247a33c77a495757db1df4bf75c2f06d22a929d65a70cec3f1bab5cbf390cd9037cb73b9fffeed8a714d16407a58dd2f844ac9712f6f25e717ad66773934ea652f4642cbd30bc57b3cec0867098b35811a39681df083de7ebcab28c9fb249b54cf030bf55570ba6c6c149c0eb4c38aff1da795eafca513b542353786ed62fa94c7649a1daef6bff47ca6b04737757a15e13437cc5890318668a50156b6a2ab9f77ad5263734b659322960f87fa941821d207d013371c6c0923b7db85051d4d4642ad98089f00af07bbe9ee4c6bdd7a02570b64bd4906c654273a5993641809859cc0d2423b7ca9fbcad87c6db81d56198d67a905a5b13251e3c9ba3ee21d5dc54336958672db1a76abbc92a8e02c76334d049ef6d2dc8a1b98e14d1b591c217f0763ba334ee3b54553d54101a02889399dfc3340c709f801161f90d65b0e225aa946ce0af80359999dd115ac3482a70dcf7e2d1973d15f3a91db7c8040706881868e4445e3122faf71e818b536b77dbbc5b0dfa4e777bd14431f9236b69b5b0859d5d3af9b8f1101cf8e5263c81665e5adc4493732b6025788eea79fe1e90260549da9766dbca693e2bcab955d184d353e2d4c2a82c5783e6f19b182df06fc4f950fa573ee291e6e85d214450cd3597e642f64435d1f8d7423d8422f5e32260ccbbafba45581e76998064e937897aa7fe30b36b16a0851d6b1c94af8f61c05e7e2a833e232c5feb9426d91de5968b535034ced3645dc2653772f684b7cdd71c1f2858b056fe9ff36c953bd908d8505f152a6e8a36dfc2c274c7ce9953586c65b8e293a6d38d679a206de61c34a83dbbaecb614843e8bfd9d832619f4c0ce6ca0c7caa5c773fa60257b1a5c11491e5bcb4bdc076344fdb0fa2e4bc14c9082c61c13fcec936a9eed9d982ba4c97b174b10b86cc2608e4724f2251a46e72885967a83b990b0a2ed873f932b481f00416676497c4141f02acedcb68928a5cd09fc1fdb8bb79889540f1310e50d6dfc895060f2e283725637d1e2e2802935bfe4a068603a5deb90158af1aba53f7f3c97b40067749b6a54cbb3bb6b598ade51b6ef39a41db9595ebb816153c3591bc3b6a52509602bf566a2b26088cb92472b184a25c4db1febeaa55c78906f75acd340b6da9de0ae4913acb6c7848ce372ec64fd169b111ffb8532db461878db5425e8b34b78608e77d8e02b1f8a003e78e933a02910bb0f3da6a5f7cbd67829c3f54afd82ba35f5b94e2ef9e362c044a4e1c6e17c08ce1238a2ac5642f5ecea59709304a088aba4dfddbbbabbaa119dd1f77a0a547d595eec4b355af6b0cf27c2b90515b6d9103100109533abf169aa8d04d39173bdb273c1da23e1647d140bb35b544fe6679d78c622477e1542fa83a40bed3435ed4a6c5151e2c742a08974514efcec94dcd9fec0d4d92a8f9eba636c842d34f2cffb29acd135a7ddd984bb73393b44debe4b835267d658fcfcd171a3a880e1ebb3903734096fe895f5beb82fe5baa037458072dee23353838aad9c3287290ccf9d1bbdce09f47bed786c8ece3e1e6279e2ee3827a0b629f2f9d5730ce392266ecfc08235e4d0899c757fe02a7599036d315cc96b8a0024eeced9aeb94e9161b8259614f49de0fb1f46498be26bba157a025cd5c95c2d0e7ba00b4a36a0e26c5bbf0541ef2456eedd04b034d4947e4a1c7e2eb6193e1e453c4ae29160a4de6a4238d3541cf6b1e2464e62987d898b262182f2709c61e477913110b39439a012eb4587e0054e22d2079942323b3f4d88c7364f61afc75f18ad0c9d63a7ac79be294e5e37d5fb85de192e1246b503e16dbb9b0d9f57d0bc91342079f3901bdad177715c611ff4bb63af33680ec250b2672ba5cacba33ed19955d8fe8c051c7c04abf18d70c4318cad1cd688284b458ea53f51af8886afaa3e30320bc32e5564377de2822b36e5320b2005e6f281937316a4015d21575883b6dd5613dbcbabf33b8f6bb74dea6e041047907397cbba4b719121f5e3b4aa8176ce956e4aeb0ea06dfc4e52fbb95bd67817b24bc6c9a9cf39886aba0d4f90e87355f46e38a75ffde66c925af729832893f1dd09a98eae91808bcb73ea5d40e35dfd98205284da93ea1fcc72a7d3d4d02da5ac697325592687b90a75c8beef0e43c7243300bf1e160c96d17bfb81e3dde67846af2ffa229fef45641395f0a328cca9fb82353d494efa5a268ff09a116239bdfa83dc141bbe9417f4475a7a9b88c237675e675966408bd6e04d4ee20db0c11fee4f1c8d64a89b55ccf8ac82b0c3e5fb593e48fced63e88b8cf53708730bfed24dbdaab6ff891dfc1a25119859efeb38797b7c7f1cca0c5b8a93b2f58c4f18c3318b9a8c05af792aa3b394623ec397887d1c6045d0625b3a92b6397a6054075bf8d31d22d5e0dac4f4201f6c058fb7a09c95540b20f7fed132e318dbe55cf5e37a75518edb9c76c5da2721725281ff1cf18505aebc89b5bb9a9c593cb29a3ee12ea81f5e6c6592ed141fad18c5afdc1c54373d93e2adc4420c967888401f53a0bdef1b6cae03b292dba066dece56f4b777034ee1e661903352abfc00e6e4d2961abb5e79a937e287467c0be298f5f2fffea65ed567558a0d749f3e3b0dc456c57e05ac45680b1569f5597f602c05e8c3b5e8ae05585abd8fcb3d2e1daada2e1abd29332859c4f8225f3f94b257775c2adb1a0da6053506aca50be9090cf7c028fbb806fa5accbfbc9b2761732e971183b3e709cbe81207216b4af59482fb3f183445ddbe7c784a4adb5e35c67f0dc20025e012434c92d75ac5c2ab8f55361a9822990f8df61371feaccb33f58991cb177d8dc422e845e78354fc7dd96d77d24d2d754f59c21991b40d40df5e63af130f2f7d415c2392087bb1c6d0586ae4c203bbc505d5a19cb5cb43feedc051ce51aa0eea50fcfb3eabfc16188c49a49bd57f0568ba7dcc480709595c8c7aee209bfd4b09970f4bd720c66509a6bc7880c5a9d39068548db873eca5b65abb73649adc0996785b9a416fe87e34c5b49457c9738dbd556af4eb97bd3a6a3f2732261c972320a4f4ec15c66329841db92d1e1e3be263aadc8e5aa701cf92c094bfd733974cce78ad78f127aaf7c701c1c5198d0d127694772879c51d66db1ee11ff0d26ee9514cb49c571f751876380b01fb5839a2e115b2a1840e67cd4cfa6771901a2b756f07409f43230b63c290bbf5871a05d5b62fc78403456937c6b2eb66705b15ff376cb32e4721685425b309b7b1b2769a7124dba420a8b5dc3e65768096b99d19d2744c5bbdfcff14f5dc494836e8699b8c1a8f77b40de48807d20406f36f0f555c8be5aa88bfd5b485e64a275a8fec1204fc98cb38aa12edc98784bd1c4415c8300d81f19b7d1dda2c9ba06c71be1e87a78cd30987dfe55d1a04a891e8da161ef8418757c823eb9e80f460763f9ba68949b265f452352a596a4f129c5657f54783902d23922b7b8ca0c9da64fe6f5bed8849a0c54298ec213456990518b7dcfc62ce132da7521f15b6fbadfbef74722e064d160475253be8e19945c76de5753ccdfc4a28613658ed7386d90029aede2157b245affbf2f5e5f9a13a12fd54eab87d312009a92f50d98d271cc3fe945f6fe6b6c18a5f1a4083cc9da237f45d0c1f76b93d76e1439bb57340f2e37ceaffcea3fcd55fa32749e0153518343bee16cd82c34828b3b54c074456bb8913be83962c85be41807fc622df5cc50ea02254df137790729bb6d1befa841750801b409ba9c418ddfcd8205d16b8e3d3ae5301c3153fc9c8e9a59809c9a8aa14acce10501d9c26a1728af58376106302c7a467695c1bd87de15cfcd4038f77b620906196c1e1b323c70a6fd202aca87b59f76db6df551f6dcdd31267048a8dc56094ad15f1311149a4442f05a07a995abe3159dd0b7beaea9eabc424489d0c5420a13008a26f4860a9a445feeb53297b5653dcd981946b77388972a9c6960f7b616b5afad974761a00bcd9c40067804d3565787129943f8d69eb6d4eb6337dd87ba27bc7d17314cd64da997ae33d9c35f091e8662bda2d67ee680a4d5866fb6ff407e7b3ef0d71fb87573f2e66e028dbd06693e830ea35a827aeef6996f5aca2450be9934e8d7a5fce21f699f256d4a2e607f75ee593df00dfe620ef5f3abc5045bae2006789b70cc9c3ee4d756f95662cdd3ede0be5ca1c2b74b3418ac9387232e4dfb68c7fb2f80ca745a56462a6112ae5067a8873faff92d1e98a1e4f685ce49aa60217b28a24ee39adf2107d4c191bdb0b0e0405ae10afd7cd5827f6e20d7515e5900bff213adae74be174c94691746f19a94d49146bf5e2e8de66eba873b89a87b40d248a03f58ef672f42e489d106ec87721343428aaf5ba5763e01982242f4fa8282daef4e0480a5b673e301fd1aac39279da76f5dbef3af897e62ed2d7d42a26316121219866b1bfef38bdea3075df65ecb9de4a4435664c46688edea30413aa4354b7bf97e52890ec2f6029cac17bf2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
