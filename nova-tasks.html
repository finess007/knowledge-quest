<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af2ece3007ce7dd718631e377a1ceaf590901f411b1b4fc8f8181686691152197bd5a4247994a9e069c01c2b2b23ce0c80eaa5910b6c990d8c78de6bf456409653b70407194cf1d1ecad455561e8bbc3e07e78fb41fbf3f29ae3ebd26899119450e73dd3a3b73dd13773e0586f9dbd9c49510897b6b752afc5285bd4d95998cac0070177855d326a1450f90dbbb75f091e766decda1ae04220bd8bad55d08a96319d78e5464f4048d531f4d56418737ea01c30ad3fc07e3e04706f77d28bed7dabc36975b2c38a16143a82379fa0db279180b8e3c0dcdb64e73bd5d5af9b24f62cb319ca13c9756521a2470a236237d3f2d06d1f1f5dede0a597f65cb2bb80ff26f2cb17bf7daab58b44586b31970401757be0b2b772ae61c6aead7cb1d178111ec8582f0c14c6657e42d3b1c88636fd8acb1f038dbc3a3d11301166056958dc7a01472736e7a5cf02ca934fe9691d8a822b2b99ce0c136b63c3f7f7a4111bb2b60c20aae83b9fa939270c4a9006df378b98c9dc960017f875d1d5b6ad727076b1180d8023902266bdcb61f38d30786e859c568bc330a4df4020f40e7a74c9853c91a8b224b444748a80ee4316b5a4314f665b7c00c20ec083f6faa318cc2c6b515037e6351deda99738f0e9e31953e84b7603b1cf3675fbc4955984d20067733decbac856820e5d687f3767b63f2f45da010217ae2378fbb28d60ff7cb86b3fcd32cd537d2b22ddfd9dec9dd05247bbe798feaabdb9f6ff160a6139b1ed08960a4f6e0712abe39d9d3487c978a38a1d854a13555fe0a3a1932c6f95cc65f0c32400e59bb858c6aac757fe41e17e266e6210d41ad2cb2ebb7ea0cd4c42da74c07325412e4e3be05946bcdae1ecf7a50b04013f768fd1f08003a7de2f6ce2631c6d2b5e94e7b1c36316d530d8c44cc3e25c287a8d00c5add10ce6e99e29a73a57a5da4624e89bdb66d6f4f8e767b00ea7565e6e52845ee9cf9c6ca00f26d4fdeca4f881b194cfe00c3b79293113d44704ae8fb00be6ad3dd02a5583cb253cdaf5ac55f037bcfe5a6d6614d3ef52d61bb7f2eeaa1c2e260d1928930df37e69067da5513c425f013e2ec19840a05b808506137141410ee0f49070e14a5be5b7e67b1fce4654c255fd4c471f14523575bb942e027f6054d63eb0c3bde4d496160f1e71fee3ae1f4ea5789cbdeb755c3c7bc02a6611c3e6eaab0986e5834bef56065d94e8189161d2fe0487d8314c8062540dd2d8a451dfdd9ff6e023c252015aa949421bf420af6f28b3076e8b5fdf8d6ceb21854f065fbf8ff5d0af23ba4bc3975491cda631b230aa242fbf45b1f8eb98c49f35ef37729221324a179507efd8e13709a408ea58a4c4ef654712eec178fedbc93b55ce941c78294c2c0e540ab2268d78067992005058d00d85b9ca6134a614cfbc6aa92466c9c8f22d65c49830200e4a9e0f4316c148ef4c9c141cea809b8268173d4b6225ccb51d010e72b4896206129eb777337b402b0e7f01cb6eaeb7ff8116c0a0eb7c991bf1eda6e816ddaef38b60e780aeb119ca511c47703344b7e47c31f28c990ea350a167a5fc9864474fb956617334985ef11a96fcd589618a95f5f7058103ab5afc4df6891e94ff160dcbe55eb3ff94564232490508bb93398ffa68212753063b4becf6f33f8020ae7aa1434fda0ffe2bf7eae73392bb57cffe25abe645f88641eb3f2274960533a25027d0e5033162af0b065f9fe979653702b72ab3ea3be53d68d0076bf2d4decd7be9f5499109c3d0c6bcf287701856cd75ef487671b8bf351bb8db557610df4b3ab713802b7316aa5d0b37b5d45df72ebda3a9e05cbd8f4960165b26d566b080584a838f95d9a75db5917868a9854c3aa340a5c483cb689b3901391c576aeb2558b8e0aa72bf7fc015da0975427279db41c1f8c67830d8e43ced47f2b505959bb6380f283633126837ce609543fb34fd7209d850a326a782b1a52a7a6403caab55e5311cf56d638ba7dfe0a71f2990bd43d2bd1dc9d9a7ad2f1c9cc5458a9ca3923e45f99276dee286d5ff04efe9fe4137dfc3d49bddc49d99e8c677d68f7afa6d5fc5e26c3d507713c66daa4c520131cc39d7fe4dc9e1aa4a48ce30517e8f29b92522b1a55ebf15d2d26eef3de3df41c01ee87ccadee398dcccf7441a33ab2d534a0882b647f02236aee53c63c3ffca39cf7f34feb8f4167bf2014a133e82de910a4a40da6a483302d4f2c7f9b3b598fbeac1731031eb0aa0a4415dc7a43460a261428e4cc1c413198747ace61d64c8c3f44ad1c4a142fcef2a302fbf113d35a673fca16ae587823867b9163984da0f23543526924dd4f6433e114365ed67579d6b0fe3dac4c2d478a7f029065bab37fe99b06ab82bd6a03e85471db26dbdfb4dc9e1f549ab04ce8cec3764db3bc22c48d6ac5b548e965600aa35f322aaeff295d05e7a0513651aed96602c0c7bff2aae74d203f3d35f645289f7e56dc7d0471189c94ca0e88e270fad2caf74e29b5952f6ddb7f2bf293da8a8b540f2e97477f06b137996d79a7ff93db754a178e7c6b2e1921e3a523a7077834e956c49d9a69ed431e3bd13a4737c51ec4914ecc3dfbf2f30376624231aaddb2a18b8b02e8f747826d02548aebee60f65a0ebc3927d968af0ec8ef1198b1bbecd7cc68da280706fa79a8f72a6dc5532c1a74b90231d78bef272f2c6f6f9ad19ac1c45c987626c43189707d0145587d6392c517c8affd63d60dd955b7e5bbc7090563df2c834b4a4e28f61c35484e2291eb46d5062d50e46e9babf112d3d625d70199c0650780705a0a569862ff2a13ac3472e43604e65747e01b435d53b5e7c270f78356d0d917067793ceb7ffb3818b3e4731e99b0c5e632f17c0712ed9f9b4914d7122a66c83893e8844d2fad2ecfd86181daf91f15e9b655c6e0c700aecc37e5b24036b47735ff00aca4e4c991d34eaf8c98a1ba46c585d35986f4afbcd47c7199261565e5ee0faa7ed51cb17e96eff058bb68c872e09b44ae96dc9e7a1d134895f93fd8f9bbe2625bcc27a436036b22f2fd0988462ea08f081124a173b7617a89603c0afd31106c8e1091b36612c40a684864d5aef5682f7b70945069109b588fa84986477b26426eb00587e470197fa99539ebdefa3a9ebb8956a9a1aed1a89e687bc718fb125299933ff961ea2087028e9805c5350e535f85eeabe7863ee9542f3f84f8d926d6ed7ea1b654f4c5ba9a9cb9e41718a233d5f7096b3654857b4291637c786ba8d21378444f91816106c834695ad20ec3e8a80821588d0753006697cfa38533ed1729d1d19cd69477c8ae407c35597d713082a6e1411d79324d87a42544f61c3a1eb9fba6915dadb439fa4990eeb4e59750a3946620943dd04c9dcfe49e6445c3da4a5dc1a34a0842495a313911babdf557317a6c2a8c1fdaac994bad35350a9882e98595f6873e5a5747419bec2180c3b9eb4e1528f7d20272d42fa9fd4401ba645c4a725250a1f6e208e97b8df15eb34b0d62509516598b3173116207f12f991b22c38eea223b38881cfc00272e57df3d6dbf72c7a453e6c89f72f59fc7ef1a7011d5e1f26dca41c42d3f5f07b7b9aed3c9be3d6d563de10fbc19b588b8814a171a409241894d747b259ee949d2b4795e8158433aea8211b0a303f224c9612f78ba6acf74a95dd2ac274c6a1516bc24c5eb815525dd4210c6f316ba209a9f9d4033e864421ee697c93819c5ea10d7c594c45e0b30eddaa6c33464e25ca8999ba7c9af9b55aebcc0aa76a902b5bef461887e948c2c094c67c3609fe85aee233c7a3a11cfba7a4d872e12fa5d7b6ee99c277be9ef692cc1394a07b72a7b394d2f748609c5dee5295522eb18c4203aa1aba9b9ae1818bf25eba6887e54401186fd726c85dff1b6d68b19329136c32cff880a7a1ab975527b28a8f8ffb7a8e6248961510686583f6b54adf76adb5ae8adce5a6591ea6f2334a0506685336e50cee53e2ac4e49a278e6f2f95863c314d4bf19de2c6f47ddca3a8c22c9dd17f279f38460a8feddc03388bd6cd9bfeafc490ccd579babb8c4dfec3c6430d7c3cc5ce22f3c29582ac5b67a7af929b6cecdaf057b7e4071ccde387817440ff1d47c0750e32dae75379148ac72b026c89bb0328fb0536540bd5eaeb863568b0a6c637ce1de26f1932390d730a87d99d8476c4b1b79b9a04d2686125318f98938220e1f2a278c37a327908e90a2d2ad194a2357b3fda839eada1497001c97c2ac81b02ff46fa44a87382bcbcb6d428987abe294007d1a190f8444cfcd6d12d48d87e61fd3765cadb03224c9e43e32e76f44e74997a573116ad2da6e376f20ca2954027705f545e57f119d09cfbc8c6903a1f9adb656e5ac8776b0752e750d65e38803202e8b1af78c327a39941ba3c12d8786d4874784cf15f8c485c3a0b21ed5acdd8ac22f596ecf2b4ca7cd86a847b5cf923cf37dfa5ec0bf90435b1b603fec7ff68864a9ff30e1293bc115d8543ffdb30f347adbccac3996f1570a9369d15e99537bace3a1f4a336fb540381b00e55a0fe8869fb782383f91bfa870e48c10cd6c805af8fccc6343f3bad5c3faa71e8e1908bd13abba4224711cb3ac4ce329c548ef13cf9cef5a222d09da99a2017f4ce4f56292772419ec748949ccde87b75df3497def4821994ed15ab5c0cdebe52a2478046b4f31d46427f6643a9f45c724b1edcfb8def37a84daec9a2ad101c7225d25dc82426dee82b02212536d31fbbbbf5f8d8f54b8df442875dbd1f04163549d3759f1a8c2041cec9faf4913a41f96ce36260159ad2f19f78cf83afe6783b6961067f4c1634b8e5814247766a33662f94573237b7e7f9ee7566c3863426be948b19ab4129638f1d98e964e6e83266e8d11e30c6ea7bce018116bcb532c7e2c5010472a37967edf630dc5e417d6445d147aff18d44153b242f9d5ee50335b19be721b51fc3ace2f506577dfb81bb22ef9246992243bbd9848a0332ed64ec9870f517e5826eba5feb2cdb228b15e625ec3a8b9c629a4d0f44de0d5b34757b5f9e836085e8faa0783de099d4c9724d4f0fa51854d080a043c0d8f3d5187d32ff7e6cc9b43662c24674c5a0a09d3c6684d1388cbb1bcefff74b090016364c1b66d41e1df9f5543c5e6a884d223653ecbe0b4d2e4a3e96cd268f575f1e59d1cb86a270036ab99b4944e83a81a0f1e94c65fb5e895150ced6fa991c7e1193f543a9644cf4c371774a6f9847cd88b787ced23570b5fcd6dd452eaeced4db926b6ac05eec8ffeff23abdd8b9e589c16729ad4f0771d6209779c75888a55a8701c385b030aaeca77b55adea122445b62446d093dac3b15f184be06cf243558450e510fa41e39f8261caec65ff046543d14b7bb4493bd111465fa66b805a5cb146cc5e5e814f400e807b1c26025f15a99dd40308426954fa34a78ab21c9dc5818f73a1bbb661abd4d6f5cc6e71663a3b504df6817fba1096ce3046f1ed871a621db2a59c310f4c07b9007b63c3c02abdcb1f15b54bfa28acc0ac24865b9044711ef166988939900933513d7b8e237355954719a10d31e94033d6911c749826b407aec9e509498d84974a0f998e9972deeb0b2ff81a391051dfad7d5733f4186288c3a734c2f40332d999395cbaa97ce4c95233d42f7aa12b839122571ca2e27cf995607755d07406fdf4c2f1d5a3c12394bad7202fc8257a867b7863169473434b1189c6d3da9dc126ea64846083f225d70f8e3e12d4859567cde1557116dcc1f91b2e520907e69e21e7dbdd6f7c4d479652f706e138bb3263b940f18cc39430607e06979d13b2e6fccf20e05f386fcf577d159b5393e0a05066eb10de7df5e1506c3a336f456245b63d8eafc309bec23f38028694424a05a8ae61f4cfd31d587ab77d6fa7aa637dbfbc894be3f7a8df96ec1b8ebf5c33f4a0e0656ef18211369e5e280a6ee275086ded0043b3eaea25d82e6e12b1d35335de87dfc12961dea38f49911423bf0ba81a6c38d7030b99e2addb88ebdd822a2882ae19e4d859490269fff79fc549dbfede65bd72afc2a5f1753998a00bea7cce520f575f029c5edd3aca68ebbcb8e7570a7ec46fd9748aa607420838f5a95ca25a0ca337d970fb9fa1edf6eabb41c01b730e9c3bff818d44c5f58cecbc6d1fd1d805c5fc89360deaf505e2b2d6b20fd991864d8521c2602f574b8237db21862fb3c618bea54cefd1b6a7fbc0f3efd57427ad2bd28907a5df3eae0e4edaf7f4e3c5ab54626ebc26b20676cb35392c1216dceda1fcf872d7aa39bc6a7e7218e83375165024b71ced52fe1ebebccbee7d6a5bb2845a7dd97e64b348b0f0a8214c0d039bdd0a94b7d4e766dd2e7a9e9e0c97159c3b9e56d3f20a27ee9cf314b86cd231f99aa7564549deac2c3ca1a4921b64d1e346c027b596e2106d46b0c949c635cd7bb2bcd5df7b48ac12c0926f286a30ba4f9e019ac587ef00b197c4cc6c343868bf9fdb1fe59f0502acb34c86ed8763138f4ac3bb7266f4663ab54a79b8df738387d935df778271a1aa787227bee6fb2bb20218d86cab54369ecac730ca3c951d2ae39e965ab316e9b8c2e6fad51015225eca10ba387ebf009a231e61b99853566f33c9f53b468e17a32ef522e7dc7d974caeb1d5df6130ebe99a6de17b34d9a6832528cfe074f20b5145a6464ded523bfcfb34f004c266f51b709279720f602276b3fb5905a9c3e35c2f66822b05b9c00aa4d3f0398f7a330847ea91cedcd5404fd906bbb3d398c369bc256b9d5ffc4fb1fa712407f43927dcfb339bd800ddbac88a7c3cd7f58074bd09f6e0a367f7a65b10cc75252577bb379809c27988e81378927313993d0a1e0cefe1c164465c20c698932e9298d737ba7e79de554eee878375e0b336d3f43fcaff119538007650e7058405208551178463932bc9bed4cf122243b48a33923a87ada7203bc5ff709865b824e3c2721fb96f70cffc820de3bbbbe7d156392aee49578949bc8941bf57895ef9637c499e30fe28cf160eeff5ef7659e18dd2a8b748e8a925a063dba1ae052704cc736f1048d653058ca523d56be35f0f73adcb01791eee3e89016a41cc23bf3cef4e096ef5ea856cc41d2696e450bd9e761bea516fb19db7add579843fef1c8e3ceb0ff1071a0b1b3d868b2c3a66509d197ebe6de279ca4953f517f282e30e9c6b3936e06960f9ecab4535768919d0b3621c1958e8e7475eb4534871e59acee97764e16b96e50dbc81264dc1d4148f85831de750cc0879ac2359e121daed3433896e37e16b745d1e373ce59b9e12d18a1d6280c604179f1af6d0b0a0c31177aeb5e5e62428b5ffd7d997e00b494c2f2330b338543654887be8b16fdd8b4b8d5e3817512f9d3742438269a6473999b5a9755b637d0e33be477ce5a581accda212423c139c1b23cdf9223cce025525f4005df7d5939275582b24e5ca094bc02f1adc5f47400fb020419c025dd6d5f409a1df75371e6b137ee2a4a6898a03abb68f67025a41f60b4fa3c64d51b07f7be0cfedecb6916ded49864374be67210663b1a5e0de181c77e6a1902fc6fcadad00726aa97b6cda2f8bd76f773fc74526d863a447e02f9c7582155b3c378644354b6c0197ffb90f163512950ee0e50aff4ecf93d40a96d6693a28704a1698ec8f5d71c8acf187634ea1cddc80cfb24b4b253ee2cecbb32da68ffcd2ad09153958627c643ffa733832836883f1bb3107f827a4dccccfcdace95772093f6aa3a361b682ffba69f66b1ed7cc23d2a6af08bfc09aa9dbd7601187140f7a9f3b36e02c26f76a2030eea3047a79e993f79316513d2f7020ff70b553869bc5a077145c69f6975719e720699cbcb45e464520ee9fb9ecd9924aeee3a16a8f1d46850897cd2bb78c85ec7d4e02dc6827e1130912f32c20dfd98137281d550273bc4fae2d519b8f5cd655c8725e0c08324a414cbcdfed12705f41bf30b34adb64b88c2b7f7cb5e65f7937d9bf208200e56cb71656b6ac3e1364c6f91a44aff0484467e507c2aad6536b7531265bda3e3a046b6f4166da4bc5488b42a00151fcd7576103c3f1c55d2126449f6bafc892e97daec86ff4fbd58dc7ff693b397844497ae8e2afe34af1f79a9c960e5eb2c675d356c3a54e709702d17b354aff459219b37a19bc551affc7985a12abc28388493e07867661a5ffbe9b20bc1a96600439176190766f0fb7c2c62e2f1db8ff3545a6561f5a38403c5366ded130d8955548f5addec544ccc3ab3161eeebd6810b30b7bff13c589a81dd7d7c87eba7cdda52d7ecaaba5d0dc5e6500a33f75f04c0992619dffc3081d9e60dfde3e0d00cf5d9d9528377e781e60cc940d86fc1ffb3a6efeac4bc91447f59a25c4ded3b048a66c3412c485c63a7644c975fc43c6599c836ab2d6fca4341c068e3ceb344f95e733a2b1d1e943c00b3978ebf661fb1874d997cc986715ba7a893db5bc59475a9a52941713e5e33bf97e5eeb8310463a4f22020aed4df03c4ccbad3517a32de5797c063c6083d2eb903eb5276d3d1c8a9ea4e8f1b241ea7968c35fc6c068301cc756cda77c8eeb831a2884e6d2d578d3bdee9398d39537525d5caa5d1d3af2a20c1126d36ea52c1ab18db05192c1b25f10dfe18c03909b4ba746ce9f222c21444bcd5350f56b426df4b4a1ce0a40c707dc6b64f3d05779bb8dbf78c1aadf81bcc00b4fa9fe74ea361f3858fffffe57a070279b7633bd078bd1b0bfe87585ab94de610e958798217b27f81997d502bb416998435a0c82eacdbf9e3026c4ac6b3f6b73cfe1d6f7209e84aa5416468cc71ecec72b3d3b9cb1fc32be7a74533f04a96f3c92c96a1f354e374484a164d33e4b3df3603d50f20a886a641705198567cec7c2bc995f2b42a53a9f3f0252217888e7f55efbc2f9f3d5f94961afab02d10687cda8de66ab0cd0b7dff26d717ff67cdca7840e00029751ef7758e87d64a1f6678974a4c955e2d406c34bfe70ba581aa4cd6994e6aaec47f05817c53b5f0bb75972f74f56aa1c5d062258c677a91a45e9da95243616841cb5552bd0ff42782d8747643aadd1f9d85177b759db00689dde39fabcd48531cf6ba5a279120326b40083e46ad556f64e8ac5d758384f94418f639d378a64e585bb680bff6791f1643a86fef7fdd8dec1c856ee0df0092fe62c4d009ed569d650339724e9455ca4c200249aec334a996118cb56aed749c6002a296ec3f6b37ead226933bd797660be0752b42b07df8e1608ad5f049901e67418082048da8c710e7ecba610eed42dbab22d21eb975ba983a6443e5b7ed9fe48de44a07dbde197bd286f43f93bf524cea8c7c4d4aa38c62a472038730c48c9a0c2f2d2a9d9a79724206699a4199b866c223fe9ac41f4da733ca2dc560636fa1a0a714d57bc5ef5ddec84d23314b448737ef1d5465d38cd97e7a94d924c0bbbfe1cc5b88da655ee2e69833cfa1ad3c2640079d395aeec8215e8f41df9e74f5645dc2c3ba4f438bc5d89e3c4d9b8ef735eaed365d00e361e102f37ec68c5ef33cd58f6871098288830087b5b4590da49ba27daa611af0e46c7953ad7e9e4ad7b5d1c43b1843abc170f20256ba8bd828c1fe60e1168e39b131ca409506d5f88d9dc8ac1cbe99d7c565365695f3e695c0f1b7593595609a7293f86068f6aa0bc5bf347bc593a0106a3e43fbe2a88395ae1151f1c3c5898c9015f45c1630b56dfcbfb97559cc3af381e3bccfbf6ba907dcb29ed462accdee177c41704cda66baede0dcc18dbc1229faf67bd158280695af24fb1bce0716b3f15ea25b6f6e6bb08c1fabe9c18a4b7d533ead5806b5e798de65629c39871fe435c7c763748f69a0e8613a94cdbd427505a531366df936c690debf1c4b3d965ec8fa62a418a3f9bf02b81dc4eb77fc7c8c7720776f1011f84a93d1bd826d4dc68a028c4e161fbea39c41100ccf17f852dbc0e82b8991065cca241dc4ace4cb03b7f91f163f19fc1c8cf319b0e79abe9795011af0cd4363c14017b25b26fa8cfa05055ec968b59664eb187ed1976afee630a61dd1b41024d7de8e21bb751f238d339c3d81af70e93e15f38eb533bc01a1d625fc0a3977d538868b41639eec920afe24672018c09cb1421ef95c3f05ed14f47ea7ee6fc24ddc86e88b669b067049662f9b14db710263e159322f6f6253e43c5332b545a7e08177e45aa1f0fc8b82a1f681c59e4781fca68fd34f9774d72a2e273cb1582935728e4136a5361ab76eba38275e9ad7b0689dfb401d081c7194e147010145dbb3c2f93e73d3fef67280af443de76208bc318aff3ff4a98c96ccdb90cf9d2c35e64aea046b1b318c26978ab2ac8506337b496a9fa006a4cf019bb9099ce55d34245fb525f4685fdee49c4af8d1008cec10a7fa9167915cdfb5df1aa98a65b98015415b3cfa4e5db86da43ee36bb5d99dfe7621b6ee5f6085b674094bbe3e0f0655d40307df88943ed1935aadc0354b9525338dce1af244437fd029b8b3a937aa8aa6a6130563b7b687d0c6bb0170e92e5f89fc5d3623aac9bdc83c63f982b65ec13f4899641487c6f1268d8f1ebf508fb79ed4d56650ab4912010bf96dfe1fc3b3f09424c5dedf99fa23837c2d85b6de299ab29a68c4166f998cee8108c26cb6d3ada04d9d8240606c2afd5443692a0e9681fd8dc62f671e52196fa7fdc5d3c646ee8f0081322f554d26a13f2264f868b2c3116eb2d1015c91b699e237bf536d0dfd5d59a5dd55e845cc50a5fe615d6dac8a4cbe234e3bce6f35e5efa68dc14a954817260ef5dfdd8bc6ae2b76b9971ea9b17907c8be1f0fec27108c078d1dd97ffb274d13ff7dbf02d3e1c5f7b186f39eb27c8151f69ff116ecaaa5dbff2bd130d7515e5b48bd313e2d2e0c34f2114a7b9f2bab288c39d206083c9196bf16f496744b2ef6624213236d3592d0bc75fd22259420750628dfc1c5cc161e0328edd8c4101a05844b6a90b5139c86b174e541930be7e7f0f4ebb52549ce2ef53fd42a3ec36a78022d77d5ca21b63cf4c5687d485f6361cfd78155d1bc718ad35ffa7fd54b77280c0c32df8867e1e9a2156d7b2cddfe28c545c7d51c50659079f2d3a9c9efb4d8be30bde8977d26510fa74621c402542c50b92637de1638a754e910c260a123eb8ee9bbd805bbac3f0afa927ea3fdfc29403612ddaf6b96dbdb7f8e8d2d3571512e1946684c575d7f234a55e921ff3d6d96a523ab3483c7c360ab7ae921e2b76dc5ee9b82de36fd1bc6378abddcb2e7722689e2698bbd60a644fee2aa21c8ada9a94e8e6c9a6b470f4368150af0402127b944366cbb27e61099685186c2c402200e0481f263e648f7ef788c12286981da46c68e85a269ce322ab5755b92da39edd6239b6e649410f28864a8087bb8e2adee8f2a5384c792ef2c4fc3674494ce9d077dc5468fdb215da91ef451acd3634ac2ff77d75b100daa3c2bd895625e537b6e18ffb066e4cd4a5a04402d1f581a998c83a261c4a09ccb9e9c9f4ef83fbdc83ad9e44e6054226e1878a2b55f370276f89a49995cd8b4cc45a3f7e6ec966cd164504cc6f05f073933a084bd85c2f21810eebdea0624c5915ee1f1a1e1cb49d3fa1f39a7e3721ddbd37db3b9dfb97f32368af8cdfe2f953fd59075144c60afcb42874399454e49ae69f9daf36ca286ed4ad0d8f42068efb89155fb2c10330ca81eb53a941e87cddffd8181477e1e67c3710f717cf097a88f988bb50c212e04b849cab4c221acb8a0c138c19aa237fad26d596129e8735a583c4cdbe0022d602b1c893b943b73d2f0eef2845e386448e2481ea38c646ecc2755d20e67a5ce97fdd5f41b884dd3cf8210e37ab46aabe8fdc05d326da96cbe62b13defdf36c8f98d672065a96e7d426a415d92b9738eb5ad93ab68853f7dab1a15bfd33aef7454655c8a53132ba9e3f4d0bbbf16227e06863b9ca6abcde30c6c26df9991c6d929f14d1b5f154f137772eba6271ab9361008fe8e332a8d210594863c5ea73b90a04521c8fd0d51b6b31499d5d12b29bd40c11a1c8eb8d14329f5a8b1f809ea9e7bd48391cdc7f4fff7b5ee5cde20cd1a4d42f6665741787b05c77842c0fa606d8e59d0f9b739d64227538be6c8b7c50b53960e3364357e6d4bcba2cca90faf12817e2e8b519924e41062cc95a9a93addaf23737fee73ee6cb99b172ce1d3004fd5ce8c7921a0b3e1f2b211f1b8fa55bf1b543581d598941181c9d46088df8501b65aa7fdeab81a7161bf37df93c6ddc01c702b6905ad079da6593f15f5a7a4fdf928af4fe2d74b545b96a8a1117e13f550c018d3efecd2ce07d7f4133307d6fd808f3323049c07a76ec1d612176e732e0e8d4749e35ed2e0d0d62b47ae436752132bc1da03e4ecf98dac5693ca30493b909628b4a75157b743f8495f828a6c6d1acd94682593ff2b1e61194d5ab143ebb58e40d989424e9e1f3fd781c2bd540d4765b93f93b260505439c2ccc1ab63a05df2ee349afc7d31bc847c8e926c5c500acfa4f4cac2e1cf579bd49298e4605fa7d8c27eb39c6698f9665643cb47b9eacacd18a8817c9a9f6f5a3a1172e2330b8d01babbb5b01ea857c1fa6cafb0808b7d51812f708e462a30c69b72386d956b2f4e8f2ebde686d4fc028ade5a0bdcbecab614561b6fb599872badb7960974224decee8c65fc379380a1d3ad31bb2da8ec9b5693a8c341d3636f0ddb2c9a228c2f86482def069d22dba8ccec21a141be7c1fea33d6e99408db23e51cb3b26d118b4186cf8f41211188d93de36006c95ddd2afdc8fb536aeb5e31d84f2c22c00240df6bdd98baccc5db5583e192d6b39898240116cd58f676ac701bbf6513860b67ba6d3f1d92afd349297a1281d05fcf170b0f4a7180417d3a18bae9618fd19180c5f9d796b4a30c848babdb42beb7ace320d95974b7e6e28c73c9352b3a2ab29b74ce9779ec0f37e08e8c0e1def21719058fa168223487dc7e45037ca1a5de6f024e2e5d29d2e528a413399fca82a8c3df918c036c56a53bcf65fd234b6ece94382454b75f8284c5b97251a70dd862a13fa4d3fdaf977df6e2d4697b7dd3483801cf808fccd18ff49eed5a5bc1e67633cc9b787c6e649be8da145ba5ac9178de3c5c442f997103371fcc5da589bb545663e6f2adacf57bb5c90b3db9d036b9a0ffb64f0d38e247b62fe9ffcaaad558a8d1efeeb7e1221de69f0442333673433f3189365a749e38509cfe3eb2b5dcdc404bf8d2191fdf7b63b14fd88e8547e19816225804be765744452a589b7fc616474c640623009d498bbe0f09fc494292c983cc80894f4ecdca3f3d8a964e00012838d4ba69b651890b29cdf812e206f379ba0ae89e9feb33a94ea5a6968c57d179c32c2cfa088cbd57956d7b9709cef48c5a6179d7638a75546cd9512af41b56ead599668e0c4b8a2392f050bd278e10eb57184f8f3eac4bba528a2a455ba918cf300a0100d1c7371ad91321c6e7e4429038cca5877ecd545dca1e51eedde078d193d0a43e0e7df2db9d7809da98967eab6fe21c8fc9b966748b0a13adbb56ee9e2ffd0277e3c8360c54f0e68f0cfb77fc24e1760729ceb845f703adea8483531293adeeb6fe3c6fdeaac435be93c8394e5fe3bc314446653da03be5bdd8ed7738c37cf49d5a75382463d8d2a1c2379d6675ff4eaf0bd7e415aec9b8838dc0ff84a31b24e8613e689246235f4c4b850981449b0fb99c9ea1f62f784de334d56bd1c549fc3209023dc84992e2a2e8a3e4f98b4dde4064c9c594ed9a71f9799ae0d125204685f5dc011ad69b8840e0b050e893a87c6b2205336fea75cb793e3d5ff490417e39096fa68407316dd30515de857a78f875045f3677b65a5dfc44646addd4e6a4471c2b5e0cedc61edeecce2b9924569a0b199ac309a624c5a27e234a959cbc27c26abe3464a021778b8092eff1fbeb7a7acdf0715b3c84325410488b01cf9e6818db586cce5ca9811982659d61af77aaf79498d0acd839ea891bdbe7c76075d4e9bf4c301406d5940bfc44e7bec3e92ef5cf42b98ad0aa07066b9fd30e7d01d686ae399a86c8ba947551a7b057040601e59221b2346feba42af03f8794306f683461b5a00b344310321bf92ba3e36cdf6cf41580f689c2023c567a828330424f84aca05b247e760ebf0e08dfe6c01654ddcdce9e2485e1a38a335b4fc26be1d6492904736dd7cdbb01ee495895083abad6f741ca9ac5fc5e441fe8c01409afe0059d5ce9f38820424234a691df43bea39810e29cb93ec6cf159960a2e8d4a0e728351b338a8711a8a9fe120c89043cf8ffcc19978d6a6f07eb4fce0170ac76d08fd47a0d836bc57775dc0b9ffb129e08595ad26448226df72a50df6e57dfab9b060487ca9a9f869ece3bdbb51926c69c8083bb51ad0317adf03e4580e64ab63f51d457a73db9adc2d5f738b0da917411099881ac7e173103ae0a34e6625e0f7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
