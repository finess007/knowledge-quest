<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9901718472e52dae10a9a72fb0a3b185036a24c6c2f1be75b9273ad70a472b16a6fd6f943b22661464ce3cb1492a055f55442b5cff2b7cb4e3ff2f74ed7d6edb4177f050cb4a9c9708e01ff3b4bda76ccb3fa85f842e4976b8fc400c1012a3002b2ccfec2ca9eb28f19eaac4c6fa4121c27032d28e2c15dd765e76feed954ea51f1b8c00e26de3f3c9123322008801de4eee39a31a95308cf9b8ee8513daa172982debe7f2ad1f305446617f8955d40aeeab6059e0c4affc3e7a0d19cb1c2898427c8d1ab550f89dd3b3738431561f2eac9595e92a27dea73c62c77bc80a77f9e0162c1426414ea92d058b8312f7ad90fdde6ba4ee5a1d727a7c27c7a43f87c07a560b477fb715918dd5009670fed0e5ecbcbe67c870c1dc325588ce5e0740bcda2c0ed821e983a751bfcd18fc10bf3e4f0bae0629dc2662e00d0d3bfdde018cc1605c2c0536bb47df2b31e5880b9989c0f5f66fe615f5b7cf86b08f7288deea6785420fcd5f470f5391d80a3f4a1e174a7fa9a3ad9b2e6d68d1997824597a16e7ac0c03cb6792dafab3318d359358942ed6824c6613612ee8753b264c2a471470dbaeeaa6fed6613ff6778a99390092e9fad795dfca9e884c91639e792374f32120916d7791979ac95af380149263aa1973e4b29bcfe111f309b59b28ac69c1c57efdf3b3c2e704da80b34cc832f1f5fbd70cfb3b2c78134b87897d949f3face9167ef3b3771256450ea3acad150ef0f70abee0263faa698f96c5892dd16654bb78b6f43e46c69d6c93faac73cf635792853a2834932640d2e9ad49463cd03bcc6529dba87c0146fd634fc35deb50329df4525ee844c4730a92173838a3e9d49c50c617fdc9bcb326fe20f3108f94da1b6353af483ffd703267173fdb6ae247bddebb1320ca4daf84af271b08d9b3a08600d17716eef24f75de5f8fb782f4b1d36e45402c349ea3b6f91d5b8a5504b255479142046eb8a0c97732fe80cadc9126ce49228424298f587f29c57f2f01fc2bb603272fdd811b993159930ccc01507fa0b384a38f7a9e6bdadc60d023518fdc42afb8aa40c7fd29e3f0d2639a94d8d134a26b0a8e7aca6a428f25fad63f769756b1dbdeb7554069213238c90b2c5bc3d2b6601a0b61cc407ca2a8f68521a25b8a608b5be0169ee3054c4635dcbe61fefba8f8a5e9cbd3905d0cab08da99b5d91da593ab0f50a70462205d605dd81a8cacd0128aaa6e5b5b5044b2b634b85ec4f329e4f40db42c5cb130ee853442b687170a5b62874d94f5730ada9168e890eec1b18fa12c3d9299b5afc7853393829d8277b6995e3c7daf9ee2199bc2e5aee0a1e5951d38ba033f4cf61ee4e05df299a6ebffda26173e015ac8faf05f51fa3ee9de265ba8d8f0a80957e4e4497ec972987db60e35a35c1788b8dfd8fe6faf301431e60adc68309996566c82b79e1838688e8cc24533d809ceb7c141f0089612568860f98922fce068b7fec0c1690b6243c5f5597ce5004cc3ad2ec92b8a0c0cf01fa2197c1d51cffc9bd8cc67ac7034f71cc8006be48f1cfe588852c8662abeea2bb3f498ac096006cde31184a63f51e9a700a6d17bd8f091355070f13b5368cdbd5f951efa6c4163c1272c02e6b38faefdb1337367307a2712eb0ac34a4486e08fb34d4e8cb076e0ea3c7a02f9c05151dbb3c00a655d34c04c1c335eb820f19eeea57f938a7a76d5acd2f287672277640ebfd9ffaaa9fe64f22d8416a0e6aa107ec47910602bd233e71b3dcedaeb6d01e28ecb1a227e5bf2df97422aceba68ef01797f681bf514c7024cd1c8a65288029007bb63e14dbb14a756fe89f23015b72d913dbabc42e29f18b91ea0827c7b724cecf526abd2d9a742043091dff831e5dd339d24b5eb2fdb39fc70424e87e8e1702fc19084b829e1f433b1deac93c6e21862005439ae8e93f979becdb3fdbf99e776f615979d74b50a0d8634bf4aea3ac51618cdac2034b8b7389b6f447fe2d1fd311b0b9c3424c38b96aa62461d02119b0262a0d025c10f55bfd35ced0925c884c4d51c421709353f300a469150ef500d45ab38073ec773cfb8e1cb70a78cdc87355660c19f3d20a8c7700f15a3777a12f02ceb8e41e3c1bdfa565cd5e109d3d26f26cd44852229d13ba73a9c2d16a59a61df5cd4da6f7f13cb05562cfc65c490b6ced140b09bd3c0f3da43f834d233646f46dc558a88d977c4b9ae2c7b3c42e3f107d16c72ab07797d1123ce146883d88d409ec230337c9bf0de9bd06f7feb123b715f7a86cf2c31836382824dc89a4e5e270f75ff8c21fd75463f597e633e79a00df8e0d3a94bf90d706ded77a42164644882823ec71d02b69267e8a0fc08e9e73d301c27ddf4df20fca2d4728a176e65b2a98032b66b9259fa8ff489e64c29331d46aa8d5875b077895d82ed1c6e54f948ece8cc806a7af122786134f07b4626ffb0293ef44dd7c36438ad0be4bc4bba8d2466ea357d30de5f0a5b169b8c9c3b5a76c08efe016588d85119a4a267421aaefb92a37f15be68ab9cd25878a1b1ffed4ec76e8349e3a7233eab9b8157da50baebb66b9fcd3d3f0b186e28a15cc654976b3ba5e7ef9c607dc6628a9ad77ba235d325da011253c599ea9efb2597c06232060f5c5b563275ddcd8c42b7ad7b2dee9af0f48e7b7678dda53c7ff4d9255ae2d3b8fadd7720bdf7819a8b542e51eb87fe6ef08a8af2721ff9136931907a353ffb825e5156f118891de23504d79b9868b8a9285f5fc23c4b0f2c27c01b2c5a55902b7ad13ee8632d33a0747aca8d6dcb93ce91c58a2bb889bb52efde3cf0d247578b3e38ba67d431fc62c9cd434db457d474aa8e8452bf84cbaf5d68268312c30fb46d657fb9fa596f03114a55adef7f9c88ece1d4d1f24ae77165613d944af52825758335eb59bc19bd6ee95a9f977878ce9162075ca528fc70746052c0fe4e10c3c2dae92c6ef5841235a6017640dc8eb79e4897f4e6f631c8a116998557518a424a20c0a7b5787ec86971ddb61eb4b71d2c737f68f6d590ced6c9fdcf774405fbb57235f692cd2675c39bdf756f962d7161951913fa577473c53ce3540744a37ea1e8ca666a66413043af3ad82a9fff03a023d2817c13c7dee7f582d6f76c9819bb92ebcbdf239c610d9af903882b3bd2d44aff94784e1dffc9606396aea73659787c5f58cfd2395fc445d3ffa897c4de783b7839e55d0281d6af291a01b8ffd8366328d6a56d694a28a108daff6f17011d02bada06b5f1a2dcff4007d1fbf66093656e9f9d68e404c40775cb27c234a2dae26d2ae8a548d92b2edd07dc14f82237611ce9343320c99e679efc4fa7a926c8a60a1c0c0c5b4469473eef159a45ed7e77f0e1733b2833f363f73dceacb127df0723e67b52c17f0d06e35c4d0406ac68a285f6b12a2c0b59d5fc747caed93129ea7e44257f672f89ca36efdf39d5ecca3f0652988c99c7036b9280084dfab5b4ede6be461192ab646964e6177a8da090a5d689516b27e31c25b3f46aabcf743a819971eabd2603fcdce1ce838193f767aef90874862c541492ef582398e36eb64f80af6585d054124887732cead7f81264eb7e48d0524668f377230e9292eed64e14eaed580879a52724b4cf9d294770ade68b83476e33a69023fec290bf54d21db7a57eada293dc44432400438a61237e33fec177a5a49a25ee9670dbbe7accd6bfb5f18c099edb4ee7fbea99450ce11385f5c7e8cd3608604c71670b33de7cef14e3c9bf8eac84c076b1eae30a13b34dc9e7af19552e3ae9a37963cb4fce5059dda8a5fb133aba5b6d7c1071371a43e00f2454ba1b8d17002d5b767b0140ed549d8e2b4c51b4f5c231077a8b891249bc8b592e494ddf72ece6aeb0f56918fb6d5f7198158204cb65550ffd7b735f83c0788ad1d12557391524f2314dce7859d9649d46c102a6b888fe825d4465d501883a9045f26f7ea516951f33d87016af42e082f254dc280e694307bd793da2b4ea65463da6b9b3af5526d91a8665a403a59de61b27935d67f38d76b89019b9dfd56c479f9d8ebc8d53ee09583bcd5fbc32215519fe121cbeabb0f519125fb60a9fb2307c9e04436fba908bd8307b301b1347649cdba9f734e666f465054168f8a60405b464648e0fa6fd3e74fb1cc3321c72ef71b4a867b1f079421e3c080ce69df64e2be8a4ff186b8bd48e2cda71672113ac9bd60717770347db1ef8db06e825031c72730628c8f2e3dc69988645b46d5420a2297b3c5d611277fdf75cfe14e5ec6dcb65a5580996322224c9eca64ca5a29ad219ed7542ff7d0d7df69bd4a7379c67de0a0956ed9d53e5f491712bd91251844a5af44ff0f625d8c6d25c85e00a7b602976724b94fb3b74abc7608e6e5872e5cd504018b29576199e762b1205206caa936d0407a4f77b1ac433612433031be32accc1bb259db9d4405a6af13f5a95797eb8139af6302aefe1e5daedfe1e7aa6227e28ffec03b1fa5f111a35e238b6bf540964e463f616ed09ef857228c9f1a09abeaf5bb3171e641c77d73fd14943211b056a309c397c1723945d5b6cadb0e10098232466c1a2aeb595d7f8381b3ee79fe8c091d4827bb4521339051748a04f2abc23d4d3656e5a728858811faa338deefbf8b9551e4a7f739a2c8cc8e42ed8bb7cb43baf93778d1f5ac8e03b3b75be9e4549ceac91d7707b8506e1d29127812aab64b53398aefdfe6951e2b823a02a7da17151c100f1680c4d6d6be9df5a0e5aa0071f6831cb14bd481321004b68a9c9601ca7d4a13ff5e4e603ed0da714eec805e913c6529de92c9ebe713f2e06171a18c0bb47327c77bd0bf5cd5cf0c280123da860fd3b02bac31e13f6792c9395200a2722cef947d6a46ec64a2bf47d29dc0f93fac951a8675f138c69d6cb2fbe0247d69ce3ad8186544be7bcf0d38922483c1ad4f0c7db8ac56c62d4c0dff46c559daf9261fe923d325d7757dc8c116ab2ff3122ed58f012895e043c4935df417b35dcb7e3c824097256a52db347d0afe5eb77e2aad4674d56190b26bc7ec99b2dc0cfb243cd5ea25d9c23e287fef6a15362fcc407c31cf04b3f98c1749466ddada76449f8273d07b98ae0b105ee1e315e0cce35ea55ec2b27d7cca325d20424a7c4538893fccc139540733d8f165b881f73a57c1b25b3f3f2819adea343e432543b6693493e2898f9012d7674d42875e1479215dddff9a2f519bf190ac43e4ed191243af1e4dd7c8a88be3df5530501387520c8a084711fa26b16d321f8a97b65de2cca61045f4617db17e74450898ddb371d1eae61c2b7ca51257f68ae2f27a8fa3b233d54367ceb5434c9ea6319bbecfafe92169b3a22ab65da2a3d474269e1032d2f23c95f9646e063e1ea37f01c0c750ed2b2ae7326a84d26a4274d75ad79eb9911b8a378c1c1db20e25509d1dc208ad6effed130d953fffc84880776c92ed717475322dfe1a47318311b9a473d3d05541859d4a94bb94d9f8855c2382dcfe1b4f4983bd554d04207911f3ab34feb8c124a64a850f39aff2ff3ab443cd3cea43bddad7868bb831cf73b5d6fcd226a170420d7db3ec7196fd3928d08288f769a1fef81db54c3395554f539d9234e213594d0964a663190b0115a46eece261c5e318f63db6f7b08e435aa891550e4e3f5f1c36045362b16a7d9715b2b55a4c69a560e884b5d23b7631fb371f2f7b9d7fa639daf360b939feba6b3a6ffeaedefaa31f37e32c3e5653da2d235aef7145af87890ad34aae211febad8fd49ce28b8a0af169b34a05883a20b25d7766f6be59c89946ea6d4c1575b0b599fe6ac3ffa1aa553b23a8a91e8b0f69bd65185e636332839bd461b498dc9480b4fddb2f12e4511696cbfde77a49e1ec4257f2373b3549b7168a9945c1f1099784fef96f48808f110b88ef07a08a3f05eb70d003f867e78e0f9afab435479c3c567f292bed424cf3031446e43322d2a89b696dc1122d76cbf83c63220b55dcef4eba8451dbe3308d0595a210331f457bbc6b05c33afcc9e0d7b2b1a742f337da30fac9057acb691e696250e3d6a1c892b319d9b92df1709d1c09b3ecdf3e215eff7c6796103e1bae1135d7f6f0d80430a6b15cb7d46676a1bf908ccdb547be948b2a4fdf036d5a978452a86f3cf881012e01f21d4f7a0320eeed9ae1d2d0e4fdab2f3824393582d3cd5ba10dd0539cd61119412d0ff9288dcf1aa091c4b6a03baefb3cd93aedc95f21fad40555f1491d4478e28550ddbd04394e488a7ba3ef770e5f384b2d3d61889e479127d66bcaa6a2eb18660eeaaa02aa2648228f9e9dce52e80b11041818be7f8315737583eb3bd6fd4f42180f4980469faf646093d60222af80e24db12fc1410aaadcb7f4ebd9250ef4e889071a3729888f81ce3d5a5579895f1e369e6590d0815498753dcf4ba4d20141da06a1dd96a22f3b0007616628d7c9cd9ec0ce0247348638225d508fb10eb105d45586fcb5ee94d3206ae8ceffabd938cd3dda8a1698365673cfd988320c4b3bee5085365420b78c3a6835fd4032b5d71f34a514ace1dcf0772df4fd98a97471af5b90f87c7da6e46a64a76a12dc0a1a38b79842e7ec32c313a9214513eaa720de7c72ed80faabc9d7951857ec3c942c88c276faf963be3bff5b53c19ef5dbf83b5ccaebe4743aed0c0e067f8c51ff7396b1bcb4dba682411f56680825450694c8041fead1cd45fa543a3b7d684ca7d0ac069627aedb1106a49ab06629021297b47ebd61b295ac35faf7971e413388a45930531beac6f175374ac096bd75c932efbe4720c960b043480279f626042ff71d6c6733c5454e995a06aeacdbce86ae272e8ae9353129a078a1c5294c7941fb00449918fe1489e667e3cd00fe232e42151e68726e019990f6aae96619e7a703e0d17f07f18b889d1cdea8c5ccc40a56a2a91149fd0cd30d7210e908809b729842120b5a32e0fb6a97fbb0779c72c8a679a034225722f72b41eaae4ad73fafdebc37873c1452d0d8e53b00a9d2a98fb4027bcc020c8f715beca7c2807e6fec81996abc15dfd7809457c57f7e12040d06c62c948464ba27bff03350202107e0988b39b1098f56b5fbb13ad38e487df2cb83d23f182eb06f6041725d79ebb18ce264a8eadf4afece5e1b03f2b3374d1124ae16882826fc298805f9c750f6b3567ffd4818840a5d08595701a94eca264c3e63d912883ece5bec4e1f688a6bbf225ae8e0f063b5224e264eb8522d4cf5f0354b62964f5523bf90b31cf32f9c4c5bd28b1a278a16bc061a8a03bda116a0cf2fa9b6b690dd716269eeabca54f175f2219f00e6251104feb6c8c271f9083b17cc32f33a7f19c05a336ef1d7c05c993fa7e2d8e09f496dd7612cc5e252e3060fa9fe96d72084c5efdc42fdd4a2c5823d6b23e4d0318a24bb40034318a7bf91bc0b55309a611b58137432c5bb70d82040edd688c03fc14efe234a42146d55a7b49749401435c827a42efa0e214df2fc8e4d32aa87cba5a8d05eb9daa8f2f7be831d2b4aa2d6fc92e494935a9ac9b6ee622ccdfc184f3f4fdf18038af474957d7ad682d6f4693fef9d5b2f8cac753bd9dec4e1f9a590542d3feed165a8048c27719adc5c4ab2b8bddb7e107784d75055b1f649258699bfdeb6356383487bc66a29452f8e43859009c37af71c677b81bf52f1e9d8249b58d394a013e9d6dd0efcb51e2df3a65ce6327c65234c7906950fc8131f51134c491edaca87549937edabdbdea424cc514eecd077b3f54afa7a116973219a32e49ce3248ca414052040002370221b92587670341de7aed89f7ce78de25c6ce34977418f3ea296aea9c7aad42cf86a9765257e95bb79d07472c7d8c871d497619f77bb43b2cdeeb46ab3456ced2dcb5dbe877d4920804b05ed029f80c3ae16928cd30a369feeb77a5cbb7197853861ae02ff59a995749438fc356e925946fd26fd09933fdd326e3824dc2cde6f45704160e510a81e53d77d2c016997fc18f8c71b3309646f2d589d815f24b25824d6b5f21de511605c41e657dc54c97b7341419eb20be19cc28ccb6612a8f73d7c87dddba41c07780ab7389b15d58e7d21494c1a2ea1882aac181d21b33eaaccd0a7d3b540a50ba81e3cecb32894dac995851e59b75f7bbbc106119a4408419f791054b22ed11f7ef97155b89e2aabb0fe23f37778ea27e7b99e3678f5c7510e7eca77d77bb9915320494fd5e40da00cce12ea2e2b98b1e2dc2cd8ef379d4548a511267ac37e63ce76eff89fddaa49b7f55e4e84e82043866f050eead34538b43d5c52f6ac596a75d6ae2501b476f5398e8d0a360b67444c51ef7dcf1d8338dec0122769f77192eef32f63d757420e7e5d569c93162f74eabf5417d4f146c40a1e2af5bb4ba6b754a04eec429ea05861bf16a9207c91c6202443fe5c80104e67506c6ca527d96a22e3f281a6677b3cf7777255e8e45fb72b0fc4b30cff7a675bbe886c4d5e1b287960c634417398488f5fd5525ec365b52639146f3ebfbb0ab0a5023b37518a7e352e49d976e2a4d1baa36d403c1e56eb5cce815a95001a8035db30ffe20019396b5dc1104295c0f9b2b5f12281552f9afe550f21a4f7a8265079f3d0f5c2546f0199283d396ff1bf926cef8d841df6a7bc199cb1eb64dd5b101ff7c8936ec219dd36c021888bbf804fb6e9dfaf0454ebaa7a1c158056a4db2d90618410ecf3a27f1643fb09562e6638aa2fe79338e85a42c07e8d1ccbaeec0ebf5b0494610c016d85cc11680e5cada51761a7c436127269dd708e141596fdb0ecf86da46cfdcc0f5120a3ad673a0ad8939e9238cb7b6d9ef2af97745ddb9cca4c43d3d3bced65615766e990772e29603b0e0917e8a1033728529149b60d8322a7f8e899665c22a8b7cb774ae65faea3c264f2d6ec02b9016117d5af7466d90df932457c95143cd52576e9f824d3360275447de20c1c46eefc56f35eb46f30bb2ed19696d30ec18b61292dad4163bfcb27e47dc894d16f18abc0ae009177624a57b1dccb45de1dd7917f410d5c0aca7ef89a32856efca438adcee0ec4fcb767614dcbfa1ef227b31c4ad03314be37fe87d275bf4608876b4b6e61814630d726d8069b5399140b9fcc1d0efc4e876c468bb79cb7bc6ce6b0f07d4d2db9aa249ec7c6c455c63bee8aac6010be97509ab2e75e6a42c129cdefc19dbaad21fefbaa3698f735f0a919f8763492e4032443f30575a3aeec5ab08eb404dd102c126cf19bc30c3cad0aeb217c2b945a758936b0da6b769347203c6435489c5f984407041060858e18f0536945d5e717610c2a45aa5e409dfcb3746a36fe5f6e71cce1ea86e58e544ce2d962f838723373cf2ef614ac6e9fc63d3c6bb69573c0848d83aacc5e1049c299ebecb2152a3a9879f6bb3cfb0ee32498c519f46ba8c78e51cc96aa067edbaf3eeca4a75bcbfd15bcf37e0da8c2c80cdbdf622ab229735185d9495c5a0b21e70b0b1f1fce1027ea81292176445aefda7145d793692b9322a9bf47a47f1384bbabf68c51db294f512b3330fc58e12f7ad8d08a82c8da117086051f1ab12db9b55ffa4ce8ba8ba8fff3dd537fa6252fc2be21083d2f9643fcdda270acdb707c5d0a8fb2a142e05dee009b8d6998a9949d9c4d838f909d63e70b3098eb96935c8d23b5b34d5eb2292b61bab6efb1f0b01df042b9cd672235a7ead50aae2dfd94854bb5c57e7aec7c407a820773eef7c30f8c88ca9afe9aff32aca906cf0c631a0aebd140b038164e25e86f8945c19e2ad08ed03e605b2c6df3d6d48bbbdb7737a33f1f616198a1d79a0a56b6bc30f3d17640372e26625ef62b54fc9226f1e79b6cb771654697cfce885eb4892b76545afae61e31fb81de29132a25ab620922baee630ff029b1a3c5d531d71ff133b14da742084fe89974db07284ebd2d6321e3a2f6461ed6036e986fd2ead6bf0b7aa3916ea179b2f65b897717879cecddc254311ee891d6bd20d6481d6576ef963021fd84acfb3e26db4b6d554fc1224e96107d4f4b8fb2972cd136c53755947438a4bdcc5ee6538f0c8481e9f8ba64f5ea6f17e8523e1651e18ae3359eec1d8bd030529e5f7cba4a633fc1ec88408567a49ba6aac5d9c45125d5c0e1fe6694767d93ed9c9df8f1250f1ba3b32a0c74b914fd77ca33086ed23bb81c93c5ee422f0c98d752dbd34446925fd4922777ad089bd2ec7cba7c00c4fcca8c478ed2720def6766c0e6d60139d53a3b12799f1f552a173cca09d7a52dceec6ca09c64a080e69a063b9e553a697058ccf192fe00599e4af662492a4f4726d3c5b42ec4104887767276719e1b8929c5523b48df848ccaf5c71aa86ab0bc3d827624c5ff29493672c8f49cdd6b13c650bb9453a324cc768e3b411d484881ea22a165db7e398e6445ead747387bf6b54df9896664e468aa2d0afb2db5891e6d2b52bd0c7813e9f8240b914eab4dc9464447f01ceacfd71a472972b749017c4f6acbbe963b5649a4c3e91febe71499e2d1a49df4b0ce723d61dbc310fbda810f6d985fb62ad1806a90355b061d348cca50429863ceadeeb7cac28f55fe5a517697f91b051e8c0b583d136797521c525ff305f1bc247a9e747ad423eea6e6be035fa61d3af8f1f7218da57e51299954c5fd95a874510fc580491f45bfb3f832cef23d1af7f65f09e5abce70646594231171fe2f01fd1bbc16419adb0181759acafcf8482c2dfdd781952086afd08f18ff8c8136e19b856bba29683a98ef6c15c3b62872c3bfa331b55aa848761924d0451f76ebcbbf78b832b5f32b8a4a29e783f8b1b95114ecb054f4f1f8e3687c3bb498ee91606d299a3873927ae0f3f26ccf81035d69f2c977368696941503724369ce826f8c977f5d1a513ab174a8395dfe9a995fdc82c5e8a24e76bcc43bbff50b44431ad4e3c8ba143400238a96b00f76fabd9a8c37a8c0698d42f1a918e66454c0db7d87cfa457a21c4046bfabdbbc07f7462745262613e7fa9416dd0de84b1ae076094209b5fb235312ad405e735298532c648d24649483b409f11a5edc017bf4ee8bc1a7ad0657f4461768b786b972847552b2b0601250ae35f11cbeed6c7f975767f77cd9de31643481730752b7bcdef7ab2733d3f347e59f10b4bebfb0dc6f4ad7c585cf60cf744036d121e69a000eb22f551dd8c5e7e8e3f5996a9bd6f84e7eb7ae854361c514eff06dad23ca949b642890472cbb64cddb9626f1430874122cc6ab8fba05a24a2d6ea39f4722d7bb7144306f72d6d90694d88f94798a7139f908d032ae2bbcd10c67465743411da014b42493d36d4ba147e64cd6140798529809e71cadc03ad49ce40f97192681ae3248ff2135181b971853d634efba9dfd2f532e15e40fc5cb41b55a2aa6a11237eb63cab714bedb53734e1f40bf03d57deefc2119a01dba46a1ac08838156cc06c5a21b719fcf78c6d430b109a180f66da0bc4259131c6a123b3d3e0f97cfba43aca60623baadae06237af331195c2f9b573e915e5ee457df66c86b521416d97aaf3497fd5aba7b5beabfa99213f83e9769e106926c7a12a7234f4a3ec04423295381299681ce2d41c1fc3c407682848ebf653161c0c78c3baa9ba76f06f201c4ed8414980bfdfd57119c843394305ae5a0f309c07a41dba7d2a70835a86d861e3542c96d230081ebfd8ef12d4bb0afc3171b4b9c1d8fb228823a229b6686c3db52967a4841957c3466c85f83e40239829d1dcc0818450383c54e2454670d5d4be78b2ba4018df94637c8adb2d981846a0352f85884d5e6ef639e3f57951f25407de302608ce30599e7ece35ac70b6645e849556db7df5f4e80502c8d5b08d95c0ebb49ccb83137e822bf9a2ddef31821e325c72ead29b3baf90e32f97f1764256dcab8ceaaa10a274766e183e9895f608381339233f47058105d8a0a53ea440045f428041bd3c0016ba9c02372e7ba0484ed788586cb0d272a3fd738604abb259dede62a46268a91bbf11348ba1c50d6c60077d7a86e5f3753683e08e8c78d823310c5152ef928dceb3a6f8a5e9935babb004069da45128897d2813ddac05a1f2c7e84af0d6398919d3ad7e4e97dccc462a9bc32993c404f6ea26376544d7ec738d691acbb6a7a626a33e522080cc3f37e49027e5793a9990a33254a1a39346098ed394f8f96c868acb103de2ad37ef6feb78acf5540b8c451093dbcc0e2f4c3d830c90e17964ac28b1d09a6dd40b3e18ae85f72bba44603d4ee4b635ed8080a9beed58910f894591ee65c2814637c8e8e7f03cb3f864e42706081e9eabd75912688ba23ce464ff6c2a692c71afe8a45a2184b9420d40eb82991126cc0213395f10445d86815e2f4f38492c8bee01c2b86ae95c39bbc64efcd515674044575607724712c5c5e26c4683b76d5f55d3488e12adb85fca6cd76614194615813564e66b175f7e5427b9b4ff8a1d58d449734ead2c957f6039f2bfacfd863eab32cc8b3b7f3750189746e211eb0f50848bee060f9274fb948ae14b853c5c4567a84025c8e267db31e9d744822bc1b66ed53e390b6c421552831da66f7e00f02ea4f0b2a2225156d22e2cb9c4366f695690106a216496f481ee0fade846cb6d79a91d15bcceba26cb10bc8daa0c34968258cb0c4e21eac47211229057861d037cbccf9f92ce7438ae50c26839d8b489405b9ad32e89be9f3f334e17010fa792f93ece48deb87cc62ed47d54b241c371e79c8715b2d3354f7e05dc402cdb89d4a03ecfd378436559207e55dd895d890d216876883cb734fd2cd2d89b91d7b5e68cda3a3fe4d7e29190ad822d98784d5872cefd4f04adcb6f19c6786470722fab50971745a1517f834c6fcca80f5760f428820d9259a802d0ad5785f930daa4c371792968ace0e7b0c5daca413a2e43789d28d14a40ff7157fe703f641a03c30cf22bb0726bd3d75c92170edfca5262d6d651e9d3bd3389a7a90444dd2b7691ca4df35b3035d02c9071abfaafa93856b143d46f31a6f35c807ec3a225397bc861d24689825285f404bd3b15f67ed5483ffc1cb83991b50d93e2ade28d34542ce9b5a4f35f3c8e56c4a64b170d7a22e09b4657ad8a33d1a2df256ce4050352f691b12e532ae3a636e10477fe24ae9eda23502c84105123b84460219af3a8d8993519348926436f724504c4fc95bcf4d23cbea3d8e2a8afb7fa65ffcfa6e0d95c6da96bd9a499ef07961bab911f561aaf56ca1e129938a581f12b0d558ce13cc412aaef6f5ad5504114c831dbd62433ccdbe206f2313149eecb52b62597c9c78e9c00d4726d1eddebeba88a29bd2f4200bd05dbab9b2c1d902d1a8628cf4939cc55e56ac937f416187b36aabd9a2ccec08cd7ca6554935e8fdbd06c8caaa23f479e668d0a048ce934a6d84be07a23c981fbe269ecbc7e7389ee3ed300c7cb78f7dabef5bd000768d71f527ab74670d07babfe349f9333edff43ab4047b81f184b78c78143a125a3ee5118d840073c25115779e69b6520c8ac99c312dc7a68d686aa0930f3c29f5e3aa40e329c7a1147ff05a5e0901e92f82e82201f73aa6989c129173c461256a0af168dd1a3b37ba4a0f948da22d8a5b16f927d539a48c5b3445852685f28dfbdaa29eddeadc899f9a336bcda362196e56ad58dd5e05fd64ebb2b61965b4a0c7c43f18dc58772552f8a2387708db190e2daac93c8f2c7903708e2ec82f014729749f674b99c91f9e1e7d18ae764f54a968b2cdcb39ceee61f27d97d212d6683737cf44461eb425808e70b96851f46fa90b2016bc6c7bf8a5a635d25601181a3f0213b0603ab18ccfee7bc6260318932444569d85a00ac02f23948ad1f4535ea2a5a439096cd2ec28a3c6d2a3c5c584e9a30a8c850324e0e9fb658a6c8ee57ca07f646a097e57fc1d7341710c24cafc0d449a23e5edb6cc1d0ddde62510ea099dad2f5f85132fd2bfc1e2d21d0521b75952640c950fbe7d54e7deb91d258ecfc84c5647240a8df2b4656d53014b19d112ffd1d7ff38d3c50467a086d53734da9e7d1e58c6ec226ae62c31deb4b73458c27378143800ae4823c4ddd16484b9f42162bb301ec829fafa56c7cebe79d58b26b14eaa4ed751de9da43e2ee3a6361344189eb562b6c1343ef51275d6c1beb2fb007a21da618cc78694661dcad51fa1e42a00d4327598fd34c1f06117b273d84e6705b5d02dfe33ca09e5df68efb781ede7faf7897cb5e6725eeac23b5078c6c91888a848f8f9d2f5f966f74f376b56fb86f85e2c06028add4336765935384a051d6d53e3d1afba2842e6b9afe2f20a74433d6b983ab3e457ca91ce63bfd352c03d5b20e385125f9218db28d5cf735a94f3a18caba7776f96a93abe698b08445f429bba42fde40f47071eb6afab999f62ec243de422d9f6f0f0b8a57a0819b6fa4624a6661e9fcc1d4d7386dad20422ebd5ac4b7c7f295e61deaa8280ed7ecb791aa0debb33fc8eeb","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
