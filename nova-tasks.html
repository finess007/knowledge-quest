<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b3e76925fa92ce828e58187c6478bf235a0d687834be82007a9446011ba79bfb5db71e3f9bbae63623347aabf70a54debeb00a4e2d89f4b1420d8aea0bd489457549327da5e34497623a8eabc686419307b51e85d6463ecb729c6488bf010418992dfc13dd9cf674764b9c1b99390cdcc4fd6cc06041b6983ab5c8805a9fa5cd84799dddc83e781377c8d65a2236fc345a49cc17d9418520fb36cca04b96ba367520e0b2c3c3e69d02074d8f227ef3e8e3a1a23743264df620d0b2d532fbdc1101b5eaeceb0aa83427547ec21023497babe2eeb07c00dbdf47b0b5e3d6b1f8ee575625046531cf7db2cd67e4126a607336c4fda89ae17123ae5bf6eff9e177e2082c9fcbe2b35472806a8138b0302ad9c7c7d4c684388dd5772709479b0eae28c421eadb5ab790aabf98eb0384fee51421ab3c3dc43befbc093319a18c4b920500733fe44e64594116e9f8591a7784272768a9efe51f408e2674291b83a7742348ba0223b71da27a74b0494052d869b6b46dce618c3438fc0a0b74297b686e2f5c0ff1c6d5ea409db0ab0defefa204229355da702390fd57e87906584b399ffc16f817a0ea1e6859bd0b135416586152a1975fd47df1a781b67a3ffd8f1e6e94682b582b0a82633cb16dddbf6452eee2eaf10618ffdc81ce3bc466644fbedf8315933ccc4ee6b0f87a217545e17e1cc5e036888f0276b17a57e3ce01040ca52cbae34acef2e66988bfb3c0e52c99bb8a305422c376ed1eb7caf2aa58fd66fe7dce9f868b638966c6f31e13e67c20e8c6d00db00c3fa688ada5b754ea220924ba5efbdf27c5d6f18faac56546a34b9911a5cf37941da46d1c01c7f6999b443e12555d10b316a7c723c6b3c32567f8ded225424ffb432af4f8c98e3494cb4de53e95351498021b932e91faae03f616a18dadebf3ff6a430583306cf15ea5e6720530432a4e9dccdc95384406a6bb39334dc0ffff5f20fd660836ab1c9753ee6500b08118c2ab9cf9b1c45e255cce747863811d53695d2c6eb113846a579f137af89e832b494414222dd4967cb20dfb2be19ded39dea5947c15f333c8827b2d1d0a30d81968be2cbe4fdd693750cd0a77dbb7afd3883d3eec1e5e51ff670c322a6557b98063805201c80953e177a7dba16be1f99dd440c82aa359340f663fae75890bc8451be6d88c54631795d0728b11013be7e6b0a0243fffca03343c9246618ce345965f5c1206f789e490c59f713c80d2dc98d6e7b2cbe01f77f1330bc3e6a4b4950426addf16d5298939be9b1012db98c81034ca6ece2821dd799941be50f72b11341aab18abe2c460cf4b4ced0a19ed6023405e4846893739b82a902fbe0db3aa8951ec665fd58d7761593857952f25937b207a1e61b016e1827cd2ff33592b536ee6c2af0187a578d7b2b4ef6f1ade9630ddb4c457d8dd4982e0b1de22eb46a79463c6db21e623d97448065879ce63ba8323c4bea80fa7d93e8334a7e67dbc41bbae3316dd941f5a859d713f19b96c91a502ece19bf3e4d62cbae6616835dcb6949b1775eab1a438931f34a8d6ee2e097af2485d6e7c6c28e3abc0a53388b6ee0caf627b7bfc8ad0071d801f1806b9382de5b53894fb1f87dc6e193ab30544ea85bd5ecc13d00dc9636c59b52300bd4909858d4e8201b23211c6c8f2464acbec54dea1b989e7540ee5e0aa8afd720696ee5c801729fb0ed0adcbb7ace58c677f9fbe68a9173eff9472769f658f8982f1cc4fac997765c5efde14c10e4ab0dafdde4e9bf591f27b72eba75fa20039564d96772d9f1ec345d2fa9f01422e102eead3a322ee9bd22a3d28f8d995ffee7ffc7f61c3f20f9d6cef42c9a7bb0c0af5a07d8f510fd4186daa1d6982e9ad0b500a95503ae26a7f37f8b488ea51efc29a7391b5d1cf17b6b005346205c210a80eee062e4c52179b1b1357fa10bab5ec4080470b2c7937a15d150134df105ae19120e48071beddb4de9fc7e66777998430b3e97162452b5cc53b35e6856716ddf1a1edd70ac952a0dca2ef115ed828b3b642c715f66016852384538ddefa0ba0057fe3cec56c8dd2b203ea2555a626772a2b9f20e06a82cdccbcaa57713614c2b5e46b64020d9f4b4b11efd6a2eb0949bc5d9b05ed37f0af08b70b8eb06bb2d0e5034e484940fe5e8c5cffb0790310d63bc1ae8b75f0a61600a5b95cc4fe25caa23539a5c9499868712ad826ed7b86b5836c7a8c7ee22ec8188e9a4928a5ae5dfa1118d62c7d7f0832a73a680c4fff1bc899c94734a86ab956a7a9da4ec2acb874b2366902af4a0c197a34b0e777431a0c3c606f5964db371b7949eccf8f45434369def99fe6723cd5e1e510e42b61a507aac9ffa5dab326ba237c36de297975b8c5ba93b405cfe80e3fc568f4fb465c25e84052a62434a0a636dac5c979573fae2219bfda1f83128e9fd49de9cdf1d201d5486962366577553c4e380aeed89c016fa8c2effd398aa8574dea9ae7343226b2c0a8259183671596438dda3c6b6730641410b4beb7c996c6d3313fb9b50c46246144fd9657a57a5a03d173eaec5051c5a6282550e616aa4318086f84e3dc676de7d297f00baece74d45fd1621b28e2bc9b4bc9e2489828b35bb11a92ba2d573a94dfc808fc2ed09dc1a3ed560d42fe4a829a62528eb4bd42f650039a735c1c525cecefc547943f5bf8c6fdf10b8a233c707a9e9837ff30fe4f6bdf6c9db79d201db4b3f5c8f7dfa823809d5fdeeff221f7296774d4a5016e0ba722c9449dafce55a82c42e5bac01c46705f1169d0518fc241f6536fac1ac53daefb118fcd1a0338b2f8794cdd9f3821fe3e323c734e55e3e27db0e97a36136140a35303712a4b62703018b6f5c06d597b30b72f9f6d13d0596c378dc237acf44c90059f4527d7ea79f95d5706f87a730a49eadc624d1c5df3feab40d80af74ac7de12fd692961af89fcd661d0b07e2ca2b00fb86aeaaa6762bbfb800d6b9a1d1f1d99acc19c4f03306c4ad4c98d802c7d0bd2efb8789f8f3c1b423c6521a27f9af2f78a0adb8b5937334574925131e343a481a043c21f157e92815d11269bdd3f92a8a81c71f5ec16838e928e5b3384bf8cef88cbcbaefb78086d1f740ce392532e49eb011f8094f81d5bace03aee08b10fd64fc5109f4ef7827ae187dcd87999538ed2f68423aadba7b1d0500d4614337f414eb2f9942855671dd2d67ea4b8803f81959dcba8ea385779c0523901a1003038e2e68cd3430e748bf7927428b942a68e36f20f5b2e521251ce2a1749d0b1cb511a3ac563437ab1717ba9bf92be04d946fea190046cdbe8b171f2ac787667eee5a29c0dbbae4f1f65307aa7024738f0b8e0c7a61aec5d66e62e6624db9a42e89501e35d66921f33eb7c90d8095b1d69308d0faa00526f35aa47cbc3eece027ea014b22e5fb18bbd3954ee664b89da6657e4021a9ac0d4d9fca5e6e580b29e20beb0c1ad651253f51cb213172713c4b8ec17196858b64880cf61e0f54c0c109d952112e179d91060fa114d7134af1d6edee2f8dd4af945db62e57e33c119806aa058dbb3c9ea860bd4286382390057e5df8f0b2e9e2e31dd2917bbed02297881e58a6d704845a136c3b2c8d631ce48f874341ee53cec551fdbeb205d53e832b96da75fbc639077c463b556d767b97b2a46209ca0d75a5055a5b418caa02207bee182d158d46131201da4e9b83353253f4412d3231fb802877909cdb534242a2d910921622adc6bdc3abe2588c625b90a6ab49c67b92732ffc1f47c971046652ba400512bbae20a05062961a3fe1cb7039a1d5a1b8cd2ab94aebf6db5224727e3bdaad18b2d167562bf31404fad0c59adf9797695df717729d91cb1c4fcf05d2f2f80211c22ed101dbadb900269c3ef2b38f4b356e00fe32c26398cf34884be2a993f3ba6ae4496f7174ca7ff9161097e65832b1e150ead40255f8a5e544892202524beebba7eb9b89fbae660b51f87b2860a4bdf01b6639672ec2d0490b3e04921dba64e0d3e365f1451ad61d386fa0c9b9583d9622a8d33d7f8a77c5da60c02368a96263e4d1f7bad564f54fd1210bcdcd1299f40743387dd652be54fbb998a469b7f1edeacc28cf56a0441b6843412ecc65d728c8472650a95d037544bbf2cefff7d62ab9cf7483343e61ac4a9ca6e2b391a64dffb3b9f2c3697282ffc9d5c9548d128cdec6ee75fc6e91399e7e9a311e9f8a37b683a8eb32eb96dd1fb751b116e8fa2e5b2f283793583609ae2e8a0aec83e55db43752d576f7632c9a90c24b81e7de55e2a504f4a009a403fa49e224da94b6a081ce0a5cce313621c6e6c3dc2f672c03bc55a66709f0c2746800a27bfcfb4c6ed288f7bb77b9367bbc983df35741ec0789ba18c9bf5c99e398d7f428fca85a585b52a765b89d7e7f9e3d77818befbc525c626c2ef0ceee0752db451f80a327c6c3b4877dd4a7ce5fd7398c3f8b56b5d68a8632f41e6b7927b4a6c58f8ccb87835f8622452c586839b7aa03fa91b845e955c5aaacda55666dbcd48b74ea2d837140e5b515700d0afc896618bde2a63e62ce6659b95df7aadaa0d6b69e78972b6fff5a9f80899c58a8c9cf2ea53774d226d3c43740c6f223ceb5d61186e902301a2b45e691a92a840c9e02879d1e46fbb30ce6b61dde5cf7045cca911a483e699bd90d65e6b500887cb89bd35ab605a48550da3af2b44a1adb0e538cd3c20dc40b992e2180b816aa85b98b5e5eea992301087ed2eb279f1c62449bb1be72cbdbe53fd907e5c5e2a34975725ab538dab271dad0f2059770b7085c60c8ddd628b8151a9d1a438227c33b99298dc845d899fd2047793b19781e5c3cc56b6ef3f9aec20a7df82c512dc2fcaae75929ad83ce185df4909bbce0f10470a865c63584bf9d8b2acd7040888031b2b8f61f83860da698ba200821da08b1b9abdd5f20690732d706bdefed142402e613314478200be3b5de961ee4bc9ca8fbca03af7f5a07b44989aeb0a30df4d85665a56bbded1fc1796fa44d5cb081a9faae6b6db8b7b7962b1450e36ae952fa5ce2ed56f0ac0565981181351f3554b8d89868b7dce0882f8da2ec8818c1dced7505e92b877aa3890cf91a596fe606554190dfb6efb7690a6032cd49d71ba428d8b2d1640d32bb9b70926e8ffce6a5ff4d977cfc364bf437c550409e797fb7db111b4fffb143132f93e20ff2aa2870b9de83287835d8f4758dfc9b23d945e4526a8710d8271884390360d0351d653df300138af34f23a636b8d71e3f3911c80390387df901013a454dfc7351b62b59efe442145cc8f8e7bb1ba597506e3e76000d0f1f69d6c38bf15ec0db22fdf229ba7e2c82aad5dc50dc63d4825cd4004c69109c64845b1f14319152518f98feaab32f829c4650555af954f3efc604df6322814be0975e9642bbaeab3b40a9854f5363da4cb6ae131211a80635987a16ef4a4ecef55db123c17f381c7f0256bf0ff19dc8ec8385a4a771c12dd91fc3c12424fa1c8ad662b7760178cdbb454b401ab72b5be7b9ee45fc674812180a036397ccfa91da65f1f1f053325739f906cc14c81b709001f84c0beb4b241734dfd23496182f7e5ace96d75bcbdfb4ca83a05007e5865878a06524589c3f38d847e31f236f2d07e223ccda136eab97133efaf31cd96acef94c5078962684ec19670d12a34907143a0b35ce35d47aa849d5c0b2404788d1322f865976cd699c7d2853fd80a87e407d341b8aea52c40fd1ef7e7d67453305e3db67f9dea3b45d0205ca85507d509e26f6284603e5429cb53aafef7e22826750a0881231f60d2ffcca56572b73b96f51da4b6a79e87588c8008bf974c6197222a5759d581c2258bb7ed61f6a2d850d8c9fdb61bbc7b45b35a19eca5a2c79dbd1a2d7a8f9a697b559d3afaa15b6909d89214847266a7001131b9856732463cbf159a5920c42876826ab42a35527bb9e78cb46ead91c87ca95d7838c2d5c79e66f3fa981038540fd144f45ed4c33fd1541df2eb38586ebfb9cbed5f40755e459bf43f6fd791d15deee7fcfd206dcb4343cbf909853cfe0a1c1bd42cc338da13209016bd1881721027ccd0848e0f4d87c67ad55c506de286da1cc5c97100041f41a6633cee7b4d789a7377c83130df3fc741dc765abe1e91bc85ebc9f694ad015a6fb4afa94284f6afb5365a3350087450a55d7830f4ea52ef5cd794c237df193fe80bb6383b34961f795c279bf25b848086c224782d4c39a2c46dc0b7a9a283fd268edadc9914dcbfabf08e31949a5d5e1914339e4b030fc9d48449a0fbbc081c77fb3ab059ad99e5abf008e890f33a62dad61f425107f2fa6bb7c308237ec26507c62c441d91c6cd35183c4ed11e304beae89c78d111a5ddb58467a13de06e561fca36a7cb38135be9ccb41ec7e49435392462656ed41113cd4a0ae83a3df38c4d5c43a83880ad3280f3fcc800486ddbd9c073b4db8f503bdf98c3bf0938f781b79342b3ad2c4b2fb4dd71e2fb8735276312db4f9a74a0784693c60f215459eb4d06e0757b4ea6f0c7b7cafe968eab117d5b55e8f9f915fabbe75169d4f62ee5761834c24184397331a21718565547323ea1002f10926213f0bdf75066a61284edcb7d29418e36a63a08dccb60448e6f371294903851acbfb61616e4099c7e46b3bda986583774ea66af906f4aac2deec9eab46f3428715ff95b4819120588ebbe25461d3de78537656f9fd8d29901f7c87b26b727aff9e17a739558cf1278b3fd959659d2f387be6a0f6a6e528226ae9c1744dd1ea63650036a1e80d49d200f45d24d69a95f009ba43facb9382afa86ec06f9d40aecaf255d6046f0dbf07e7c484d325086fa3621a3ada0e25b29c81c20a5d601fa02ddf34041f54159857c44f51ade29e2ba7e3a48f17fc6098ada056c6945e2ee7961af3569aa14160501e96629b4d0a40eb9d229b52a9840860250a1ae807eb80dcc719d67cd23d1b15b2ed2240a1e46fb65255a1ed7d9f2296b64106f6cc95ead3848d8a92f2641bd77e9a10917a5cb627a2fb2af9b975f7217448bd6b17f175820ed39c7e53585146a73c838df9e687b0bf4209d82e3834128173430f2aecd0e0f213d41a54a9ad91f7bf0c9e4a48969d8565232ee0ca38a44ace71ab4a3a5a3860ec86d893fe2e879eeed06a2cbae6493492de78b96966ec67f93320059c8515626ad2c4d3d116f022efa0e0d2dec491f969c125ff9f4c1df72b9e4b173f4319546a3f36277945e455b53bdf9129bfaf1a7c0ab17c9fb52cb1096668e794a186996f88a7e7107b6976defa18548d8a0e1bb988a2796418faf2e92200563b396f652c6ace5ba8424d24c638ea93c1f7799ca766540e240b8a1a46f50ee535d3d748e733a8a083bc97540b9241d03f0a83fb08a5a4ead145d162375a5239326307844c8e57a961c5c2108a3e6fd52818561f4f63f1fb363b8fde4fd8693be8cb2ef1b6f2445b96edd12aec9f4c55e260ccaf4a00a3594425f65882b50ade8ea18fd2b9b667ed4939dcdbd4677e2bf17a1d6ad6e41d0e1b19f3c3c195342bfccef006a632ce914d7ec5f3e6b8d42e9f0eac815642f090c7311fe86b0e4eacb861cecdab479104bbf73c56dc9555fe3e2d5caac6c87b62725e2585f947414d20cf006e9c734e8ca6ac7c648984e163f6a5a4c329732bbf97bca16723bd611cf3491650704bac14c0988e78ad9671673c2b8bc6933d31ca392afabe784d3a23192946a591b586e3a14b8558f49fa5ec39ee70a949229f7c5eb5ee332c917a02790889dc9a917dfdbb8b399e0514332f872a636427391c5ddb59ed7eb83b38004ea73501ba191030933170fb2569dd89f53b79a4f50360f7fc7071b0d0da2f68384765c195fce00f93ea562e4149285a1fe260da78d89e9f70f27f0eca8fc03c9f5ee76d95f7a878b07db8168f71901c70fe896edf87d01dd794faab5ff3f88cc3055cb42e9a56c6ca21c2dbaa267e252be6cb3869ca23f40f95bf50ed6bad1838e5c7da093b0c4117664eb921eb9e963fabdee9d9c3a773c8320a31d504fd83f9a03d5b7607597afc439fe221d0961075840815a7e782ee6ada69b7c187e6e21456cba8f2dba3a8ef88d1d8eaa6e0ab35de9e19bd858d8439671f4385b5fb723e23673e774b5531f403844a41c43eb53fd79a5a66049ba95b9fbf652bf89e09a24354b73b74ae18ae9fa45fe30ec70f5abee56a62a08e7663639b5a3bb7215534c7f46b9dd11d3fd065009cbf9d00d98cc5dbe2b7ee42ec25a0ea3dafa9ed2610195c19a23e27aee6c0cebdaa5d38722456354b0347f951db3a85f6e9bb611030eb8b4acb3a7707bf90add44ae5bcaaff17c799b086c49721a6602d9fe85a0c7b513c8cb2d413bf02d76943b7b93c3fc81b43b0e78ec6bdff0977e8b40b87fa11e00d525a42fc4362d4341c7e440a175ca29611f54ed11c46c71a6070534cddedeacaa811ea50a13cd7c11f765ddd8defb60ae4fda78ba160924804b8e2550defd6a135f4c81b2182977acec803047f5b11917a96da6c8fde257ecca9e97964e2c6d812e810878700e3aa9573e0e5e1f6abb9608ab8b36cf41e4f05e7f8400631b2c0b33f5e99cffcfe90ea6f14fcaf229a79d966c470eb144ae81036e59cb97478c6ceb2cc7de09b775d7613345d9c38f6f457b401155f78ce6c2135672b01f2a66f2526070edb5ac569479ad67d9526dfaf5de92706935ad85a946b02fa4d0c0aea3de51dc814b04019b05331ce3206f48990e1b3fb28c6de47b29c7c374b1fcb44c93720add9c005b062793954617d389e044e2488c559d86a29a8f1eb941ca3e2bf1baa0a38a5233eaa020e2c3aa2e31118c635faef86665324e74dffa7340da2576a60fc549c960968023d771eee098b7e22eee12f45315889e0892936b5d19bb69321f95f0ebb3291ba8fadd10427674492427c271769c7f0d7a2befa263b0f7cf925d47771f6aa1d264a1e9cbe854f134b9e676e94f89b2e893e7d0236e3758224448353fdb4d83c68c0656737aa9b0b4b6a6113772e4b0ca9d53482d70c5a2a375058095a1704e7d19d378f519c37ef353f6b7fe0ac03da45c5fb0a2c1fc2f875b15d0f9e32b754fafcd6219b294c0199330122effc295fde1aa89bb1c45c3b2ade0f9dc2607650071f3cfc6196517232f4351bcf216afac98ec270f6652aa1d915aabbe5eac68b2afb8b9ecff089e42a0ce3625509e37f2c9aa46f307f83e79264e5eb01dbf438ff623ed6af3621684e466ea9206d5a76cc48de6905db75af106bafc7d2680ee5fe6c47153c85b5e5de358c3cbb4c7aad669f0d447046143ce41f8d8ea96337cff13392222f9958013c6fd6db8816e0d500acafc8d9f2ec8d843d3b95f0f05364c39bca51aed63e4561e87c4693cb91d5609dc007dde6686a3746da07db05a43a5799400b064c2595955324069a9025ed06efcd7a0d273036f76a867e9d600c52f932fce635f8bb296e4ac4f6100392ef5ade73ea4b9efa06b7d5f147367d9ac981b69539a880b4890d1f6d933b6568bdc87ae18630e68c11b558faeb063618f7a2c22229577a3f4b788ea607f5d2c3c2a19df745f78fa23b12f408370094356e3964162f0262a39746ada54d938843576a827d698b9034d55a9065cbed2fc6cdc54fb8b6e920b7c59d94a7b64114ee885bb32203bcad47290cff6e8d73beee966238969b9e72b985d69f858b8af0232ef7ad249cba4eb6c7205a116b8193fc0a3b9bb44668114dd5e13b698b4036b40ed2aeb4ffff21cf412287fd6e434300e7f3688b3da3f64228d6bf4b2faa1998e50ce8930ea994e2b313ef1f38f19b3a4d46d01541d882f49de955a3ce90aabde3252d2a3ec22a4701cda69fe00f2ffebd46be0bfd50b6d0d09031091abacda109821b8a3b2755bb48c79293ec7cbfab64f6526dc2483d7fbf05b7518f7227c6b0870fd6a3e2038e0b625dd62622d6f95260a651c22a140171938c4cb373ba5db5706b2910544c467f1b4e48e8ed1085dd7c4a3615a1069d925e253d265fad780a35a41b6006b37a3e4b8004efec5b2259f40de1449514419f54e0019b0c77f8186d1a801d315f18a5f1062dda43dff800872d751c8940caffc12161883fbfac6418dd05457aca10b595a4a390c8ac145d52d38b13bc92276f324cb634656a5d713966c49cbba84f4cf86daeffd0ccccfecac6c332eca20fc0bf62c4a362d7c5343ead184bc727bfc5ffb6fc41c91749e9bc4cd39e51183c129d6ff5107edd2ba25ecd98d02b897fd1168b6decc32b19d58998e07b86bccec7b1b4a040caa9de2b3551399824fbd8e6731a6322441022f1d2d58c373f3b3c008cf34b1b192632f6093d23592da8f652833024de884012bad9547d7ef94df4b8ea6877b0a0cb619cafe44130929a409649d7b72af5827b0bc16dd49f5a99c2eeb8aa46567a0c5c3eeabb8e3e7eeb1001b71915e8d704461f4d51daa1154b5e20dfe40718daeb2f02a7dd334b9f7e75ee9096a91c028c4f96b68816b8dadab3a1f18b5f1f87a003abc1343c68343d081a5b6ee488c0c99b76d002fc7a32c72b21e62fa58db8b2d4b75ccadece5faa3a8ab1cc1797a1dea155e6bf76943776248da80206a104eb992a67b1f49556d97cd41ae6d0cb11f0a1342725d0ef4d7b135e6b5161c9ffe3684770d6d361cd37da108bc51f94f9aa6dd565a4c96f9547daac0cfd6c64c39db7e841642163436dbd77a806936b5c1b1b016f1eb8d18acaad124ae7adba5e1f8565dbecade321390be6b56f523cf5569f8749868728d6b9d2dd446906d1e3089f03cebb311ebaf7bca2a8523e69de6df858554fcc6bb2bb49c7da7d94dbd293dfff2abf0b4ddcc75c613d45e98329777659738e984f531fd0daab95e70266003d82a2915637fa68a839f8d554a4b0386c463544f31058f7a46b000b891f93247c1e145164b6d76516c5ad83fd91349044b3a06ca53f3c6adeda1631569f61180e49d3c3554dc7f73aaa3a857fd38e6809bce41542c7ea105a01f12c8b8bdc9b6db83a6c615ce66b411c392c3e4ba7e64e75f9d34ef9a52dac3b8f51981027dcbf4cadee4004f22336a31b43bcb69edae4775b8f9d73bc4116079990f97cfb846d87ada327cdbc22070e1a117921ead975c3df1387d5c4fb1e57ee1b8171f9a55bc42945a59a9b6dab1ad9bbdbb3cc922c93883d03ca90b4eee277edd4e15e7b7a83e3ee16b847b805d7af503a169ca978e7f4bf40fcdcd6c7538fbf0964b4a9fb60e803e437a6082c60e7690da87f3c8f86d4e8109dcc0578a64f664b3f624aaef20dd3efe6b7cc7ee8c501089e584841ac92b7be6d286fa7521a3e673819f04ea95c054eae96a9ffec4c57f957d82a372b2f760b4fbd97a19278585299e251086867def01c405363189d3020d156686281e91638e897b6f9e98bb83a75b2b1d886204c70ea12ee9dbba6ba3bcc366cbbb199d4fe2b995da6462ef0b5d91ce8a02b854a62f4518aa65c330834d55855893fa05ec9a00cb6436ca5870e737e6e7972e8cebb8e4321e8688067406fd1094aebc4865f1c0b5bbb8c25b1c00d3971c8f9c3b037c24d404bc4dd2638cd04b82687e72ba37459045210a541aac034939e819318eea7c92737d9c6db55c96d0e6020036de162e5836ac8b16768da9891971f81121cf5b9870636ef0163787d6dbdc760970fb9f0ce457418375f614934888f67a7a6fc2fe8a08a632e8ff6ded36fada2950cc1f12617564123378d9a02409f7b9e9181a59229ea4d979433c6eed519450c51aac8c003d3918cd596ba2440d4334eefaf48670889f0c93e59e6683f0046fe9244eb0d81f0bde76cb7d97fedfe67cbd89505f3aecf74b340898e6aaff26bbc07b7f700e0b928fee17fd42204d4e4632fd510ac4feb68766481861c93274a4ad88d7af50e0e1bea8021182535f0324db63d46ccbb2aa55f9f8403d6e020f2984754acbf9b75a7db85d8ae6d9a0123e2818490a8ec8eea0f5ab680d84e15c6cef7cd6c1e21f5155c8d7e7cc8a1e33a9a860f0e0d771bb843ffe11e9680396a93cca0b5335879b7998cc4af0a90f10f7051df622e55406bc82e4200768c8999ff2294aead6fc14d09e96537ad3f66a2db41ddb28016c8b0242c5926581f644a31691d5b72658c22b15923d7ed1cd07094f7345dd150e49799ba84e2970f1ad422d6dfafd8c7f3ef914f727166d75c73637a2eba5d1370819b891e130e4e49c94ca2cca1e90ca0625f8ab70fc19bac0a9ec54746ceead2c5789388c7c3b2a7ed51d29122d97d22429a6c83bd054a15d14dc16a9a6b0acc316d76337fcc9bb0060bae10d5d48e79ebae7e12ff5db694c806ac971359b88835996f5408ddaef339efa951e05165695f87e5e0175980e1f11f1313fcf3b624cadbd3ac7e6af9575afb34a2a21d254694fbca75b22a3c9c115d82cc428aba0eb9d350263c0ea33d0334b149187e9d5eb11d431edcee3d511271471698e8c93a92c083dae635d7b974ffedb4463f09a62039c4f8dd2f04fbc6d340518f046429d56fc25e44013e676c4295db4964747ffd93abf114b7138984aac93129e7efd1e2a92d3e406540060f7aca866fe698fe72ce567cf9dfd809df119319170ec37970813e56056693e7f210d1f3eba50f7318b51305f000b78cb2f713f1c07425222b0b5b39694d0429ed6ec6d4b10af47c48eadd0a5bb723895b3090d075e6301677baf0da13f6f5ff8fd6fce2b218079d5bb88f205c22c52d3d21b5a3773c2a67173431409636cb0999da5a8a4be4c6086efc8e1782a5453cf28989d9a8cbb3ce18f48df07ec2556b0b3096d6dcade05d906ffaac25617d2c4e547640efdee2a64453eb86e921acd5ba910136cb5aecccf0a2a12b94bdd0215e0fda5e977e6feda63b96163482b28f52c128feee56b797680230919622bfe02382f133a93d51ccb311961e64b3134f3342552689173942597ae649b4d93db0974ef9cddca53e0002c60ed170bfb538aa8464590bd316934e0bda2de27ee81e5c7ca8e2d7aab9ee061d800920699b5050cb5452786ce5846fb98db56938fc27fcf4552cdad41bead21d33d49030909ef3eef50d23f5f2766daa716c734898670717654aa2e669ff99945837c173e873bd749ab005cb0987d5e091deaad14f728acdfc43568cb0371f4613b3c0f288b6534702f986aa15498f1d57266f92ad03e4d77bdca51fc0e5f023ed840f79d11d870bb5e5b9007ef1fcfdf972a54b4908dc36a62057baff92c78519cdf5ae82de8a951b342340d2fb1ab817b0c53ba9eaba9a8fc55ceb6908261c4bf1639948f7b32b689f35d8404509aed26df0709279952c471025bd2ef8a3c19881e077b0eb83527006793bff5504915d0f1f8b1e8bb0d05fbfac9fd06a82fdb8da3ff5c1f1721f1ed9585f5607b30315cafade09c1492d267a8dee99ffebab717f3732c56991c447f127c19dc7284fa6beb884f4d1f20d5d7df292da9c0a47e501e77fb74dede88cb20f6f60efb1105055ab0502003d13ffd69b7b6c0ccf31d5ea7eb118e047c377a12c7fb06adb0d39387c81edb7964f05d7fbaf831c2e51482a71a26f68355da421c9fcce2d82a67b6bc1377404ce88065e9f179b96824c38e21f03cffc43a97e484977a5d7fb699b4195f1e6ec7ea49d8fce4bdab4066d41bd1c2d6591c7643739756fe7f376770ecf58ac3d7b4843f8c573a4c7778a979b8054d7284c6db3d42a30a5559414c421ebc8a48ccf6d8182ff3150349a032fd4f901cec58cad4663a42bf50a308f83910d00f74006ab86e36049439a21aace63d008329f1e3ba7386701c40a866e3e9f09c5d7c2d35c0809a9b8f5952f72494076a4d1dc09417ff6bd5c0da3f42083ce570377673877665c34e69c162aac8a3130a0c85d25f70b2ffe5fc815c1ea1f293a964e1dec7697aab5717a858c063ca20a4c270983f9c2314655ab0016a09ab84b5aef2276820683d54b1573a0a34846baa2b3eeb0cc9ac89eba84a34985cd9fd9b9b51b7716969e821686e320abed2370193ac826073f0ba170b01e4ddc46daaab08c62c20cebc78bf1219c1f013052eb1dc0de34890434ff63924df949c29447ed04b125bf9f1758ccea35b5a1b98a12eaa2e4a48759dae427bb2d530178e505dc4cd359eabd6755485457d678af374fee60530bb21d8338fb25e088bd161809e5b0c2ae8c93520f6bf0e0395b30f36c3027d0c8505f2c0bb10688e78cbc9466bbaa481afe2febba579d483c09b5933e22bb988b9e4b444eb94a33920ece5902be2f14a23425c2af17406b0533b84c9cb4185bd32f1eb06fb31d126e5ec467e7353fbecd729c9879019f778644cc0bbc8ddfa294b326e8d6a7e20efd9b598dfaaa56ec4d53bdd9e88c988135f754619bc172419d9de0acc2c0faad8bec644d493856f5db1a52c32a728a3317f62d9d061b40a3ac071ea0","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
