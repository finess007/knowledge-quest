<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db0b3a5c9d29de0910d85736e1fd4a9f8f5f0a6c5b210c3a66cbd8ccfab7b8529de63b261e0170d5ebe6a4e529f45b0b61ef1cc98b24260da54f06d32248e29a7f23c37df1943a9ddbdcf332d8766470832244db756001bf9d36a782b33daa2b9d44e65366c10db59fe98e80eb5c387a88e0d45b15044c08fc77b20d3052299db5c16386ef4ed0a958118926806b20d5a13312a8c85014eaba977ff1e0823437680ba39cc5cf21070d0992fd43eb686f03650fe0dd3f120a339718a7147bf03a203444e4973510b8279b53a12482a4025e03fe1e9d2b40631f990004866c4ba3cb6c2b0849f8ab6b828bc0b3a67070a434c3926e853a8fad2213ff0c4fb7b1f746c8929d36f51b6a4fbd961e415924fc13e30e24983fb04d3ea4806ee37e90329dc0ba2140d58959c5329b1f720c20dadfe782964f275260e7a4442d1834b8ab44157b144884df75195af322a8bfb4eba686b40ac2691e11249cebd31f6291bdbd6decb9790e95aa523511ff674273b232255c61f60252a1691375922cb5e8da7d043d68193446ed8e6c627d77751559db22e8bfc7c13f5a9089fb8ceda0bcf9c4a304c826bd5c8ad556cf2a45d68569bb8638fd08fc495be1a7f4f834f2f11d6e8e16166167584d6fa45663dfe5ef1d3a2519ef0bdea229146ba70534950ebfdf5bed324d394f3a4cc0814cb2647bcec88d16dc0a812d0c6a9c832d8ab09bbdb75503dba482d19d1b92f28acef6ab8c6444c60e2483e68150b74442b0a385bdc2332cbb5f3e9fd3756c74d137258ecc2ed4bb0b9b1579680174a3557a2fe44c5086f2a1136141d0a2d5ded8447bfcb003a58be469dadaf4a516621087d04812b585d0279925bfda83485ad76159c7083957ddd06b435551bece50ba65f753b6ced0d4eb018cdcf51efd8fec87636cf115a0059fda66870682da63749ed2f2edac49eea4ab10c313a4121fbd94e020a58293a54adb7cb9e72518f5bd01848b6437ac182f006ce6fdf7f751bdb67143e91d2f45cdcd25ed9f7f1a3ecb4ad1e7c4dadfaa01f19a62f3f9c9d967475d6210d40ebb00a4b73ec90af94a8aed0edc38f5e046eaea167b2be794abee2b696d1f9971e6c8b455175a2acb5f3e0cece66e1d438d3ab53137b25737008dbac194d3b6a3107a4bfa523f338584f9d89ba635f669f4fafd23fd1145885274daab8db912342b9ea4841ec94f3c8c5390bbb9e996dc0fc46b7514061093aafbf6570364fe467e8985e9f14cf08a42f8612e304abcf51d7b92c8c23c7b335f71ea68d2d518e7d1f6eb3d47e19724a6c70275713585eebe46738ea37acc18857399ee5fd1cc62add7e6db2f456d30c84af0b767182db4734f33d406c36213dede1ec4932a8c7afdd5cf66e0e6ab44698d891847615892a08476ee25fefcca83a1abfc5051169ec3ba973cf793239c58cbd94cde775842ebbc660cd8485e57b7ec6a4150c709b8659f4fdfd9d3ebcaa58e3dbeb397603a62ebae773f6c0428f36fa86b0620853f6b38f0b621c35f075bcd42d96410b7e36290ef82dbded263a8f023458aedac9fb5fb987decea396e629e2e8ab8959460796c94be32743bc16fb43a8881fec0aa2933c39f717e92c29bd0b4bf611499fbeaf37a2867041c9a61147b7c3c72b3c2db37679f7a579779071b20ad47ba6a4be39f01311c9adf0d12dd4cf5482b77d8ada4fc3ade75d0096440d8c0cc54593d8dbe78ca7ed33253edcddcbcb04a7fe273fc3e6787bc8a5ee8402c8dce1129057b2398442199455a2bf1cdea74d71d77ec9be73ca3d5a56836054a6a1ab2509be9e47f335cfc7191a404e494ae37e1ed4beca31f1c092aafcf81addb8c0124fa57dc960bb388355a368a7d8ece6de94a9ffe4ab2b673d48c0fc9425917fc63761c241e131ccdb64b6741280553ec4c14ab0ff94a8f9f507bcc0f62a5c3e7c2e81c31d0b5f06d5de927b303fe1f57f52e5e5c5b14e76e24e1e25b9e3327925a6f6ad721cad11f16b99504bcaaeb789d3fffcef12c66f16d7709ee29f0a02ec11c200b82d83f55fb9ab364ca3a976981b1a47e4b0eb731cbbc563f3142e78e8e805789fd23e8f0b0bbd3f4554f827865e0ef08860ac873e5e35fb0c8e4380ce8dd3e8eb42c1ba7bc9c2b08d1855596c77c0465fa8296b9a88c01428992e9e9fa325442a777dc1e16bc45408517c72be330351f8d4e7e76c050b3fa6cc3380f7a5ed06301bf992aee7fe1e946e7fa9b7f031124ebea4d8cf4960a1cc6a6e3116ab8b795b8fcaeff6c8ab1b1dad64f7ee56cba5b3add1ebf033396a460ee4b0fe08825962e4840c50747f45114127d79006364d9c0a7669d25b9c0e9fbaa84a1e398f147de2d8283bb47c95fb194d370a7acb96083fcb7600838a46c7eaac51240e0901215bf1b91b698852106f4789df1b84539cab783730a77969f6def7552242d351236245c04beb0fe3260098738984e8cff7730fd3275e9d5e665e02addeebe2a4f8e409142728c2fbf1ac201d3727b4f605a902d81607dbf68495569f8345ea3d995e27afc73f91d159c05d43b3d78cd4dd943f4490e96bb48812395a09c90f0d5f1ff8cbb85676bb87d171bdd06b03bc78c36631a85ae75fb28ebbbd2eb79ea717de2a3a3d19e0ff1835aed21a8cf7d230764ba2c82978e934ed90c9bac1633f139b0e0a72810bc3125b48cf6ea687c0f4ce4dfbab7330014d58ac4141f980db9fe9d8882a82fe9e1cc5ef133151cc5c8108a80c8a119162c3ff30c4508a6e808023c47826dea0331f81ecfa737695857f088488974473a5219a2e09e9f91c693b39325225629afce678b25f9cacf6e3b200e4925128091ecaf8d48af539201ff2dbe027b57447ec00841316e04aa75206f91a72f089cc6100430cfa45962563a6fdfdf6b147fc88dcd54d8f06d8fd79362c944d3524db05b91752cff0b21a0dd259d2ad0e668d3f68301d45a16b68e7c9aa0f739643f4f2ddd0c3604307e6797f408ac72c114e59b918ae72d33835a27191aeff08560916b5a69ab4d50c7787a9ac5af198f337bf7aa2e54a88d3789a35d2a4b0de49904e0ae8c6c4d4b34757716b17d6016b7bcf7ee0721d818209dc479986ff50ab85fcefad987e98a537d6b9e36c86d9231e4ae89712878462cc57c823ceb152955168d1ec5247903c3e4a3ac7b4a80ab2f54071b504399db823fd4aa82944482c0ce4f490b68c5136e3a0110dbaac707b616b4857f44bd489071662d60b07eb7f90886ade7614dbb4b06adec6ea87af78d45e751d855df874b142ceca270fd347f41bb717def203c359dfa9a220b8a20bd6b19ab9ffa02246358a5dfec750bc5944446dfe2392137b83ec0831ef8d33f32ed4773b5f74a0c3d2713801ae2bc33091729b130ab5b4dbf04809c17775e26ac561323bab7de8315b95b89f57c0863c51099e2a4bf3462e74e2df5a19966a30580e1d35542dc739e1cab3e133ee35788b4d0821378020a4855072d7a9920bc3089e95c0a1a5eedbcb9cfb36375618fc297ab2f001a781b7d70a32a9ece10a3feff9a2fb505b94fd131416a240a8f819f86ee5365d785617da85dfb0ebbb5001159a08ae6ae02fcd2cfa7c9bc5ebea60e0c7e2c36ed7acc23361bdeb09a4ce42c273520d3a11a9f57902877b46e22fc6bb56f0a4b5123148bda11684b35cc6fe58c93446a73f8e2405839bdd134c600996493e8f5c7a195d9fb3c9ca7af119d77a92cfbad18284ae7a16511874ad12d5d9eea8a2e03c06318ce195d8aaaf2478a19c00c561231b2fccfb1de1dcc0fb29906e966ba2f64e86bfbca1d9c0c37648a04459d4a31d33c5dd384d0640ecde6471d3d8aedaa8c6284c9df188f942f44a4c62a3e069a55133ab3bc4d3b0ed22b084dedf5d1b991084a2814091c35a31f5a249d24f431f59ec6458879e867f03966389a4fe2c929ae5da2aba91d1eb2932229a2f149215164a79fab94c054a083f17c485dcccf44482ea4569ad2c3d39f95b268e0c08a5ca9fe0f24c2ca177c1d398a60ba96d2d82ed0bccdce23edab1215fe0531a1e869ee115f0788b0d9a8af5b162c10f8d3e9eab246270e1788544bbb88861efa23739bd679cd992caff5b6fb0b7ad1ce57a8d6e08a054e62e1fe30acc6cdb0bd64ef328516d54ac5a9182fff1c44005089af872595d1e316f1a86b0845844668bf249c9baf38d75f93f5e5b5504b4aff7052bc94171c9bcb02ecf675ccff2044937f840192edff7722da4f24ddc15b49f3c49db74788d0b06c51bfad69088a901da76edbb1c2eb786d829252bfbb2c046fdb978c5752c81610e367e80345f03ac0b6888e0b64a0885f670aef7238762ae148bf1580f00cf1ae4f393e834167e8779a551159f4e87c3e589f08838be1b307fb4d2019249c5af209c9a0c33b4c485b740d6f50f43fc0b14169e489af92a639c12bd406756297d3168a52e8465a1cb42c25152f4b37a4052cc70202cb581277445cc7f5e48ece312a05cef0364446506d5201488015831dbe3d7c1485fded67e663184c04364d2049d9b7208293744f69b0504afa6fa89bb6d886827a4c21f02a6e349b6c2c983375e23662d9f9ff6c8baf60ecd12fc8b57e0b5f405f0a807f4d2472116d157999da42b3c877a25de8b56f7af4c6056bd6dfa7d8dc1f5889b508adfbc16fbe0c06a319f7f1e1c093f8d6b937907ed960d7a4d58b93562ee86b12f2fd02fa6efdc50eae9aad18ec9d06d00d1e0dc199699f49fd2fd8f09ae971fe46c7e5987a2a46ee49621c0bbbc9783119d0fd999b8660d87727c1dac452d6a59226d2953086f03d062d015ec52b1b8658508f66b4aacaa1d7503fc8efcf32274455e7c2f844da413ebb3579759439e8b4880854782bbf1fe46666b84693c5bfa694a8f7f1c436cff0b8776665e96dfa00b97ed6cf2876d801c349659bf7b71f4d28e79937bccd5c4b941e19bec70a1e104d45b13654a320e68b5676a0cbf7bf428844037fd608baaa7f1b5330288654b1b4cbae2dd457278d6daac28ac40bca8dbcf689df42c3df01c7c155e2effae6cde5b3ee13c027b70e24140cd1a7b4ff7ba6e5b9ac0733d6a25908b51ff65a9cae791e9facee35c2991ee9ee22d684d40bfbd2d8fdd6a45485f6330dc1ce978858ce1166be4f3aa4f69700ad1d0a7da982c2447dd91e030628d4012ad49bb9c051bacb4d372a8ecc2cfd4aae0ba26fb319384e185670d8fee6c3bb4b0ef3fd838230f0271da39995ccd83199d1c8c5e9812b6b06880195e5835e4e130483acccf767b295c6fd167fbd2a03c2615b9ccd345fbe0d37f372ed977a07e590b974d1d7d13a421413d03b38fd68e0cdf7c2962c94e773eac22ceb33ba4e241f29b36616b783643b54998b99d7c5be7b073e85ec94923e274f21477bb700b4e2d65ca04eb3b7253ea7a660868327f00e46f694ae75548fcd11d8309b290e472889e14f318fdc765beb17f6f601e3348d8e4233ddad9b20358c8d2a37acee076dc4dff40cf9f15b1dad90c99fffb546d8e338b7e42595f0adb7fa4f95ea87656af2d26f17942361339f21695a26e50fae05ede7016108435b490bae376bf2343f7b0e55104844ae7bd3de19c3032a8aee1a3d04ed67c7b68d09d4ae3fd4847159ebdd66b3cd17143d336cbf859b6b3d21e227bec4ff44f0a7e33170405ee3bdb4c0c60a808acaf29c4890d94aee733b550c51b82f65b30ffe93c4093732f3621abaea96ffc0a20f92eec03525d13232c6141b44947ff9d54da06b8586f9b3cbdd51ba0eef5cf3ed27f97b5c8c6b301d7a0fcb94c4cf3ccd9a1a3a83eb78b044a24ead6d54218678d96e78bf36b8b825e471f15c8c50cdc20d3500417b4584178560f8d0ade74d4959fbf707a538861c4e0de71b25156f4f0abfcf5dc7f1ec8f17164c32869d6d1e66595be9d35186bcd3ccaeab3d3f0961233c6d6354b83f25115f03f9a37ef359d48628834020091c642bcc5c862f3c6023affcc669389ce44ddefbfcdb087fcd5541930a78ce595ea53e1ceedbd61e272433da44da76c7128e342a5f03bd98f22d39c749c540f2cae610ed804ef737867ba49e054cb9e67861fb735d27ca0eea15997fb5df05b2208ddc905e7a086a44fa5ea3fb41603ddc0a1a86ec1408ef338e6d592c78dac1d907dffa493c7154f6b04f9b072d85a1cd17d04fb2b36d6fd5e29dd677338164f411a9e6abcd3ea4d3be618d37a2e92c5589b2c2a170067ca14833847dd3934066068e2c2adefc4a313d659a18496f93ebdd8c9b9b9d071354055f7b2060c8332eca095200026e8d853969411ad8de5c47c23776b1498ae53af2c017b35fd6c3017b3dca0714cd39bbcaf46fa4cc7ec96147e7348bc1300a10aad8e7041c3d3014b671fc9c7d92ef25d3b2c39eddbc7a9a3db740a0ed62607f3ae7174e98ee934f6eaaff2e3374d10f0bee3e3c84edcec22178329fe6ce3f3537105e842b5f9f4622408819f60017c4ba950a65463a591effd191a6fea8b9514cf8a285dacea9660adb7d37b2a3be9854c1afc2457b7bc4b6f92adc835b95372dabfefaee0e6a77da2ed3d2196091b15786a86f978fd5c72ef2eb2be4b0a770c20fc55b18a376e76916f466fb7f8982a0b8658c9f9e93c27d3aa1393ad2c4d42d19326dc4d38da2c0404fd9b693fd7114bbf4920f0124399019b3c429040c64e425627d61fed2f0e12a73536e13b4528683f7ed99250a4095a0c5aad4f77442ad325577a46b0e94097ea711bfe0c588df366ab0b8f875abc3e75027b2c0e731fbe14ec6f80e1c20bfbb35f08af325c0dd8387c711e270a09deaa866574b14ee5a1ebf1ac9f4b58ecc96c656cdd19ade9481ceaa0b9a9ff348924abf6be3a171f3df3b1a40d1e583d1b8a9afb674a3897b185ddd4891d350ba596bbc851775178f7d9ad4a14f89dc0e24444ffe5998ec26af57b2906665387145736201f3050cd876049c27e3b31c8d06556f03fea8370e0c41259407c347460f17113fb3fd2b1ff0421e93a781f4403ec118af14a6ed880302012650bdb2c0aa94f992991e35eacf7f4e9a2ed90ef3bec08456879fc7b69c4cc9f10089a35cdd1d1147e1888fc91bd332259d9206866cee54a64b87880d924dea6b0507b3dfe9c4fe187caf502c034f34b72a166ce836aa937b6a02c22c647b83d7684c220499d98d69cc82702bb719223022eb993adb714d086943d4a0ce953b103abed869572a1e2b688aebcfc928424833acf8ad445ac534fad1178eb1d6af3ec0479fa672953e27a890c69998443eee71b9a5c4ce717e17ea1c74a6d293e52d0b015db9a9b2b2954c25df1b5090bb1d337ba3765f40b6e15baa369ec0722e32203597a8b1e7cb4070570b7d730b9af111b15f22d3f4e01198dd95b69e3700373db5aa8f92c60aabc46fb30f603cffb23a8834b76dcb585de47ca0c3da144fc249dae4d7da524f9d259eb85b39101d2427406d94fa8a9b28cf311f7c2b1ece475b995ce83ac217eae2405238097b7d925bfe0030fa4ee494645a29aa16f61943557a137516a3c22a0a513096dacf6e6af036396128dbd53d1983b96734cffebdc6a60d6de088649afb15653ebad0fba2f10e00d1145844c36956e122fc65459dd200a5ea6316e8250f61fc27c44d97b7d9848b3eec940584797b77768a6559a91bf1eb72a1d074f06a2f3f76358f8aaf0d953c6e7db8f36b4d70c4fece3cbc4fb80e4a654799ce71e6d6d5eaf33c0cffbeb8f3fc58cd394a7b8eb0be19f778bf96039d8de9676e70d0227b684c0c6daf5bb421cff176293131feb6f2361914c2f472954dcabe201fa61fde7f5f8a8473af5f79a837babbfc308461879d9aeff7e54074a2d543636248fe2a5e59baba99a2fcefc9fcdf7d129dd5282f94034649f88414dac0dbd96d469fe409e8c8a401a162a73ca4d826f8026f1a475b678d5dbb606ba084744dd27c5c5fdba262acb03ba02eba10ea058b4c8236ba43b3ea71a2e880a7566d57f7d2ec7dfbd8c1968504d15fc01a13f16baa67516832b296cd3d40f3777c85c1241e3b53fd8e65b0d052f6bc6a0390f488a660e6dd26ee59b0c075a5ece2adcbf68f35a5b43578ae64b1747978e94d22b5dee1682051cecfb68f1620f5f0c12d758d5962c9a3dcc3af8b4d8dd9fc1b3eaead771923d6b6bb7ba7d523b08192188c9852dbecd8e8e36173a72c1559972fdd884b3e8bf59f90233941158c2d81c12c280aa33599c77cc5eb81ceec549229fe94f46dbc3bbcf7be30b89ce91ee9dceff5f6061030366313beb038576e43580c10b8177c7fc1f16532e3f0770fdc6b12ae4f94f97d1c8fb16cbccc803e5db190276eb7e2ff62b45e53940e93daad91538135d267999f490fe5ae5f5dc42ea7dacc55d8f1fd31d980f213268cfd4d06aa5c2572fd1b46402f6c40eed5875573800b35e6c4f9c0cea6601993768f48502b1c0b70001498b8d962677f391a0bd210e93e223f6c37ee6a241f385eb613c5a76f0ce9ea6111380d97df772255425db3fa6bb8b9e255dd845d28a0878ec5c9ca686b397d2c75b088a20984d4f81ae5cb89aaca078d027c4e97a72228bd1cbdc55dbd29fefeba05be3c73b1d0b56c63ee196b04f53c2870fe5dd24a489644f6ed46200243e2c30d99d8ca435a2ff6afccd0cd8819d6b96a225a20b24aaec010c48b250557a2d396ce104522d4e3be23f4b39af24edde14bb9a86135750769ee0f9e56cbcacce3c4c4f433939d38a2361ae893db14756c514fe8dc14d8716bb39b97cfe9b99a53ec349a3cc5af5cf93d78a018848fd460fdb3c093aff4e9dad8c0121d98619f695007c892bb1adf1e7b11e37ac204a7c70395b3cf9e5d64ec3157f5e99b654519cd640945d4da2062085543dc303af5b5ae4768a790a800b8762f4a68f230dc79a0704c40b4789fa39428b836208dab99027572b949c3623a4c03863e40698ad513c327f9e148d6297728d2e2da7bd0b469ff613dc4339313e40df12403de5efb0a009572af73c6055f7e17b859a5747c2a98f4146751eb0ea68638f51a54415530568b6b57bc44ef3393091aae4621a484a6470265fe0a369a54aaedf6656f8687d6a063207f8f211335a1926fab5736022ff171d36682c50366e2f2bb98b873c2f12faa03de3dd4d1cd833f949e649fbd8473dd8c4c8196af64baaac8982aa0a545e8e6472ec06d1688a407207212c21558364f27e038ce44832f96ee083bcc2986a4cf496a5971f7669ff6ade6a9503d8549dbc17e77c47c57f0fb40339b834a071f66131e0fe0d599c5df2911cfd06326f72b8c2cce78dcd59711afed77a2649a76556dc859f05716440e14d3e1fe1fb8ee3fd9d5c7a903b92778703d034e82bdcab34b664f403693edfece6c22302468f2e3c3bae4f9b673d84612285950843b7a5b5cbc4f79712d4ba8a4729db6b151b76caf92cb6c9848dab5473d0091e398c3935bfdb0cdfbb976ca153a264aa5d40048cc27d15f2a4be1274d85764c1aa5538f5b601abf617ecab2dbc9fd141f40a2ecef1422554dabfaad5b2c5e6ef04c28677f498ba5018d40ca51da8686034c536f89be13794023dd8e6047679dc526161f836116211ce36251b13220ae1782391513ddf505bd8cc8342e2e661cb4397925cf90ecec9ae858044bc8d77087367c959444e27bfd3912ff305006e3ff19817cf6fd6f68fc70989fc6a6ec5f7c071d871e82887a6aa7b717a4d8ecbed8699512c53d8641156324afee83396c6cb95bd8d25d9bb5c5f3d46da7af51f8f0e3cb90b20e78a4ea765152e85f96171f0fda981e0f04b4fdec1b1e0608df76896a25cada10d22c75fa7e9aad8833d3bb3d1eefc7384daf03515a206d255788ac4172e079231543edd521402e9711ae9116879990aa4b783377cc9ce6d198ee38102f7c81435f2473208852b22881e52946649addf74de3a0208f6a89b948a6811a3865f82caf35cfa2bdbaf099e4593ed5e5624835dbdd545ae9e5624414231900a0928eeecce3a88ae4df1acf1595c96182fe4c49b5479151b5a882e3f3b47b268be2288908af75d47e054d046899a98f9f73deac632bf95d2f9101afcc71fec8ea03ed0aa19396a81df63dbc347111654da44ede90af03b4e783d418d55b4db8b9c221c0c16bfdc5555ad4a3c8303f42b44f46b0d98d590c2cb9ae6ddd9f5bb2fb52cc4a52adbad64fd9510cf713864258b56807738c84c09c7d1c764d90d26c9ac846d512c32f5b62e4fb932d250bff05f0a9cc9d6e48426c2b803ed966b5040ea9c1cd1d356168bc00881d7593322067efd47caf004e8e458bd6e81343603ea2b4f6359b9dc71b5e5720e974daf3f1fb29d839653c78926839a316d9130349701e0335472a148a5729d57c7f28279afc4f4b24b2428039649d1a553bf5abec13e85d35b5471c91fe1206cdd525b918f07812c1d816f961e44023eedcd311fdd96059be9bb3f51b2b038572b53db61ae1a2805c67d3d1eff8d73848e913eee77312fff460a3f9d0b09554d10f23f23c81fd55e4a16045051613b2190767815f8bd659de833fb2d2d467efe55f63f5db3efd0cf434e949744da1479252386f7407d3de79604cf410bcbfb37331061a24b60748576600b4b9c4e56bbd56286c4a7f70b6d124ea063b3d147d21f7e21608b241866f93d9ff867f7b95f1f520784ce0b8a813ad3a51a2f99ddd5a883727f92421eb8725c44be71370e1ef5651ff15da6925ade5d4d08e81b8f4da657e216437a7d64fffe2501a4c0c68ad3fb54e0c6ca35ab9ac87c424248c810c9c85f331e53834de9a61a39f1e5407dbaab3a50c37a1ab29c8a59f2d4a56e4ad4482e385c2c58110e6c91b0282e7baf10575028c7c29fdbc365c3a87e345ce21ffdbeeee4b48512c4b7621e88a8d1b2c9e2380c4120523ac3719a28cbd30b7fd2c64e9628d7216871ebdcf3f7b7a1dbdccb76a39f4f731c8fcfba3c1eafa3780b614a71b0a223e9beaf9c57ad982dc3db7054b1addb5414bf2fe4b5d3b6cae6796f9a56eb1588c3a4e1a5c904017d766d2464fe5fea072ba50d439ebf5819b6a470dfd007d3196990dd3d93e6cf538eea4fa15afd0f368d35cd883cbbd00fb58fc0cc8395e0e7fa1e153e20fab1bcad0a6bc8adb8cb0d2dba1f64c0df2251e89c10e8e41c61b49ae737c28c903b0ffafcb1bbd25bcbaf13b3243e1d3c0c271f8b8fa12f5194ae6c0ef0b2b1083e34e65bedab29c7b8cc140e388f9043a20e4431f93d8261a9968c1ec53b443639c08384de3148f761637af9362b98d0de279f7a629a73d05b8fc53e86cbae90b504be3080508701f69ce8db07df358b193be81f3d377c1b2f505e84e65663383644ac8812e9e6e508d16e932ba4d43576be4e5ef78aa10613bf0c6aed32262ec31f84b785c9585897deb6a210e068c5c93372a98b93dbeca9cfac15c9379cdf9aad91439cfcc104ceb85e0ab59671b2b73ea281feed42d76de02d1684658d2d75e02236507e11408cf314714abeda7b955766831f0479a414e6a2051f7a4c4aca80aca755cbdf486866c9a97e1e109520cb8c6a3480348f6cade86478fcecd25d4ceb0eedb0c40ceef2d42e0dc53f00de870f8cd4f775936dd8699827e1665d871f07dfd423f86651135012a8b10de680e98189d63e52d138d4712a66dffe8300dc7483fea2f598c9bf4fb304aac745f6fdfae136a03ef6280cd85a3e94020d99836d11c7776ea4dd86b7f3c0d4fa064ad69688e5baaef2ef56cd1579a1ca3c8a1ae9a6c44e4449f79eda651889d8579d39f23947882d54cf743998e174ed4ded15ddf31ad38594b05fe0c7633160e8c48eead389745bc9ed50e3fde78f644d35c6237c0e64ca4e1d1da96e353bcdfab0de84012a433a21e24da65c348a32cd4fc160e638329c0f60f0f5d3c6e8b98f5d542a0bc7a1481107ecf1d34297500b84a384a3903471356bd416393963e32e15f10c12d1203d602b73e8bbf6dc7dcdef291a75fb4b098a7f3645314bc1db2262953e0d96f5a5e54d34b56288be95dde5fbe699749a658998f508ff034866c43fedc05c36c646b825269c0749f15cc2d7034a1e0534106f6c9ba136ec9f6cf11eb6dfb0753b9b0cc2fbc03efddee4151e9867c6eb45ba8c09955d27026bd19063a20aba3f46fa35ca486605603916ab279ed09942814253a1cd232bd6ea4510fe5fff79545cc844325cbadf5fc292991976f8b032ff4fac414910d0841397a4aab74ffeb6e8e798a3dcc154ce7cdda81a55588aefe01066583ac0e92a661ac1da2dab658edf956d306f0286874a9e354b64dae3b2a828831153f153f679f31e65b3b4b39bb325cdfff746aba1c6dadf9064fc14bb6da50cf10bd91a285625c4325abf9833f7d4b5fcb3c6ad8e6b626f20910df74f2bb6a5554d24fbfc3d43bb7284d7529bd3d31855bce7ae247947455e17a6ac436f6f541e9cc48a56af97393b63ad6a681cc56a929893079a634a8f26853562d477836cdd48a1d7cea5a2392ee0be27f261e2f5b5ad74b912f53892c0e9f46ff92fe0097fb22894366bed55167ce3e3210e84d1b87a481b8199707693d5d9c7ac3290e4f343211b27fe644d74ee2296932413563c6e451a42b461e13ba57bba4288d6cd3b95f6218c48d653158e83b09f1644216f6c08959c91697ed349e1f95cd11a50cd6561fff8601017e5fe964868044c1cf59b7d3a8d2d9f3b1a95f6b50df4ddca60d7bf750895f0f6d53e45fb434513d8ea14a7abb65355ef78a735115f24fb951613082633554c665ac68f6b80f444663f875086c465d84dbd4d731d80b7a7d1b984a098a2a0a996807607ced92cf9813e54335d574ef4b1826072395a900012e7b8c76ba9a9532660638bfe318452f76b48c31ac4206e72963f1723ee977d73b765f2cf59a2ba1bb1c18c200c36b8a913fd1b409dfe7115f5826235f1ff74113db6db1c1f53c992ac257668e3436c41c7182f17a5d030beaf7611b7cadfc9ce5356853d4b0614a68b1b008b71faad41b72a82972393382ae732767b0384b9da7ea74644732c95a0bf564c61b7682d09c392fe63c197c425279ff474bddc2ffb9e5415b61812ee65adddc6fa936c76eeefaa92d0108bb2a9b304a5df9d16afafe6efc2ad44173f70fbdd6875266ea48975a9cc8239cbab1e4277e2c84179705f38c4e40afe7622594cd5f171a8aceab9ba4b16424186094b1b8508465f397d6ddc549d5f090d155befcb9c445081f2c3435bbd4ec2c5b9a4e6bc90e78f928fb5b3d8df5f5793f34ccd5e64ff9cf38e9eeea35eab8ba45999f5fbc6df7c19f3c24d5b0a6ce4dc22e6a953d5e831d2caef29e28f18e13f1aeb7819dbdde62f27c6768ed81951d2c7415e6c2cd7f1e76931a972df1d4621e007ece06cca24b11fccbdd3d30d901227a211860e3e635c598f416fafda98bc4b0bc34f4541e08028c29db23491feea851b4b0645451af0fa3f91043420e89b4f9b5c6ad9d0fc4d99ced3a89aa3a1f6d7c140a4357f070390ca595c401672a59126a16b4f3257526d67e5a820f5bd42a478d236f62407fbf8c92f8aee9ab913a9e34a20da738d5d24e11f0a97fd168145f2d2bdbd6654331ff84c79f4475ff0b105e5dcbb639d8fc03ad578a1789f6df1a8640209f72f8d7a9d3f096084142ce544001af56cea24fb74b03961f7b69f6139cb4321a59cb0f3c05c41147c2217baeb7f8c9858f74d96da40516b88ad30566fd73decc0b61ef28e81995853f00930fd5739b292e44fb2555410ebe9527b9bd6ce4665f0115ced6cd168a723b14cecd27d391cde6dbdf8e05ab0c7b54e46268831d79df5b451d666d6e6f7d26abbd79b82f351a44c72c9de4c6474290987b4c705ec74edb7bb14ec1dac946ab64ce0c66eac6e7326ecea190c1fb76e08fca9553a659cc061ee6564ace468d06f9955a6ee85b6853edce712b6ffed06dfafd7b7a15c50990a43b888714a763eda180cd07358cb34cd281d4bccf0e3ee24196f685f5ff97e3602962af64ee9c106f920982e46325c180b5eb7890bd2977f45f26f97dc1e6b2961008a398fc09baf6d8b952dd17a7e3e81b9911abbb82e9229e1d25b2787bd06167d5b83fe52395ce1db2e8855ecd05ea735beb7d0ef92d0211d66c7e1d98732cb2a26e011821a37a7738d42e9ef7a2b95c2e7166da30317760e040fc4f6fccce084d9a989ece114da954a2e86d78b4a37b88b7abb3eaf2f2ead613ac6026788dbc0b9fd908df77a60eeae0085ffeb4c90c5222639cdf4c5266013a159d364a882899874f222b591eda099ac247a284b5e403659fab7498c8a44ec3fe8d0337e2ae79dbf0b5b86dd03ef7752f5e45ed7658c22891bec7954e2fffa4fb5309cb7d6f5fbcd5e276b37114352b31ca364c06531885f86e60fa5fb158b38d0263ada30f850b6bed794bab9cbdc4605eaff0065c806169304e2a59b8","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
