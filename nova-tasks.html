<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"07657b1c88fefff35492b4a29654d21fd0571c4d0d7d2edf68fb7b5b1c046012402aa548940d42e97bcbfe08974b4c4c51016b0fe0d89738ca0aea359b6883e6131ca1fc6924bec66dbdf2166f786d78554c616c5e33e6b8b6a51b164646f1d65d5c076f72339bc330d9b441add570bf7e4bd685fb584912000479928f70a47d72303f96a111b893946977bf905ba0a4670c809984b51cfb9b366bfd7c36641d84f09c365b4c2538dae89d36dcdb391f3ab9e0bf40c6a43ba5824b1236a9e90e756de0574dbf774feca78d1baba090d1e1eda2464bb8de6e539c3ed6092045447d995f39b1fc1beb57bab7540ff0689dabebe8e9d368d1c409f1aa4f6f151174648349b16457cf10222d02705d5bb577bd18fc041d1fb919a51530c23e5c19d38bc669b3d51a051b2051b2d97aae22dd85b65be5f48a99939797cc5867ad81375dd49adbd9db99fbd817865f0aa93e0131b05780998633a3c6d209ac87e633bbbc0616b9109d0233080515f80d8b67c04d209b486d25b2dafd5e2861210e8ac2211587051676a323a4e504a71b7e0f27720a8849499fa6d8e5f0ff3babe8c8f6309b2c2c73f6aa463af2eb95692e9a7798eaeb73fcc263db3e16de2c8221dff2363841e65e151d396ea684ee24777006acaec5f54eb785ed0a7af06d55156d869a1156f4f640991360e45abd7b8e912dcc6107fe4b68557b00713079519917dd96c7049ab3beac32330aaf5627adb2f1f7dcc3b2539a677e9f65a486d9c75682870b721123d97a2947168143ade36a89a83b2751d392c515d12a9231d8e5a5c0b0ce2fd46a5cb73674e5f8331803d9006eeab660a90c8bd080f96bc4af98639c34e600046c1842b8e81acd4a95cf60243cb5314392d5a79083f061f38b6b0d932f56d65c125a6fd9722162599246b9ff82a4624b8e70ff63689dd28ed82e49e082a870f275d8817098e894d5ad13a6bc5160eaabbb1d536102a5f58a6935c8661379bd633cfd111c79a4f5478a2ed3f9ce73f7da64d75e11c9e79b7e59cb06e64b45b78ebe1f1884a4daff76d39eb11f54e9e125a79b2451acc605a27ddfd53fc694e6d25b7606ce60594838d185368c952d1736ef9cade97e3310a079fd08f78c17557a09e10cf6d94c65cb7fd1c49b6895b8c8f75509263effeb21fe0acf0b30af5401a873beeb574e49471d160e772ba949281c40f91f141ab955cc2690415e3c39250f706032d4c146bcaf863eb9cd75607b5198a2b096a96712f1e69e23d3e8ad2aa67acb16c6a7063c7660485c3f63240287128640de36fd6cebc9c8295c2f29433bf8264873aab9561b55fb2d86ed1afd5eef6396189ae3f959a96ebc8cc0bc120f38ed4a055d0c425780d21e93b3f8e0f5ba94a5b78022c53822457f833fb9eacb8f4396bfd48505c4a7958cfefd5a4d04617d2f79c4b8db4d4732ad23ce151a4e7541db5205bf457691cad5ac7e2a6f7a02a56ba30dd8827031a60816e03b4a0c13237f36245ccf4370f3b71dfa69379200f521985d75d586b78d0369623a973d5b37e332f7603813e1fb54446bc7622c53e377fb773106c0ae0aa1427ac711524584cef76a92b715e89fd5ea1997c321cb332b831cfe3bc2043d7acdd0668da18cdeffeb907a643d451d9b3bedfcd348ad6e8f351b2743f408cbeaccb86bd58ca40bc38276b82857c2cc6796fbc4ef3773e4a9c8f382700329bdfe1dfe2aaad23d467de69440cc34a164416b95d917a04e153a4d579bf6922c4e8498fc546cb4e9e4001862936c655192913e23a969de6786afec97ee81c60ed633e632e0c491d1f20ab6f549045e7f1e3d219ac1828625a3be01f347f7858e82767ec963cfc070fd3c04dd37f2e67993182f806c2b587413b7704ecb223d26ee894602434fb8a0d745da4c26c09b41b40253982203b978e4587e662c2721861399e32c6fc7c2079198fe833c00a2ba187fe149ed210e51c66bad6aca4008d5e33b9aa3edfa29f2e443634a90a7006834a5ed74600c3f17f3f22369dd44d120e69b20ee55596906e5eb9e259d2f9a39c838c5976b46a5268eca0df1f7f1338a205d923a495ff69502dda0541fe4f02b7269d7e06c85c4e34368246907f7699e5ffa34232c4fbc670a466985e26646b374fde469c8e4810c1865a7211074d1a03ad17cfcb0fad4db207c3cf22eeb09cf97dea8a2328d156d84f5c25213117051b5e8a055a1f9fd7de31c7a467739bbd518ae79690749a7a95c8e50b03ae247a2b0b2530575be6fae659401dc6065f059f827965f7c6347333de5893951fcbcfb5fdc1b4347a44e7bbb5bb8eeedf166a9a18c0dde3a637ee56ba447e7f2f7f9f3e5b9807977604840a0e7124572fe33c457e5815575084ed9d0d90c6c6d59975bbeca2cb74c21a6ef722466724ce7ffeb7b72ccf9e81594a8c0c829a740e3a88a9147371e1dd086af326e3a8a1b9e5397d26a6ccfb0a655c2a1b42b362dc84b942cdfcc1f1021fff8d41d058e20636aaaf2bae1b0e5b0eb11172a7ea3fc4ec959926d8d8b8921730a643fb77f24d9208cca9080ef299f86222f66e7abb668252e95395ed1bcf833ff5038b12b1a730af228052a51dd1c9d406afe484d8528a69a6ff33c39fb5b5c3d009b26925ff8259e24c8d7d62b1700922fad58ba52ac0acc10aff99ee1803cee8224b17d7c13d6c2b5304c5bec09c6f5df295ad8491aae41d613035677c614afaec66223a9f811ad71d87cd6efcded016aaf7c133b3e32bde36d864de310bc768267fe3c206384b1480552fab105b762211b3b9bb5fcaf00b3c5451720157ac0b472fa1ffc97f4af213b9e1e5b4ac77985789df654a57d693bfa1d0a4a4a0f0e39d1fcba98799a536207ee190145aab7ebaf2a4d093455eb6e2e6aa5021d06bd67bda5ed81dc20d2de059fa35d4a02c5803b093356cb4505b95100520fa10e06aeb9cf6f79c50f9839084568d4a7a4a3e1f82160434056cd1f41e66fa72ef5b9951a33bd8103f83b1a959817427c7cd66b61fccac364f06444627926d600b8f0594f01bec0bb6c218dcdcabd04a7779dcf52c702023657dd98cfeac2c9e67d5ada1b7f28f376a90065431235de792702c269dfecf79817bd2d61b536b43ec47cb527d91f4f612e64e1362d5658956b1ef31c62f67175bca306e3a85bfc4b3b6c3ff031248d1296928b9bb59c994f82bfba7cb8186c25cf969fe10a8d03047c314d0178f5b7296b199163b4fc8042de58275c6112f6b0ca976cc4099fc95f3f8cf98918bcc14a563a9ca182e58a1f595cb6ab1315575d16d0f7be9dfb9c571b042db556776c68fd7ab3153327fb63ecb2791c6e5e4b26627b7466e9102333762e5851766139d1598cd755de3407498695d02d1ba17ebb7fdcbd10adf47dc845b5bbd58c52e2d67ae77f014013d55a3e3c920ffe060662b47ef15507bd9464934ce369b843e1f89ee2d907a8ea65c613562897aa7ef1383db5c10243a78f28c96b1d27258e962a10feb5214dd1d40f00ef9adf5f2e089f9fcf1f92581565e9b168ec9cb014910ee3cc8e724475592e9d399de1ce1ca339dbf46444d772d0338b2dfae43412efbb55fb2114674bdd3c91dfcd5b0e808988cd8671ac857ef71eee48990294ae43f9516650cb2dd0d91143587f5bacb7b2f8b95bfc6cb8337fb53fafa83467345719acdbd3c4bfdf0211d237c53f8cc7036c808bc468bc5ec9f5a12d4316dcaf0c9b29b6c0749fd098a9aefa4e374b9a8fbfd456ec41c4fc010473d820de4109f6c0940a590d5bf3e94471b92f7aff396941f1f26b0bd368b1c54e4191b8ebc8c326e352df51ca2e83f21b315cca1fcca2b7622b9eb504e0e6c2e40e8f11db1270b8851f810426b1a4b377e7ba29dfdb800aef23e70b3a499a4e2292e856063e5189e149707450944cbb636a5e84073e223c48c6cd248d7cbcb5a052b9dd5770f81715d6385831889a8d68c9a9e2324c829f06e86bfd88c3fe27cc51d70084713f261600b3081edd6654e9783664f8940d364169ae533ffb8128c611d4e2a6b09d7554a9d627d324cedf126b6459ae11826eb72d52324caa99215a160367bf4b9e2d94d4e4257351927678fccdf883349600f816785448ec710775f2c827c84561558a6d31805359b196e632d65f09fef49477e560f24f02135c71edce1403acb050e31affb646f4f44d2550af0b382c92436b56de3a977505bbeba42474f328a81cf8c88ec2149fd514eb580d483b2cce234dd548dc30c1155a87a053b31083cdff2d6b77b36bee5fe8e60443126075c06b34beaae112dc863c3d22e1bf219f8d2c1be4d9b8b5a1715aedc884525a8f60d32be1e89aecef0a0669198b9b6c100577251fda806c89d411e06054177f716953a557c4b83c4f7545baeb38c8d3fa6f68975b41ffd187cfcce6ea4b558e50a4543cb79f9fc9bed77f973fad1d1c8dd67dd65595b6571e9ddccd40e0dcac63f3736945e36ded23fba984c45dc96aabc15fd921a05c426d6151e2ae2233938329e9f2b4449183df4f1c96c73cbaccf4113f98aade2d01ece56b76031d3b21782fdccce48c5485c4584ad9d0c4803d56fbc969201f64c234c6df6594c3bf09375408e519fab1aebba0f3b3724f17201169ddd96f9f14d33502c0c56ca72dec2e0d45d69da1866ff2e7dc3a3964acf964e8a51e8591000435a488ede4c8f1bb0497f3688f3b4623f99dcfac6c47c17985055e3309d5f86b4b009e3e79b143d350cf5fd3603710bf3453492362671d183f1391275bacc31378065d27d0232a1125e4eb73a1bc1858b8749c1cd7d0e56ea223eb5a95e0891bd3864c42b7274a9feca99cc11c66d49782699ed695b498b920cc5b2790b6fa25486ac45d14fec7139e051adc24bcd94cdbe5c631e8ea8ba208158996e67a83440c9ccdc22957fa590080f9891f0e4c3c3acfd7805b0658399c1ae2846a70cdb6ed875e88401b6efe46a5745821fd4247f3c77290dd9f61f63969140c82dc16a400d7c2cb53c8d0b7724eacf6a912be650c68749f4369a9912cd2be6d295d063fa9440b1f4b1dca504fa0e1811c3334d97e1c2c848906073d1ebb02de17d6dea54557e9e3f1579c3908d45f71b55eda888054f76867a3a70772aefd65da07f717a90cf15474d53e7bc53036d3050f2652141f23139cedfbbc5913e9d284a2b6008f6f262e53dab11cfee50fbdbcd91dd23cce27e5947464f3078adbdedc451c9330e9f0a86370043f6becd7b817bb14acc4d925b1ee1ad1ecef99651260715f04824a04b5039ed66bbc82a1bb5ad501abe4ed0e20b04efe539c9cb204faea5873804cc697dbe04408f10fbd6c038dff9bbbe660b0442d09f462394713b89e6013fb23f2eff4f6edb0ac5ee535cca6e80d92ded72c90ca07ab4a4118e08303f549e4d08aae3f9aec299ea43335d6e82fc98c9bb325dfd548e60c80612b3cb54bba98fa1ca5a9ef8fea651cd7306a24664855bb7ead96333c2b8630e9feb82facf626c38545d2cbe241ff1f606953aed3870ce7cf415b4743e5f0c9982be649304f1480a7c01fa234ec174413c0526556e5979506e202aaec81e3b86077edc5f6810b5fe750e2882b082be8f6bd3d73586316c64a137a0e74a575d356449e7ad68fb184cc8fcf6a64ac8c97cf6401a81213a9133faf8137e55a316659a57ff9862bcad20d7e803fe0ce1f9a1df81076e1ca08c19b4bb47de5a08aaec9e64c4295862266fa87181de8291e2f41ae856e7363657645a070e37aa88e0838d6b9ac6f5d518707a72f694a9697242847463a59707350da69e66fd5e4ba5e3a7a41107bef2ec4fbcf4a8eb19182221dc5f666f0ceb62160d4726de865ee5eb36d193662deea7f596cc0ee0908457246fca1f714890a50c7be05b82db9c6fb382b8620790dbfa9754d96b111c84ef27b2048906c4adf33c2e38ceeb896372b85047ecf15e946ef822d2ef831696c08a20d611bdc34af9e34d8d00748b28aa4b4e66f8328fd7a4531d5805ddcaa95e6ae4c41e33693087454eb8df63ff84a1b124ff7e287b7f2c95071e428b68ab0a7148b07b9e8e48c047c862d5e1a4880f1c06c5aefa1cd3573fedb28adf6ee9361b0699535d97cbfddca984c5226354741adc66d0945ba12fcf4340b30b9ee7013d77caabe3d73afda04477b25dfbe2dbc9be77b6d26371800ebe5ce5fb3dbd71f9a67dd7b43cc2e467c234921ccf1bef423974133c7eb2f58b835294478857d03ced0a0e6e15460a4a6b4f4ceb8a1f5cd1c6ee70b0496454bd232e25e80e5f335b56a74fcb5f9996a5cbfd90f389a4867ac5cfd75249172eb342a000952ecc285577e28c40be6bb982d352aaa5a4832b58c778ff12c4c8c2e8b53cdb4e0acf6289b922f1dfd36ac233d5c79e9423df741f8fa150c376138f2c39c5945b6eb60928ea6b90b0597d24a8c082679df7fb9c82ad58108581ad6353530a4ba46e5ce9a00da10e34bf7d2b3ab9f5841f9a960568c3aabf7c11d8aa3f973478ef06108d7826f9b739653ddbdeb3d44ea4351bcc2fe4d153bac65c8166c3b69b105455f9eb8ebe935ff7a845ed26204b358f312031fd374cce3cc32f5bc275060f366dded78f6307db9040c52e3bb103fdce28b3126aced78333398eb393416d9cb41aecb39b094ebeed1f5ae898eb04e7c44e988be337ccaf804d54f58a7c03d9bb8b01386cee742ff0bdfea2ef62a81cb265f9badd4e45f36b14777f650813fc77629cca2078a4c3dac2f94caab8dd242c4427a1256a55bbba940101c833345019c86b6de1ebcc96b5413e0a42c565125472343821511f42939a139480648072de21741a6cd6409425a021ab7aecf6d02553f7d85530f5442638b75d443245bed219b1415c168345f1ef6a4687c2a77d35bcf1bb45a947b0089b7b73bbff05eb51d9b2f4e06acf159c09d7a32dcf1bd196431b65d6c9d4298d37f31a419c995ef9335105a105cc79a21d08eb8da8ce0b0c2cbe48eea84b58f0838ebaffb6933d4652e7eeef336009c6edaa330a11d96b28ba0b7eba44da156d00640dc6d182fefa68ff31030ddada3b2f049bdcae679020c755eb7be2eada382e8370f5a49a6caed4571f6509f8c8b889f2952b9dcdb0c3411bf95d4a7d1ef82139cdb8624f1a657a048a959673faea4198442f42f449f902d1b0d26368463708aa5c1eba74e8f18a67f46306fa254729d19c143b238bf87e90d99781205075f9ca287a2172b908f759b3d4539777ec06d2de63d9293cbc72626ef905148714bbc52a64c049db7c3b37fcba5f1708296ab68f21892354bd7e43ebaf6e8b0bc4dfa1bc23cacbe68ff4c3f071a9aac13a2b0e39740777d1a2ef1d391f6c621ec9a18756a60e0613935cc92bb8405f4bf7d39a577541cbec52da4c506df93e6541af770b2c2a33cfd35cbaf566c73041f1718af91c5c7f562de5cfabb2ced64984c8943f96f6f699fc70c7bd2fc1f9bb00da12a2f29120cccf86291ec74eeeee6117c31dce8ebb11c8e5ff54651169693bb73dc38888f6de93d959d1b015830acedbbdccd94f9baf876ad0ef68f6fe82c71286e02def40f9f8c14b543d9f6ccbb2e70460853f855fcaaa03bd00440e6db2ff24120b3ecdbae8a5b1a07d770d3ee158f5897ce695281ed69c4648583b4277a6a2855c1054ae5cd8ff09972497386a048d0dfff0977349642ffe4d4720b75450f9f0d2b725d9e81477af156ef4ad3b128cfd6b631f30603fe6d227da262c5096bb64ee55546c26e082eb423c466e7e6da40b729a7bdf1116a5e51a1a4cbf158763c210fd76bad0e202a80a38ca5fbbc9859d829edba18b3a0776e165ce877891bd57b5fffead7ad6605ba2cce7fdbd5abb1aefc962a33781ab5291faa92ff1122522641bd86cf3ad862aa7f99c67ac7a7c8b36182c31ce400fbbf3a9f3bd6568c3d0d94b03154402dc0c16e95da90e9a8847a5aa82862af22ad77ede3ad0d7bc53bfe16d59296965c5b8c31b9a0191f24da99339718ba880ce34ffb2cd98071cb31226b65ef4e096dc447c50356e05b6da7e0298ebd7eccf164ad001876b10c6a0627c818e28bfd93cbab0032610f29ac226dcdfcfdc1d662be92377657a30bd63866af49081440a615abc11f85b1f75b45091e309935a15366590b73e7b57e697b223f4717239ca9cd76d96873cbcd2ac3327bdc2d0cbd63fa3d605dbab00fb9c24ee03aa4f358a40a8e9581cbe1d23f13276e62884472d15ba9e284f513ddce7854390ece5b25a0be08b4477196a9bd5f8c3a9a110330a10cb2be2a460b16157d6ec1a63991a60e1442a1f432f70c7594e8617ac5f3935eab72680181c26d6cd0e3d9db7113e4efefdce4f4ca0abc385e5586c75b23ae2a68048b9e0a56fd5ecf9f4366a5f5aa51f2e8c5de54e4b236fec4e0087a0092e7f406fda5d3d3c7b050797d15b61465c79ad5ba27b10021b9fa991f387468087aefac4b845f290670f8faa36f0d9ed0188363d14c46ff6401c938ea2caaa6adb36db32dbd917a45f2a205deeb1d18df137da2a8a1cd372267274cc36ffef94dbc115e08fcde8edcaf0627014456a88fe7d1ced6fbfaa93df303795052553e57e3c40522bfeb6fe6622f58bfd27dc564d23f3ad3713ffc3a105e8194f50fd961c02171b0526784e86e59a3cff8f4316310cc489d8346d53e112f5d47ef43091088b312d60881e1ea5626caad23b6da2faf6dccc1fa207a38f8131f3a879ad33744d4c94dad253396ec83ddbdb9bb9215e66fdfcb650c4f3bd7e342871dd0faa08b7ff1ec602cd3a01e8035ce86c775827237db35a4272ece2df896fad5b990766087f11027034b6fb4d2bec640b6ec11e8c80515476b9f063189347754032309f22a4b82b0af418b903587f8da3197e546a83b05819f4927014bc4da3588b5de70fdcf54014f9ad105560415b31ada1f43822e27654d3b9d63b6710b76dece4f70ea4af8f229da53b4b506de10d2fa7d3138ef93ca8f715451228cf55934ff5fb520bbf529c8440c4bf4e8c76f778774868af82d5eff68c35f7efaf40a02cb29769c3a76e371fff87952558a5ae2880df3fc6e5d12138c9a9e30b5c23570c5c0d340264bb462b2139b7e6f21c0aad4f9e2f0516f944dfbfc27ff2b48318b4db573fc90c39f536eeb9e0e596a7735d28f3c5fa9da9686e9884bfb0f155fda6a434e4d1dfe255cc13e3ddc2bd44dc856a5941aa7b7bc77454b2e01ec3d94b74afee12b5523b53b57e9652855828cbbaf90488959fea2584a1cf0085fc23137490ade9b23eb743c9af924cbaead8d73aa6b229e59e885dacd53d8c45c9ede083f11e7734f39a234d4ec3f16a464cc8abe393f78cf79d6df1c10f8cfee9dbd189a1209b20c7427d5af67034f8c2c58a09d1a32b36595651ffa182a1222448734d5e96c4e554906cfcc679ca5fe3403a3c8a9b3d92bd47b77c239eb80dfcb351efc9f339084ad8433413d687ee316418ce839c44d0bd854e6c974c7b7c376313cf62dc70045d385d1dc6a01d7de6b25ce6956f0e5aff90ae37913a170066e3b4290a8abea1e3d2dd42b01d096bfc1d903da5aabdd9543a5d2fc5fa491f19088d337038134d6a14a3e48b9b161438cad0eefb94d68d0d8648982c770dc61e868742ab445a3970cb2ef3c7b3e01c4bcf26090c91f1625949e70f885c28d0d2386966a2a75d0dd07848179ff18b6e64c7a988ebb57b2b0f8acb4e68df80e17d4f1f24dea723b7cb297a0930d24f36cc0048d4ed3a3a41d5f3bce0134d55ca2a189fbda85a318557300efa03c1ea9650a4cc1d46715a83571bed3438209d1c05343de47dea253cfb0cd7791d70061b4a46f7566cc5fe76a36a1254be173566a2546ed4def48ca36da37d3d80ae4003440f85698dfc18856036566e1c75a5024ebeefb7ae6bd4163b86584469146b3da4415c1c28c90d9034321e8b45b0088c6e145fbddd07ac14ece7dfc887dc13ab699f395ba64f83ef638b886c53df94f772575a276cf5313174a3d0395f6451914b94addbd02c15531a2e1eef314aa1041d22f5371f6ec5ef0efae01290d8004cf75ea345e1be0ed0c94052cc090d5593c73ffb21a5028fdcb2f705ce1fba8ced786d1236d723607b4fb400e8998893e6d814e65cb2ef7a16b886b4480f53d49313b48e29a3ddf3a01a329f9933638c571e14d0dfb5463a610c1754a8ff383cd0973ec5257949ef6d8a97033f14cb8ab3a7acb7ba9b8c07a8c4e43956801aa75628fc10bad76b90199327c00a2cf4f185ba6c6c7a27ec54886b5d8bb47d755c4404b6a5e6fb8b3eaf42cf28f53157d45ffa8f0bd131542d2f02c4fb9dd1cae5c78a0b2fdda13e9212f77c8268b4abe4c567aa9d9ab31ad71efbf9aac1090db8adaf6d0355c683f8325213aae0d3e94a0862874a82c4c3860bb28c21719bb2369c1ef167bf3dc0af8a01c1deed133c7c11fbfaf8f7913bfbaa92bffcb577f688dae602f442832e0f860c6bdb161a6743503dbec9620b9e754cca442a9b96a441fe0b2502d54e60c67dc4b1f8863d1569f0f411b652b6feba415f88ce4f03e50362eb9865ad4c1ec04ede757e9714df59fc4f9b57b79dac34948a50d470d046a8129602a42b2baf5f1501416640a0e06ba8e401eea67cd303b50b52358a18dc251182479594381d4aec82b570a7073ef384653b00d6994991bc2b818134d8a9b937622b4e7cebc66954f5df15efa1b3550e91f1e249fa92eb8f1e208bb36662890de746daa2ddf1d68f2c0fc6aa32ae23d574b2ee62a0c1607ddd38686288c25ad83d9e0acaae6fa90e32a323d7cc98817480789bbeaedb7603012b2b63f6d957943cfbe815c94450c2aa0e33b9ec6d74ed02c10169a6ea503eca7974903832738125c456e7a4cccde2065a6b34186e89d6b4c370822bcbd5a9293f2ec2897582c429b2594a459b5f3328b2976c018e4e1906d250ebf1921f46f5f50fd8e93d7f7e8e68d87598201ecda021abc287c156a1c5a90aed99d518fd9883c5ecfd34ad47bbe89de358ab955894d8af8e32a656c7ff41b35edf31d482c12a0945a6d9b9f9710c721bbf23710a2f8614c1128f75c19414a21c22409b4f805510cf936a7cc7d7abd29c6c6a7e7555bdb77be4d718ef91e73a63b0a076b8d01bcd523082e041dad6bc01ad78358aa8ef2a18f758af62300888335b1fb64bc792e3283ee08c308af6d54ec51ae1292726bc6aa35ae17860eeb4afd0ab1189250e8be4b271d0a47c63b4b7958f7cdf50b78071d1a8a3afed1ab372126cb2505c7fa00dde2af746c48b5629fc8f5f9c81dc13b8400df87aba28d8c89807f61c0a26f5e059365b98628a3eff50b602841c8629a519ce2b42361873eed26ff9ea9570ddeb2e9c2d0c56c6afe43cb549770f4ec650da5353f4fa881370f94359c258f771ffae8c62dd51b354aeb6c19d2a499a0a74a9a89ef328ea4eb96222f667830e3a58a1edc6103355e53bc39e10b233a1bf04e93335778793e5937d70b453fd5c0c3a7843cf29e2eb2e25dad73e7b3bf98da8955193f24ef3daa75be8b3e75d7d7944fc988143cbba332fa978629728fde76d65081a72180ffecac97411fe9c9bee83456b41a63c0156898441e1da0422fc8ef757b25483cf8d8f5fb2d30944517e8d12031e4c39d206896dafed30848f10882941101bbd004af9abe6ea58023cbd1c89a6d09360abe01fb6bd028f038901eee30d2d8064c271d106a4f9ffe06039d78348e3179053ba50baad9501f544bcf00188fd1e251e394f8c2fb3bdf82ef0b90698228b0b529c9beb8101ffc91f1ff259c9ac7674671f1b2507bb08e91a36dabbce6f612370b4102113585e95c140e9a585f38d9b11b6d9217642202103f4b6f411a648cdeff4bbd9436f26b828ce9733e233569edda3e462a7412840300de67e9a81fddb3d4633ff4662bd80930e577f29aa2a094751ffa98fe3d91de5248d9940a0e76aabfb027edcee76d40d799db2638311247a8bb79e5eb7f186a04eefc3a53891f43a20a4c0902dc9ce8cfa2115d784b4caa357f56a2ea9e4c1b137120197b42025f91e228b9eca637db97277b63ec0bd31ead4fefd305e946736136b9e2aa0ffa4f57982ce02b967cb5e563b7d271144b8e5dee43d5affe861c4f74957d69f7441f761fefe8d73a9b8260e7c266441e1cc8f25d21feffdeeb04f51a8f3e90d82cbee43e92a00669645c21da9a789e2d474fdd1e6726c45669dda56bd6c0b83c82041ee4c640a5146e2d5981bb7761343c5efe3bd01a61e3955b0daf49b24c426bc4fda95f3888950cb49d99aa1980aecdbab2d433e052dfacbe1dd258097344ee80d6c748bf0dc4ee96559041a9caabfaf59aed180b388cd3914c4441d69a79675163d0c8e13d7fa498b8f30c5edfbc3629dc942aec4ff39f7c9655b4462a35bcc1388829d673af5acd2eddf8a62dac1d8a945ee71cb48658a7488c3e4cc81fade46c3bd3d5fcdfe9f8d43c5abe9d9cf90f82fb60080634d769f6da6774a89dd426198a48578f5d3f3af62a683c492728cbaada41b4a2cebdc276c72342dc52b2c086de148212d592587c32c508514cc2d7278454a40e521b50643e02ba4f60d1f2030e2e52ea7f136951d4e28d3e88faf761618cf10dba117c0b3da23923bde73b0c17b7e38a9334ad24c4894818cda29dc249607289c52c8bba3df918d23bf5a662bfe6570731cbb61126b7e6fcc86a83535fe992fe663ad76881206cca49880fa4c45f83b9c5beb52df6669076c7087d16b43acd606fe1c80bc7d03796621a985876dc625b40a0eba8800e2d4850b10ab40a8a5092f8ced4adb5d93ed2eadefb4cf2d26646789541b19c05a34f1dec5e385865106ce6ded08df99fd56ae730be1aa338bd83e90f5142ee757f49ffe5be0861ab86e7e275226dc083de4804b5e1d84dd4e43ecd718918871b40125735b0d64fa7d045d21408d7fbf80816985701d03ef6f419bedf79322d79cb6b80e0796ba850d89a96ce638a0628e9d4f699d9f5d43c2c948a3adacf505eaf56ede5f80b1a6284cf1e4d829cf41f24790fb81151e6e3bc3ad349a4da878e44662da834d9d617e3b1fb298dfa81373a3f5c3bd81ee61093ba0d31e820fdb1c45adf35136946f042ad0396a400a69909abd3ce910ec0ea4078c26523434bc6f77c2090539647727bc46de92dc41b239146df5f6b85c8f5e02fdf13fbe711a1111a0ea4105483695ad9cf2d8f458c37b16005efb4ac7e273914d7dc28748e4dab0f68546f03c7989e56dbfb4e81c8254ed7d5d64a46151d43926bed5233748cd4d0b17ec452b167f17e582223939183e006496d8f8248d2afcabb951bd4f489a8f617c53b47196ee6fc2e7ae1f19896d7d532bddc9ad50ae550782648281764a7e40e1ff35828fd127c22c28c1dd5734e99e31e953b703e94ae8b070703da5506fd44eb891d2b101fac0295cb0d61e63f607fb208243b98898577086ca0e6d92584afec0dd9806f86dbddb48236e4fa55b932a7b5a2ea41871be2f4994c7120d892d16393f417f495b27d841ff73e34e80a97e6a1798876ea8cd1c901e26d9118d5b319623dd5755e34f7e56230da3a39d5e4240e9d655293c2c230ad19bc22dd4c3a36147a50909e7dad3da62dd659220669355ae33d7c8563f9d6fad61f03f2e7c0f9fbb56350dc5b25ec13858765495eca5d0a8d7e3536d53d07879afc3481055de06ccd91496732557a4f8992977a871c9729ea94df16087fd67045d984aa4e6eb04dfa7e42b67a18d16684ddd4b2730e41d9d800095d67517bf328667f8615ce9e048d0b80e6cf3d55acd662e1462b030ee7254b12b0a9646429b9f93d1f7601c9e76279ba28fee547be1ff315c9ae4709e65167692ac93137d20bd1c93bb357eafcdcd3fd706a0ce2fd1d1f02663435237b3ba9a6afda1cf302b8a96697b26d4b17a4509231395f2d41316d03860ca74d416b5b21cc97d7fb887286f9112a9d8dccae70c1085296f1d05861878e175b848d091705617d4c1a02693e3d9680256a8f853046b15fb581c7071d7f5541a7a49eb8e4c542a59e8a8a3f1a2f0af691533bdf3dbeb9536a30b14799f7ef11dd891f5b33b8b47b6208aefbb6d34569d26b56d5827908db72b70e9780b07f721228b3e6a3c19f3124de750217de67df702edf95c41b59e22737e780fd8551f8ac70e5b2cdcc00ba73b635fe02c85b6f13415d1548970c68ff5056623bf78eb2caee782a8375a93b54a8edc8569a1b3d90410b1d6944a41ce0f367b351bae22754b08d16f4af5cd771f08f6eaf3040c85bd9810e5259813cb0a8ce79ffe97b8171d9816d868a072314ad3188aed47967667a7aaf9e3fd83edc91d7b1dd0a0532385053b92776948a7136c035399d42436be80ff2e162ac4c7b06f4acd8003fbdae47d1d74fabb2097d0bb0ca4fffe0e84e8a94fda7f905750580b977f964","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
