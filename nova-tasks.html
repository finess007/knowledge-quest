<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d7c369c0583c25d7a68fd148dd7588bb2f4e274edd2b16f528a6db8e7aabfdfd92264d14b5d4d2600ccd95fa58c249c188889d46e47734009dfffd91819feb47175b9802fa4e42956cc5896b3e57ef8f476d2d5db884025f976d67517beb805ea470bf218e03d9953ab40f8130864ffc62655b89b0e362951519290d3feb933995449bd5681bdbbf565394bc03a1fa375e171d3cb1ce96b8b372716e64338e27e0f16f1bb68d6558768048874ffce58a560b3c275f3e603a0dfcebf6fc561aaa6bcd8fe9900bea48f1769866208eeaba6c270ce0027807428f9bdfe8820eab77fea1d6f3757ed29b7590685b4adc9d73530f036ae43d3e589286f2e9b92e15f02649195cc7dda018c1458dff3bb8cd67e01dd4e2fb704810b2809a38156e79d2160a2d413b758d3dfaa04520f67dcc471560ecd891873732d848143e05f939ff8949c51687c9d96d46f49bf11c89aa8bc04d238aaa5bd12aed47a0ad2d3eeba8a8c947c5415005b9bcb0850f45e77d41ae54a1b69f6f768cea3a82f9f7c0aebcfdb7b72287d402d39df87976b001a390443c25e2f88f8f70538c373c97cf5a004d602ac4d724a374076c9e24d13c044cdcd18da6f25b14c38b1dc7c37136fbb6f0387ca18f4bc5213d5bba485bfe01239498702f7ddd3ec300e353adc28bb5185d0592ea3ea30e70ed696370def3f7960fcce513805cab0fb812e94dc42114208b74a24fe885c9a69f63f9623d7adf1a38e7fda8a92ea06798dfc01691bc2d27c78c0013e702fe40f9f08d905a7d95971be8810b83110d5f570ebfa3c3cf1f8db1a436b03cb45b8112ff2468492f87bd11ac91c23bb34a82f43eb733c26a0138f1bad026d4584a4d3daf66f51967d8e9858a6de0b24753ce9f65ac169835be78bf05b959424d571d1a7ff68f40bca919a82d972fa0d0c0df55bf82aacd2e9fba14c41ab456ded1ed7dceaae5f41620896acc3c222844ce14cac3136a376d55af86341ad76c9373cfc35d0877bb6933b1bd73c6ea2717ed77f6ddd4b620aab38fc9ab9485e58e34b700197a7ef41c71fb75f2062f470a32ad1a6886825d6fc50cd2b75f22fb2a75947ea3676f1cb16d635fd915446ef670da8469345769394da3bf6bcb18886f2cb4f12bd0aa21c81a56bbd8b80817716d64f96df682f94a68bb27230416f9e3fd67501d0844a4fc30f3c8b6bed1acd677dd5102c2091d829f329a51cff6f0d297d64f2d73d0ebaeeb7ceeb11a550c72affc54aa998f5ab97b83d7cf21c86088c92faff5954a1b6074f860ccdb5cd4e064d4267284f29faeccac199bb8374ad5b61936042aecebb1e516c8257084243075eacbaeb2549da7e6bade5b7b11a1c2e15a90b9db4aedf667d478cd2a38549fe1bd1bf874d2e3872f608abd8eff95593bc1cf9e2207d3c4dd44c07aa3e4d49973457f1c57dd474b566c316999e9d0ccfa05df76dee56517e1678dd4f38353b6fdb9047533ef64c2306d83f555370a09b4f62dc249357d8bf21d52678f320c799b77f389f164d7819fcdb1d9465df2bfe65df3907bd50a4ec3ed24a404fefe25eb459554357a859c4a8a7d2d5b7f5813313f46455e44205dcfbfefc74a88a7093eead9acd45bf77afc7178d522287805b9ea40b6f5023dcf5cf041bb819080007af2095a40ba69aa0b401995f78828c0eff2359803e40b5df3bfa58a3878bf9a3309922c143f003213d6772bf37553f631be060ed8b91fa7057ab3b1035eb0a299c3394a271fa3a8519915f0381defa53b351403314830ab87452f429ece17bef3920a40aaa1973ec95ff58c1677115961d6662b04922f34819c5071afea546922f3e630f1c0175696d8d2c6ca77472f33b5d2dbb2d2426463ce66a1e9c43f8e3e2cbcf6c06b1cdcb9bb5cb42aaaef7dd9debc8e66458b0560d30aac20da990e21338da0474646ff4ac2fa0dc3cc901514c6d0407b68e338a47b5e9a1a756e23d5a015b3c14ce9d661a0a0d93525c30eca1c1136fbeb60295e3369fed6e9af820cbc5267afafd1fd77a5ac77f380e085b63f359b489b3266f8c0f4531c711de4177e97e569ea932aaa6a04c91bf0a8991111bf077ab4d2eede8a0b904e49ee2a779c2ed8f2ec6a7210aee73da25f8dc6b322c22e1f91af3e1356ce40b7ba3274dcb32a1a18af9e0204ec2dcbe324cc478cffd5077f77fd714a1b6204014e51457d294157d7b8938c041b547dd38a7653f2f7476e1ac4b252a7d893204d3132f104efe85bd0f7f3fba04a02024ea3979afe4a6867290ae28f256e56b309f8f066d4786927d7752f24444182e0f45a738744c962b8f92335c67e43ea04d342c9eed4b17dbdf9a18b35ac0e644b2f8d07c72cd93ce1d4cfac86360b59a39a29cc2e6aecd5bbc59b22101e73e5d129ca0c955059742c465876742000e1f5526eecfb46a59b2b4ee1e57c8520f3f847f0d90045158ca16acffa5bc875561c07a1f9fbc60440158b553dccc541446012ef1357a38cef7fc6cfe56fb8936feed51adb9bd547be1b8e0d7fa4e63361d0b93ab41d2468f4b499f99ec82d4758bf0824c46b9857e6a77cee4eed11b6bfdb5b37feb434f74839127da8a1d07485d1db258af1633e7d506db8afc39eded386f422e11f2ae2b28382fbcabb60e78a6b75707c6fc1e77f2f55c3ac4357586eac03e274df6fce93919700b46848aec4365e25dfdb5f1b4635c88ada69583624edb9725d4ac20e46b4ee341c3d359da26ded5609c7f72373bd3246487e63c29719060a225f36e0002450e607df998d34f58bf4d64708a5d99e78ff85af950570dc800db37f582553be9148ca7646d22962c7951a2bb205386aeb034887abdc067026a7d493f92e36d068cb4b8731b12e5d1ebd970c8d216c1ea518f41db6653d0c7013ffaf34e7382777c2def7a0f426d3b851d2f64a9d5e125f26fc3cce8aaec4dacbbc7e8f7147813f0f992a683ff1703edbdaa626f34744409c078a70b902a5f58085c03ec55747cdc12703de025e9b683a9da5b194ed3be0ff4c75804f32dfe8317365b31a3f631b852be97cc61c711351313eef5174859a165f3653199ec1edf3e14e78bcb5cf69ef9085227f25dcfef7a1ce58b83a293a45e51aecd9d18c1db8900031aee86416d9584613c194ce6ba48b7d55647b80b09b8344f8af4d7ddbdf8459471a8a06adeb505254f886cced9656973f3fb6ec4d14729b2f518647c2360e013ea40a6b3a6e93e6a0ea6c587c6e1618a4273dab3b83f70a9685dc652c83d6a50757dbc7302d672923d663a6594ce51e9273dfee07afaf583731bc435239dba8a537521e0db6b96cdfa99d6d8d0843e4932af3ac62edd6aba712d75bb27b1a0d9609383f9248cb83312c53ab69256c2b8f50072cbc43a90349a7ddfa3677c6de2f6c3c433aee4af45ebb93b38342280c6f8082cfa35e14914b72786e739544be3035072d2134d80f71e4df5f3c1259076f219481ae9ebe9c14c4ef57b584075fad42176714651bfc7c6ceab658270df852951abe93b154e095854f9050608475b613e2a8688c561801cfc8b8e2c83f0356d6c3738ee2fcd7047910d7b38c206d8813ce21d8cce280de759f345b408b47eb49b523083d9c3fedda7c287eeac1c30d691f00adff69de2fc0b048e7049f9cce3b17b30d47659d35ef0089a47e4b8595b55d81200c4c74bc0d056c93ee19cd861ca13ff6aa8215a777eebc13baa62e58194f9a0d5e144880ba6b4c35cfd30031dade9b570a8e17dbcceb4fa2e77d0624d371e49025c9b9fcd2158b4cf2516c3fa4f09197bceb85ce559a2d5532698e42f951cb155ddceec1c42d7059031e2288cb4cd4f46d76984740a3c1d0394c39ac54e359aa9add9fffeb5bdc44aa4a04824c78b7c2812bdce25964bd9143a2c9b5024ce9530e86dc44a5daf06039e82c29f408e07b80b63ba4d8beb65c2075c2d29e8a6a3024b12046e3c3a78b639791f4d3227cc8298bcd1d8981c6ddebb73e61061fd33a6db920ac6645f6746a7d264483c0bf8faf88213c2bc6385826efc42df27524ec6ce7c5894db2f6ae406a555541409846c13a124d28ac40ac4fa882bfa1f67f189d4c4f802e6e5502f53e5aa71c3f5c09ea6f3aca01b6c9ef457b82880fc7995de1117f811de093d2edd260b43b5b7559137cb3b74bb8e9a5373e89ec62d12a8e067c4a32154b63c9b1238f51d2714e967e09f936578595066b3e09e0ea900d79f41b2919b0808ac0cc533a4bbd3d0ee0c83f79d25ae27d46696f032d6595cd9898fddd2262d7f003e992c317085bb7cc83f5a2b82a5fed0b721222d15014c14f63e65e4a8fa8b0377c90c5be731c4214c1dd2670f29fe9662ce31ce38dce65b1746663f9e72f1fc0560f64fdeca2ad29cb75e36e9377badc861555bcf60dcaae06b67b6892de9396a5b1327c388fd1eacfa46d27f011a475bca50391d1c68c7d2b146b10b46086f7fe62b581179510c0b79ef3079ac44468788e79a761faf0d560e818704a45f05561c6d62cb6867c34a1c0e9dad484b811441f7cfcdd010a3c8d4822ef13cd6dc753d8ba0875f52c040e87ec868830c048bb973269ce25fff011c5750d9eeded88cce7c9d940f87c82317b40951e4b3d38515141c256069699a481aa9c269d0835d3a0e39fb831632cbf74d3d5fab1ac81a6fdfd666c6ab7df09d67b4c4108f945cd4a50650828c8a0da9de0e770aa15241ed31f5f9182e0ff420353099de48da33f16614e3c3642b2ed30079b6d5db4ed4d9b93587438e1fd9b4a81dfa6e22efbc65ab2aa6ef17beac3c86edc52c770120958f2b81330308d9b23220c7f624d203ef530c28b0258186166c890518ba81bfc206329cfd0ab8ed990da7e8cc7d0846ed5ad1b51a4d8c43107de1c48371f0fb3c1b27e8e50c0aa9cd5786076931badf81ee7f7c205a756c7fc9718c6cc1d70eaa2c59fb96a6db91a9304c182163b7459ba6252d390d329fe5ed8adb578dd87a9eebfc11b5f2ea82300c6c43a880af59841a3a069bbee83e9e36f9389bf3c4048a47636910166b282617f80c2366db0b2f8c66821dcd8dfe97a49a1461e2d62940afde690093f74c73ac3c6198f0b96d746b508cf12d8899ecc9a31775e7b3ae0fdc2ead58d3afbb10274642b2083889c7d54d336d564800d87b40bb071014b718ef65aec3a6064d478c0ac4e0f52e78b64597b0c09fdc92fb089b394ce6562ff07e5ed8f6c43161074c7167fe917313ab673c0da746b728fc33b546f2072702b14b3d6153db3b1b2976a5356e4cdfbde2813df8ba5b1d1ebb52fbc2de3c0be8a124a9ca5109d436b51585dace6a0682a7267ac9a3bd08fb8d0f34fea557f1a52b5fb17d57ada53adb0a9f3d60fc4ca2d714bbbd540d322e406e4ff7735abc42cdc7e77266aefa060c8dcb75df8d4bece5ae589aca6d0ca2b00198c07b8eb56041d226ad7bffa7a2f27c1d8c3995a473af49f881cede5007718905e3d9555a1f435efa8848a2d6bb856e5e192b03d35bc92ab4b0b2b7482f59016bf6535b591a9ae669bdf95ec69b9fb68d4123bf22a2346f30fa09e877ba0753dd6cd1539df83fc3bad66341caedcd973f989af858446e0d94715bb8b4c2f71c6bfa562e3c15644f685ad14394b285bacbf2b15efb8a22a05cdaf5916ee983023973e4ec96019a88d8df62396001462ca8c26eab4db7e6ab361ec42fe2ce6a227a470d7a11ad156c7b23deafec1fc475c0bfb0c398f30f4209183e55dbf79624e9e692dec663a4d3f40633e148e46ea1064f81b3260c7b4796ffc162307f58fc020128a2fc98cebae66361fc3e6943bcbbc31994ce61b251c6375def8212a519e3cd5787228d2c60692a6a8f7e4d50b53c1d52688474ce1f5691dfdcacd76c40c19c3b42ccc09e57adc59c52ed04c3edb8835b4d7f8c5c6a437552187c2e4c0806e2f429997d99661b3bdb6b711b357fe2cf400e1e834c8e1f6a58f0174f21919fb41b68e1db797e5db6f577d59bf74de7d1a401cc9a62ad05ae06fed855d1002943a87b16285d19d2ac72cb27980dc2901047f7fb35ae42ac3e46ec29093bfe028fbd38e7eb774a20a8a0275b3a033c7a0709853c0de06221c243539220a03552d028243b49c73f0e5c3b75f8e699b21c3adbe53397117561df920e7abaa7dd2de643883a80b53f180516d595aa750ae365380a314622b3af27636e855ade7fb9421d9047463f57f75293aea5c78882bab6cc8fa2a175471da4b6a5ae6b6df4f8267fa6c8ecbef8e522b1e57bf20e3b5d174df139f77f93515b947b27e22dbd78288d7b6fb3350f11278522f1f54e790a878a408f280dc194fbf5695a10544f7c3a3a3376e545e712cce8d164cf5e7f717bda061372dd8e249a2e21e64e99567c13e8a8d0a70ea730ca90625ce8243cc1188d93a45a100d88ec7e1aab51958e855be41738f0278b0a483c4cbbbf5e8ad856a0a408e0e5464a765cc0ed4d7886ac395a046bee6ba0061c87316a241465736e670ed5670a41dbcf44e95276f20f88edacf299e5cc28ef50df022b5ec697d4412266653286578925a93805f657c39605f76b9be45f57b2ae8649cdf0212634c16185bda0824f7bef573b0dea837ea8323343c7f42f153d0c2fd229c8fbadcf71cbcca387c7312784220ad7d503377523d974c9df7ce0e50334bdf96502cd25aa32b665bbe8ebd9d2201a198aa8d245350ccf63bc65b9a9357d3258dc38b38988cb4e0bcb2c89c0f3e3040d9dc8831f84f3b3eff5a079ae9eaa85fb92f0d91fe0792b96b81deedbc805e1d5ddb6041f64200d6c420047583f587c5076459a339018f9a814b5b6f6eee1d620fd6d951f89de47cff555546008584ec4b04321697dfed371486d2e8858f4f1106828099ad040c84e83d13cfc663a940f1cce326a88e195ba14dacfdeecb18b68fe4e82315f35af85dcb87f99cbc7b34863a813ca91f01e422eeefb6f027c1e48a625c3ccb7ab601945553a79326e1615d2f9cbfa269f2c376d7c055533d82efdc6d78d7a87649ef19eee2c84a7c8dd66354e0fa449bc7d4f98da2940bbb282807188bdd65b5d843e62d559ee5f47cf6b30b4c073fb1268b33c092ce0baa38ec803f9a39ef2b5721ecbbb775b8b72c7b11bf5ac3f5bc3a7e2b364cf77bec5363ba3e8437a60439ee14af15c0c420f280675e0cf5416913d2ade5f69c1a5b5f509e7fcb0e9336b1bb3ef688898c71953f8a3b51f96819a961b011772c53b79be93d9c419d5f2f897327c313e038e7f38d6a15b24e324502245f0bad03ca993599f5c81ffb9ad6931dad42a1f4edca63cc8003a13158d7829f4f8b60a7880f82541739b05d1c617eba86a7986320d07a49ebc8e41df2a18803b38fb0216f9f258ff586403de480625242282cd37d37664754e9e0e77f8868480cd1f4b80ba3c05d60ccb0d1840388a522c36868f6adfb137c3df80a6657db2a01651757375dbc06ee6d0bbea903c17a26d0f61f67d5ffcdcae2dc8422510e06e4ccca3ae29974d842caf900e8e5485f57ca643df53156711ba8d8b300de8480fce51f13f10e0d81b5c951254372226ee3b79a154a9610d7a27c1dcc62271da4e343220238c9b3b17b1ecd295c540c3d262d2e6ca9adace7681fa5258847698b6d9fdd86103cb60d32993b4d8b5a436bb7d787e7bc11b89de9b00a781551c82712b943616946382a336852025aa723154946eb7efce9f8a583335bab226f488cd6447fc9c08fcc188252a57eca994fa57eb6c0067f08cc982c1a3e428ece3d658ebc8a1f3eb5bcd52760f4be1400f049b617f6334c236174401928a6f2736558de6f7be215c4884605be28937e3af4e09337760d7985155b1ef3337b356aef6946005772675c4791174f7abfcae82d9aa73f6cea15a81bbe03df78e5f1de32be4c6dd21f8456961ed68dee8a796a23f732f2daf12fbfbda32bdf4de1455b53c85f56134cb193db1455932c5457840f70fa77fde032e7415b438b03fc6e7e8ef17db8f71493eddb3f277e48347745c93b893ae17b9da0952e0faa38075efb5948c72d68ead2b68c1c3afdcabd89b1f9a1dad0c239b7a8d7315a7898dacb3593006b86c25bf0bf8dec6c045c7d2966b8cf4daa6294e4e9935125b5287b9bfc7b1df53dbfd23d285a5db22bb85639fac2ac59c888fab09794a4089b18cd17b9225ad8bce0e6eafc0a702ccab026abb4f613ea4b18ca9c38c79d51bd5ce5c1bcf5caee11961fb57e266ed81ba5531305aa5ea9f4c5f90410402383210962fad8bf9ac24292cf6107d801392933621a9f5bd1a294386e285ceec297bc3c0db52c389c8a315482ac1383fe31628f24bb37d356b41583f33ce54784a9a2830f30d1479367a616232bcb887dc433104e46dada382f0e72f940efae9f85263e5208f1421446b457a2ab1f38ead416fbb7dc3233517e92e5ec58f948cb1dba9be8bd8a857e842e4e2ca09416b7da5ca22d26fe46f16e2bae9c6c7b443a53c8d2176feccafcf1ea30bb0f1a0d6abdf7c78f88deab9a2af008ecf598c80c76dcd3a13b467a308e57422d926386f8aeb60a7b55f705cde13578efe2abb92d97cd8866ed1cc54e02bf54040730ad374b5b2c29db32946591e14be859a07ded41206f1cf5d68e9cd7a717de1132175b211ee9e06751a22af0156d42d3e99abceb2713dceae73c83bc894c4ffbae76d8f031aa4a561f31324519ff4236363d5148a684204e9a5b8fbaaa133925652fca3b85251cabc369c0b3842d645e35bb2c6b2a195c18147053efbe1aa60ab92dee2c63b5e145bc60979edaefd110b8153c85374b17cfc95de6296b508ad444d9ee64219138b6b56791fc5e4747d1669ddb33e8d9cc8ff314c8cddf6c8fbc70985bca7e9f22641221ce843eb38a4d2ef7527c23b7775590912882f81d1f0c9ae3b70b1f5acf4bb1332dc64de3af4288f4d4f00826c6afb4308deeafda071572102346b2a05410ee0c3d8fb7dd3d92867c5c88d228e0054d3aa02020ccaaeaabf1349a389c0ba009b39fb59fe59b67c5cb2d5c1bfcc01abc09d6e3e0b296c7ae198c800b506f14fcb4d5c19f4c13a2dbe2573ce85b995c2feb3d22d01dbaaa23f41b6de58638a28a986e349f26b9198c51958263e4555f440b67224e265667f60af579fe8aed60fa35546568cf20ce8e59cd7fcaefe9c2785822e4a6922446307dee0c5c2b65feebde67ecd53b845282d86dfd915c0f7810a48656dd6d372dc1a876abb282e4bb1c0c816edeb078cd1fe2bcbcec8fb9f4d0482f204a25c432a4be8421ee66d37f4892bd57a4985b479176573f88576dd7137962c93cb3c979b3cf32e9af406bf81c4f6643a0d4bab9f445eb1edbffbf03229871a16a996866ea3ae9cfbebb1888601c4cce4bd9d13f2271d982955a939bf41dceabfdd11853197139bc1d4937976ee7ddf7ed1fdddb18ef37187b050a93dcc749553dbcb48e118cf36a001a8ae89e71d312d78168afc4955624dabf1b54315d55295c76e27b1861b232aef7584c11de39e9a4a53c55ad8845c651a3f867d98d1139f6b55d27f3b0772c19ab0d3ac99ee63e06c0b054a32979a05e06170283b4151b8e06f29a6f6b85d36eba9924f54dc420c601c8a1df3c5ceba5f9447869ea13bcaba77776de630fcc18f8bc225302bf93cc2d7edf16078165f714e4b72e6788b3ad9bf14ce8c0cfd9cff5afa0c00554520db4b390c2994989cdeb81f048e2d5a6829c3f604d8d4f286b02ed02d911ed058e31e0a3744c5e9693d71622bde525a41aa755dd84b56842d592cb408cecdd5b5b8e846dd50c23eecb9bd333588edae19df5d1a698d8c3a847ba90dbabe72cc88b199f646b1981c959a1a7788631f62aff71ef4d3b5e4531bc0b3cbb28c3d9fea79db34ff79b74d2ffdb5664d4199421a59f12c61744609e1bcbc53eb7bbd11eaf4c6b30eeea4e9b8cd05b7f5f1131369627c9cb87bbef2e637631e55213ce711033cfbc29e32b93776c69cd57fcb693c6f598f1d004452ea411c067a61e5f632821f981eb78ce60330ff0f893400b90414a619aec32eaf45831a14ea6bfdcdf0a4d2d61c00eebc430c9975fe020c6be0d0e317e0a90e8d609ce1820c06a2a2293a813d32192c8e5c1f123dfc04560c372a9f395eb4d42f145112112be3c8b01fae5293d4e5020b9429a115ec4d81361a0fc1347365db9493ff72afd4901f6d76a9b3e5600a8cb35b1af1e4ab0021b60b08e5073127586778c46586e77031279da237d318d32a1908c385003cae61be00bb68148a33cba9b6a6b775494e550ed79520d807dc7c5a52ea15b240b372e338371fb6c5564ceac62ebc7aa1f2419844348e75763dd6e88ac7293f38f5fac894d608f1890aae79d15ba87c797f1f6ba9818310c1db3b3842fee96f16c3d501e84c12f6dfc99995d87cdd6106c67609789cbd76e45248f7382e75c748cd1db561a6803bacad8bd3a5d390a006582ff442e9a7fb8451ce2a8d7552d4870363dbd434b0fcbc605ef7edb6a8caca5628c38bf8a62094a123b28cebc37b0e90c80b0c54e4b6443a94f70bec31f59b975630522691459a1d7ddda3302e3a97cf297f087eddde32a22755d70e2faf6bf5d7a8524ef41fd588fd53b2c5f6dd9674c5afae08445f8f72830f909d42e3d98a2009ba26f48b036fd8db4c7cd2adac892c4a81512c5302e1e54265eb3df0bd30a1f9ea4f600d6329d3ac1cb0ff0749034de9511c9a0b0403f8a3d74e3264572a6b3c6a98a9ae9f38bb3651244a517540ed32517afcac445d207749a999ab1ac8e05bb5acb17e88689e9a55b12cbdaab3929adc4961bad06b26936b584b9525c6213eb01d8c0b080441a1e841ae2cc26a01ca1680069fc2fa2a487a9707ebe8d68b1de04d028be472c04f330d17b24dbf4851905c3cb544d40ef700e456d567f19bfd9717936c86cfa37a34edcbf390231fb01c0961132571a740f50247902c8999238164b0b8bd10cbe7cc2445a864a82123320fc575b735f42250fd3d040190a44ca19cdb9ecd434e186b3aaea9a6ff5282e076a9c0e6b4b7ce5f75b2ff95eca5f8b63479599f75eaad69abb10a2d7c8e553d71251ab1d225ab30b175124897bfbbfa8d26b46c425ba0d86e38a81615cbde53d6ad70a8fbdbf612b0de4b2ce678d5b6852417911f5032016f8b1b4ce5c55773fe0cfbdd2d5eedc9953921442cc7eeb3388288b154d52934c7dbc1d6b1ebfde3ccc81ca97bf097aaee14aca635fe0d4956f5950f2de97a2ff9e0ea0b67f78a310a7494e29e07b01b797cf96a1fcb9cd1f326f406f6e8792d08bc31725811dcd9600a1eb968b3eec958112fcbcbcb5c638c8b118ad408d13978257b862c013a62ffb776267d6ba6ffd1dc4d02fc993b4e0fdd9d3bbdd1b36f4db214e2ad1043081466c9e64e0b435e8963a8c473839de7018c5ec24cb8a4a240d0bc34b1443f8e489e39f4c96cf48a256aa0c851b0acc28a4b3f5f611fceb3777b0f57303ce44e44dbb25b30b60d7abf6c38772d575b3364f58afc585c4c6d091dd333f3e47c3570f75bd79376b5a873297f92583923018ec7ad0ad41622b29fabe0fe9b04e27a6b6e55895845812f93f46be59c7f6a2fd6e3368174f0e515875c465df08a496cd6f7bc80beffff0aae083494368d544532869774cff40c0966ff5fea3171c0287a62b4d6842f11e3d799536b4afd5c50d7e1f0656046356d7293795fe55bfba0df7969b0921a6b0581421aee2cc7473274ee7ef01f1f287d2bde65e8f75fba216822a01b1c5c614a6ae5077bb4ed1015049827053a5754fe319a095ad91e2fc89ef3d7074b2e5dff5169f8c2e171715f9e412e5fbb6d68344b5d2134c090f8dd7c864a1c59a31c4ccd4c401af3e618046e1841d1ac7377e155a99fa9ab5340a93a909f9c843ac21fe86c50dbf7b64ea88efb012b3ddb011dd75fe08a161d222a881d752e18e1ba5c0372643444932468939e37808e4be3666132ed965f40c05616b7f6ea22e1e06855542c9202f167db48f01a741b8d8b719d9328260c0ac00b91af645b12fc2b3895fa886a503f0f94fd3bff7517c4138d102db4bda89f454a81a87c609b7682b860b22113400995600db3b536c54e1052625f5ea7c0e66a2755bc4ed50df52c9151a351dae21902d8cc207c87add95498e076f54d19af47adddc1d4f38f60086ffc7c5c749228a72fdd32f6475ffb28aad676e20306db46d0f6595f48f65adefd648414669077d3292430ca0fe156b2455336303a8cef2c8a3437d6cadf76b5e75e41e4bf9f0ab0f22199959d40e85fef2a59e4e55924af996885e1e3677dff6af8e66fbf7015045bb441fcd6961b545c28f37b00d6dafe302d0d640a0ce52b928137d90adb968d6308f8a9c4bd508d81b8f664df8842f3f31e345076ab34621504433563b0bb978b1188bd430ef8a69e9bc49e2d4d8fd678531add3b8dccefcea1e0c19f2ebdfa0608e12b60c90ad6f87ba5a20f61d6eeec064b2fec48e2607649ed4cc6712272cc48104157ea4df9b5ce3823d834e7b3e472e806d69826c9e02ad297fe34d8e427ae3b86fe173e3c2b4d5d8db51170813216294bbcc11475183342ffd488b90f2fbbb47f19dec483fb9273568f7fc19086684ad996df56941022bd6171abe2e9ea9f9e9d005bdd7365b44722251e4c39d4b2451878d877b5cdcb97dbae4eb6fdd2fe4dd6189f7394ec6fac27837e460c9028a478187a98c6691b585b2cbe10fea5e48ce44b0442990352924ca489ed1c73ae2e9a574f08fcf8d762a48a882a1a7c08998c44c1e49b8198a46626eaa17332368a7165e1754b8b6da22b9adfb08693016bae26bd2018ccafe8ad28fbfc7e43738775d7c5add23305035acc579ccf7b07e2a59c3e47caf06227fc0a943319c87c861fafa65baff119a373d6ed8638cf9d77d85dcc78bff87f7f92bc4b2e8ccad558e89d51199a2e91931af66ed4ae46b31d930c0c44e585db2f499073e0b09514494f9a9d80240e03537624dfc0b1aae7e19eada3e71a61a1cb858e489702fa7c03ffa42e58d2aa680281f49de85940bb567933d0e02e2d518440bc8ebbf13ac55da7de382d29093465febd2f1210cd0147fea388ba9b7a241cd5a7fae3790425136ba7e9d8ef330ce0368c289d16088510c16c068da0d02a292f1fbabaf1c85dc6f839aa5f580247b132dd88191b11f6612f037db0d8274cb3fe2ed52639e25c6c8b0db68748cff56c271a2fc6a350e3a101e5a5f02a71092e86eaaa06f3bf480181e7385ba3fb6748d5d2907eee2616d32549fb473b4e22dfb1c18998061f641f4e4497417a55026fc71e5ef60516e89e3acf62bdb18d3ca765ab4c12b6e27d0c7d63af8bf56126f29efa16731000f1812640c0734341c2cc59d6ebf225c24e828d17bee14c68a184138db277c2fb06fc57603bddf52e1e724921d5a94e1038308b4b19c7c304c772e226557f05b684328719bc324d1b30a7386c0e8589490840014896803910ba9a07bc782f292c87cbb28df2d748aceb5c0dcf1815bf1a0a968c186f9f0565240b9800320e7d591bfcbdcc7386949f5b4f3854c565b2cbae0ecaf3534990faa62d10b30d31202fd6f3bf5307869d12924e07a88ca2615389cb7709aa6c029b4da539d8f70ec9f741bddaacf68253179bdf8ff654f5e241531fa8d58e54a069837d0f68871dfe32b4d61a231191b6af58bc42b0e8afab30ab58c4fdc790ef7d381562b60e6e2761bc80401493f632539c75a369e1f4abc8fcec46c05e90ff330777720a264ffad57a12f3446b5fcf4089f449cee8831c9c796bbcfef9e5f149f825b6b0e1b5d58291602c7c2b8a6496df2aa69f47942272984308bef898868ceaec1bf340d1dec06e8d8a1edef11ecd645d5c68c12bfc0398b7b99a1eb95fc98cd320088cb611e21ba726fef4b763188e61c7d4b3001873d4e846b0fd287b155ea890ba770dc44885e74fea941abf649e48f1cb6990fe052efc6060840f73c5b27de57d3a58563575f3e61ef35e93425d1168c3861eac1b173392bf25c211725e88a14d3adc827899a27381dc96591693893046bf05c415c011f71c1c5c015666d49937462726df9262ec32f2959c0497cf0d0dc3a987345ea6c1235ea17d19d4535783bf9c36f54fa290283919a6b48c53cbfd5178f7d356cd598153dd256aaa4ca846850e7fcdb6b347c64f2fdeaa6f9172bca5a13b84c82e7c642fce501bcda841b0c4e725760dfdb3763df4a9a96bf5e4a19c328b1f677daa809bf8cc96015395844c0d0057b847302396a6b22cc076cc016ffb14875d8fa78aca737fd0f1b9538d251b228b7511e51f6112f60394f682448d3b734c8be6f6b810bccd806e0887abc34fded9abfc5d51a6cd07fa6d4ca548c593c0e7bd96b626bce8360ad9788106f6b925db997fac3fd9c0f8724a9c99828e82a76b68bb3df8c7faadbcd1265c1c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
