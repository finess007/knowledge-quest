<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f65d64549c6c32b7fb09525e96472e94a398ad33d0966a58a5101aa579db21a2ceff4021cbfeeeb49fbf3bf2864ef75464cedc0286d60d3f4f5bf1da21be83a9282e5466d634340092d545cb11e360bd666cc1872571e85f1276217a7ab384a53fbf75629df0153e627b2176a6006246c0eba101cc12ace671e39f8d6be3a3c91d83e9eed861aaee508957961d2f700401d0a14566d70b594bea01225cca203927e52aa3d36c287d9097ac6da04d6a92fbf992a635b100079380735abc6d14d8fb19a37e076ccb8e69b074bed49792678aa4878504c4219b8c13f7c40c4976d5823a0df6e3355c71d7d8c395d73d3d98ea7d247699e244d153b454b23388787c385a8d53b20df6fdc000ab95b4dd7dc72507d0819c3847a8e4c312e5bc37387068a95889b55f4aa9b4581f5d1914dfd88983835fc8d727f881139704bdd69d333d896c9f1e4d9635727f97e3a92dae8c38f88691c60c5b99354ef3700e2f4a51e22ac8eb399beca31b418325e0e330db681916d59d0aa3e882db7915c14da5f9df701d829a1c850232e42eec87d6710580b847cf51b171ec74f0ad897fb49c6499fc55c7488ed62e880344a893743247413ca08b818af1912382337db1693de163a9f4749e7a3c2f6d0b9425001b3eb1d3ae56b9df755c53d7e77ec18e9ed4ec0e883a80da655629baa5dfcebe085e63d90766b62da56ab15bd3c4d24727d0d4ba08d0117ca14a7f48f9972f295aae65be5d2b081b6ba9234dab61f9462c76403f04530e4f45cb9477e503ace17aa0c8f989cd7b805e9e2edd72b7c45464c2f447563c01a1812a847a0442c91cd05aad407e9edf1125d1f174e9828711f9cb64614cb2353260fcca8353c352a60cee42f5507a6101f4f6122d729a54196918888e213d0826870c49c3af4f7e747cecaf8cd9e6fe76f251fe4acb31fcbb49871fbd2a5d3873b67395e8bde771c00aea5fbbb3c9d5a7fa562b9685673b8093d81ac2ea9f130d6a84ab8df13d7f7a399b466b10c727014de14b750722a83e61bbb3e8c7db083008950d04b8a0975bdd6a17bc0c62eb2847360d0675a1c8f6ed3628d0edab7eee1734536a692db9cb7697b970b031c340659c62f031a0f6fe0a6a3e60a5fba69e5b0a9a07ff81a6d75cafa892be87d8973a59f2a4a6694179ab51f4e262b0ee7069d375cbe0ff7651bceeb2e628ff16896631e38ac3667919c7b5117f6066a1fffbc003b5927b6ad9ae89aaf59607fcf16e01a946135717a3e496d0c741a544d550702ebbd6c84cac8bb4b03aac3d23a1e1ed809a248acbaa8ae98d002a757f8fb92c884f0f1b2f019cf5ee2a110c0d70b2dfd57d0534f6872d6875c7de2b04fb1ccb362b02af16d6a09f3c51df3a592bb6a56fc593b2662b615edc6b7494e585227c734552f5d945057a1df2a6ca0d0ffe2c0ceeaac913ca247cf395dc33ef2baa3eb5076e879cef3f9556b456c26dcd354a4eb920a2842f98ab57725b758227acd108225d994bc42fb58d9e9d4da0a777e21eafbb1be501a0851975907168f9cee4a7ff7f9e0a40b06b34f1a3d1f33db79c17d35659bdc480d5b5229a3141291e2f366eafc59ba1ee016c8df388aef943b5a8675dda3eeef3a5df84e082314f6bc31f0f9d8f9e5ad52489d87d93f246bd8783f0a1156eeeb9e524382b27d265efecb63bff9c6e7026f6eeaa3d59f562fc36cc9d2bed125c36e14390712fbc428faa9cc108e8546a1eb31b69a1ee5514f44e257e21f7d9e49ac24529c2e6edf201f2e08f9714ab7ef76711041f19b3af8de2b0f1b3c40e912e7b28d477d6f3d37810f3b9ae329babb10d5faa0695a5ebfe2f4d6d1b96f4d307cdbee37e637d743df84d97c2871dd2a777c81916bc232f7e32f1c217ba45a5946cacf113c60e6cd8f65420e512c9c69d885128013f0d7e6c170053d1b36f772eaae3d5b984df00703a402e964ad2e8303fe935dc78682fa4b2edb0187c989392c707e63c7fc185f769f7c575d3eccd4a04b5847b0747b727c12acd62e0925d6ed5d82f1f316de7a5e7a0a69702bc308447b4ba1add7d4b997a1619f2eb7c6f1476a44c944540c0f8b27597bc7ad463542059ec1a75a0b10901f72e123b1b7e6308a007584701d0c52d0cc80d5e626962993327c255e30690c6417e138665821da962991889d06851ae8a9cf02fd68c92d7ac114c78ef3ee40538339e76fc779164974d3ad89f565ac6bf0e0c4066ede70cae0a4adde3000eb2b2b2ab2eb278ba40818814df9dfbdd7a8a8b309fd2720cfe7b43e3d5a9b97b4d255d99cbbfee74db0b6413dacfaab271aa45b90d35ffce0cf650d3133045bdfeaa0d0a9496a6f00171e20ce73ad2c64d7e932846db8b7b71952f21aecd6a8be5957ce20aa9313d5d6f6c39e4572798882235101922acb555a76f06cb2c8423d644b67d554a4158b8cc26880adde69f25554ff4fb7ecc70d7fe84e206ee3095f6bbe5f26a7d2de9a90216ad373ccb6193c7da434ecd3c0da3f67ce8526ed9c128d7561ceeab2ff697b05c9a0330fb4a9bda2c98a99a9a54ca6e91ded92bd76607dd4740a74d7fcebc19fad356d0512685237e998110b7ed73386d34a4dcbdd3e4b0c3d706ef25a177e57e4c79998499fd27f414fa9949e4fc866f521884dbcd8913601ab865f6ff336e74f29199ab1bd9f0ffaf2ff0032a5a25f1fdc73fd8337141a3e4ca4f39974b0973d6da22115f9667bc1d1d7538f663dd85f2ef98c6708a595511e234f427481284f05ecdc8c41977de45527e07c19d701f43100facc880005df7509c68a81be4045848469378656f7336db326ab37e9b14f0ef30b0535d81d4e200286da5a8ebe4b4d9e75cde3074f92f99beb9b13beb8f20002a25462587bbe26be11fe81ca2867eae39c2208902bdf11c94031d102c1e80c22b6d0475bc8639becb1487fff288be6970ccb6c2791ca9a69a293202ed23983a2b739e2534257a37f9365e6d67fd620981047834a95f4342e175ecc8e809d9e615799b21f024f118a9baaccee7a1aa42cdeea5b795052e6174f2387169d7943c5e41adc96019a6eab5787836bef8da9982df657e82b9f280e84eae777fdb284b69d16e6cb01057f79ce642daca4b70b1ad0a0bfe7167804564eb5f67741a2480662bd7775450056123aa26c6fa3df2271a10cfef706be54e73ae744b92189405a489858c2e8ca918dbc569603bf5634173514990188c3c76870580982aa2957fcd04fd69eee23e7a02bbcb0eaf04499925ff54476dbc6532cdd992acb4311ce7af7c7ad458b02bab082ef77c542823b68d87d67bad00da55adb06ad271f6a1f859bec55d854dd1c55f8bbd3a3ee4f0a02926fccdb1462055cdcfcce5eaf2d8d6f9e5c338ae5f2b840af5dd74c2945c2537a9fe68ef55e1281792d1f92ea036baddd161054f593a6b122121245cf4d9df6528d1a872569078dbf9a8bc4b2e00e9e07eff89a6028dcaaf1c59009c156bbf1ba14689f9af72d0184242d4eb152b580f3c985aed4286b74fc337e8099c6a59016511b51bbe27a5a8b8239333408fa3223288ba4797370b18bf3dd06ef8737a9bb356076660659f4c25ff4165b8a0d085775e98f71efec593927ae404576239435f37457f2a88b75f21f3830fec74329e5e81f40e21c4b522c1e521fa810e760100b417b90b5ae118f09b3b2c6cdcf0bd98eaeea0649483e42d7cf256080e09ca189b89e7813b4592e1099af29c4625698dc9a7edfb54e6252bebcb11a6aa62a17a43a31a07f57aa9e884a5ab931bc4b8c9eacba43eca6ae05795ff47983144684420843e9c1f5ee332c0ef87c8382b2b9e6e9b0bd74dcc7d2bcd304afb7a1899508eccf57d60b77f0b23496918371079c1a2cbcbbbdeff7e3757486553347af03866f0ce432db76758c5229cbac459479a772d65cfc4115ebb7edd9f27dd3c813ab1ab71ff4bf0a6c7ff9c91cf4025a9a47c78a7fc809b1adb433035010f18aa0980bf785aaa1044283881671d842a457b1728ced42afe8064b57e43c1cbc0e5a82679f12a7554a5092dfb9a59ec6943e3cdabcecb35b0387e8fb74a6512325eed1abfdd169c789a82a3b75c1ea6fc1dd21a4d120dcf931d1f616ffc9700165c0e1f7667e8c82dbcb72d48568562fc812bd86bb001d4e7ccef2e5fdaa26650fffbfcf2b9a2b2b4cfb8cfb32faa9331e2e1cbd3bee6f486e662000ea2277147486a5425b535b252ba6f48cf4ae6cd5f2f3a3823584eda40c163fd8827c010ebd13e783a91ce9ea53237eb8d6149064e450e78e1138ed2a4a8047fbf6ae3796588b20de33fc1dee45f24146a6b832f1e7585f07472a99fdc5f3bc05abc5078e2c72e21a80e90729b1099f5269d2a06dc7305ecadd6aaeed5971d2bfb6359f8bd861c096595c4c88bbd78c9ba1ac2285256332f5e613f71c7732edf48c36db63d5bbfb22ef248f8383ca5f134d7cf4cf78187b5259ea81e50c4f54da52207579ba815560a37b166c3e1eb8b4c3483a1652d181fdda3165bb1d18000f8de511009acffd45ce6a5b79f9f672bf25b6e199194f7fce690bd5b0e7beebce5b062d3f88882a72a8419238b0889fb496029ce7a5f97f1f6df39ff497297ca1669b9d96311ef441a9c9ee35f19119d737234ac20681cac0c14e460508bee727fceab2d14556694aa77615d5bfda98ee4bd34b341454520b1e2b892de7ad8d96789fdebcfae7763d71be88fda8a158b147eff3ca7485ddfb7db5b90bc43e0d7ed38e3102143b2760edab5a0edb67fca87b27de8fa93fef46630e0b81e6c905f2909a9146bba9e612c43336492a7a5adf54db5902e5b7a83c53fe2f35102f5d64d1345aab5ca52926e75248fa1e9f20050149d484e5a6a025dd4585a56de13843be655923405a1f42a7cb5a681f4e502895e464b41d2c1090b3b8ac35e0d9d1dcd82dfee84c28fa15d7f9a7a208b71341ce1700f032ad85ebdb7d8d7fce12d4543514858059a50bba319390215549fe1023c8449afe6b5bdad373fb5c0d07cc7cb2147b7974f520a909e1648f4567a3573541997c2e06aef80239217eb2a268d9e5a54eb67946d9782c65f088c72e86b35f9d6fd0240dd923b547c62d3f42e55a38f4d5df0b0e3625531c4497c6363da9c2ddc31c8f8a71247c1ae4cc580d35d6c8ba989bf18aa3910517d0c83b4d6d487a80c3748eb541fdc2ab764ad009eb9444df459c315775a58cebf84df741a8653d43742d31f9cfd98ccc3a3743ed068d3110da89f1076fd69273f6716919a91792df018ebdb94671b82daa10167d770a7a31d83be8038419d757278401b87bf7d1a9e6f6d557b471297874634b295d8879454622cef2ac2169374d1c8b3f027b28ef252b47d4b9cfd360b3f058c6e676c7d40104fb567f9f440647d75515d5cd7f1caa358dc8f668fb26d81bc0cb04f99f6a5a86c414f2217cf1580ca42d0d5ecf51175e3e6abc8589b5ba8ea0f57659523d7b0d01030dc432123e3c98c0941990a07db07cd4c4d709179720c748905224f137e75b83bfaf40143884f501f7d079da17359dfab355c65c5353e98fc18d3c5286642b2ce106419a153e0a24d08f3573459367f6724adac9a31b545d9ef5612669f52c588ea7757dd42f07859b4313eb622e368d24fbe514a69d9b48b640df162a631aa3899133952fe9bc0c073f49ce09186ba76d083403af179fb3893936ee467ec675427ed8bcc6a126cf3ee1a188c38727a2420a218ca7696db5a6c4344778ca83e8da229e72a4f65d7d3947777ecd8662d5a0972919f57a3d0947cbd77af8ea6cc14c515ce7c9737456dcd96ec99c5bd57866dc650197bec792514ab95fd2f99c396de1e861b791d4685211653354cd82cf1551489af5e0d58a4e289ddfcf3c8eaeb1803841e4f2d6ad0a3aecb99fb68d9849b3a8ff7c3c86cdb0f638ded88929f99cccc3509e6850800c7277b63295ce124918a1f1eee5bd58c2be941fcdd1c72e15de4b1c6b6c0f8e517d6e7a8a353460b23773ce3379c1912c8280e6e4e532ffe77a8e287d5ca8bea1d22845d40f762d23a7864033be784b189fa8a703553ad8f182165b310aed93200f6c1e6943f0daedb3697d55cfcf7403d70114aa7b14da7c4a882119c87a0c7d46944aaeb40bfc28ae958ee3f7595ba7938f29658c9b8a717dc4afd8f0c4ac7c907cd13474632313e3009127b2e2086039c322bd534689878625001373a22ac42ae851186e2e010fdcbac616e0ce723e6bedf631b0e09d0df973bf1f9537422b7e6d11580326014002ca73e3a7b2bc4233dcba6b44d60f7824f0389c1d6f0fcb03df2931bdec58c51c1aec3a5fbb5494425515104418a14749951f6d7b45953099cc0a1b73fbc29b09d8a0668e9279967b4cf45cd2f3edb7058ddaa89eef68ae539a49f9372ea2e81094404fbe2535fcc6d9404e9f6678a662c58bd413f0dea8799e88fe675284285db2094244ac061ff25460425380ce1acf01781145b4ce9614e6a23ac7a6c41b317df7c3c411483575f2e3767bf4523ad2439b20cd2ea4a659d8d0e5a4ed8fa98513114bdc0e3bc75f66ffa454d7a6fb46e22927b647f1b79a487e9d94e04e253fd7f71667451a51621a90838e66d3429887effcfc0aca30042a47e249fcbf78f977167f42d42aa6d9c2c562256d23bd144b12b98249bdb21f2afd53930546d142893c82111717842701031ee3956b010097407565a4e78db5e601a5ff078467592b805d184d1cac5d5e88231e7a3138a7a5e6ad9886f072aeb729089744ad699c91433c29bdf084bc32deaecf180a7f62f62d2424b25c8d110e26fb67b0b15f45f282745427d472c873295514fbdc6e3171345fb8f1b63b5400d2ecf612f50fe192f6db039d1b9b366600304b0e26e5af57f25a5be9feb6df9e403834eadf78f1a0d88260732ec8dfa517369b61c678acd5a5f14fb46533522ff4d7f8c7581d784f897f99c7cb891f7930d286a611a9ecce19995d59017812861bd40998079a7d279dad2185152afb204dd05dd386c89d2831649230bcd2bd97f4830a3afcca15f3b1aa45857d90cd43153e9d6cf882172973c1b736915108fc53104c005bb0bf86135fe08e98d3e264f17a1db9a9ccb4a351cb7902b49d4c0f9ed61294c4448fdffbfcc7ef42b647b5b174d462613a7ec6cf60fe6741bcb45a73d7065b1408cdbfaece188725616e9dce999891264e9ebfca30f96a057c7cacbd9aa7abcb784b20a4bcc685703368e8157670723a3e4d585eb0c7de0bbf48a38611dcfb49980d30713c67ed63f730506a85c5ec40c17afaab3f549f40407871481225490e90526291d111ca44e970638f333cdc224ac22c9db0605d0323aae64b1a84527c581d874068766ea2bb850bab47e2a4e68d79b6dbcf41f9972e10cada9a8bf3514249b665817ae0e6d77fd883d1bf39ec1b5f66b48e07b2fcf4f55fb19f04c8d5166e2d0b2481e0862b51722d4b8ee69c8c3da578a875d64d42d33478242d875bd82d57fc3f2ad22ef5554b514e3ea49e948076ea8ff553669a63b5c3d68335f2c671f138e62d090e013f1b892d594e0103715f850f7cc51ddd9d358ee9e80af41267db1c5de8510dc29cd76e89ad773a9d986d6ce6a207dc46d743ccc05aacef4220eaa81bc0eec1c0d35407a1c4ea20c2c25e6d1e231d241ae954d498baec3ae61dc5059842f096cd15062cfd8787c8cd7fce97209db6d15691b943e0a668fa9fe24d40884c3b7a72eff1b94b83e000d389f57515a90a5cb31a889d9694a024dc2b3e74a6935b1459fbf686ed48db8bb575e5151791d71263a6f67781472dfc23aa0d60c2f5355e70634e1e7b6898815a6efff260fc0334c18b592021a7991f89be87e892c9f8b0b584be81ff3db4d187787402d549ac047a18c6763882b2783e4888942e79927b442ab6521c0c14bd47e04a3b95276c9892af06976febe21dcd0ce1c7cacf2b67233b3b43355b5f269ccf40df2d754ee414ce89bca6f13464b694e835bfd30130542a2d3d74e7bf22d16d248416f36ed61edc4293f69b9df423fab6762229b3e26515189d3dfff0389b311ddea145327cd755cdb9049df72d07f9d1121c6ea4aff1691614ba75e54f7f2af970863631a8aa30123fa2016253160bd78712d8ad42d0de92901d58158ea430de5a1ff17853ae6971a0769fa426e2501b6663949de698e650eb7614a7243a308fc5d57c251669899af057e1e4683206e270db4f3c31e0e5642f7e864f711997141e1b19b22bd8791afb13041e4024e5a61aa3178010817c417c6b7653b5b451155ca84ef020d1bd3a5d3dd98cd9324bbf230dfc40d8e1d87040f0d69ff49b46cf771ec1b51106b7c316279fe28ef951958186b1759ad1c7eef494c7aab0a68c6e314daf64dcd0fe28efae11b4871521b806569142ceba9286ad810368e38b9bef96e674bef01732d74e33905a6fd5f1dbbd623891d0d880e8aa88d22ed056528ecf7e6ef6fdea115dfc7c668e8247f4c643b13774f8b1f0b7adec32380d8aad43f7e48b3b8948b06228332b28c839a54493070351713042bad6f72704a25dd8ce525037ad34d1b4b00fd6cee2b8c6e459ff5327c31072d2a352319db02f61ec9147f24c2e73e46f2c0b52967bcb45c451deff5db20af27cac0c194357b055fcc13d73ceb4f2945158d38e090a5dc2fdc3b85f49e96f7b12111999e01172a14e1a76c376bd2ac25d391de24c45bdf3f4efc121b873f48b53378eba5f3779305ec3e448ebb7d85ce53110138b3fd0914aead4ad03b88f8db75eb5fb268408a9b73d1709851fb16e090336f75c71f2468782ef9c86678b20fd62eabbe315af8d0680cde8d9bb9efaa1a0fe0f627eb68e8abd0d5c9d4cf2433b12a34cc66e3430e790ea8d14b6c2670742eabcc7dc0e8b5ae65a8d0fc4a0dea69b3f65f4d60136c5c9319607b09990756d29412c4446efc00ab0c65cba9ac828f1da4a1bb155b4ac73be92214b71bed2219b1dfa2777197f694d4f33a2db59c165f3699432c50c384a8e3301d96c3066f9eca10c41a3cbdeb102e5eea13f7386147ad296cf65f8d86239460ca3713d37fef8c85bc63683753baae5884789e20ceb4eddf20075259d2818be51298797334708d11cd969bd08b17ea6e84ba6fe4c75342c9f34a16e2ff29ce8c40f5e9a5a99bc670b8592463c6f853bf1b7c7c6079b09fee37500914e1247446f5946d4202c416a6a3ef54a3208e8512e685e0eff6235c187cfddea20e4a5cfe4942598e760d36c35493b8f13d32125b8d488ed0dd3c9eb939c56ebb29eaca147dacc8cb4b25c1bf7ee32d0cb2b283af9307f9f469621dbbfc325025fc0fb4e8efd27607a8f6afbe9d73fb8d33ea8d1636f9dea8c5884fea32d1e01d7507c7de792cbd3749bbd6040cbca5021050e41948fbcdc917163fabff304746c666e1d23d94fc9b338c2c74e80976d126dba2f1567cf3756e3a8c142eb07825762d82f87e33c99ea8c94e95abe731fc2a460cfb57e26adf34df2b9d7b74529cbbd40c9e34d6ea93e0abde2d2644b245545a76c4815b92811b92fed4957b8de816a93e6f9d4c5309255d68801853f7cfcb9799db9f39462434b3e2d7fc855628209f67f56568ae173547ef07c7f9e7d1a8a5c94d1ba255f889ce9c0ccfd298ba934901b89aaff0492b948ec95182ac70c3d891c521c7f3862baad5548da420b1f2a26d78eaa871c2ae6acc1a9d8f7d95e170fb95f73eaddcfcbe6296b891dc8d72557df3f2fdbd063ab12252c2ed98eb226015443c529eac1965b20b8f061c588700eb9ddbea160edf1d647502a3a920e6649725140bfffa3bb4c9fd74da9d44ed6e59243ae025f713414a0df981cca3690c8c8d806fd7499a1e72070dc9092f9c8bbf08b521face9660f0e4f8ae65f1fd9cf781489096ad8a26a8115593be80b7bddd66bfcdaab0fc71751791d48498f1f30eb79c27684a3661d0a4abffc9b3dbaf7ca8433bce646ded9f0507e4de7b3090a1ef2457c5897175f50ef987e0222bdac68c0f495dd947a5c8f678ea140722fdc51848bc61d0ffe3b9b99bd266fb3775a72189bbdbb118d852b2c8aa4a8bd739f93bfc1d0724420ff652a2878946edc151f795fc6ee89c8c9d759f4fa05d19cd5ca0d625e0335652f3cd077638978c5ccf73584c9aebfe93ea5b126b8b9b7b03a034c48bdd29eca9778480f6c244e4790900992ba06a2b14525fe1e9302a23680f5bf2024473c1181dca772c179c5d5422d4248cb091e7a3491bbf5c6b45e82572fa3cece28aa28887992e11fc0181b1a26ac76397a7b2274bcf3bcbe47e8156c9762c1eea4231ba1848cfb333e1230963abe4554cab4ece01539571df3f93eccf0d92396777be5e58ea8f4acfa1c0abc0e76041d623ebe4a20abbe78d9198a6cdc58e31002cd815add5caff84becf2c836f8f51e40a640e8bf1b3351ab9f1ca54ed85cdb9e5fcc8eb3eecf8afb6f4d4c3694195deccc69230ad168914600866f561b3757336214cffd1277765beda1b6e585032bff37ca2892beddc50fd771a514d6a1031b43eb0c8346080944fa00bda47a0a7a0012150d482024bab454fef8727c19fcb8a09825c7a6a0f21c2992c64a15682a80ab32e28e15f7246e0a587ccc5870d28e20f423a3ec13d84cd6ba7b772eaf42824b2cd3c260b9539587e8aab09ad4e961790ae24439c5f1bcc04bf923ee028c7ab880856c8e070f23f421110d6302a071de2651d048f3f8618c3e4ae7701aa32065deeb40dda3fbcc5805e56c92e9dc292dcd4ed6f219fa3bb4c8c5eba51f1cce29b12d924743d1c4e8ae6c792ed8bcfe5a9ae587a80ad12e3f3db721422e32ba5c8fd6932777bb50886128532bbda265c120dea77d951ec67125746dab42bfcead82dc92951c7a941ca54938e111584f5359d919e0c500448eba10501b65f259ca39f3373583ab40a59b150abe9dad67b841c47134c730a2da359d99fd6812a5391fe6c2e8ddfe270354139ccf24dc67f97b9de1b63f1b4fec41574c0c68af354c335ceb4d5773abfb21523d4826a450c806050c75f29fa8ebc1558ce71b740e9bc2944257e3b51a229f9dc89bfc5051214edaaedeb47eac69a8eecc3faa00b62f4a9ee68330b6ade35e93986e3ea94c6ade6e5f7756c38e6ca7df3b4b2cb04ccd0cb10cea808ce909fe6de0cae40d590b23e5e4c722112e86f01e398af5727411aa410ffe9555bbaf792b7bff08ad74e14f4909276014134b0e8d25c42d763e00f87518197f575507fb92316bb59cb7dce4f52a729a218f50909a610be253ed25c2a1fc39aecc0dca11a749eb5edda40850cececf49f3efe802a67e0f8ae550081b63b994a67885de9b0e2ff03fb10ce3e8a890db213b24ca267d65f1a21027313f1721c44d87f30a144ddbce00bb6fcdada7290995384af053d39dfa7077f647084bfecd9d85fb743fdaee3df048a5aa7e95d0d6dcc42cda586385d43e65db44b7ed3311479a66b1ea921003b567144f3242b563daf13ee53f8b371495949d0a9acd3cc67de026c25373f115c418022d91b17a834ff7145c03d245d2298c30562b1c9cd0aeaae718cc1de1d33d1e560a33df37c4f681c84e0eb1b2ed96eb9e391bed5ed9ebe16042dd6bdf4f67bd3a434743a8a6c26f38a7c15fc18dda38f89ffd3f6cd5882a6eb82d1a67275e4fffd72f867b1f091272a1e8766c8e7065b5b2a2d049a815d126bf7acdbd2607745e7aa34f472cb0d3413cd28ddfb8dc93c773fc6e7fbc5548d2b92aede4e33f1db5fc58ae846a0e79c01097e860c68440ff9abe9e8553b2aa489c377c3ca4dfdf4b94ac6fc96680f627c1ce194598d20ad5600df6206acc0656198f9176314cd80e422bee0003b7b225d4b7fc2093ae6fedbf719bae2408a7451838da9171e4cd37d6d5b7f3caf7b6a9b508a760c0a9c2da2079d6ee1b263bb8f2993374b7280a70c2133551863a714ec889b9ce19d4a9c154f6e7d2f82dd97ee097ab5232d4ac3b0f4ce7290efb208d74c55cc3f5b0cf3a52dff744c1c6cc731a7440e317faabdf20f017160af7dcc614e8ed36c71e44aab0c065835872e3b533da5e56852474958c86b70be4547c1d13c58ce033705cce2b0271d047fc3458391939e2ba50cf85ff7735bb4154833bdffbdb5e6a06fae69d658228f94c25ad46f2fb4746bb6ba9303896a623b586ee81c88b5a3c3a6822bc9f1ac937562934cb088c0865ac5fe31f8ba579d13b877735167cfa710ff8484a1240d8877ca7490c6df67d0b60b09a5fe7614f0ebc1bf0638b4fb181057db89cffac20903b1ad4a41a810560908e5a6497315beb6086ebfe0e1dc76d914294d60c4f17bd2a7b9fe2bcebb31f4a5c08db9c341519d83fd65b433e1940d3c0d2f33701623f670502739310d5c909e4ebf8cf2d54e0a38abacae5872b9cf4d54927243daf8be3d6d7a9fa3e0fb60ef48d8434202d11f2b80b97767ca3aba71b4fb7eb1b8360150d0f53a33a6f53c41b2812919acbba31be56233168fcf4f8fd62565126db4073005a35de23a6297666f282a3512afebda85b253cd40aa5921105d3521c3bf62050dafdcd3c37161247cf702f6626b5e80bab0ad05787e894d8647235cba5262474c9f7792de2876b00cb3bccc457644567bbdab9f92d84dffb6ab310f8a9a1ecd358df9aa9983b38a0ab0b106cebb45ccb1f4a982a960abc8e0e5f56be39a525a417b0316602c117b320736edb08d8b78a924f2e21153793a34f08b1617a11ce4dae9eea665b08746f6579ab33ae20b24a1bc817a03f9cf0afcc9ea1bbd85b6f4b56c115d3e8466808f75643a69708265bbdcbc38edf0a4ddd419bccfae68aba1e0f5ba632044e6e0fc4c9a1a9876c848181d71e647a764a86521bd1e7995c9767a2f3fda634091481e31f3ba7e3af39b10f2f0813ffbc0566ecf3b7c304266b1955d553698252bc6eeae231555c876a622596c1337652291cbcfde1e36474771d20f3b2c6d663e2667df2c7387a69969ed27cfbd89bbcb042def9cb86c8f7f63ea5d2de73cda93985b470cd522ee20f5cf6ede4a5730ab177b84229a0fc6910c2d182cf5d17165ceb128695724355d75eb42c314bdb4e84d8deb6821b543151ac764c07d30c51b582890f5592263665b00a6881bd6c6d82f6b92fe71ab8ea951fa38665b385f4f420366ee56da143def0d339c7a9c291887b9a705faceaee359fccfb626741b9636ecc9fb1669d0b4ef97d34138c372dc88e4ffaffc79589fb12ec45e7a7ae68ee0e2e6820e4d0df3678ebc3c23c9fd5432ff7cc4a1cea69ceccdf1c3a20b4e98c47bedb7339ac68d8c4077f15bd74e03929de7b7d0a06b8c04eb96a25af22531d746ba2369523a7ad91a71c8d550bc8b2f2e26b5b86ee53c971bdfb3b32db7922323ffab52930928e229c29b3619f0dd5c47a68c463b9f4eb7ba845ab97e7974e255197574a50fde91d01fb877e3f67919c80dc959c71d44f56a5312553b230cad9bebd580b4ef9af9e5d733c5b782015f7f2431a6f09ee13b0eccdab2e1ee5a823e0c15ed7c3bcb3b6a34cfb0ea14a16a0944cef882e70dd5ac6b88a2fd2eb7147385b8760f69aaffda3ad4e9dd5662be9f1cdf096e23c049d61bd3dc008cf375f85c89d04d63dfc1c537322712efd77226cf4ad5f8c021f76ea4e4afc6bad9d76500658726471377b15785c9c733d5bfaf9a7389e62a183deeb61159281ac89728829f9987d7cd6a4d119a5f4783472e81aa7e80d2ea6a2c07265c93ae0d5eb82d0bb9e8eefb384ff4c6b18b61d1ce25c25cf84c8485a0b154544f2153297c54d16b71fd7aa3e92496354e97fe8e21f9c841130477281c7ecec8dbb5ec11fe17351725928279fbe1df95e3d65aaee91c2374961f9c27afbe3d8d938ee15acb7e01468ab717791ca6bf37a80590ed991f94b2348aa4f14c6e22128c2e80b14973460556d40de30a63be6f202e24c57477f01e7167421a7a84e8e8d976e08dec12ad368c4e10a7009ed916e1844b7258d91c4a78e2c9ad724afe6b93f999e29ed693e140c4d86652c83e8ce0756ce9c6afc17ac53b312afb43394f2b5a7983ddd805ea1c21e92c5768ce40c53b74c4155edfc103e2b15d07faa1da20236499d1e28fe89d68d9fc66ab63949f29f4d53f598399a3cedfc3dd471b786de8a92ef4e5b883352dbad64077954a7bfe55f8c641c5fe5f09a39cae54b2a6801368f2cb41053327e3ccb6cc23661d6a01657acd0448fc29ac993eb01ebfe4ba7bb6e776e7bc026ed47b83aaa5957e50d831061c1165c8985737415eba4571c0edbcf619655c93f4dae194d76cc8bb585461b84d06f1df728d111650a45def5a604af9f7f3e1678a376e002fba016cea756c97ee743c36fcd5a8c57a8c1ae91296270bc37d7f57a6cd3bf99d4598d2ba8fe7119d2c31833d5659c874693142486f725d750498c8a18b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
