<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b87baa7f8049d5b988eefa48ae298a9743075ccb86159148a421a8b0a0e74a93e4b41aebcdd394695c996657adace1bbbdf9ecb4856be42ee9cf6d01624c5c12d19e438f535100a1e9ef2d21df7fee7b0a21e8a9262a7eb81d359d27e3743ff028bd615d596f66e9fffdafe4d2af37a81dc3e42e649786955d09fb705aaa0f0f169b30eb08809a239a68113f686eb67f861c2f7029f9638cb8de7c9237579672275d4b70120a175990f4e9196be4eb7eabb45926c20bece0df1d56080274d2cd98939458ba3e60f9162d4f68a8d81d04e0e5e49ea9ffd9dbbf9ad6aa8cb30480852f9386f45247ac0fb240405844900513fb6a02d0217e2cfef9d0f21dee8691ad29ff890eb9be552e183b3f540fe3eee2a69045155d4f013087dcac35e8172fe248aee64dea592ccd515b145143358ce36b3a705cd0bba29251af3eb2764cc1cad068f4475bf41fda317bbaa8f557cdf47fec3108ecd70bd0d6a0e9d8022a19c7bcea840b8b523d8a2ab56ed7f88274ce1621f45e0cac5ac614145659f078ceacdce785a94c79df000960eb4f8f8ed059154e066ab860ffa60cace08e4fcf3086e06879ab48d1cba0f2a28763b2fd773375d784a65669b0aba5e0e2c2acc3117d20d0b2cf393802fdfc6e08ed139fa86bf0b3608dae33e8e20b7955bffe9dcb5b8cc5ca211237c9e2e6a24c115907ed9a73c8082b23f2d83e34366cd224411474ee9191961d67d5d9ceccd803b15caf7b7701bbe1e10b1814dad7aa9ef07ec63cd1793cf74ae6555dcfaa07d21037e44f3692ab8504b61b0265d9a7285def717d79289f5539d6f3aa51790068d22c4c39d2e86c8b78bde00a1ed664fd70506e4c59054b767c6042063ab8d8918cbf2eaabe2d5a8b73ce0fbac31876d43be8749f7898154312bc69d8c4351c894a02746b92a14d23d90882abd7938bb3f3b5288c945ce656f10ce121b9ae592f6ffe0d020bb663107652ddc6d48db8e6a6bdc890ec07f79a566f5ee8c3385428d11a548fdd2445761bc39639e2784308e6491d22f652af08aef39ffdda7654933e25698c6257cfdda2ed715e2cfa9ad57effafe8940fc368c09a96f3afe9034c5350ef4ae76d614ccd4a86254f7bb98cafd81c03f4a02fe353c341b35139e3a8a7ca6a4deaa3372cfd5e70a2e0c121605164e49c958283f85ec5a51e45ef6a99875879c867f80cec5aab7c66fa68cb38eaaee6b0689d501bec3582c856b39c617e6b8c8c03441bb4b169e3db00e29c8ecd952d6fa50ba461afca1d16bc012f15a8165d014448eacc68516bd631272e908e1e7099866170a8599d84c7544317aeec9dded3db5ac5a58bd7d65f3a8cf03c18f0961367c948b53cd9837533cea95c97422757560e2dfdd17903f67f5b7b03431da077183d6622ae13b3e5164207bc5b1d2f67024982667d2f82e463b65838318b31f2fa9570b7a844830191bcd76d3eaa22826a3988fb659c435b5b8143a4d6692f87d5bba2dcc5bdc42f3df1a5659c55f6739c2eb9264387c9c500f77b723975f2d2411a0643c99a95b6e9ff82642fd7309f97ae6e640e720fbdb9f82fbf1c54da49518c2096ef1f7e56fad1ca31b680eb7230475aaa81856cd7e4057abbf4fbbc7fd6238e3d7c885e0a9ea0938ad39f763de43d90737648b2c191670979ea4d5f87d8b075541a5a7a0eed2208bf904d113808cdefc91350fc72edf8500682280dd1cdd3be22c704599b6d4d50642557252dca72772eda1e5bb704bd7cdb05e755777803d21e30f210c7fee72a38e52749253b84c811f9d98d7ce961906542c6ce97bf6d2af8622885c3fa2c4124e36e1903546ff71c34391de696e36ce9559d5e0df803581e720354626d5108fc84bbd445fa838d0cc8069178e527d9468aa28742900f58c71f2286accd89c57b4acdbb6a43f27820f0cea45e561f518a5e95a47a9c48d621dced2d4cc7c8b6d3708ff4accc8c879e1f7d86aadcff320f40a5900877372c36a9af0001e4f7946754a3eeaab341e6763c67efb88c4f1c8f13543fd3efd78242f6fd831cfde8e3f039642fa03b55c65c80a8153e1ca47841ab03d773b41952593c1f0ad1c7f13563658b42106831decd2df68cce03967e421b7402ac55346dd776441e6b2c8bbc7329d24186af60999cc043bc5b609a635a12b1e1da69d790dc1d36ab2688f65f9af10d7b915c287c5b4750edddb87338212caecc32f926c2e5abce4049564acbec9e61a55b1b3c1d75d4c171fdc8a149b27ee2e9130e3edf74987827215604d24c9a32e822f9879f39790f44d6c6fe57047330c749291372f72272cbe1d05cab7750fa1b55e4748e08ef82a18f344c0fcf12b4ae7cfc260ce6f2fb0e0bd8ca4816fd950ab50138ccc1ef4c5beb9d7314da4ccdccce6ebe1bacdcae22c5a3bb93d3820d60b52e6804ed929fff13fb923076aaed04b031c3c0aefbfbd8aef90a541fb54b44607a605c9a1aef34fc528d75c602940bc951f59a5cb6a9c5e6c66b97ebf5932634bfc69c6719a43a813af95fc04dc6690e19679b1c7e1d36694cfcce93b70b534ba10ab8ebfe3538f61877a1a58dadcdac7f6584323d9542952fde4f01564f8526f3183fee5337dd40defa3344cc422fc96ea50c31c55e2e4180717fce1af1e9a630463d6138ff6e46388a71d341fc5ad5683a29d427658f8cb6100379d8b029516bd344aceb29d783e8f5a95fbf2157f5762477b072c9874360430b20dbe43633c606069877a291d1579c9e69a12aba69b3d15b895b410904d3f39cf407df6da4735b0a423aa517b250329569ca2576f3c1df808c996f44094fcec1588c1d0d0b03d730ea02cded54807847b544ac30f6e8b6f5eeddb0b4b2abb0b9e318f618ed80d1f68bcfe976991fccf807a82c184528ca9562672b679d67a93e546f60f94c9ec836a7082690df0c914d46e86c6da7543c42431228e9848cdf92bd15a4b32e9d0885dc2347879d127bee5dc6a7aa674cb3c86eca0db61f1a4679c5456a33a663b81065d26a3b213f757370502da632a363fbc1112a4378927c1748af67bace1fa509d19e05726adf6ff0e58e819f09361d053e9724a47e6f285f3aa15ab50a6723556f722d5871ac3871865b49f0cecd0e702cc835bf0cda51a444c4d19aa07f1a0ee590678ee3654d60587d6658d84f8cd41f338ebf44372f2054b426c1c58f7b3279c2ad564df8c10036546020ba6499f0ad9fa8dd2b5a049d04230bba600b331fa5cc9421980675169b8cb44cb72c97e783a555f64f038c7303be4e6dec3a9597f9107b59554be727abbe1cba5eb57dec75636fbf6220def37f6c1b7a997e704c5a8286f72a09fab1a831c64059d9e9f9b775df8a0d59ca9de6130e0d15da8edf5aff45bf2ba805dcc22e3c879adcba701e11aa9137ec843abf57efb63cd069d59610a623211f538f5783e031e4d676ed68c63762914c4beb7e2b86b98eb655f65a3db93bf73e948b978eb892da90dd2286deb62062aa0ff87079e6c797899ad414d68768c470546c1b4f5028d138d0aac3813a7aa7e1fd4b4a2a6ee70abe80315a071b7ae7df922b9838dd49e77e530f278fc1f9c3ad1bd9c2bb37f69379156e63e13ae530b27fbf30d5ac0133690c8418e4704bfbf79af831ecde135ddfb6a067543a2fba7c7955d2c2b23150c03a832a5564617cdcee7bcd37ec8de1b5b43071830ab8e0cd81dba740d23605a7bcd35151893195a901c61d86b529b37ea96d5b1201cd29356647447c8f3d0d7d3f2e5541af5327ac40818cac3775f31a3b70be46ec19255d6a192b182fef0fddb2e1129bfbcbd8217639cd8dcb450663b87aea97f806e3752a4352afd89465c20cd5104e26a2313c95008271e5a096243cad834ba436aa79fdb81ff8e1ed16c44c48b03ffc3e9ac64b85cdb7b2110179482f316e71513c1aca664f3ec0d755d34e3de9c982dbb8cec2d893f4147649c263981e7700ccf13cdbb615e3056e322b53e9310f32d4f967baa2191441024a3b313a848ba4eb0adc1935ded6693b52699a0934d2e473a3491170a61a36bcbcf81c9b551a5bf3f8de04ce056c7a4d78bb95d6557cc1c6f755ebc50ecd3e491ceda1781f59ef2f384078d8c4f632e09f027506b96f6eae40bb1d8b06698de35807efa870c8789e0ea7fdb5247e467826401b8459b268576118652fe71e52366e838549a5260ba3f87d92c28504986fed4014987d4e176cd6e82f83281be4c61a8ac71dfb102cb19c8a5012836db4267b8bf7d4814a2c35dbae274b1a60508630a4fcd9caf1b2b767d433a576fd587161bee777b5ffc248395ea9e122ecdb241d8d2c1543c113cb40db30428e7cd0cdaf598941c1b0be794209b0847f2ad55e0083c8d8efe8edb7800a8488b3c4b9669a8bd8a9a2a8b638e894cbd8c46a4291cc7bb00f51ad223eb5f909ea3ab0c1762a6662e393fb46e03888ef25f210c37bc635269417ef9a50cac0247f3a9045cb0df1e7fe3cf736547343ae178f8dd2042d00cafb2b014d47e1612d1baf05810adb4553f1c26e5f065842bab3763a066a441167976c6415c69c4f7a62df09ccdc3ae6697a53dfa6683ae69a1326525e6085a04f6e45ff02177e18feb62eb2cf9488ebc43881f5d6f295b20e640be7119de12cc684bbf78ff098e2ecb0950189cd5fba81c7fb6cd8c9f751a8f3e7609b700725fc2a4fa8e8a374d406fc21db9ea213bcfe0cc9523ab5e937826b16c86bae18f3646df87cf8069551671390bff24f590cc3403c9f92bf465cfb6a1a27cc32011b34849ee2d716bf7e4293f879c88d21a5615ef5d33b893ed4c9048e55c6fdf3e3576071a14f2d97c347f4dce62ef3b37c062cac9f0685f8f961c17348958adccceb02f222a3d7310fd0daa4923a9f471db636872887a2fd42be09f1279ce850b8eb803d6f3447155d43e300f2940dc47f490bd5241f3cc03d1fe314d7a96362f57e43b2156b3ad28eeb53b4e6ea3cb104d914208c69df9c37abfeb23e421155e82a46f0674a112407ee6955c4456c1b0aa7ddc96db1d272a7149f9a365f3e5ebf82b976da64b501f5d312419a9fc8f42a11303021748fe6f32405ddb31cefd7db46fe68b02cc74a34cf00a8a6185c92f9b0bd912444c26806ed9928f509a0b45182e3ea231392214b36d42f54394610648678a0c75681fcd8a593851b7bf05a03213de8c3a7ace6ff6e578b1ce6c8f9207a3d308eb03de2c0202bee182311f80a6baecc9685bbec3b02fe4a8385927ed59b49b3db2d02e354f2c76515a26ca236c3f8ad4bac0f774c0d644153afcdb0cdcd8d58677d6af289ed59d15dc78181fcac465efd43a4e4b9519d2500200196109ee4b93e9e21c1442182c9fd6a0aaf6e66abeb93d135a2af0be49b2867203b923af75158b3f1a10d211eac313a82cee6bb1d43325ef90d21ac54cc1f626d494c80ae632e321810dd4ba507feb0bdc9c7feaebe993fcc096c9aa62a141203c1bf8ba653dab4798f17f8c6229619f6db5bdbd2cac6b32770e2b73df9d4036f63605ad2b6633f5845150a80f0bab5826f324549df3fc40d6103030148b59021115992621643158d7b9e2fc3f54d4999fb740f6d7659e03e845e6dfba44b9836f4846b713407f41aa6f5f56aa81cc282f7a94eee7e5842c668cb84caf00848c71b1608b35f02b737dc85b316774856115d5d276cc0341fc0f2ca4ec105c886e1f54d469c77aefce6c5559bf87319da102c0d9e07b7b432ac6b1ef02f76ed4f732e467b6a510b189165b08dd667be64e8b4ffc7a7ceeaf3c267ce56446571ff4f802a13f42b4ef9dffd95153528c5c95451b53ccb051cf52715c9f127792e958aa4d9ddc3ee33eca89c19a64f066aa2a9d700b7b8c140ad376f1dded96cc9116ad991e4feb91f886c52f21b692ac1cc564acd2ef7302c1647218214695df9abb1826087a2e8ca6d02fba65593e158fd659a231aede24d099f04343b5557274a10c14bbf211b9c3cca89911c62c1d1474ef1a13e67343bfbddbde3a284be05ad82417227ea9021c9d96a832f2fc057265bcd8908acde33df50e8e195cc4818abd7b1a31dc0075df2ed7cea39cf4751ae75856249d54df89287361989f53a1d13285229b422a13b485c35983a64943b36d0c714358c4e430902953dcaf758b747b03c9ccc6cf48168774f693fe73d01195c087ddc24c89cc4d11be1844b55230a489f15f66776daf2f492449d9bb425c8bc52dbbf6414e1b59b7d8c03d709a6cc1c94e6b81c668a2b3d033b2530ca4ee847cbbe4fc4c42945a2f4325ac71f35166947567e63fc50ab7f106d53ea70a1d15aa28583ecf069de9b6a5c49a5c192375e44d55f94e318e94da2530adfaf65531b88449eb6c92a1040956f900618ed05d994a61baa544b1e38cb348dd759a2cbd86a624fff922d411bfe2fdf4944dfe577ab3659f96b242897885491e5a393334812a97471e2955192e61728c1a2a781cb09361571a1a74219431c28a72cad4efd5e342861403dae02ba5827a96f9bf77e40a65041df1e84fdf85170ebe77a76aec124c1b148d64f5a818d45affa0bfa43a21268c6f6afa58371a589beefbf45d1b755dc7f00e8fd584e8ea6e5f0592b9463a25018b4d40cbf3177d978b018ec0aed08cc93905357fb4d2d1af9fa4bf5fcec86d91e58f5a7f37ac6bd9f8dad77d316c86ec5cf0e091932aa11a7eddec6a42f303db1eaae35f6027cca38c3a7ef0a64134512d965e619c12073865aa78798a5d3d0e399a98b51ec7cc61d2e042b49093a98e99d1cb6bde81959705db9123ca8daf48913ab6d1667a27a3c28d0382634da075b6294bbe3e07a03ee421f683c56c3ccdc6cf7b1eeff015eb45c9b1bd15a09f111b896d21537c44c7c234358eef22e856e68e2a214c384b052a141e1bd2d7ecfa582020f464ab7b95bd7fb1ead390ac5acde71026b9d4abd908b9cf20edc6d064645dfe704c4d3d5cd436232f65bc444fc04ca5a63fd203bdda7dd65de1121458e2a09ae0204c69decd5dbaf725cefe5de972f7f4496085da6cf9bc7f68af332882449c4b8271e0b92263054ecddd64ef254b800cc3b1c74d7f4d290949de7b14d8baa2dc05ee1d404c9012c4ddb069239eb4ac4192822097350a91227cd405ba932db017902ca39f9ab528edc9a390ea655a6e360df5c1f177f92a02523484a55fbbad7da051fac94b10e2389d3a0c7fe21d74f5e350df2c847b55b0d941de2ba5f40c6b7df1dc7fdf4f064378e5641aa1d43e5fdaf7980d3537b71d4542aed6c50dcea8893e47f1dc894d5d0e7fb45bfecd22b5fa200931582372e64c82cf3468a89623336af2889cfd8aaf2b5a99bc22dc5ad60e38e4545f8bf6bee90dda848e5330c4ef7c17514c9c2e528cf34e37f56b84bd9e2baf41206b54ec77158e2f0b7525aab234b259457b33b86598146841d70cd1b1a2147786b6e5e0b1b49a20e93fa6f0657d50e9db7ab1bf44843300dc37b66bd441a019c4d6bba11240f8256aac384e4d04dd56879ea0d90d8accaad00322d555bb7e26b8646976a2620295ec97175632128a1a967bdf2f0de44efa59975b19e7d389b0a38196c9083e61968ef8bf1cdd8e33809089ff4f5e37d0c2d09bc9a511fb7f1d22f17fdf720ebffb176eef25568d846329d5c2edce55c0b39ef1fd7338a30f24d5ec3bf106066fda00c676ecc94f05f5c96a125316690943ab5427ee37832cde2f4c550c8f7a8c05dd3097ade5db117137429cf77339798f5c2a4c6477bb6a25a0124ab295e2c20fdf9012c3cdf2dbd5db3032730a49b4e064f16f6e71168f2b1bb5e7b5e6a4310120563d7074235dc49ba4ecc06957fe5d05c28646e2423124f4696bd209e97a49b19ee1b3c52dcad1f4c82f948b9334fa21d9921389d73bf7cf49700e6ef158603943e86aa505e5d8e23d678a90e8cb760d5e7019e0e58d4827e5acdafcb8df591a5f2a4c0ad41655a541134b3495c3696861ff0b3d1663ddde5f970e3068ed95d0d4ae5c83cb72feeda162fa52c2fe306f12125fba790363a3fff059828580a61898fe546e2e4eab26dedd6e47448b09a8950d76c3a4dc87100ae40a6e4dd763e45fbf4f40f9377be4d0c2dc2cf5a891724bb1479bccceb0cd278a930172b024200e4781171c0046ad7e24a78acf84faf91d8e4c7bda35d9395eeba5ad1b75f7d624de743939df3d9bf8d9dab2dd07a56e2887b5fe3ffe7181db38429e7b96c3737c4f31d2632d22043e60fc23139884dd9c4e97b0f486486754d0d939e9bb2ce5394e7ccd412483bcb716599ff10e0b748b0081ffe0d3e889c62ae46ce10873590dad0df5eead1d7283e076b66f2c2a7c18f01cde032f8ac7f4b79d3c426eeabf5f7a287d99a3c068c49c23377fe4c7f969921cf953ce02ba62859f1667d5be4f912dfe6737569b9c221f4fc5e8ff14859355e155f0103256639cbbcbad655114e45d74231c6a39cc52e782e49d8fa282529d38ef468d76c672f71e5e6494fe098f4cd3000636d757d1e7c6f1947671429c8da631b8e8325f8e9abc0018a5dcf7ff25b39619e7ed85815b060179b6737667560c7744b5b1183204fa1b6ce37b2573ffdd0f7091f303a7f6acb197b357dba43e9317c071ab3d2075437bd3b5cbe3079b80735e75a016c2f4907c81fba746efb9d9a6bc2c46b9a98e5485f9840605187635e7b41c8d128962f90e300cae5d5e34b9a48b33e0984032a3737530ffe35f192e698f86a64c5ffb17db0bcc8487a4b3b4a72ffbad78718e926e113d964c608366c9f243e454572e65559af92994cac7a3ef34d9ebe3b03dfd465a3eef18f1b5a57b2c4d1b99f793381bec69f10f6dbd503e09d4fdc225b805554563fa82b553649ef78cfa420c8dce1f7e21f31b98aee070fb9670903e692a8823bb8db7104dfcb051831c58b093aa53af8624191bd20513b2db4edc2cafd037561fbe2909a17b2e41c60c59bc9c710271579f66bcffc27a75e0323430f815c5ba6e11daf8efa9165789a340778fd5768b22ffcb5301c5a64007ab3054fec27eddd9d775b3454f89203b3dc01093429913de4ec4fe9892ad70a512b2a8c74fd93f92de2c4130cbb1ee1fe08fc99d361e9b06c8cbf555ab760e9fd5e3ed0b06991a36cd87039dffb898c6b779082fa5e8a1e72e44fbb80256b635c6512896eab3fcf33e946898f002abf5c8ae050f5484abb34e4004696e35c21278509aa6eb2a7859fc0386b2870b76c49fcbcde0300c37eff8235a01ce3235bc8f72a49488468f74370acad67e409076c0368ef840f504f371287f2295790abc7936d6e4527309af2bc97acdcf94d7a65e6475d7c17d5c9d25717642cd99f02b59cfb0c7bf2d4b396d3aa52789dd62bd6dc390f0d8ec18b0781a35d131a24fde3db29f3a721d1819448a17f72165622fbabe0ca4c5944f8cba08dd572caaff01d3f8092a3bc13995e625bc77cdde586001915886e7df323392c66d5b3621d038bfb5896882438bf55bf21a17598cdee67006a60d4890c98d4ec2d6ff9d9688066df27e796c1f46ad4539ef42db908c1b17dbef407e03f8d629a706d5af064b5ddaa73bc1472a5eb931b9cab7a64e473e3aab069389158f712192200bad27de43abb3927b2db214aebaa355342f7f36abfb2fafe1b41e950366bbf4f01aa370b6bdb5c04494c9d51e7ab265af0cc12366ac07d0de78e1c3561161e48e977a800a2d28d64dacc2d9124b6e3e5b3e69c2d79ee35a90da9e33ace1295aa2225d31e19caa39a94e1c52d7be9211a828bf104235d1ad04a91e67ff75f59e252a3cd2037295afd69b7c8a64320d895d219c4bef7272f1232a058a52788f3bcb1735675f9616ddaf625814b884eaa61bf4e13d17e3977feed5e6530507251244191b1ec53cd4a58cdf153526af0a2a1a23b94d789dc9aacda68db744e47566b49ff6b9598d8d52e7d2d2294bd20561a94d24d584c16dcde301f7a6c4a459950f598be62cf2c53bc07319e8f80d401e45919bc4179ca274840efd19e932afaa5caca6e4691950a16725f6fa4982699009f4a9860f3bfac2ec111f78e7acef98463d26a384c36c6e4d954b6bb081687bba6d53951094be86863c2fe1c186b97c2222034e0e71fa1566cd21f333b3943f2ed2b151bc574a1fc3a23bd1dd69609b347162a5700620ecc243d39f9fabf5677f1ba5506852013c5f9c479f3715d8a9c1925d98c86be076409f3528a9e2dfcefa4769d3bfc4b304a84ad9a7d968c67c355f73b6adad43ed874ea0806e3745bab185f0b7dce7d2c21df53b19eb440270520959344340f518fd4967dcec81ffc7421545490e2245c8ead2b47257d1fab52622a4c35cc76a5b6f033147eb8b53151b3dd23786aa23c8a8b77b31a10c4cd802e86a493731384c5aaa1edeb2cecdeaf538cd8835b7d21b633daa08991f4db88df88d632646dd1bac8d626d0e1e2a14e2f4bf2e2149dab7305237c4380bbfaa4e166949390bda5afbc61040bb356c3bb053726f702cb095377b0492ff90c94a250fd66aaa4e027c5985561ea3118b59b317a432b7c6c49218b20b5f3528964d9b6ff740cb3932e2afe8f641abec56988eeee258b1d095d7e0f8a0213e3f3ba5dbe24644b5b844d1639ee716d9fd6e8354344b66c43583b13282eb4a2a99ffa162bdaf018b77b7234c14a43cc59428154f7e0b5064bd9a233c17aec2e4921cf98843fed3938d7b6fc205960346493721bb4b8dbbb12a58b312e1f040e47c967b2abcb172eb42b15eb62914d2bf880222b053b9bb6c46c4476e02041980d4e732dcc661e174e51ec2de79b93715b7279c2f002847747c40832100b024339303ce1fb907e05a7e8120c7bd44721d8492792264a1aedc4b1f7c8ae377b523ca119c03df4abd5205bc9f6d9fec62b272d22710098f76f26e9eac016d6e43fc1da8a9644e9da3000f4cb6b533c309b25416879b0f9502d1609f12d6daddacadd74c7b7fecd43a769e617065c087f1776d88faaf186161ad6845b3ca881292f9a676eb466ab8a5561ab01d24652406c5fc4f17ff5c820d87124494129e16753606e5ab37edcc3263dae5aa3c69218ea869256c1e678038c5ff6e9037b672affbb02cad346c8a6512a578876a26b8d85b2f76b1c2b2ed47a90adbd6e5c95556431bee9b08866d791e4263c7ccc5c7f1d2e8e71a4ab5471cf7e7246b7355bb08939d13820faea68f927f6050c37f763dce81c51468542e970f4c3e1da5f9e5b3f4d6adec5291376a820b9bd47ed516040fda9dcf820c93a3b9fc7a8fb6c2b5e07828cc3e187fc1272aa29138f3ddccaeb24e0b74ebb835c8e346d3b35f01016becd2e7bfa8e66bce8c43c46c0bdb41a896337c62fe5193208c97bddb000a648fc1f372b669f7c30df8f0b55632a8f9b848df484fb436568dadd1fa8403488265e02b17d75fa1ece6cd1b6208e6ded18d13aa03505db3fc1de8248da7223a15410b204d9249a5be6d9e465a86c78603bd23c56da519ca83e94e9299f5c7d529d8f2a4007d556bc6619d5ad130eeb71feec3c6751d81f322e8a6c9a28c577afc13756acc8cc1defefc683873c9b78e7b298de5c89c8d299fe113f2a15478ee04b23a8222a465a47421a9435cebc61dce6726df926260d3fa9434b0afe8d06651312c2ee38f9c19e7c373a04f4325458943f7cc65be44d8327f891756b9590f4d3d639098594904bfa5082ff52d25195e634021aa3819635b452495e76f25be282b11336d95ea2a76e88634f244c07a882c136a3ce17b42743a7e89fb368588d3089f8c9009646f85e1277b52d9fac8bbf8b8762cf4b3b56037812d318687b0187af854c8441de0a503037969cfb1a5a2c44612cac139d48b580d26aadfab147395ec7fde69557bca49f6d3a8cfb254c8367ab98ed5e35477908126026e6a3d1a61f0f3dd0ee90b3c040491a14b12e275e24ff5735b36e763db6530cf0c3b31415b7be88b3de1a169f3fce9ee809a17168c8ff7684df0c9d882d4ef3aae8693e6c771c8ce2cb3dec73612b9588cb7cd8c5b40a94b44d5fee600859433e9bea2ef735aa725c039e23153f551085815178cff05f8fe99dbcf202ab4a664881631712705f40c7e68fc07c986ab5ebd2763be7f0a2093245e37158eab4e1ed8b8d0160da17cfa845db1426d902b05763f77bb388f77f7d826fc798413e3f661c9ee0123b731cc1d84136ce1456e6c83a37a5f9d6d81bb259648f6a8dc7aca6c0b6fa30163d7712931d4f1762105c521f483048faba5dd7b5613cbe41e34d6ea59ef1861782a54140d9b871c4f94eba5c75bde1983d303030d1d3c868d32f5c40e542c1cec6cffc7329b7cbf4d309001d951c948215aa44272b06da60892dbaefb5112acee41ee7fc51ce7930158a6c0249a5fe97d7f8fdcccdb4b8236e090c84ce6649fa362e34cc996710491ad10d6c6495222cc48d634dd598118e711c93a4b55ac28bba06b94c88b44b580137e82c8d8feaa240a3a25ccc9c3106fad5f46bb4168d208ce938e4bbb38d3973752bd9f5056ee995f14041dc751ddffd5d0ea8a8a4f4770262d3cc9a645b8539018f3afda715f1528f0db7b81f34a2b27b3b737dd236ed09ee9fb02370ddad2824281818adc7bb6cbcca8198995e187923f391f06a24490b0f753419f09ef6755ae0865f14b7a0cc2c5f4e706ed30c2abfc15c445c558122d2fef391769c756fda9bff1928c3aca0f45bce63e52dcae589cfd2468c54284fa2ee7549d6abd3dd3300bb531a0c9f98931d67bf08d2c7111531d670bd847bbdf6958191330fe001e0557d0a58611c3ea0d11b6458979fa9b6a8a0bde90cb04b2f52385035ef1a46b4c91bfb4492e68fb82bc4c3df097a8a1c5bd94f57b7b3cc37453e855dda9c9852d51e12fde24c1030ad7aa4f9cee41f81866362bf5faf5a41cd61240c43d9966c329876f678561d1e0d1a32ca9e9b570404380c8109f0dfffef31c3787ba58f52e419ad6c20f9967c5a748d102982d1988b298481dfbec4cba4afd5d3922f0841cec0207c783f6e0b29f8ac7a714cceba558b4681d16b6d742040f74237dc924f19b9906f0b699b07ba90df3174bdbd9c9774fcbcbb8ab3b6d298c5926a5dbad088184c857300672f40f76b2dbdaae0090ba1657347d5d9f36c9e54e3faee2b5c7bc39573b710fd4f6063c9fdb40e1fc34326de17f0b25bf8548dd903555b6e126305ff11dd3159004750d739946586d65d26757f5932a3b025680792274357073ef1b937946c8b2bddc35f4ad6408960cf162f16416d95fdeb4edc45a61efb5ae50bdcdb29124d1e8789b9e105c603b94218b715adaebe14c419d01b71c8b70f025ad27379db585d1158e7703e1c5f67b8cc25f8e166adc84645dd894981049a75714ce6101358a262db6fbdb9d95caa9b96960245aafb618a0518eb15e32682921fd4fed0c2e7b8ae882103a9619cf56721087e0a4387a2c2b12faaf4460d4da1752cf843f0c302b9f54d75378833d8e61d63e73dc3ee4b3788c5869321828c7ed8e4b0bbb7b00d16cb026e0d892ba82ebe82845f863e8dbbb69d27648c481333ae6f0ca925441abe8791b5ace8f269c830e9b2abe497ec56ef4329ba234d111b62c47f13d7b2d9038016bc84410db3760fb8e13207bde77d833f84ff0e96f3b1e283074b423100b97b561e698e1537985cdb2bc01ef81cdb9626a4b40edc15ce89928a3ae83573cf3c8e751eae531801c923f4d3b1ae61d9760cc799d54c4b669e9610cff73572694cbb47504af54972f9228229431bdaacf132ec19b4aa7a65893534b3eed61d49b272bf63b970f5b77843adbd635c5f89e6b3cdfc0c36efefbc8b84fa27b1a4966b5ab0eb805a66d873afe5979995fe0e4cec9f4ea2f1bde99cbd2868759d557a46d114a5325ae90f456436fe4612e221b05c8952b6783c80bf250ca9efad3e8ab4f24c6a6e83fb15c5aab620f219b67d47814191063d7370a0e3a3f65f44360350db50c59af625bb726a33573410d16dca10ff7a053030c58227a185dcc061c8f352d56923510595c9839fd8df41f2e6464cac31169304c9dae074d27662f670977b21da4ce09b289dd3b7f2ccaaaca42b8010df2a296135e190ca9ce64639ff6f9a053243fcf4eba707798c8f783640b25fc5f749b4199eb78ee2d3320338b92ac3e93b3830303490a999bba98918a2d8b26e38d3fc51ef1efd814a562a55bb7226c2c6c0bbf75b915c686cca9e1529f4d188cefb437e9d1a7553e93d483100e81ae941d53d566ac9ff9f9f2f188000b0177921c5ff15a821e40d0bebe7efa8b63fbc31524eb448844bc12bd6e27ce9295a7b5a91479b0abbf38b8d17a90a357e8aa6aa3014450ad5a781bfb027b23cc76bdb75c6d646a1920fa4f5d7cdb00ceb97742a813898755924efbde83c6ee06b2fa715de5c2c800393f441b9fae9bdb3bb8b8298993716a99b7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
