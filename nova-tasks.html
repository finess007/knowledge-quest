<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef1cf8c59b283e747eb7f5c496fd59b289db473d97e5684fb9c12aaf77c9a4b25379f242defc56d2eb5470180d5815576fa0783d224f0c1c7d571b24105c015e54ee715a33ab73c29934d12380fec2a5ada5f8f427d284766fc5bdf47b4a661fbcedc3e0b191775bdd86c7632e15c6c7d39884072153d7a82cb5b94c5c8686c0c4a529765906920f89ef1a6e08372ecc9b7b69eabde08f0d57d17e6dc340e16932169dca1ad60e4898f97ccac4a4e37b8bf21d8d1bb90680e2b4bc2aeca810844f37737038fab1108fd3010336330dbff4effdac62ad6f7a805f7595270626afa6c42adef8e35ca32548dd10104df77ca474939e6627a67a1843c7361304dd4316ee373d05303cd5e249cb1b5c0ee9f8c50eae657022656697e8c49e872d4ddf2fc461982de3c7878d9cbef96968f1b74ff85e0e7b5dace0e36ceaa74f8ac7d211d45828046cfcbc5d2e82535742e622accfa3e443fb4d91a13ffba8de30254fbea389bff8a66aeb0a964a86f5d57785d6589d53cd9d241eb354ac3d39e50d6cd2e4bf410b91c4c379117138ecd492f58a04be17408feefda269f7a598c107c98d0fa78347ee972831f67bcd89880b261d3497b4feeffa16f33ef4b4954be33ae0b25f4063e00e04e619d136136c276ead5fd8ca056d8b2a9c5bc96b8973056dd92ef2c2b9dfa08264525ea4800704f26f7c12e7ed73d6d9828cb5021745c91954645a8f8752687d96e11b13832302d1a4b936ddcd42dc63606d369f8e902a43d369cf670b1bd9c5ea49478eda19fc09dee50733741b1791727d30eb22542b9ab205e0406147526ab8ecfad08e6e885d5ea64e89b92479f8fad8040c4344f580780d92b80ee915b4c0317ff4b5948b9d26c3329fa6a06a81fedf11cfec8cfae6a4dc6e8b59cc5aaf89c26c8630cf8f278da83057990949c1185ec9cb64ace7843555514fb3eef4c21912b2401daa975d53018cd3a69bf5a24dbc10398fc1e0c62ef7fdccd580149eff270809690fb331f3fc6dc40bac93ee2b60a878ce5297fed0e7348cac4e5c41fa85a52c9baa5b3f099770c3868b0d02dfe0b8f0884e6f169b83827112dc6846895a1fa5f859c2eadbf62b713bdc72ce7a2f6dbea6b97270671031bbebf6e581b76fa8ce7e4a17c1509b3cc96e1ca20849d2c66a5b8013ff3366cf4631e74e6c156d216f34e9932fe18d4160ac8669181601fe1bad87299e87c1132d4a8ad6de123a1064637ce0826123b3090dcb62456a0c3c50f60efb5ac39ae7c38c01adf1f4c870372638dbccee19026b45a8c122c5c863cdf7ec8d7d3230e15484859ea0ea5268194b90ddb559ed63af37b2c1789f26191d9234382703e80acb380f35efb5a270bf00a3d603bef109edb097c4168111e2c159cc2230b917cb0f948c8d9216876eab792d0588bfefd52de5289ce51bbf3803719776a6ec74ffeac0db9d76fab545601a111dbdd7c972bfdbaaebb26d55117697ffa02300c0099f21ea20826410748842e407d707b89165e6a98a332cc30bfcd30bbad9fa87989ec76c933f7a5fe4c51a56f420d9fd092e73c509f799f79e9ddbc128c0723fdecf170fc210f44fe23d6deff5ca807b9a48d8dc1562101270fde5b6f505ac368ac4ef17071733014f8fe9b04b4639894098d4aa9a349fb70ba132d13a2543c54aaebec5c96535ad520f87d34c064bb7c5d12b4baf0e0780509b80045da46c36ae2c8eee6fe8ff027c207f5b963618ff8236d85cfde7780ec5076f7cdb69bedb5a6327a48941ea7f44d6f9edc7ad93ce49b017b6f472cca4c09e1916e2e7816b1289c8310c178e126cdece1abccce3a8832b2fc7d6d09998d9aa1b5e0738af502026bc330438fb472f3e42a8e35337896aa7450c38c6ada221e62a539f9c6cf9016ebf0051cf6749c48ab7dac415ccab54740288d80a4c31505a2dac145ab82c7e93abb57bc7e17d7d55503f8e968f57088e51183e99b817a84f37856a5af10484ddfb08f9394b96d160e6911bd35d6bcfaca5ede18ef5e97ff5d89e970f5822b0b591f474e8495e0647cdecad0175b4624974072f9180e2a991ca4ea9ce8f099f839ecd486da3d77185aa636c6e03f9eb2a688ef98bedd2fc68cfaa51346aae38bd1e5608834466189d68853675b1b831814452b40328dab65d5a099ca160a7a612a74e2abf5b964abb6fd639bb3d34f25b6bf962845cee472f5e4ea6297a0038d179a23867f2bf69c784bfa3dc944b6f2a088cbd4211893f168c2d9d6944a03ed6c2c74edbb3390bceba2c2692734685f20a484a88aa8fff8d955f74e78c0ec692224650b60e469be7ff4347c3a34566b1798fc8f5072300c7832a9610969626e719147ac44c95bb7a55b3e47948ac6b8a70dfc6514661218d8c58704f1cca0b161d45067b0088b1ed513dd8ca8fff12b169b4daa7ed9485d402baede42996a66fd421f96a2cb06bd2cf577ab0eb91a0ebb81d01dd1d6dd481af15a43331dcd71d761152ebf6fd697e8e2f5342e2a383f58dfe3f12ba1d2b94765cb45df83fcf8794131338d951c2327f17f1c677f1313d740584987b746d538668c049ae039e609df799c19464d8c8dceef60617f614e2bf30218cae6ad9308ea21b55d17371b914781239420d8f29c2df913d168f948fa2ccbeec233e1a9929da1df9479f725790545d7378d3ae2baf1aceae9a089f6fe349aabd0b1a478b75b934d69eba7de99741dfc6870bd4dea318b2fc60d856e591bd095c8c474c91c692503ab29a08f5e390830e89ce6db16e60edb80cc2f7e4f22aaf85fb05983f00c4d77aacddbca5ae76dbbb6fd418b1e22586d808870462cbaa54c1626c363690d41f01765894148755886b21d54729fb0e90299748416b6ca40ac5b60ce9887517f0c9115d52630cc464d47caba771886e70739b6c10c226fa358005c67f85e0391b55e8b4ac247ab07bdfe6476c695887ca7e943ee6cbbfa96d9761c53e7ada1740cf4c1d7afb0e98e6b8c9398459f9421848b339de669b3f204ac7a0880ffb8f70f34c83db4c6b7cd0748a3efe89de6a833eda428255afca8fa7644a71c0d4005cd0a06080895aba86250a7a25e2ac531022f5590d0949200a153ad4d4f7ca1903f613de0aeb96f88e404d427df3fb0e4da91f1cb4726007e63df20a7b0cfb48525d05b421b88658ff87d54522403cabfbd7eb6a79fd0650299d970560f79794837bac951706632fe1d56a1b471903306c4dc3cf98796366ab05e791a1a136684d8065e331d789773569c81cfa8339897f4fda16f63cc57496ed8f00cc6a343a931b5ab457a7310104135bcf5c7dd8bb9b35661e3bf1a8af311cac1d1de7e2d4f0377af0fd9fefff24bebbf3726086cf5e2e75c57e71a560fee92c1c5852cbd3fb95030d412268fc592b2cf73ff01d8071cc9bc3647c8dba5c3a456581f8b18eacc4e8aa61d1e4554e1c19aa06346776ac874844b674ae8668e50086fc15daa44c0ba5b342571bd331fedbc077b8f4891d83f55ef2f6b54e9cbcc4c95ceddeaa4e39435989541b16a5256684632a7703b9201cf325b8a83023c6de15f7d02c3099a7298354fb3d149f233c2e803aaa2883aabf1b98d6692b944c84e9ceacdca6be8ca73ad4e88b900c25f3bdad761d83b7f7ea6411ff8d23d307738b57bd77cce2d11c76e43526179ad451618d7ecf4e450a21c1b743e7f520ce7330c6fff2c0523b1cc619b4721abd5ca6c41904291f00fb7bf0b063d24cc016f523f2600af082f1ffa0a6994faae9373cf9497fb3414a974d864cb646528cd44bc4be2b44e9f4c8dfb10bafe5e11de5d1bc5ce5890b043db42c62906c41737c7c89f41c4ed2e10f87c9a9680ab2539d5ef938d9eec9ca2a7d05a90bd50795a879aa7cad15e29d09a90f6e622fe06280b0c6495991dff3fb5332900bef7f3dab1338daf6521a2ca24dcd65da9a53430dc7ea63de2dcb1ae5001af555836d0b1f1fb17ffa39e8c34b7951a99d5ed9262799e80cf86af700a740d88a678d941d6b0a69ddcab0b49819ab778df174b8bbd6355df787911901050d74bad3eeffb8737e30978800523321c9632dfa9879a3501164abde63b549cc13fa55a99a41bff40c91ef41748cf32b76922cf8431f1985953e0255169b09a6c783d0b393a7a44350680b33c3606eedf1fa9149bb4080d6d9d7a36c4b0a9eedb2c571819475c24f9cdbbb254ceb79d15ded946772d5073b3593c0749bcb6072072c3b120eb74a30c8dd2e23287abdaa2386fb22ee8b988d6f07a2f844886da4808c1b8633789400432b3edf738e559cbf457d34f46689e81e6cce4a27c591b0cab0d80131b40d196b913dde0e6c6612f2e6fdd531d744f04e50a54341796563f2b8105551f22ef272f34eb95a01fbe3bcb6639c3f2b22a21c3883bb739d61330410f2708de7eefeada22cb9975aba402b21828c81afa1835b677ba03c29fc4ab88bce36e4edab49f16a4272b53ddd794360a78eed51db146722690770dacefafa56075a77ae75f5a10427c3fd9c7a688932a7efd9b6b3edb9d57a0004e7387384723af225cdaab6b7531e216fad43ca1330dfb1af633ac945f5012b42a04384e6d6e8379a429ffed670783059ac66a71ffd4e843c8da6e44ad780e6ad887d4212b978d25c361a72016c4899ce3a68a053039909abc150e6880143f9d6c4ca8f1d2a6b7150a526ea586d4d3c36727b72ddfe154f5389fca870a75cc8978bf8ff4642fcdd73a977b4e7becb92fc51efcd0918cdd9e38b8c918e8f0cbae866ce02e5a5354deb7d2b2e8a8f1791d31acf1aed24b4b9d22d117ddb1c746ae177d5539a218dec4e3c66488877a8a422eed6cd6f8cb0586b44f9497fd5a19f922b366924320f044d9a0ca3ee2d2386064fccdbde3cd19cc38426b8c5b89759eaa5342f469a59c340c44b04edb72939ca01747fe52b0ecf0b2ce3b779fa89fbfb2fa4307c286d1362d6a4bfead96e9e1f5999e7b3635b2e4dea8a5a6632dfbe68058c144d4cc26159f8f7d57f4b44376ea4b564e07b5109a4de2f25a68508744ee3fe1268d1221e612ddf43a83f104c5ff371e101326acdc7ced8cf3362e4c5932a9ac2667d022c186813959241784b86146298c41b85276dcde7ba4c21722d578e9bbc2133cda2be5021dba2b2a17a695f7d9324dbb9f9c5175a2a286fba0fb0f4b11b28688c8b74bec3101a5e1d0c83fc370005fa676b11b52e486a9fe038beecafe716967228ad6b67f460a204f407993bd16787b35cfa95e93bb66294ab1dcb1dc0ca1c7a96712df0c9ab681c1c36b8d2be97b89e4577fbafca06a6c76ed0b0a8ce97ea3aa4ecd6d4c58783abd59c9a9cfd47565c89828a905eec45ff2fc7be9477045c47f98e83c60c607a4e94876015b7b230c18e3621129ed52ec82c34183157ba52398797087fabb495842c20f766f888ea162e0f4d0a1d561d36f66eeb225c3db6a0ef0a95b4433aaf4a45cd628b98f5be201bf1965d364b98e3bb75efb99df7c7f91dec59369d76a9ebdfd923eb7de50ee95222889d1d049663811e2bf0b8608523e8b708bbdb4bac8d131b1e44c4ef84c83e97a41c934262177e5039e627b1770ce919ce7e59039c065eb813ae53ad6626c822daf2d322591c052472f939d760e0271a59ece98aff4475d24cfb946d130655c94c3ad61868e42da31df41ccb8df13e81393d7d7e53310918270081deb9da015833bcc7281ee6c3c80a8eae5daecdb560b8965f45da4a96876398773499e469ddcfc82bfe5dd7c3390474607b9513eb1c885c95530af21daf01344735f1aac08b6bcaa3591faef51c32e98ab10dd4114fb0f899f702c945d75fcd47d9e1cda0c1b26975b19dbaf6b02f7bd07cc720150b7be3706a5d933bd0be5b5ec363a7468be4d809c0a54a03d5836a32f2e1f93cff04ef0c227e53bd34d04fcada914e811e130b03d04dc1c138f27f0a9a51ece8082420719a7f5bd3f01e64d2e664bd490c8f2f45178ffb7d14c0b16732559ea90ee0fb0cd7c0d224b89d4c7b3d8c04104b743f1b9b7f7fca4d9adc94201ebaf678270f4e3975f557a6bd080bf2a5fef00446feb08d214d417fc0d06056a030549c1de441f509bba806d9191aaeca829cb8bc7d356d289d9b182686c69680abb50b47faeecb03cf808349898bac5805c79f2231f17759e6c271905182098345b4cb90386bd72f78a23c6f5c461e3c01d58248b7e1df513a86456923eb7015dbec11ba0dd449abf6460c87edf4800de1059d4f05ec26ec9169a910ae053c0bd2b05b483fff941cfdf065832e2d9a6f13095263233731cb0a2635fbb828b3bf227226c3cb62c3e978d87e1702951fa5080a6150cd147c6f5e3949a0b7eab96dace503a02dbe498da8059785153c1ced73e1703259df7b87f132d516570297dadd50dc2740c07ffcbbd8fa83df8981dc188a6292f490849ec6b60d42e31fbdbbfdf9d074dc15cbcf0a3e90c9fd273e5f703ed09d389041deb28153390129feca6adc51771aa1a8f202c823e9a7dc34c5b6f049965fd320e5820e87e49ff07001b6af9f164627774d97890de122e6c3b7106d9c409d2178639eb17c76421eb1c1fce6789ca35e1f2fe4d90965bcf83bada1b6578fdb2d0689c060796ca8adecf9e5014b4aedc3290380b0d170ed2bbb53dfbcba5ac3972bd5dcac29edf02fdcfb1cfd03457d08ac353c1a29092daba51b4fee39bad54d9d30739cca37658c6ed91a44ce2a3b59d7fbddfdc3f3b5ea866d3fba05604b72df10809c9cfa3417dabb106fa8e617271c6c896127b417102b9fda85183f4cf04f69da2c46277d1ee3e1c8d955803146d32bf193d47941cda339ed511dbae309e3fd9fe5a7f7b9f1e7af59d1c4d4917b53ec91b14c8aafa6a555e152536fdee68eefc871ad84923112f3ad3f56164b8669963e0c39c6a845c8b61326415d07f447b53d218172b77e6f78d33a6e79483cd31e90d823ca378a2a2391ca69bac417e690c97691a322b2deaa8aa312ad328b0c31ab3e580e3182fc5796dee50a284097409b458446d1ce0031d6654008c8a0b8ecd09367d248251fb663372b10074856a5aea12dfa66999c6404d63d2ec880fe84a983c10f539544f9eead88c35c169f5f1ed1788ec23b9bec6bd5240fa828bc3dd5b93be9916099cf0fbfcee919ce6297188c3e61e5d29ce13f2995a22b30fe877ecc00fcc0c4555956d33b94496b5991875a8f094e97f2d778344b9bb203ac801d0f4c414d4b1e35386ea2125341e6d09dc4654bf1f320e922aa6534634e7d94e78d0d4a96926dfcb79e2f1f2b93724fceedd57eae6efb385f1c6f5d1a65894bf15d8954360360ec00a71c10085036154bd8e2a0c224b0261a997a05944bf1a07253e8b122002fd669d38c7a1b6fdb19092dfea077389e52efbb462972d164922c3292ecbe4fc3288ebcdbcff666270c5dafc3532a87ae73465fefd80f8c1b3f361d6111c954ea130913aaf58d2769fd126474101c9589d3868a469477442b3740dfacc880f172e3423deb63a491c78a74ddec0d0f40302dd46851f64e892fc3537555a123e7a6f3aa284dd516e8799b6262dfd545cb592b91646eee226df601046250e114a4f00c8115e378cd5b06722f819149beffe65b226917bde2ac153adb4fdb2477f74840292d511e64ceed156e697fb3dd3a93d7064a2928dcd2f476dcd52b797d71665870889d9f991ac9125bd4393024d17bfa60d14da5a8b8bd3e217dda2a57c12d61004c1356750ca46839f0ad59b083600765fb082fbfae4aec17151baaa4d95059e33dfb6bb30bcc46fc9cfbd6a60edbd12008e1178d8b321c60b90189a898e74052f631ed1db9cdf97874100d4cd959294c4463a02c03bdd6f0389e35a16993df21667643836a7ff31a26ed646bebca5629b8c0e44f1dce3f03816037a76607a9d120454f614a991d5a4e0ef0f9af51042a2e8ef159c61c8621e002386b399d4bee69ab088fd0b3b1f5fe390f7af6feaa4f035f86221fb126583432a8604a7b51dd820f0fb5b458562f1be9231778947cad6a23806ea6751c0e8ed343dad383c5929e7e7e31dcd5dee0ecec8f6492a3001ca901b01c8ed2d8c24f401432e0e278fe35ab66256a17f529a3a85bc2db144237bed514dbfd39d6541351489df4454cbc64a6ef71f4181a95d4d7245a0e41e86d4ad65ed1c4d0c70b238e8b47d277d591c5fa2a421267714a23356fa29f2c09b2cbdb17552405616494cd2f96381034156292cc1f47412e618090f588017d1871fbb82e5d73d39e2622407622e466174d7504e5cd88b51a97fd9f9138ea28ce95a64f77e01cd8bedf92d19d378d729dc14151714efcb5bef2f74ef705b1a705446162e54d2121d1e01a485d0f6ea45a03879f1d989deb4158b487f4a28c4966bbd3481e112100df83f8a6768015915c8ef062394aff4bb308ccc86180ded24a30e2ec6f3d7fd574661f4862343fe1ce712bdeb7ed1ec9010f0b7e20d2a49339bd7fcf9e8ee18eb2f889fa114dc427736116836fdee4b56a0add4405cdc2ed0c93ae7faf8b0b0351dadb35bbb37c6164bc1d9d5ab871ea9db85b8ca493d97cc830a423426c217a44dd1158c4f2408798cededeaf4a483576a2ec84284afb28f060892c21b632a9950dc8abe1893f9dec08b31d8968b010ed5fd17a09f14c83a86c4536c9f39a237643f21b116ae44eebca39ccc5bf00aad0687bf8528baba70248c58156d4aa568a1e266f619f6bda9e044d4f9e0d7e0646ded8e7a818d9b266996caa5acc051fd76475b551349fb2873445c6ccf07b7052bc56aca5c80097065adfa4055707ddae0446284aab1096ef721ed3ed97b9d58f6e192a44036680466b52a4e759f9a4a2b58aa0b5493708fbfba1e443b14ecfc7ac0a3311d8f660cee99d16c637aa7d19851dd19563ff86a216ea01fb6ce088c3f2035dfcab7517bde1a894a461813a978723b40d01c1f534fb07617bcda9e74e5a36e369108726c66da65ba51f3e6cae884baf77e38a1acc1fee1808fc716d5520d26699fb56a69179e160e8a8a8f285ae8b1a17dd29ddba0c310a81ba552706a23f4a63f608d8686b2105e215ad2328def38c5f22da0434a955b51709b2c174d3c9ed89239f10d82b6052fd5d4c335857822a420279637e7e4f3de73a9ace680ef1730dedcfac498ae028f6eff648d76ccdc345a0b081ac1686cdc4b3887ff750bb81613d3925fdc47f581b97a17e965bb9db719dbbc02511e8c46622fc85fad32dacbba8eba9d849d7897eafdc8001ccb1993c79722b96837e9ade2014b0f7100e4b22e4c48c56c0ab45cc09939c9dda345a2415ca14ca10f9d80a77428c3c9e3edeaaf5263e27119dd757820e581474ab4f4ecccbf40cdeb163afefba07ca86f1e665edf7941577732b47c5311e09fb10ba3dae2f11f2ff6986dd0972e4335206b6d5735ecf9c1b9cb879eae5b1c819767827bde14dd6d2673685fa0730fbde1a2cb7fde3a8557fcd8c79bc42adf370567d771a6951a6f90fdf44823d5a25b0900dd350a27e0953825bec5255c953ae46d407ae2d6ff14d114fa2bcb56f84f14826d9a01dec589e623420bc37e77bd4807cc112570c22b9d1376c3f000bf486afab1ef4ced9982379d49cd8c0f1f29f3f88365a1abed833778b8cfbc8f9d8e2c4e4590ec39e0462ad49bb3d2a1beb40ad11151e52a9b960f4834ef7dd42fb879c5a4d1e95e5d8c77534aaf007cfa9efa40797879da6421c35c66fbef1788af9c187531d403ccd10da636b1fac3c98bf611c33f6f2f5334fa795b036601ee96a5d9901b0d8404766f8f9a2e67f620769e0105b86876a84b0494ae75802eabcbb1361108fe6e9d6a74d6fad1ba07141bfdc54f2c0aeeb4c5683c167823918ebfa41a16375f412a2a61bec7566bdfbf1d8076c7f55c119552d63ae8e450baa0ceb3fe999b54598910db8d5419bfac48a8607fb8546bf501e4b4c763b7edc4ed91520b9fc99d41a30362d72504b6e78be4a8776c54807a431e4f4a53d0e6022512f18f14edca35031e81d4862f14e5b00b3e0ea866226b88a1e5722ed1a639fc4f5042b5350d246a5c40b5d6c648f76cb11c30f86f66db5ee266811df8c66ed110dd8cdff815aecd2fb5083e2712c5c1113eaffce16f56db0d21c5d8d70799925e3b0cd8b77d8e06a1207d667993a15693bb5ebe3657474cd6cde50d679577511756bcdb2c6ee2eec8931f24a0d1d2249147b3cd815d95744ead305c919f9c4363dd4d900c8a3d5aa2ab28579a5093bf4cace3350d91c2b4355106bec93482a1659c9ffe0772dc9dcf2ceefd9a283b30282f50ef5b2f58639341ee3711b51f05c4bae7fcca6f174b50a69ce0cbca3324f9fc7edb38da8e1fa7e10e703092f87b2e32b465308953468d70c9f4ad2e38df9ddc9275346a554049bab2264c057eb1ea3678c61f1591b4da705fd5954121cf06fb37e24a933a049ea0ce8c663e1141af1aa3b36cccebcec37aaa4298d5eb2963ab37ac4216e02d8c44605504a716c3105663d41d144218c1f4cf9cc7bf75e5bbaa99a99d8c1b4d5f6da5d5391501d5020d3c93dd009af18bfcc06b2491a670a8312842c6a0b8ce07acddfd609f40f6291bb87c20746ae253973adfb0269b4e3f78b586093ea31808c9470cb90033f34f9a4bf776fb534f3ff28eecb880352e632d3803bd3f26105c57dd0633d7a90e9d499c5e1feda27cf5676e2fde6fa8ac4f67f2e2d2083115a66c29a5192592cbb7978322d36d0ff68760af4dfdfa5d6098fe044f5cf2dc9fb3d0243c47203254b3f149885667063e3e77e0680e8cfa4a15b4d5a7487a21a4822f5b94875ca08f5c6723dfdfbf0b419d21625ee757adfcfda4cfa8c352b93ba704a51f39beda1a26a32d2b96d143d3ec8b48286538e17d76a325fd2997a6d80a71babc5b7276da10d70f8b550f18abd47bbd4a4d91dc6d66ade12289d02f83b2a76e0f7bd6cb829e8458bd049911ec1dc6e9be21b6f9366a440ca0f7b66470f316919a5c991c3d818255e7d4d94d70e21358be17d576013e157679f108064dc2e63495ac16a34b7fed489b05517163204961ad17ab0ab08277f674162073d82d38a845f29be17539f39f46e30ded58ba749dbaf9f3d8db9d8d55727e782301509511aee511b8644df3dfe97e5f6b355740bbd3b1fa6171b2508ddf3a8359217105507aa32e0e1cb81d41961b951b274c8edd5196b0b15205da88ee24fa16ab1a2799470cde55f4467232c782062064c598ce70049e9a6776615dbab4ae71c1b5b1a06f9bdd2ccc552273be59718f0749b3d2a16e2de2c0790dbcd2c0b55135ba0d1b25f64b756cb4ebe8dab90fab62c17a9be61c1f1dfc864ea0faf4cc734fc08340d6fc3588ab860c3bda8e06a2a21472f888203085968e220343ed925d1f05133f67e803278a83ca8c53f170704d8998c7cf3d309ae6b980712caf2539dde4a3b459101c7585093bbf8c7271542884ee8bd127611a7bc5829bb6e1aa4a182c3b1cc636ef7afb1791aa8d7a40f75e7cc6fc8ebe4fbca291d2d1a2337c7ebfab501daede14cd69456f997579d285cc83060ef943d24f46bc9b1f8ac550d237de6da1a52d09a17619652382d7bf2edbf380940593f6839e6af35b48cc5110a145f411a2248e02586a04018e70ad129e5e0d82e71688d34152fa4753ad569730dd5a153540e5acc33e627289270546d679bb0c2bebaf14cea3c78ec74d2640d995c5e01bc6467e9426f3e4815bd8bba3fd5bb662564a9ec8321c8dc08482bae0031e89244fda3d0eb4c0996aaa45e21f2cff397e06308d14ec0d0ed3ad08d8cd0775fdfd590ad979b12d2d00632484e4c9259353557b5bdcc63f25cae6cdfce3f0fa26cea6f806b0da6d78d873d603695efef58acb0b7027d7a131f472e715cb78fd9d7c7b062746b1139ff18802688ad4c700b5a16e54555c14ff37b27ff1180b281f0aeb740f0795e78ad576a3629cb7b7365d469850d9b1892d7102a4c671649041983d7424698eeafccec724b2f27c8f7db3839e4f7b0d1ce5523ed31e9c8a554c53e86b4f74297e192862a5e3b8ecd4679e2739669242274a11554facfc07552c41c410e10fda8e848b911dd9cbb66cb73837fe05b8dbff61df397c266768ff3cfda07a5a7c0b08d64beefbd705086237a6e37fe7fa66dd1e0833c87772fe1728ebaf19d8965d0d98a441d23af3fd83c98bf0ebf82b6e89bdbb44d638ce8c7476cb0f65fc2a8b55f988847adbf51601dbb801f974f5a1421756f39482f07e0bdcbbe210277cc66e08c78eb574bcd5bb8c547f04cecc73c98e3afdcb29f645c2bca38c0dd18fc42ec7e2df614290bdd84351e6a19b3874d94b1085c51c5abcf3e49eda53e5a68038936803c1c064b97e1110683d006278c6977115c0e5ab0f93102171ecbaae600b33f7c673cecb710b05f9da33fccaebc3fb0c93f147c3da18860a955a0117f969cc5475f0a1eb7e85146f5f203bfc92d2b8b2e64167615a7fbc08f5ff2758117a8fa5d1e628c093a4a040942afd7082fd141bd47fd2c3d36be4d2ed0dbd61725391ebf11415781a1bf64a1efb862236b35cd4a4edf611d388e3c694ee3b820ec4136c4dfcf8c53db4f46e59ae97d750016d850848151bd892726004ccf1c9058a21ab1902c8f913d0a77bd7d3b562b2d3e40874c928fd24479a8dd809ec27f8d3d4a2f6d4f19aea95a49bd523b47520a524bf2aab867247ad1b38d08108e9bb888e8c06bd5ed0185c681099c76ec79e703b91e432abbfb6a6f15122da1576f3e48ee7c6c4ce392e4bef83cabde842f9d6e5b47c829eacf4840285c0f9a8287b7216535b197a5ba367d4eb3f65ecb21517784bebffdf61b26626224104f58cc0e8aa9912d6997a91341b80f512470f7cbdcc8fcd87d292f39fc31f70732db463de6ec13960005810cc0a7c66d82f747cf7a8d9d98545b80430cbb88c0d49339d5ab13d11ce20ed5a73398875a7bf72b3580880c03ed43794a743ab22f1c5ea9fc23b7241487961c4004ce82fd595421960a37bb74c0bffdcf8ff701de2ab1c85c2c7dd945b026fd8aaf4dcdd7349a93a6ae56e08597ed730e1aae77689e63722a295022c714e09e334a9ecfaeafc7819f5e23615c89ebc597f76c454b30313bb0c78bd5191d3afda117522f8a644cf60a8c7cefeab7e1d3a00ef72b3c9f346e2525f4997c9b5d367405858d2cbc119fb39fd9e19389172561424ac5e42b0ea61b2d20590d5ab978eaff8d5a3a6cfa70e92758922d6334db7e2e2805c46c082404c296f139115c5c1a321d10a09e4c259e2ca77cd8445a144684b45acec053abbc07669bcbabdcff96bc7a1b8d2b72aea659d7167b4ffdba06e898ac22ef4b0d77d459e2f1408b8f35f46a51e06a9f4a127a44031f08c1476f4ea36b567a2777ff23828f77a90f27d290b68c289e7031f8b8aad1912924304df99587f296fd07275c10be70c9ecc57a86deb58e40813bd369c7b677fd434a63c98f0a7e1ddc252f09dd782a27e8f28d4bee603095963c55dd2450fa883f55ef4ccbf4f840d2ef8bf266ee70b58da59e8aa2c6b8ca74c5ab85a862c901ce9dede0f9d6c7baa6d2a68831bed3f733a7b685eb14a0164090d89fe46ded36e0018b5573ac5a3dfdee9ba742ea043152496f0a6264a23a264334f23b1124fdb92841e375326c3d2f70edb280a26fe04fdede45d2ebb76427df71aac7e38991402b2cff13c95038cb1f203baba32279979a7237cd9e8306141de23c0f2902c002fdc23ea7fa4e83746be75f1612bcd07fd5abf7f0d6d874fffb6edbbea5f390de233226192e58736d4788179c6942bc2589ebe11a2e6931c43204854a50d95a1a0920ff9f149cf892e922e4fdbfe7bb2ce28bded5e698aad371059d40bd4b952f8eb7ebf81b030471e08d54e923ea58ed81d82de3fdbaccc2cef2f2f1ce8d09f8e484b65f6f03fb705328b370bfe8cfd25f0b00828d2efe1cb0d9a2590be9cddd3dbe5545c458b9cf409bcd79270824e2ee589685308067d1653999e13df209cb07266c80ed58a382e191e5a71b0b8647a0f9066315d18d16b8a19bd2458658ad9c23d5b2d2dc3fc08f3de95732aa1e4fda130029ce5ea54e0b5e459cb2d562edf566bb3b0ccfa08cb458e15767894d33f0f343bc69798e3f28340a9b7346188161f9dcf05aac6934ab03a362506ef38188995f6b2a9bdb17765f96209d29d8861345950debe486d42be26c0fc2bdcad76070b0bd6d52fbc997f7564444eb291be1daa1ba49408b7dc1d26101ef4dc9607f3868dd189275b7d4274ef247750d6e4ba1db3a3f141378f8e467c190dbe9da24f63b276f0f40d69fb61292aea93976683cc324a5b2490ee06c68e9b2606e188b45b9085cd8db59d3cb23b48b00e784495b4aeae629c2de866b127b6d196dfed739964ee253ff6e4f821fadce2105","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
