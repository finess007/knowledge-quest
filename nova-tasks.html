<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1cfe7e4da3513d2ff3106f006daff2aba8244b19badb5eb5d19c570a142afc333f4e2d6f093bdc9fefdc45204bbbefa5d1468c084367d9ecd7425804349e1788988ff79cccc88eb03b9ae2e640ec9aeb7481aaea4daa12329e251ef41ca0eb32288e5771bc3ca1e90a03ed4504f765fa67a1a0a6a7b32862c47af887a4f0e3e955c3032d7dc633d4cf5a2224e1acb6d4e68f867dd002f8dafb15102dbd7c000e2baef8f32a9916e145d0cb99569c2ed670f60985415f24eb6ae4e591d5145edb0ac50fc5864da6b1cb3a5f119c1d709c8beba5b68127de930450390653f3d7aafa718ccc2f3fa8539cf2f0627c9d60a64ceb975dbb6592bb5edbc48833980aaaca0e9c6175005211a1c3158f19343dee622618399450ca1189471f428a78b6641d40ffc7e839a87fbf2c2f8f536229484148f9d1669a4ed5145727d1560399024ab72ddde68f9a3f9999cade30c58a0b25d0c35db3a7818cfb495034fb2e5fd16b0e17bed5c70a19f2072eec2b9125903303048350abe80c6a605d85bc99e74010a2dbfc5f79e1d060351de0f45fa2035a85de12b56c98cfc48df46c3f746e8fd64c9609d5dac77a49bd5da6c1ce55e8ffa1f00b892e28130b0eaf30e0722aa108e3326934424fe3dc2f6ba16de21ec38ae502be9eba4d7b6889e7333a21019c00e9749b3798a8a8fd12242f0cb827f9288866f41faa66ca081ed906bc49cbd11d611e8829b20f813b1bffc6098e5ddc1e97cf1f63181b5a4c6cc29dd5a650a9e6060bc901148c882b8ad29a7a7d0ab27cde2416db42fbf8a006b85c9769b827c7d8f1c5ca04f45d7ea6bd21d8b50714a4476e860c0eb0b629cd794f8e3b43827bf122512ffbaccc2d4122804cf756ed8fd3876f0168f45b0f569508ca7602c8779462f4e7cd6a4b41472c09b92baf0a25972b843cdc692d37c88566b1f9bfd261a910383bbdff24edec7b42ad614ea158731c59f8d7b1e5d8a6c9bb5e28f6eedec1172176d792febe2a85bb7415472a27590401552ff68ab6556158a2c5e91d4dd130f77004b317926bfbd7a44ba5aa356f7f74c6ec76aa38670973cdd3990a003a1125e49a3fbe79dc9846a3a32ecb7966f0411b8ed5e2500f587170d1135c1353381b7e969afe5673d4889eeae4910a2d97f9c40f73185a75fb69063dce43781bb936d40a9aa5e8e0bed4d1437c97d422dbab25ff256b3ef3726fb02152c36fc022adb72dfbbc96ac7e26d4fa28ccee918776f857e1285f3dd3559bec4237231e656eeee82427d2d6fa7ce0c2ed6874fa059fa8a10bce7efe3235ddf0336e337119653d638ea1bd118d9cf18cbf81bfaeaeb3836e9b188fa45425697ae7ff14625aece2dde68519641591087b676b64d0d5f4e52b82013238ccc0894d480fbb1ccc03549489f41631d1d882d22b304613c5b0469f7617adc4ec70135f02c49fc600dd5b0ae6d62c415ffb78d52aeb733f4ed02c765e6be6a317c29f44b634c5668c1fabbc2ce936c883a5d708dc520d1361338fceb766211096972d77f539141173b2cce6d692320b6515243da1ca59e7dc4e023a273a373e028780e2a845f5f44f92027034b7ea6a46398a617e9110dfa644d131524db8a7daf7c3af0b3529127025f19c082ae229291845e543b947ebc84a6b16aabf96b1da00b6a013a65eb5e2756fc6ce2f8d2e4c9a9fe076506d671c0383a2af6d1eb04727280714a49e2adb9a3b84a971e43e30a975bb4495164bc1608be2aa8f561e36811725e19ca685fac7a25bda35a414c1cc8c16499502579e82aea2cf74c0891891ba1a752aa772177c97d15cd1b47ac8e80cfae839a30d1d11bf6aa8650b69ec22d08e8218c95118ff78b3ff8b3bf783fe5587291c9e04c8a7161c91d1638b895e150eb34e069d8ca8e1d2261059feacd01ef1448398e12cf0affad25e8d809294225aca3104e2e0823c41dba81dc8dfa7d0836f59c7f75bb2458c7fe8a632ed859d440cd5b50934828f2ae069910c13a787b2dbe488f6c391b682934374bdbac81292d31bfa4c32b3caaa8f9b72f01ce25227372ed51c231e2b288b9d04e15b3bcf0a1cb6667159aaf4200dcf55f1ede9c078af6876a62ea719a7823ffdd0db296dc8329bdb1fdbbf7e33bdb3372f05ae3a99d9bac5ee05606d062c4856f417322e31790b6db1040597c005c7a4ceb25dc91e2a7268ec632104eff8604874bd8f7bac064dee7d4497bddf944b8d8345b3f5c30639ee5cdc38cf36f353e56f29d745a81e22d2102b92a18aed1f12465d1a0491cf86d27011593ddecb4dabcac8babe8e2a9a4db3c119c7db9070ef5ddd13c7e2ee23347133ae5ff065362896431e5c3bf54543b18fcf1d771e73be1e395496783fe03b3b6bfa0fae5ee86bb8344539d2eea6613c3d44c27a5aa0d63037e64c8364c7967a9efa116c33c440a9708390daa000efe308eea85d07d5256d154917510023ddf4af136834562c4feadca0fbf097112bf4126434dc4e4f8e0e6935cf17b61142422ca19e91ab34597954b0b6f70d6920d73a81d0a10bddbec9f8013a52b3f6e98dd3fa877e022ec226adb880ce03866ac28c567efbec4bc163f621df5d232543320acc55c886ff21004f367b9870b8ef432af1f74d5f2afb11bc24d1c755eebf86d21adfd3635269656ce455bea465fa3dfa88d4818b8560647c944b6622536f24966173cdd3eeb5b5e4ed557b257253bba92d78426f561d495d7fcd350ce0376faa3bbabc7fe425152d7588dff58882235bff323146c9fbbbfa4c655898c68fa2769843ad6fec7d11c051cb50c6513089831bde69483c1e81a00829a1e592a3456e6b74a6846d58f80f10fc7f1b50a4df9ea6e94085c8f5ef5eff4092e3f8263641b83ae68f6796ef97045b61bb04b8aaf3e0925c97f79e1c005c305e8c1a052d879bce625efee55c7abeedd68e12bfbae107dc801c144a39308f48af5fb88b17af3f92df98e6cba97cfedcf043dc15f449c0e0474fb66397c3debebe0ec2a1f2095cb2e8b9b6ac1bd985d104adcf4e6fb9e802fc5f6e36072b86f4e7894ca260635ba41d72e5e4a56a76c3c6962190590a2319ea9557a2ef5afef8a328f038ce3895b6a80dac4c9e636f525b362d718b3a8969a8dc78470568ee460cbbb73bf3521362e9cf409bb56435ca88c0df8ecf97d0475ae3ae96a8ef2b7eae357126ee6ae7da84d9472cff1232e8cece4693b73428d9c78b88ed7c1064b5ba86a2c4310345acc4d35c30f5aecc250a49abafd85308e66ed7b0bdc0702765042de3288bf9ba209212467ae67e5ebfef2b5981ddda26e837e501b90e824661afa3413c56a3ad701a6576ea5679e57b9118e14e907fd47400c6a3db7d4d87d66c80bf7e1740a2d0510bca2f2d8ff862f8dfab3d93b5270a702c313880f61733d935dee8f9aa00b0a87e87df47677bf5ebf2ec0f17d6663c8486b8e4e30d6c05f6118a2cd808c3795c6ca0f19d89615688611ee30fe92d207b0b450904cbbc140f69eb2ea4f8011b1a466b87f1c978f9224bb42401d2855fff79bdfa1c68584675364afaf91debebd6122ade63a1a52e37e59b84822896d316f150b292125356b4d71586fa354ddd7b31a64cd253a9cf2e195bbda8200bfce251a80b3c26687a6a6a1f2cad90db34336582527564c99af42d2554abd4cab29f4d25f96ab29ea0e6bd4a43fb367b2db7010838e0c5cbc89d2c8167fe469175254688b82920d9bc61b2b79e8339e4fb4e5e731749cb8737be53faf8fb6975a3a61e0f5366b1242b81e8a40af2b72adca4a027d87c095adfbf2b66461143d4801e829f39e290c40bd55cd0fcd801ff51a40da0b3902e96e483ea19724064125d994dcfbba4b95ae3f3dac1deb30ff95d4511ba3733fd287010f909df06aeeb1f14607807a8c2b1edb1b0f17b24632bfd4c9bfdbc52cac98ae7e8ed45009dfeeb5915e40268a76387f71f9d87ede4a49a814c99a0848036ba5f106efbaa9e1ccb3161dfaef8d4eeca3649fb27a0c20c9e0e63eae05ceaf86e2614c234fc07beccb49891a98788727119ce9a3be341ad9585ecc11fd30604887c371a1faa09504c79be25dde93826be1fe413f7fa84e2b4ae8066ff473b53e312352704370d038b61851a09dc46d96b3f3bad6e953e4042a59a112825001aab4a9c2dedd22afeb9c0fc65d95b208ca8ea528447dfaa3ebe4171af1e520a7396d19f05f894ccaeb4d8bfdb3773e6358f98940aed926679cadb52858a9243e179fb202bcd43c36335dadbc0ef1a55f28c522f821bfa81e028bad52e18d8e1ba4677b748e1fd9c0dc5b060ab6a687af4351036a415cbb8c709959009115cc8042683fbed27f7be424afd9f6a4672cf1d702905a298433cf13ff18b800f10ad23e0f2ea89adae09f0c0edbebbb33e10545eceb53d6266df01bbc536fed6006899ea7b23eef5ec2835fb6632749eaa2b4b446dd00eaa49fec627d0f812777ff43f3ab07e48f6d2f7ed096711fa5910b32b54a2913fdf64c8f0eafa4db454b8eb2730f9383f59c5c5f382657c3ac3eb50ea52387b3c62d7060a3e71fac333ea45fa8e0dc181f132370088ff7de9bafdd4b2d41c55658772f542f8ed40f5c2a56074da00c8b8c2c8dce15b15c5470d6af60e9f43ec0f6a821d18c1fc89e374777a337bd0926609b0551dead2ed6280313801de645abe7938cd22619c77a99bb70b011cdb5d79e4de1081e88c06776d975489d7c4982bf2b776ef506a033f8d395dfd60613f60b0703e58b3f82070a48c17407bc83ed63ec850a1a3bf11e1e4d519baef1e46fa9ca651fd7f7b7d2d573d191b88d43fb6370e0a6c35bb301d95c3d80540283f01d25bda17078453b1fa9d06b73effd5b74ac4ce99603dbf474561e134301a76e5801ba591382c5dd0c17947a8d46712f21599ab05ba2b73b03ece8b070739e2657f737aa1b6f86eeffae10deac748eca5f64bf3b8a79e676e82e59458a69000f8d3d0a884972c0f66333326b38a3df6c25ec3fa11d6c6d52ddeba28b960363ae57e1ff31230bedc434e5049c38208926bae89c13dfe1f9d60eba75bfa83e21f817ee6fe897a094277748ca6987ad7437a79ec2e1e43c8792a341250944ffeb1c91202e98779af74b2e950f7a1c2839fe28b64467616b387dc6aa4cdee2aabd249c5f2bcf044f6f2639986ff0d3dfa5512773006fa4cc538c2f4dfff18c9ec5f5c4947b4a858e8686ff8d90edd1e181e0512ef036657a23a8849e194eb8fd0fa81b10371f726f59d6c921484d36bd06a863b1600afa645df7461d1b221b494a4eed784a47e56e1077199e9706230b17819e22ef831429a518cf3e50b4daae31b5a9b626f4283cac8050b8d079d4998dedd08948aefbe750648bdaaae3483124638fcc07937054cd39d0ca1cf71a59df3e3cd0dd08dab4d413517a06dc1984c9736ba2f5291a5945057631d39330e5c9aec394c3bd402f1612ba671ebd3d17e7f61470355703317570b0710907b5c06a20039f851d3c944faf66acbcb72f3768da809bd7467ecc4d89994bdb938f6ac079219debe5a9a79a350ad616ed6b93e2ffd610f18feca38fa60ed81a02fbcf61adcc26f44e10d79d84d9628fde57aff69748341a3c001f314fd398a9088ad16ef3fb7b68ab182929bf584cd6692b96bdefe2bdb92ff130c751219f9c5d8042cfe38f0b8418bd78dcc25e4c39964c04ce8408f1d568fe43ff07417c110e2f33e8d101517624ef13709a40700a8d1d72fd6d85ca134b4af223b8f1fff9e6aa3d010a493dd2b0d4c99876b8a280476f34de87db9daff791a366dc4d6e634f396be6238817ce0ff6f5f49fc2967978f8a7509f08ce36865b6923d2d8d8919852804b6a85c5807d5152d08661f0712fb8d326fc929ba79da69ac08dd8847a22e2d9d7d2d1ab1216ce23c748723e5eda73a56041074ed4c9b4ed88572da4c7b6d6027dad893c9f34dc8ec2a9412cbaf135a9f171e84291a37dd829b6c2c28dbd4da440cf2e7ccf1b79afdd43398d967e56d8a1a1d1b5947f6c9b5a65e6b0138707072e41d5780622e5e4daa9b87c4d7bc304b4389da8c09597081933e7f17e2ae89126c7a543db22d2e55ab54ad9777ec6b74fe6cecf95544e20496f55dfe842b4ab23983a0ca8263f61fb6ba7e7786b05594bc758a96f4d9855b1ef1ef3dec9e8a6305a1124d425d17cde4ef3e5e546ee72d9b2e64d9fec8fe0bebc889f137e2888e7c38b686229203f9c346863cfebb3ed86e85d2ca98c3e4ede1802f7284081da082fcd007bebc58edc4ecb214442a07e84e3e0174be44210dab9fac16cfa7db4333b671563411290a27ccb1c5a11a64c304edc8209606d7a9cc1634a5f746d02f79d0fd4dbe13455fd63a47a190831be99616e5257a9cdef99d708ba23819a9e8f898348a82e14f24558b21295ad9e319cd8ce646e9d402ecb1967a6e9b220632a98a019f1869c70dc748c185048e65f5baa66478e0d8cb6aeefd752676a2064c198980939164c2a810e0bd2bcf23658faa87ca25a73b6bd78f8d905f12096cc60f12b88a305f583286cfe662e58160d0e9ab3273e20ca87ccf9aa42daa644bc6c881badeb1d4b1790c9ad05e7e6aadf71edff5df5d027200fd0a330e775865efcbf6e911b5dcb1ef0847bec990c98011feb68f8721e8f26a614e0a13381019055a8dfb96df35fbdbd09e66e3fbab7d1240a19549142e913bf3d340f3e2a8a098fa88cb7c45c9ff215a219990139def9f4f5db278c342369ab2714f956aa82f6c04aae99392c4f0718731a4d9ebb9ccd0d4f95b24a90dafbed6ada14c01232c2a70114e62ad2b6453bb45de263a8b88f92f83908b0d9fbda10974340a418c46ce528823b8149a9fd5efcd22f339011b389a488d26a33502c58c991c6fc8288379b95147803892aaf150e6dc265ca8f2086bb6c256590650e11fc7a664565a0a95ce7e710c09c9ab2f5f4b08a5ee9fb4a4376afb5f8515d6e33a721674a05dc3c5450b9b655160ee9aadfedfa18e26b55dac010dbbe17942080b0c704a0ab0035a9e5ccb00826db077f44604499bccc5c5bf009dd975c61da1ceae224da65ca94f8c689377d63c98a9bf8405b0b81c93d4a5cb5588632a02c5c62aba176882177e4923ff1aeb0e669d1b2f07c6b458a32fa4f69b47000f8e0a08ba2a210ef410e2a9daec9e98cbb37dfbd092740293987f7e414667edc9cf91618dce43c5daa05799637d998a98e7c8fbb8c2724d7ee2ee849f7a679b68960f0948be6003c45318145f92bee904e51c754dd4b5ae96163137e0cf092ef32d94304ae20944a9bf531422c39f9b8e1192cbf5aabeb1d940721fe25a8cc0b5c4aa7c87e01bdc723571071aee78109b30f5a056e51f6f36ba7a666e313d8d4cd55d1c7f53efba9ea732939c67c9b8962f550e61aeb1fdf80c5da8ccf75d02a0db0ed52c5d0a3f8462e58109a85117ec3f3e091f3bad493541a0cc085401ab2e5ddcd51d328709ef1e0b4fa9e9e5586b4c078c8e4c9eeb8eaa651d9244c7b0a0b03cfca2215899d4787cf50c5a98f61bf6652a60fbbfa11145533f2db5e262fea17983dedf36f69a7101cdbcef7a227b97ae807f9e0d73748f0ff417519637b62bbc5190f3d9ea15561d77193b77d86066f9fbc01bc25b2142764b36e3cc07b2564e2315e4ff7571969cd97f66f7307b52ae240cbeb54cd1f27f35c7300f52b311b68e7b91688a10805571f3a7a0350ba63ddfc49708eefe535371dee849a762d3fd43cc6c76a8d0a182329c0f9eb67a37f4a79ef3c5e073dc42df10864f62787ce8aa4786947ad729daaf973f7072be2ea0055342f377806ff0f62cbd31a439367c538d0a2076e6bda40dc57dabe0cda473ea0f0ae99879914c3007673335f61a60713cb2596df29cd4a7c2d0225b233d34d6f92231f841068ee9fb7617c05ee66e1df18a4f64a80b86371591c93801947254256e69bf892cffa7c6f2e0c3d382106e4d82f8aed879fcc8d72b8412145a4d12508292d5eedf09fbf4c03957808bf5e5a65435cde4ffb42b158cb94071d0de6f7900b00b25d5a3d70b866537c42e808a0bd98f983b5bb01eb765e982093f693e8555db8df1ee11d626c0fe705fe92de927312322e78a9355b0880f48d1aa0332519ca2f35079c1b9eddb01ae1083d1e6ee61af1e8eca4caa13f1170a70215b8b98915430f95a77b60895153390db19a1e8975d3102995b73ee9d498b105dfb5da1900f6d4d430811633c02f0d17a572acea62b0ac6fdc70c1c27fd0b8a013ff1655abdaca17598a3d5f01460de9bfb45b76104f98fb88a24cb7960acc0d635fe2d76091debcc49d02f62471e7e5ac81414c2f271775e8cb0422de3e3d193b262e9d450e71f6dc9a82bc42eaa383fdf7d5fd8f8c699ed106009a7333382a370d0bafca05baaefac28dc6f5ee2579a6e0ea188425b6b89de660d1da6c55f4f47a40678989e63df6eacfdd3e24daa366e386e65a19a3d0a5b0545536fae87354600ab56466c52ad84e97a8d996003c57f04458332c7b48ab9f02832631e0d05d7c628e102417d1da2b647dbb5e48bd571eff37949603ab778cb9164cd6de7c0f12fa2cf7098ba8aa5277b7630ddd5b00c9cf6be1a7d89eb88afb6a04a410707012baa2fccc401e3fc598cadf5976847979ccea8dd36cc2217f60d55ae415f19e4c78fcbc0ec49848369eaaef58fbd22ecc826bd2d311c130f2f2262e0896049e89550387025feda249b672ef7f064596772467929ed56ff66cf306dbc140f5acfb0de19b5d07f318a459d8687a650a56497a415180c79c7e35b5552aa40dbe61c4849a186e6539e4690a9489d9434b96dea54152ac559023e30b2f108eacd1162a33c23e2cfe98654aa1c75de761dfaf50878d30a0b79fe66f43b82c0afa4664fdb54c105c64f2cf443bbd3fc593eabb45b1a7bc441d4ac2b96c2b4ef9ad7153655dc75385a8a2329cf679fd7196ad23007d1dba54459456809eac16916bee002220a7d802610ce2f23965ef0f287ae656433f99a00ceaadf228f53ac2076c35f97ef0398026fbc355dff46d8a53f86ca11b1e589e1208338fb74083ffaddeb2c4331c47eb6c5f465effcf75771c71599200d328d69a2708cba93343745ce8fd9381541ff859be35fa518c14d7a7057cf40ca922ef9334b911b8490a068283b19baee376e2590fce31b8cfc74e642eab4d65d589c76b6fb26024c28df7038378570cd119d19ba6d17ea0a293dcfcce6e1948f6a1bfc6417f1c3fc3e1317f14cd21800cb0c140c651f7df7006f325234440ab925d092bcb58d93c72a4320613ae6fcfd774544dc8af25cecb94734ece1940f118ee9a00235d898b241ba87f5406b1424ae569d0f2766488aa0250c26b239abfbcc27e3bc81bdc4439aea085998248886f10ed965b7d1325e3851e2efbdd79c9eefff8f5c7f66c99de13465def1c61ba26e413229b19b36dcf6c6c6cf9b9cfa306001fcbcf0d34fa4226f9a619bc17bfd83029cd049344e56339dcdeffc65c6057badccd02b07129fc8213f72f122304d63d9c565fbd780cb5e81ac5519c7a9206e4c3b3cf42166e367bd81a6415a2beb734671e85507a6a43b982e8f2fe02bfd7809b1d45becb5c8682a4249f80a29e757a7a6e94a30f6477cc2d0f3c1892839cb64a6edd107d50b4ac0b095010bec7d5b1956c493a0036c47c1990e872181f94a326f97a8baf6f51d731314ec5c24701e726bfe04e244743c48b565ed60da2d11b164e5619e93f067d751893ebcca58fe1d689ac5d0c22e9e142f9a3702ad8a710fe8b5b8cea262badb39c4b48aa5adbf48be1cb59f152fb685809ce5fe6178ba7b8da9b364ea2b646dd0067663d3b70b355ca14b90107e02fc8bf76a61b7110dc663e358caef05d41a9580e03beb736cc851354c00733f2c1b0c97592ed5586f4e40fb48fa0f8efc1cf44b106f6a6e43894d6a84e881b182356676230aa10268df8181dddf04a6df700bd0321ffbc17ba852723f93cf263ccef080e231d53ad71a3b57508b69a9dc0d5d5507a527eb861797381c33859584174b43230338b5ea225f675ec1073bd4eab4aab995da6e53cb8883ecf576eedd3995be3956ad756875aa8cf6d60fb8c87689a8bc582c01c5649f89c9e4be8b98ad502c04a1543ef92fbf954ea100a118c1d933f668eeb2a958c63df5e60c79ea98c90385f54b1feb46adbea91e7c5498d6872fea6078a7139f36132f4c0aa39c45d42613358e6a9ca15a42bdfa1dfc3378541177f2fac2a203f0e5cc10fc00758d11c6232a4b11eb09d8462d028d3a4486360551cdd4c789bc2f2cc1ae59c0c6f9797cb69b5a396674d99232c70e22ac6b15b156200ddb344e36fe8404f453d54628a9d7414aa57504a7370ab96b814676b4f8e74203f6532270f91a3916a885203440d0fae675b1f207894825f52ec4ee1fad6ef648008751de5ba8162ea768fe13e4f6623383f7f9f19d3fa79ef33c34546cd94d7507471064588ff7c4a9bcb0769e69227c9abd238aff27f2278e996f62895eee617ec02b18f19bc91b705dd51ce2f816c30c8b0039194d746c833c1b3f3a804b5be1c8fa3f1ec8ebc3d4b703e5edf1f90cf6a893775d9dbf7d4e7580999e607b7f8aaf2d11b9d8ea2cd727571b9a91dabfc4769f5d5d52515a1b29b38352edb0d5441b667f41c1dd24b06e06fb5bcda3fb366701aff5f9b6850dcde8a174ba48432a7dcd1e1c990077f90fea1a89c9b78c89c93f2f7fbb5647e6b05359a81720a932b73662ab78f34377e60d74d62d90ee4ad47ec9bd3c6bb68af25c27999de2e0152817857451969354f0e9f1668fd7a6221fbbf598abeb33792cbf1ce2def807a80d046488df3eaadae43df6054f697b60d6d3a1afc2494034824efd3e8b88ca6b3c02d66ec5c12bac9d377f36d7dce19c3bd6ee9be983f3d1a57cf71f980924fdc0f3fe431b9270371db8e79ad34f613711e7fc27a54b398cf454ff1bd4a0246fc809df2efd0ef47d1cf351c3de4af6f67b20ab9663f8b706f28a6eb630f4ebc0c9ba39d769e3d6ee760b00b73e46ecf645b47910401526c29cf85f2b1e9c18a18a9ebfdaf4c3131ba2adc13353d5799b3771ef982d848ff264ee18303c25d82e945d7d32e7346d96fafa4825198ab39cdcd3a7820735ddfb29142b0a0fa0e94df9c321333d6ffd7e8c346837d830fe2cd2c4871c6d5185aa8ade01c295436fd6af4ab91762b2bb208c4118c62baf9bc8a78a4ded8379f3f6c8dc5e0b7f2a9acfd2cbdd247a4fdb7cf70ffee272dffb44325279084d21e6181c52b8ddbf7ccf6b9e64107e0830b62a805c2764a35b2c29c397b7df555486d8f4651b056da025386aed1d12704ff2d13ab79c792bf8ea802b479d7772cce9d91b60466b36cee5133b6a56c498bff3564dfc64670e739a957c690b8cdfb2035216c5230a1a94552ffc57d0c83afc5033359442ce12a1f286113b569858a567c358f5a4b93819970661fe15038be0e9503a1eb17be558b22c92d906c9680411ffd4b3408b09a48647681f837188ce3c366c239d75376ec58bd22a6f93fcb78a1ea6c5be8af60360aa185c670b7857a17bad500c67a47ad22afb1e3de88f4a83b13575dc53752718b15bacced6279d750d235e16d8b4218478a94c0d0d79a7e19a1793c168a370614d408daa3a331252a0770b6d23b276b46dd74ec53623ba9e0666b96da06fe87296b00dea2cea0b78ad7756d20111057ef9c47bf41c078f235c0d2db9a1f4bc706f8815ec72175cc157ac9790bfdfc1b352966f2cb06eafb252d8b5ad1e07ec96362b701491970ec3b5fe0c62cfa8ad22d9b9a2568c21ca0b0bad23e9bf6322f65eeec3262add6ff25bd945c86d7fd2a84d82edfdade947d9b295afef0b409127221d62d8661fa98942729df043b376f7a30cc272e6cdf6c125041beb8473c0057fa6ecfdadb397cd1423f868316dc62dbca4e60bd9436dd5446d517ea39bf221a469bb3cfb5a0f7cd266c76aa35aa7b5556f6c5955aeed0f7c3e422531c0fbf9baee1550fb82752c2fbadab2085bbe5ee745a5f521cc5af4d7aa5eba79a99edd8d983c76221d0f25b505cda273ca5671169e3c8f4aaf5cb88832858b0d7c8709e53ee9e80a1cb09d2fe38fba922b15f0cdd5fd1956cd77941f1c616d745bf6359c7c556d48628d7a0508554be033fd33bca7a156bf8e703e21a241e5c5e4cddecba5bcfb222f0c9553fec9791341af51b9df91f77b8585aff54ceac220eb76005d20404fd2e3b017d3651e5fb67d7bccfe3a890409233cc10e50525b548733b3b4a8640075d103e0f973f2ba06d2dbe2f9feef6c2dc86c808b0c4fdc2a759a8cc028f0fce56593096b41cb0509269c7791763db858ba0b71ee08a7594987b837b77a614babb892fd1024a60ee4026b002c317a55d8787ea0971e51ada855681cbafe6022e44818798db0f8188249078d38f598f952e9bd267741f2c62d6710039a5c657b2e4e1ea185bdd14acbf3a989140588eec012edb65ad65130752d0a152e6f92b0015bfbbd7bf168e0afeb335677233e4b2b11dadb5ead7a3cff87b26dc4c4a54fa69bd697e5c9adc5bc0bf1503d539e3a1312d5b0b4055d79435bc3b56cb220246cb9c5a193fced47ee042fc4c0f48efa4318726299cd1ff00467aa921297aa71a455317e5fb25840922e59df41934e3ad6d022ea6d468f4a0d6772aa356dbc2de34e86b5621966de67d24baf268db27f9cdc2ebe9b967b6a26cae14207d518a6b5f951b415f0902b046873077cc98dbe773d555a30f756b7df0b709b80e901a3a85fb1c0c59d014c77927cd5f5acf0bfb271f94d55f30a63ac7b3ad549dcea008c0604b896f7de99f7a1d7bda8c239905a528480be50b6f3b51ca6bdb843b98ec1524117490ac176c5f11219026f9810d48e463cb2ed2289c8ea2c799a2d4f94dccc46c3f80ddfcace3d409f695358ef2252470d2396e4b46b5c490d0dc1db002a980c62c154dd75e9aba4f274e127d91dceaf4ce5443176660f6ec35df2aa4eadb76288a155dfe59abad63fab6948b6797e3fe1b05809e1e99dbe4ab88727839e92da96488bf9af24d138ff6cf358cd92d3b66d90f6471a449b6ac726f6dc4d8b06f5bb33b318c9327afbd83fbd32ea2c6b2a578d0784c46b0e821ff9c5ac9d73c5a02d40a4b583327a52fe6dfaf38a7b046f9971f9cc00a917c3031eaaeb6493f4e177c9df1ebe55d85d6cc0794c7a756bad80f7d793d8832385f666cfa6298c346046d063b3ec2db8bc041961909ef22d66a51a3fc118974c31a27c9f159a36679ca2e43e65ab6913727988d63db056a02a4ecfb42faf70328350edee2f976a3852381be0bfaf6c2a5680f6c7b3ffbea12e6d1a2fa23025bb23d3a041356381edd553a158eac77f0d9930984fc0cbca1f77cae34da9efb26b972e86e0c6e7b4fa03cd4022cfca32cf62445ef8b9927b9c05c3ef932c89d191c6d3481949ca268144aab3d9c4ab4dfcd0bd38a0bd90bd6ddbdd2061d053d472655894eff33dd6c6cbe1157519759c07758e2da0cea834a1457bd09d689f2e33958175af8bbcddf3f4ff3c53834f3f057b03c45e9b8235475e76396315f0f0155c52747750c0ff5ae45a6cdc38d9cc6293d1cf89e177dd8ae6f496424796235c3091bb4ffd06e72266979d44e9039a24b216900c67ad69195dd341ef0ba2a7a47eb676068d780a13602ec2b4c6ad058ceb748cd8ea091aecc0612ea535886cbf694b99bc1d25cae80fe6d494bc406823d58990527cef6034231a05410195a054e2e33ca2060e553a3a633e3099c42dfcd90555f4b577d9571b070d92664f5f609b22ef259edf85db8712d5b561589f31e6bc0159a529cffee86cb4deb7b683c7321d0c38575ebca2e20274a92b554e59e569d073d74f0fa5665e61e82719e66e6af792cb87a11cc219a226768e17a110943d1a1ac348149e88397421d034fb8ed64557c7201b8e9de92813ae8ef2625604f609ef5229819752745a8028305cdd3c9d7ae9026963df6c20691114ce036796d989becfa78be6b082bbdf2599672f828a22644593aa2a3d72f3bbc9b0d118bf0693b2de95e1db03d2e6f802da501944ceb1e0edb7d19249ed1278707684b7f95dce1ef7280d5786c06f985870645e8efe7e6b650fe0920e5b43456cf3fc33f771045f6e565f88f35518fc403f33d767f8aefd7e989c079ad8db313d9676cfcbac4873a8b34680e5f4d28f81cf74801e4c6f3d53387f9881fbc8d8a2d66c421fe2c1a0bccab28988315b9d7fd8a9b46267d037e45ea04d8985e7b69831f9e9a39525f5d5c00aab51f013094ec5806e2a0f32f4e1eede8c3f17ba98487d2fe7efa39110b6ab5ce12527aa997f7969e79d0d84f82dcafc168fdb741fd4010493ada17f52cf3c7c2b3932919646246fb048b74e723ecc35e0bd7c07","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
