<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b9f69e494992936513db0334ce809d19db1ef22d0335d297c807ad03d1fa99c1cb1a1fdae904a13fa3b114da8b7ed96d5cc998937a697358ae5b9f8b467a54d932c966019bd643ff503c524a6eca0e126df36b886f66f2e6aee9538bf86a5cf55a4822ec8eb5093d11d4b7a56d74e4725dfe556b269c8032c2228eb4eff7c826de3ec1183bf80fcd941ae5755fae334bcf0dcf7fb9d25aa2ed83384cbee164be0005e70811c54b2a1ab7ec41536c3e591bd0e40e1f4525fc8fd55420be22f9e40fd4a14626045ae42efa16db1fb1c50f80efead7cecf69f2a25c22767764d373e6486b6228641fa40ce18066374c0665756afe32c23e88d6acf241e799cd2cd363cfe752a3cd653c5d0cbc0e09abf7af2e3bf8f17bc59f2714aa945476cc1d88ae002ff4b64969a3640341f07c884379fdadf529b062b2ea5f49923cd98c148e3ae5635620e84315e403a9f6b5e74450eeee045333f700462e49b73a5405b28428d3e6cc50778caf8e2d45269a889985349ccec94c7f76e806257064f0f34c2db66ce43d7eaecd388c0ad0a891f4d3eb7c3fcc9ec5b24367c74a58955a48d8142d7d05f731c95cea0e2c5b2e851b14e677f32b72c51630a1a978ec7218baf954b253efaf5237b645aa47597043f1abcbd125a40369fe8ef5ef9b33e8be557b8dc1871c85cfc1e9f6e725b3524f26d102c91aa3f12a81663e4d50631e0bae0add8d589866d8b4880e54ca70e48e5f6833ee44cd3c333972d693c38b56de426226defe8eff02a3a3e0250f879aa4c0d62b9b0078597c29548e0edaa8ec93d2bbde5cdf77acdbbc7db5bd675b4db1033f68c84a92fd650535f65233df7ee5e671e08e0b632ec7e925d6c528ed13bcf9212159100ea7609037f4ef50142327c0473f9cb9d3504b7f97a3b340d4839dd6c2f27ac100908466730efc2559d3b34e766f2393baf85c7cbbb6de514360caa6e0ffd8b489c6ae55639a4c4346b962d8b01b3f3b5e1742ae52724c4f12318d53dc87f9247c436fe7c7207e97a7b76bcb51e5d729475d181d782cee7a2baa72c17c7bd0b73f076ed0e2d4a172788b5d3125bcf00a3db4c2b9c0b4a7a65fe3f609d0f05742c1324f6a306d8f18bd6e89af49699634476b92d72f279fc305a4ab4a448ff1d270276f35e0e354016c8b8dd4dbbb71337bf69b06a725283fe26ac8ed1acbd1e1bf38f88c20298e0f5787c89cdaa57f17d7382509f9445fa06383e87c975cde61c8f60b23e972e5cfd750c804103698736135b13827b78f0ce6ba31d758c8b156a9b43949b95ad9898bce2f092f515ccf4b6672791ef7cca720d913ce5105fcf897aea8afe26ed8b46c63c3efd3206d14c469a5c9a220f76d404315caa33b7790818739c17adba894a9ea36bbc6ffea27fe8e6d02087049046b769b33ae8e8d5c3cf91ced3a5486ee02288d16ec93faa552c56d6064e606f1816b7cc8075a91c008cd0e17a02ab6505e58c8dfa6a52e540a9952675a1aca2af0362615e3ac48e3c23db7e7600349c9e7b63caab866a938cfcc693fa8f50face75366cda7faf729d2e2d5acdb4a9a6c655a5e405dd0ac462dfd76629958af947114c67e06c1cafbb738a369f6d73d8dd93d07f57e80ee2ea22b76f29765560b1b8ba921f05d5546b4ab86cb75003f9de868ec8b3a1c06373c48fec5a1edb1edccd397fa0a841b2011a70f839b86e48baeeaefba02f9fe2b101f2d95af940251bab4e8b62c66d26ec119ae1d4e7307075545fb78db28d39103acbe2af9a32144e6e579f6b04921104f9960de6426857418926e8f3a2def03363092f681ef6f0244de5161249a5530873d48a6c36d2c73a36b1f8e02175516a4808e28c45d9e1716076ba64fe562074853e7d31846e9cfeb015305dfe23b1b467b85b2d675df80c33aee56fbb1efbc58b2fc8a2510ab9da1dfd3b105409e05ca400f5b31c60780c6029c0e98c090f385dee675f0136729cf2ac121e2bee13c8b809ef0691b1ead1543616ef52610eab5b789fbcc0b907e606c9f621686577dc58408a1a3d70c131a45335d773f7dc627d0acb6034bfbfd456650bc4da5280cb8128922d72087edba16676ed4a03f9674fb7a31665d2653cb5f9b5a5339962655da98144172b0dff59319c30999942c5dfcd9c6f73f564ac01495de6cd1c8efcaadf6533302dc8441da3542e7314500fcf144a9f67173e1305ccc06f31febf5d5633fc4e41938ce268cfa859b542e3e3651ef605c7fc8882be6f3f24faf6030b113f4a2956283e5a7b5a0b082a9a95585f9e45d6cb788cdb4f5057320ff2a218532d37a432ec628309dfc8068c4b0aa4402aef3bd36bfd09e8c846c869dd29dd3cc14075a1c4570707c7a7272129b57d2ca8f76dd858a783b4cd96513749cc6fcc7c52358f8b1bfcc17bd9e59747746334cb3d762edb0879a72c5f79576e1b8f5b4407d6e2a56fed9e320e13072d69bbdad30c007738f792a78bace6db2b5faa5b079305a681ee4456e66a3f29e1c5403af195ae2a4b883ea542958cfa6cf3441b3fc320ef803295c147256db8fa4f451d196874e4b48648a0eac9bccaf28665aacae4a8fea54ade9aa801fdb0a9ee50e6eeaf5f9622b6c3ac286d6a6114518aa92535436e8347ec4272946adc6f2f7e01663f13f0f90cb243891f57952770fb1ae11cb5ea7c07967710ac3f9ce18fedb090c66a557597d8d0699f84f4f32d8fea7d4e10f58c0578a4382e97e85064c9d7648b989cd6eb9b2c2ac71941d6195dddb33e55b70d85d13454005fa0f7e1436d5ac7723868b277a4007da09f5eb0450fa39800d679ead8c151aace4d6f48082664770d8dab8ba9ce21f3403487b732dea2881080564a52cf54f58f8263e8f8b1bcea17714265dc4a3ef9f37ff1f49b86a4fa9b6f97aa2590798f2f33cba29e9b6b76087968afa4b03c59d38a27f313d268c15d36be2910dbcae0533800932120707e736f5b27b9e1f700017b731eca04eeb6a1892c2956ca7ab8c705184fc0f2dcec10a49ffdb636ff79529fb4ebbf986b64df8572188b9be1366616a68674dc4f9d01f24162ac1a26b6975b0f59c103dea9fe0f9e50c448e5076bef0aad719b8a81e9463e4c41ebcef7d761f2250f1738f37aad692e93b4e2eb126ae70f14bc22d5c1389d967660777cc0db661f1ce24fd3009d1338526375f0b7bfbe89a055e1c6b2c4e51c33d5a9b16a9f09e950099c023b77c6030385a807856a03e94a9396325e4643742dea6d251a6fb68d895f28656149190aaa1c1ad83ddd9956487ef6cea0375cbcac99809f1caafdfed04f1df2387e5e7b3152f58a7e6e719d00862477515130ebea62a8de5eb466029cd7cf1d7492ef3c5c2d6d3d614047d78e66088f2abcc5fbe2509d99e3251118c86879736245d813bcd7b88136ae38d213473a5269ce9c9088609e4964676408c6d0d8a31838a5ff7b2bf2514411663a18f9338acaab77d5d51a001c962f703f52efea0deba53837e52eb7cd30df9c45ed99a5af11264241774f96dd78e056fd525244210578edef8d4735d546a4f549a9146f67da94027b0c504ae9377bd9ec6f7639c8d416a78df8175df5038a3cd4b85a90a9c80fb2c67fa4084692067de2ff09acef18894b836437f7bb46343a12ba4b1484b94798871782ce591fe5847164d1c40058401549a8617f381310328db06f06fca17efc203b5c76072805ef347f5aeb59d16ef6fe34b1b50c45abe92095a17d3cac5e138ea56d3a61d97bbf12079cd1709d85842b0d0de99a932e9cf8433dacb67a72a462e2b55c55c7fae07a4c64934aa97654e45407d2db9641b33cd4abd272ae1839f2e6948e1d455106eae5d1cd4ecdbe16fc2e85bc594953732e5f04c21ab659e8bcc381e13c0bb6cc2e50453871043af537a0922f2c4881331599e153f8fabba5942cc4c14cda19adc6c6a94bba24627cd9dde51de8b1ef65ee9aa4129fbe081f4db43c4981d95f77c7cd7b0264a8f7c1cf592761d26c0b409ac477052f6adcaad0c7836737b2f7547c6ec030e76f78e95ac90b704fea95675367f86bbd4b6e738c6ea136c9813c2099f7afb9af117f9beb5109ce914a9f5f2ea7f231bd2ab713d6f74c27c0749caf9c3c7a74c5eeeac9546765275b9b0ba9e8e774007ec087a34040ddca1090fa1f9e314848a8535f59816d40a135a3da645d243a4ad8e6021ec813f99df1690c81d511d5fbdc04718abec39b7731fb7f0175a241018c6114c728aaac0508bd66455a1b6769b2ab22dc72934ed974c08d1fe4d06b6ec1bfa3a8aa079a335b0ae762efd3cc2d2185760d9433e849f5d47bb4e834c41830e9657e843e0e349248669da0f01664efb691fae801eb68d9674b852c6cfd23aae64e60aa5d87598cfcc184c1abac384c890cf68784e6f493011961b212e3ddc448822c34a2a74b27f2137d27c3e6d909660c604a4450411774f3fc3c34bdc35f729d41cbe64d5d2bcdec6081747fb39510e511492686808d212e483e64e72c4665b930bd2d39dd270e6af9c55d2dde371ad5f4ecc2233c942540bac6a9d1ca319b2600e1276be8f1e12a90824ef181ad9560a235a44d9d78cbcf641725c28be996698848951a0fbac67df21950028329fbd23317849f10d23aae370fdcea9b1ec7eb3d12a9dd18f8e7061faf7ebea0eff6df374aa013705ba2f3dba6478b8ff3ac4fb30413ba8b207c7b18a13dade661078cd1dcfcefc612257b52c79ea35beb02221a20d763d77d0fb4213a203a2fad6a758ef505eb60fb4e4b4028db3cda3491b58953f65a3d7bc51a00a3d42f0ba2f1d4aaae8a24ed00444f9895e2cf6f798705bc92b3dcb0e2e22a913b9322770349be5d08cda0a040ad144c9e35917f06fbdbd59368da794b5d9c0675f31bb4d89bbd9c3ddbf5abc59bdc2ee98a4081139b300b5a3f57c908131a10fd514455da9b664db27bc93d4180e01efa4a0290a2c750539b8acccb53ef6bc01256653df6cede024e9b6de6829fc57ee078606a7ac991ce17ecd06165cd9371af8df4ae6e08a68d08578957af73518777001b9a7a546f4becc877e75a025be53fe801a550bf6dc0e785e2abb196e75f823093b674fe3e0e4f53b7d608f1bede9fe5849563e028eee70816452f545c67386dedc119f87fc2e9325a395592357d7b28953bb9eddb982f323a2745558e9ae1a03535e7eef4d33b56cefffcd50d07cd61a851b8aff35c47689f10eeddc526c25237c87aac118e2422fed6e1cd9e0726d79e1264bc09405a8815d3c79da63d25394ae95da8104fe6d1957ea3512b810b4cf3f95df0a6c7df65ec266f210f273448fa7927a0cd820a4b11d256cd551533f7dcc05c98e323805f270986c12aae16526aefae628f3136c977cec36807908f3d33aa19c72dcaf0deb7c2b9c68ec8bd9effa5d6ded3f79c52e9817f8dca84e55b127aae2cfe614a4221ada590f3ec8b794dcfdd3b2eafed12dba5a6c7d5e43438c458aafbf84afb742d1c0fe6dee4d0a9c13edb024b3ba702c0135db48af011cb51d74b94fe4bbd9eb4310b34b77e6e5f69bfef9798452ad98ffa90bfc5ad4869bc815ec516a4fbf1e2e4aa42c10140273a57e928bcb9afe7608b384997c5d2f15bc0998aa6a0680a314bf6c0f6c6796e05fa23d4cfa2c69e477474b258e02d77f32b4a7b7e713dfb877230bc5829db09a9a99821bfb0751a7d33e1ce1ca96243f7476f946855dc81924651a49dfa35aa11f326e5cce93c1aa80b5eb273fa09f013efe42d9752efb6e13ac51099f7fd7fca9e5ba10a13763b9008d2dce1ed769c2b1ed67568e2d9d08a2e9554c7d792dae68df322c0ecf105567e3b0c7398dacbaa179990d1828608393a1a46c4e4825e118b40b6b762dbf429a40287f750525320467729290db284eb0bc050ae2d966a53421c8404da46ed6f38f07f8339af1a2a9118e48c2ebdc44404f560fec293c954759a3109853c9fce587ca453869d573cd6efb23079748271d5903f0d109b982f418dac63994d65055db653619d10b14a78c0871c76be5e2be748fab64f4379b26f52ab7a93bf21012a52cfaa4ae4674df8f80b7889c00f39db7eade87d827a0eb24ef79f0fe6d75131b28862f988e3c22438dc7afbed0d04beb2bd5e24f192509730d4679f8d5b9cd8b51b611f83fe5819b722530507bf06314446a342df93e7d73a32a9a474f92f9a8d086076a0aade332796ceedb4e53d358b9917add7bf478dccc4458745211d5b74f056e18a8d834743add68f01b9499e6842825a7f7f8c0bdc9ff44a7e121219e62eb12cee8c126ec10bf775755c2f50394ea16346b8a15207874a6801159d1ba7d447ba7094f984392e5c893981eefac5c52cc2e0f3013911ffdde8ac9bb979889aee3f205c821fc00d4a5f92ec869e33f963de5fe41cf12c95b699b6c1fb9fa968f719a7b268b92905824a17adafca3f3ab630205dfd2548b56d15bc6ff1e34643019613f929a40e6336000462d61fcef06106c7b851052330bc7eedd84d83942d586a38b8c342e6380680517138f466ffc196825eaa98fbe5524a5c5901683512fb9e937c3ba611fb3af3d0938c0d66d2a55927afa2237f796a3420d3d5b21d632baf844d97cc9404de151d447ef559e65483b812902b9ffa6c7365c6b992cadeb404718bb40776295348f1fd6395c7cfcf55bca092d5d3e7869f59bea8a34e97afa3db97428a98aeec3eb1d78f7dafbbffcb62650019734f72edcaca60db360cb6c39bde8fb35a816fe9bbde2775adc5a50e1167ccc2fae5dad456065d3163b7902222c1c728e02e35db04d444e504c70a5e17fa4d0c6ee63330232ad833746ded3621e615354373a611959645dfcbac9076d1a8f6fb30f52268863b84f37b991b5492eac1a10cd2b783b7ec4715d2b1bc1db758b4aa1978b53416eaa2afda1e66b75a9d5321e6d7018c7a0b08068c173ce7d2782bc248017e31d1cf01d5e6fb6407a55f10996f9d128c64fc8f75eb256d2970c3a5fe775514cb5d78c5404cb53152d8e2fa93d28de9ce1d2b74b2d4d311a9916a4e69e687d695121398c60a1ab3edcf3346a3ee3ea3ba6c57e56e59241454b3b91964a4ab8ab608aadd8dd2afd6ca3b048f2d5880c1da9dc2ae35170b98bed47d4f36d20f1e336d5009eae051eb8fdf4294a88aa93666d69c706d5a3fbd378205ac005d662979ed8b4c4b79edae3d1dc5eb6253b84fbafc3df0c5a93fd17bd897d6de927a3aefd3c50d3db7a860c7b04aff95c1abb40c74ff59f6fee7a08b47bb68308d2af18e43e58a488a892074f9b85d4d7dfbf346b1aea790b02f4470d1ce2520e526877c0fb56ad98abc341ed6d1c42b8cb77b84350f7f70a03b07d3e7419353982b70c2ee399ebf4ca82015459229ac398667fca3a781c5379581b8c42d01b00398bdfec18fb1086ee3fe1f541bcf35b2d898481c0ba88cd0c8d89cbfb5e42116a89fc6580b46ef659af2890d767a6ea46e56364ec184c76b6cf07b91c1a1a42fa964f5ee793b7a76acc0c521355829801f2683e6860f2b659919c64b8a16c44bd8e5d10ed782a068a364f9091434f09ad90bf9b23108354309904448d71be8d115858f7d6423ddc1acfb592b042515790d6e9535080b4bc17390e87836135cf852aa4cd9616d8b5e7d369505640ffd98c3ca83081fe98206ecf82c1e953d2dd6ee7739b4815616691698be8945118a996f5be62e4ecbb03edf90eca13c643b30496996ac99cf5a5082f7cec655d3f7c6ed421d94e5ebb033c19bafd9608645d292bfee4744028e7a4cbaf0b5fece63223d0b50401f51d4cadfc43d3ff5adb3fabf20d25763353863800e9cb9c8c58a0a743ae44415c41148cca8c407c39943b213aa53c7f8168678194ea90ab1dbced2596c1d175e84747b57ed2b6009992e28ce8f262a35a0dcc266b5bcd3c3e92bf712edf3b1e5127d07e5fbc0857c391ec762cbf0bf9aad5e2e8d708bb0a3bc0d65f0290bf2e1b6fc1cbc369bff2edd7f2e6c29f54fed9f7a67b038799c2677fbd2ca6774246030578c0e04f3796d21222975f5fb0a9ecfd3042dfde42f8d0d88ce2b437063a602886df268bf3dc7b2a5ef35bbf9674c45f23bd2e33f51efe405926c3f7b3eac63748d51028a7365a932458c52f89a4f1781b954f40cd264f1557d8e3c0cd5c720e5681f3014515d6c7cceb377467cec39fe4ea96ac1b253aea777956827dd4a58053bce713eb33a2f6b905bf4e2ef36aaaf1678394c8b78de1851f4642506a974fd84c50ed0bab089c2098abd619cc8bbfbc689c19704e285ce49e5418c1c065ee6bcf749792495951ac9cc853ff2e326a90a141d660f705ddbc6cf7759e510ece45eec3ee459aa5addec2bddca8aca41dea7ed026cb7388e9fbea6616923ccff2e7eb4dfac6dac39fe20062eda56282921105bc11955f28d52ab9460b28f5e206593b82385ca5b2f9649ce089347c9396e438ca991818ec8aacb313c2cccd5ce486a0df2bf98dfee0a37b40d40fd1e73b0a1efa201d3236bc83b620dfddbd8d4fdeec2edd8cb5bb82a2959d5dff621497290f77508a946afab08768afa1e85aa5f2b22b79f6bf1bce8fd486ec76bc185861ebc47d0f2d754ee2ae0a2399eb01e581c81bae4ee4ba6e721c1f84def46ad5cb8728905a5b380bd9c90d8b6a23d3ad0569132e1b1b35cf6e1dd41a362e0291a868425d12381965f936c53fe931a1cd375a14a8f4bf2184dff60bc9f635aef80fb027c6b27d8f4b5d473efe8f26dce459478887ef7242b27d552187f80a7534bcc03aad2f1bedad886bb01e15aaa86db715604f9d9bf016506d6e918efd1a83a5ac123dec946a8de95d9b2ebb3dec3a9f05bd0d0650d04d265ef2bcb44f0d6e99430e7770944fcc2fd5461ff8d9a4f921e88b303015b2f8828768618a84d805277ed18f7df269d3507d439bf64ec80c75a26347d9999b3514e33b6d845310010d089319084a9b8828e7d39eebb3edcf96876dbe85c1c7fa5d173c80cd61e32d020d6508223a46a2e97cf442b518611fac881c08c2c220865d105304b4de77faff5abec07dfecc5369f02f192b8320bd9312d31d7e3729561e26ffe7338089ddbb694b7217bea28129452b1966f3c4168fa94d890cdefeaa9bb34333ba6c214906024b5303c92714cff0edf5fe7c653a0471ce796a29f584abb7c943541084666a2382c5356f1fc7eb2843d91869242b5e1fb2ee73e64cb6e13600e86e3e2d14441be4e4e89aec5d3692db4ae74681b7801be196e00831a1b1080ccfa380a59557a549b82d42a31bd094f6398470ce8c31c5610d0b8baf2a86f2ca02a0254a0771b3adb225ff726ef67b0d4e8099b31122b9ef9db1ad5226e3c78979366a1bda43a1ff2c07e7fd5ed96627282df0a26d227da0ed70e0d7f1d239b7a3f071d4ee326476c9aee17a6ede682d5a3ba0be5f0e3d5785f160ef42cdaaf70c8016c13813738b97db194f37dbfe6e6e666a329ae0b2f5997ef4bae9c298264e855c6eb23b8f9b4b1cee23d137fedc560da600cfb65226f76cd6a224c747f732a062dbea2f61e1105c4eb86346b0cca6ac9820218243fe4940fdb69bcd919c78c0b08308b0c1deaf6ca2577ac429040457af14c2a6e9811200cfd35189e12d3a514ccd455fe21dfb366ba5eb4af662cdadc01364178baae37b0197f0c50b3ae013bdd3224673365bc491d39be18467f0ec2e30ee640a052632b9f0fc4bbdd530bc5d1f95c81d4c93b5d86b3d25929c02c76b8f0f60482cb517c4e3a8966fae40da2d0af53061d9e682b69c037e7967f38225bcec2aeb4e19f373772321ae2caa2934ee252d30135d16ab348b449e81696c900ec88079fca58228eac52f3ea065a70a9b662660c1fb11ac35de47e0623b92e953003b294916558d512f57abe2bbf591491597a26c05a12a61bef08b1420eaa54221dbd3b61c7da2524632007adb22c344c0e71b090ac7a15ecd7fbe478769e5537b2c5c467c397c2419f5b17d7b2245571646200c77525810d371896f470713b4e770e49c817c1eb301689642f809ae5c53e63ba43fe550b5f1be0609013eb67a79ddefbba2e28faf11c3237983064bc18c2f6c473c78b497e24335f3eea9748241db9c541727e67cbc81783f8f50c0316690f1f4b92f03a138101d8c5ca1757c0a772f6fac4c2c1e7d4b3b9b93ac15eac0238ed4ea8c058da83496c414e5111c02fc2e414885efdabc8cb858a0494e2bcfdda676481b25c05767b4af62bd0d42043ac347982d4f449d897f03981a96a74a057ba7c22df4ea105f784f9abb5354ecfbc4a72b3dc09d8442e0d45a3501812f5064f24609387981a8c71f3c36356b42d8b23210d9e1e55e9c2b67842396e3b5b7e300e508620ef2abf268337f9453164cb0e947efc741a507ad8fde30141034e79ea65de4a5ee0925bb33db56cc2f92cddba377c1833e089d8fd1919ba898d5a1c687c1e8fa959ff3b18162d1386f7956ae1252a0104057d162c1c421c2ba21ac242e81cfc419eb329bad9285fa088840c76fcc78d20d40e2dda2accc7faced86b88cca158c90a112024eda8d0e7ec640e593a8bca776a73bfaf04fc17d6d6d71f56ca7345c4dedd86ddccb246b8c3f858ec06f381624d46e1b6411edbb87135c9a981cd21e3bbc27942c98cbb191f7d53d935ec27cbf18d5c10ab010d214e9dda11699cfc8c107f5ec500000b695a55d0e90c841f3c845182124a0c0d409f9033b181fe971b83df6d111796e18a04714e9d420d0d310a418b2502fcca3d4ab87a803122407c0198d87ff548ac41479587dc21a21b4ec06143949b723e8a0f68c9f2ac1d687ace911d447676fcadf5ea4b9e21faf2bd8de2d5e0b322756e8647181099d49c9bc85ef290a2896644f1fb9d1615c65f7af43a72c3c7e1cb2d1316e46eb8c6bdffc4e815c4f00a4c658b49650fd23295235515a53812ef5bc129f2e911e6780ba8a7c5c3dacf6e697e9010027f745d3dc3c443d1185184654724b8e3c698611c047917499ca35a086a2517e3b6c558034f3650948a55c74df383dc3f5cc40a705326c10c5854a2b41fd5a052b9fea44884acc28618a517d69ae7ce34a199f6bf614944e9261c46e56f10fe658897e2cba57f0d5c1dbe200e4f856587fc09008a3b9731b562615154406719b6280f9b1745c28aa6b5a5f32af7e51131598a3bcfd527dc3e6a5871315ae1edeef6ae48f666b8d1c1d26a1a808b3f64d6f355676da7ef5b2e611ceeec6d1e16cbb48ce8891c054b6cfe90ee0f496c77b2524af16bd2fc9c64b97af475199141a9b95e4c77c330a86d1c88eba11189b3dd65ab9c8de67d5559740106a70d01f16817c1834008b5a875460c2ca0df5ba8f30620fddcd495ab086a1bfc8b2330d0127d17b89cd46f337c105e95c8e013c45c3a05700494a73e37b1cd25ebf870b152364441ec758462d5c2f1c559f0519fd4654d72df8fe83014afaa7b71dedba797554b1853c78aecc7311348ef325f57bb554a593aad700553ee5e0383939ee41f756f5f46b42ee29b48ecc77e416d73f62b72e288e500ae5ce6d2b3e23415ec11ee72684e46181cad2b667ab972fa77bff691c7f5b4df119b5c80d057d3637dc5b80ac001f4ce37a948f470160eb7971eaae8883323b21408502283d59b94b50a26bc54c5eea4362ce5ef0aac3c0d259e8511e0d46b62255dfe1e300490e9d61344a160c75a302afa306c2ad98c0e20a67e05768b0bc1a45cc65dac92ca8ea1fbd867d7392621f201096bbce82968f2edb7bcb0747049655889985b09b347160df0672a27e155fd692abac690e06458935f6d0f901404b4d4733f7c0fdcacead78bace2f7d23cea0245db3f23bf643b1d001e4d2d3addc4982f0189094c1738ae7d732b3fa925a82e6f41434a17322612a36212340b63ae04c7ebd78e195c95952af77c633f52079276cf07e6be3dbc8b8ffdf9351fe3abb68377e917ed5fd8c27e212aefa1b02c723d8e9760a72e1b74bec03f425ea6e1cd82acae8393f50b4020a9c7b495505578af8748ef185445b8495d6b6cc1cfd4d022902c403a851e6d65cae4f84947f6953c2a28aed98b8d8e0294e9df1ae551705dabfd82bdfe5e2d301d1dfb17e2f630b4a6f182a4e835bcf099ee861ff093a6fb2eb83e8f1dd02f0e6882e403fd4b7151c5e3d32247288d4d78e02b51191d8620443eeb19c06f6fab80684e8ec9dceb5aee808952b1049631f009987826c36d6089560da1b206de111a66ea11f9e7b3e5c36aedfac543320220d2f71df3001bbdb348600866bdacdf4b4b8e854ae426f275d5641a2b736e9876930e0562c4cceaac68ac82dd60d41b411543652d09fe2b7e8aa17603a304f790f691e4ba0b0507c5deb729ecceeca967ac0d8cccac7e7efe58afbcb0673af0c88197c2b3b64bb6749a33d04136f0865bd8bb5a5b2adca0b7a799dd88670f4fdc7593b62c72b368b529fe9b4ae1ac5fc05a0c7573ead0121ad305fddca3c84774479862464a7b2cd9b742c242f26461ec2a5900dddf2e0a2fab7d0e60a0e970ecbec836c220073a473f73e73e570e76c548f14e1f25136d46a36f6a5c68370af7f00f118415416d872ef7cdddec055005a79463f7bc4bbd723fe7cba5c3f9968418bb248f38d8e542cd4f2d2676418d0e4cd3ade9a508c66cde87ac1b17d9428ec253f26aba5a62e5e2de1f36444b033ace5d8a89c06408420afe2367fc744be957b67962680dbacda7a045f5fd9969b579186967a591c32c4cd3bd6f80536ab39aa92974d692dd93e99feaacf48bb495fd5832784eaecb80c3e272723c881a915c4e2e6529edea9e7fcfd5add3d65efe97cfa94ed0c93a2af76cea9990c870505c99a6e0a428ceecf08567bfe84ffde3064ff4f0d91c86a4e5265d5832b2ad0059f4a1a849fa167deae979c32469da7971cbb69db056e4f6c8a5f9f2c40f0ed523f8d44e1cc27f99a2d424f1b1568f3d05f9cff120da9a5753277431818373eca2bf1ffbd15601ccd505bf3c835b4a50dba0ef18d49f17454cb8ee0478b0a8f98852cc44ab613a275640356a3ad00d6b3074c53f9183c12e72dd6b22f0a09bcd76e51e124d3d2d91dcdab05668f6b7eda768623fad2c9dfecdb7ca18556f66d7ef51baa4171a327600753c47b6516aa8be43f47b5f7298af33549abd638d2b01bb00f01c809b802a96c852d00597f55753cdb47b738a542f82b7c701c9e581f36745265a192e1902762584c108f67c456f5f59cc9848a107b9cda8c64261a703084d4b3218649f101a192abb7bd4fcb58f6489815d97a9ce558e23976b7d7fea59a0995146baa3a9eb7450a0617a778cee2013ffb79385bd022a7155152523e37e50cfccc68075c55b1747867237cd16dc5082fe6cb2b166da223f85c522cba0f78fdd9f8312a0fe16aaa801d1ae6d9cc576f5d73e1328bee08f5e0a055e389f74070b945da2b7a8ada9440c26d25eb7306166922279c335994d2bd0c3368d186ca77e7fb69b6b55b685567971caece0cf3cb85f73733c6f3b64797c56dde10662356ac2925caf8740cfcfe4cd68909e5002cb3266e02231dabb501d45786165e6eab540fe1c1c80085d783158bb6f8daf1c10efc79768a80250adbeb604b8368a80c6c7dac407b4a6a19331c96661730e3485c30ab8bdde4838a7707259083b5bc7e6eb00fabcf6cc3022174b8dfeb3c0290cd8a8a301b7a55e0f9c3c04ccb88a43505fb16dd70f0a2169447a365d3fc0130312260ec589e99abc1e7a68bf6d0c3f5d9e00ae01609f70270ca32a2b63d941a35a42a0d3b8c257cde028c0ab589a8e05ce04f371380287004b6d97230263be8c928ca3294da99652ddfc3f0354fd050b2f2fbad754443e7e5d9ad7b50d03cead94f6a1b7241c54b4e48a8aceeafdffbe01adca15dfe7d84e45f2c18630bda91eb754026480a9d2f30dde169ca4a209da76aae2dd71a30095e770dcbc26e94c9bd3b21d3c6ea558c68d32048a796b32fb23c15999406dcc7d58e671e4e7c94eaea6c3f84cef357d7bfdf9239113fa2527494cb886d59eb53c653e09df66609437d077897ec15d6df6c8a83bc14a58e7c5e3dadc60069f790fe5eb26e4e20d3fc07404d125851c0fb1c74ee184364225cc64de4cb745649ab10c80f1f03ad7b6194fcb648c41eb00d8b84e1ce39146c89f55fda1dacfc6520acf715062a4248a395bb3f641d796ff9a6c8e4b78f24260a5392cc90f8eb2691d17e3edde924d6cb082b96228c9509ec927dddfc0b5eac48cf4efc5630343f8d17359aff040cdae2a4c5a43d36872923ab60c25e24375833025a8311282b22900831b71fceb6371b4c627207e22e6e2feeea8c957d9d88e33d12822e2b289f784e2a7f3a6327c8caa4dd043316bff4b39159ca4ae32cb1ee4258ef0f694f1c5aca9a51399a30194a9b0bc700923107081ab610294c6","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
