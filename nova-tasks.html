<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d71568d1ae965937a028d29400f2c4babb08a3753003f2ee3a099ddcff2cc183e75b36cc3515ea5939ed2a621987d5ca4528910f10afb566f90eca1d67340699cccdd4d2aeaa7d047c58802a7e48f18a95271f3a46ff00ed143298bbed5df2f0f7916b7395e76239afeff480ebf0bd5306b68ed398e73e88f488bcef67e50d1e292f425aeb564e6108f37745864c708e3f9cdbf163ff2383416770a44cbacec096248eec0ba25e49484a852f11ab120df9c1457891641285b151434f6acbac233ab4889b0e3b541d4ca24e9f21b0eb970b72f9de5b8e7aae59b91239319f444bfc4fab4d65558869b44432283f9988ba01bf712ef1ddbbaf53485d684678a02b261eaba2e4111697c37796e0c8bfccfe213c5d2184a79082b85c0f141d412e493e593f4b67cffde7ca3473fbb10d4701cefd226672f9e91ab73d1344211b4ede20a039f81007bed91e3bb0ef77d93a2a1e33eb049e4e356b23a2a5a30d7d8f3c9a8c12f112509165a225b817668e67c06cbe7512fd5fbc89e3a19677f1d7dc49de055411bcc40d88bd121bc3e8c337669f49d40edd9288be59f0ab676a4583626c1e519d66152cca1b584b744863387e489ade7590550a353991b6035546180d6376fcf2cbf8d5cbb3e45745e25999f67234a028466f3802faeaa513f28e911ad63cabed200dc5213913bd88371ef46046010cec9b869d2cfc624eab63b70a951e10415870c56dd8b000c27cd14e218213a4046c97fa0b3922e29a781a101aa2b867a92cf932b03ee4d2083f6b8cb38432dc787728743d540746b76a5f8719b36dccd820be0cd78df7f33ce62ce9491b6a40c17361fb6436032f8f15065a0dc0dc948199ff0de318056f93b0f56fa92acf19e694059168912a5f43da5979af91b7d7c052a17d1317a1ba8b102f0fb581b309edcfd7184fb226fcc9949fd36dda84e004b5457130dd25f683324c91a06dea85b1f8969454cb65ed75d18fa399c8437faa280a8252a862d0cbc1160007e9f52a26a9b51d46e6187f0eb701de868c542ad5b06e455d3b45041a5e5f7e789f1f63631c0cc0a078224346dbca122ce40a8f84b9326e3a5c9b0a6127d0c1112a398231515a75deace5e1db240b9d00e668cdcdb555bc1861c9cd0173305f2283a9561c64839d39632b87843a2f51ade18cb04fcdb23017f32f6a7a2ffec51b12251fa7dc7c4011896694e3813c1d600ee1459b465118a942aecb17e12ce0021fb05b200b1680207cdd1bdc6e52248907cc6e16caec8f44b8a12a467d6e4b736aa573b0d836f0e68476bf83fffb209c9443e8d97daa9853931de24331b377bcc846abbc119d2903dee0a92a431af948de22a0da4aeaf1a917ea88acd901eacf15f80aff633ee813f61c63fc175c414ad30591abc3e99fc0970270e6da19952308a1425f546d5a4039f6836b21ab9085a2eb749fa0844f54913b1676869363d1eab8db228e6a867a9430386db00151cc94776907d411c19b51a066713964a8e130b9417895cbb884403082758b8f39f1018d3c0914e6e677dad319aa5b573dcafd44689d3496034908778246629bd5673cd95cb02eb0585fa1889b2e1c06001462f73a28e3abc65bd2a6ea83c4b51689afbc098d07a57f666466d04d7c6c564ef18a9b4b5686430d1709c4f3a269d4086a741e8b9822b33a2645db7ed72feb82928f15b8fae34d44fd04ca71722a0fc8814b1bc78b7ad5708983fdd908b6f136efd225ac2867e2ef8423544ebdabb0453dada3237e4a900193152cc5523f854d49470ae8dacbfc963a89812f151b52453bb262c3f35f6c3597f148953d49fd43e55ef701f398cc67de85ce56850fecef6490ac3418892df9dce20b01b193dbb328dfb7841087a583f36cddbb36842ea955c85218266e1573a8600ca02b7fe447ee1f9ddb3d65dccdc15c20aca62954739cf54207ca47b336899cae00b3e8c2db0af09136c5a286e1e97d362d58c5b5aa1253a4f64795e277c18ffbbb13ba819982aa4bdf4027bb4962a2a2ded7bbbf36f82c5c013a7b73cb684fcb878036bc658b40db31d79d779edd8e21479fc71015929cf848d4ee49ac2a45b5d5ad0dc7ef8568b862f9dd270004d4ae1d063f2d1edff886beccfff69fa5cc191defbf35eddf83a0b2695c29819c59dd7a339823bafb5a0227e3ecf1865ddd3cc9e63b82175f9b4c66068ba54e343d38a25412645fd9fe1744248d7059a14ebf201f8c087101cc81d95ede529afb23015b1fde36b8b84a011348914fad056c6257c2e74a17161ce640fb9158a0a4c090698612b1b597264b3715a5b304d644c09f41edbf5d87c238ff02a05944d383bfd8711c8ff5f5391747b9534d92b9fc1ee90910a6980237371fb0f9be22e20fad6b8f4b1550ddfcb92c582d53f82c02616f5c6c1b80c2c02ff00fe33bc786c8193d4ec50dc396a08a9c49f592b026bb153afc3ec2874c23f7a367d2869c5323b49658c8d35be752a9ce06aa24408bf4692e0156b2d1a52e93ad62ea8c8f350fe8fb19724712f4a5eec407ec4584c268fde1f35d9d23939b955947641ede470103ec85037b54168141fa23f0d96d2dca12c252a9cca06527362152ffe8c721937015c93a5c8321cbe7af5d6e80cad185af9cc14b99a56c0d677f21d0cf63e3510c6482f79a6f9db5e9589287f304de3fe7f395bb93b166e4ba595141f9d1ae14f4c5cfafc9c39df33bc6a2ba886de9f5a56c987e863fc324397d07ae557798265bf692892261d89159f6b45c0f062dc882aec81986bb531732898f1ae7d3a1adeafe8a484dbb8f5683437845253a2a187508ef116f57b7cbb265c36eae6499977a72cfadb514c5a4906fbf5b0e25f64cb508e86058ad1b02ad869c7f5c1bd3545a6787d9b2df777250f70b8e19a6335db82cf6912788d21b8ecd627a9e45acdc193de21489c6062a8b7f1d1f0786e9d6c4afc4b6159ba3363b55f88738bec46e275d56246d00ab9f6198f4f74ccb0fd31d4b472617f98341c2cf22c03cfbd0d978a5b1e3a11a8e01d2c0d667311bad5c8f806665440bd13333c3ecb4711b891961559ebb10fea3b320b65784a859e91586fad3a247482f22a884d715d212e8d7995310d0d1e8e9c237d169cccafc463ab25f6171e45ac55c00722f73d9a6acf426095f84cd0c25d210afe50e035bcc726145675a86620cca63e7f520142ff147e520f4d4110523797105790c8c03753b84b24d21ef34f5494a561cbe2ebe840b0119fab78f81f381ac3a9b06f4fa5cd2b8462ec207864a96be1dab5ab6f8a81efc4d7803b541914b8d9552cf06b10b175d8e2874f54b857f69883513526c85f483329af2462a5a78fac742afb8b0928a09c1fb22ffe7969937b6df749638221c5c42a9e3970f09142e999c82b06908e36a03e733d826f294e8c51f4cd25352e526ff72f3cccc86849e5418883e3a5dc38ace133f9474d87c3757f7bfd67c780d96d5248f8077e0cfc5547bc31718b1773778cf78abc9964f5e7a3da52a6d9ce881dd7fea96b606c3af8a6c696ca40be9989652a5a09acb2914af1d283c8103aa3203c83caec5ba17eebfbfd0d90147cd135eb893e573ecb9afe74c28026c590c3ea205cf5eddd047c3aaae719a818e587d4e0c70db9605664912736a23f026fc64e4cb257b1a24691817b4f6a611d8fa7fb3daf8b704374b38e3b27d121f6c00076d1991399ae87796d689027748d293d2327b481ef3a26524837d9071437afb8d80b0b4f8b0630ab0bdc10875b1d4006e0f48dad911e8f93a739ee66e59bcf5ea06d0d129622ebb3583e85365e93531b4304eda9788163359ef36d82e2f913f57a8f84ccf13023432e3f0e549956842d5cce48be1b798553c6ad2806416572136507523f66a2eab410cdeb06271d8999d031bdb7bf6aab71e8723aebae81f8ba277ac023e5d01b358302bc13c72d28229f1157e177de532db37d59ef29c0135172518998093efa3073dc3f0d93d1d9697ebe6f51b6157d1ece58773014daa331ddeb10477e1a6727f68eb7371a2b235c329eeaea48bf76435a26d0567d19a28114cbe1b6caf64bcdeb9e805109ec946bb6eb6f94b18f7cd10e9f7697aad57704b512cc530e6c2259b64217cb075bb3a68f2ee5df6ec666e5b96db525155b8ace1e7d843cdb250e9aafcf9bcbfbe06a4b11d8dbcabbaa704b7041509898a4aa8f52332f3cfc54e6fb46fc5b9e603b327a08bf34278887a5feee3077dce2e4c0b8c1fb47419153965ca2e342d430108dd5aab1720457eb7618bb598a71a5b4fd3eefed6b0e63399b874ad4905af44edb8eb0d81bea9b772c621a06a0ea3594a6371e41516584a9ffe064f570c5bcade77b43eb861c52fb24ae314b38c1628c41b10183f750b481666892f1781cf06ea05a7dfff628c8bbe5cbf7ba3c96d6d1345b999463d67930c74f22efb54640594c88f42a95a5aca73b57e4c10955ab6e581ca12097df41227131bea3d7996d4e166d285b29ba8bbe5088ae19997ab9c7f4493161dac532c2ff590d923506c4e30c22d5f887e8d4387a81a0cedde7e11ca392a59c04c25d0d0e820ce1302c80cc4373bc041619e41bc0bec5c3ba4b7aa6df5a93e02b37e6b7616ed353c17a20d7b8e3ad91519f820fd9dd7dd18a21305437a8cf2970b47e83e699ee7207a0fedeeaebe749924d7dfcfdef213ca79dbd429eae897e11de6131078a2f30d0131fd57e7aa53c43ea319e7d67a5d2a1ed00773cb496aa78acab0d260944d2f547ede5da4c880282fa07e02a3bded35292bc97869fb08a9624f25a838e19a8cd5484ee694ce8404d5d7e84abdc5b519232b3e57422c50309a3359e9ae7b91d620fd9449de8ab89cfc1da18c40b7a9d42fd12413189f4e224e188209ad5b3490e0a3005251d082bce6048b4526d2c498587fc40d8a2ce931c3fd1ee82b718f7286d8ff64fb2f045b7c012610324cab23f084a54933ea1cffdb516159d6d8e5f1723c5e50d01c341e6f9cb83f96cbf3f0ddc93d7683554aa112292878610a957969f605999a7598aa178725254af9a64a6c29a5b4b65d3375c674d81ae37b4bab6e498d12dc40e5dc7a40e5d7706cb6dd1e56558c0e97cc9d9571a3e5813935f37b3906f0ca63bf5392e4d4aeaeb7327567c6ef8440604d7028c11867035d97ebcbe9623b86ece3a18a914b611caef28416b64d37c762315ab2467557fa54c6beafdfc37408a96bd681239a2ed7758e725b2f21dcfb41761bfb8524f6c02c391ea6a9929e3724f6212d98fbeca5e3a8acc39b4e4929fec645f98faadc59ce549278b2671715117a3b91c9516fa0e55ee16cd789c3b8e8ac9f46552ec3559d233972d28c3bdc079042343c09c042c9d9fbc3327c407a7d069988ac85ca0939e4c22ffce9a072c3b1d8c86e08c2b0aa143c69adae6abf33e6a56e31856113d737605a526bf85cc589947b33462c3f9ac278f04313ae57edf9bd2b78d206c0bfa128c01b87eeca5072644aed38332c3e9cb4b3e0f12fff2bd9ab9aa44ca91608d6df2dfbbca800fa1341a5053a723667121410b0edb3bc5379c932c36dcd8c58876057b262e867107a2f098ba26d7a0cfcf007dd26136ea68d1889cb92e2f2196c7d021aae281746bb577fdf94f756c595fe7f91fdc1df465fbbba8218883d71888b187d1eab6e8b0e004b8133c4386f83ed150b5baf1f65a321955a41b522603181939246e130f2d0fdfce8becbbb32c9425fb4ffbc2283b85ea39032d5e852e5436569d4599ede181573c3895cf24ff94bc152a1419275bf2b7ed095ddd7cd47d218e78fcbc094e28ba7a3d80f3291e5cc34b6b1a51c66e4ad33cccfb7605e99d92ec571a14cb2b93804787e68d3a52ba7e64c427a79fe804574d38e9bda4ff5553cf4e5524ad11eff0e9b813b4fe25e5b1c8a003e572b5d94b1bbde98f63e238c915ddbacc9d387dfc45905f12827e5aa6efb820c83c1328cdc6c2d10afcb1535cc5551c5967faf3571d95565d80862d0a1863dbb6c7b8a454bdeb9b78e8e749ba736fb8237bc60ea5bef4ab1aa3c5d250adc130ec2a5076f27d6b223c6b67f709f80f3ba51e5d4eeccb42b30b880287726978890ac286828ea84e73cb0f93e92e25576b59016db1252ec8d3ccd595b05e07b632a98a365b02ad36976b704e5d7054a430181f2702fea687344c23b86f1c185b3c8b069020f4c989f6233fcfbd9924acd4776384405461ef3c9b958ed51b35a4d46f463acdbd420d4b0b90345da230cf9bbc71bb9ac0407fa03059f3482ed8e8c149c20deb0c224b7d3c567f266cab7ded94e13b939a2817b7afc8ed57d9bbc5f04512b7c4a5adf9366264cdbdcd91cc12a9dec7e82055d991aa5dd81048a2389db6f78517e551989d9ebc934107d8b6e38e21d8adad4bc7b84cb7ecd6c15424cef859f2d227ac686f2a6ece36ea9d910d6ac7ac09e20cbfd4161c21f1742497e78ed9616d938f515edf0376f1b450973aaca9bea5370937384ebc48013f414dcc78468e29f365bea253bb06df182f4b1669d2a8c10bccbdb833edb590da42dfad99a9542736a02a929c550fe5524db3d6e6a3a8eb1157c33fef3fb6236e7b33b757b4bf776ad146f317e01db15855eeefdf657e7cdd785c91ebc99ad8f5895cb60c17f5cda7aa5c08fce7f79df8cbcc5a1ca353a52efd527719d4911fa3bae38cd6d6a5c08840807b8607d0e17cff076d512e8a9b5c17df9df591c86138467fb2ecd4580d7944ccdedeefeed48bdc5357052ef3fc6bfe364ba37e5bf74584ae0ca508cdfc046eb20a799a15605921d1c8bfba7800aada8e141b9c69fd21b8e3ab5d22588965a11ec7b7e91c17ccb6d48186886dc39286b96b4fa05287275ed37d4d7f9790deb81efc08e538a85123e95bdec812d61dfab1e8463821f51eacd0026ceb47e795c3651354540547cfd289335c73e7dd5d80112eed10a788c22f7847f3c3116865b82eb9f7c7ae197f056c6b80c4012392c27969bc353f3015ea07f6d79e15ab8a66d46173b1f8adb23d701b7469669cc6bb6be8e815ccfbeeba65d44abee8701a3d2f79310085436181db23b61c8eb37214df5b5879ae2fe6720222117dadaae4c5fb38a8f52b023f70e51bcd6b1671da51c1316f61c58a7000b782ec18bb75ee1a3f83bb1e0ff346b418dba95348b010b6d93b2986b94f37c36fc2bc6b1d264a465610deb357ce378b576e81863bfbf817a41f8284ef1389c7f2b11661462ef3eba61063f2e36b6b72f057882f3569ff5e811298672379f7964b3965969c8bb6f48ea32af20c0b3b64215b66de1fa883da05dd622e610461726d1f7fd5cd48b02af64d6114d96c19af500ceaa148c7f598edf8bb9494298ae9be8b05a03b30131dea9fd3c2d18203a6896e5413ca68db7c00eb68136e0f3507dbc56ba1717f8180fa24f8657b9328b828724550013148fba2c7e8a67562b9722d40289aad71760d2ed895d32eac1b30f4318e2793892aa23e9f3985f647c77755812894caa614b74502bd88f4caaf181273790a10e5f678e0935ea6029b62df520a7ae86294a9fcad44c7646415e4679328ee4598efdb18d923437609ebc9653fe3ccf04d0490fab1975f2914e17f001c509e867e839ea77e503c1bdd7f661cc2845dbd11168a61d9e9e5d9c529ea4eed4d24933ab8612fa08e0915d68e238b5e24fd6679eae31d48e8928d440cbe8234d3de440a32526b33365640fc318c33adfe5a45ffa79925751e708d448a678a7d48b5e51460c177ac0e052ce3edbfbc2eda8227b2e36acf7d6493097ea4d15ddec9d234586d3ab7fbe66266d9892ab24124556a577ea7e939a0c6a138d489d156ea99ad6aec62a028467d8336a6a2ee802e20ff4b3548bd1f3ff0b2d192c8927cb2a5109b4944a9ce075c9c754af599bdd60f5c39643fdb5e9697e545c7681541235e6f5b0ab7c100f6419554264c74f4807ae8d705d19b536b7170fa7daff4a275a5c073a38912d5f0b560bb972d8d1586030f908f43c5d58ae8a9757ad2c47df3421002002a76ed1b4ea3cad26993a820c047bba95d6fe5466eecacf441cc862c85fe24190c402bf87f25cc8eb89c326fe00099c0c222fdc23beea91d8d81d370de843e5af3fe46c4de52df5eecb42f379c5f7900c6c228a55551760d5240c9844f136b83e50f56933f962fc4de7ceb20707892de21d93ff14c52edc1528873c78186ee77395b0327294811d0d3cc4e1921a4312a9d1239ff1c9c4d7bf46a7c53170328be22805b1e202083e23c4c4c8b1e278c29ecd7153104afd6cdba58092f0b214fedb81a43c80c1a66a2a1420b36368d649408e2bb31b919ad14e305542c5c92afa3397458b147acbd363345dc64b4667bf27ceba1f80c368ffabc4bb2524b80e4232b89f241e9d696d29bb84c38e6603f94c628061fa6d71b89ed3bd0fa01aba5bc364ef61888e10119328490acb6879bc349cf1e23c524bbc5664e6158fdae7785c6aea9ded8da0120951b568a7794e9b75534bcc9b0e50182493bace206c743a5196b5c195337458c80a2a29255c804bc36b72783723736f372d16840d8f8cdfd1dbeb0d328e31626baacf8a8bd9ff8c79215f54c8826d77344718b8ce89bac71f1f821d38e898610d2d8e801aca8d9c2a5c3d0203dac6777f13066853aec0395d66b8a6619042fadf6cc7c4e0fd2139c5da3ffef30a5e7e7b49ec8c75f6f9bbfbf3f1f12f810f2828daa45bdfa9886ad1b1a590d83b4f34aa29f62726419f5f72a300f69d3cfe063b90dc02c60bdd80767d0c4406f98cd540054e0e151acd5c271141f3717d3fc3e7bcca65310740fbc1b9ba653f569a1612b5a4b475744b4d5815a7b98e07a7016366437f1d0ed4b0e17f7e2d6f7fdf682c6484d3e171287179a87db5f97d2101e4ac08c5c9955a21efb124aa7a91feb5aeb8b2eb342797e8c3406b2c83c409f3eeb09dcf1725d3373b466b240bdd38e4d73d8079a5ef2dae8ce42fa7445530db22a3d59d3f7c99c84b227e980ca9b0d26d965cc1da66802ec4c1727c9b5b849c08ed7998b00dd5fb1ff3d824b81adc98a62ef76ef5805370519581ee3f56e94a8f454773191a0d26d4ad1326a766820d5d569e2c88b4906fec7313d6f074feb8e9655f1e28611a79c8e81413eb4f9f990fc02b14fe5894de98a745027d4cb1a520d4a2ea16278965ae268c367b38936e88f73ead771c982ea22be251df442113c7dec6d5d98ccf3ff17a83974f9d84770784a19d5003dbaf6a090a53f0b784e902f9ea30dc30e4551ebc65d33f89774073c8d8ebd1ea57ebf043d3808379928fd32f6a12a80ade4afeef6faee8fa64dff0c555dad97595dd9c8ae05455900c53fdb399457bd4691e4db6bdeef1682b45a2c8f5c7fc3341290d7adc208423e2ab24c114d8e3f106496cf505028649f2b543e39e6c182cd82e50eaaee2b5da54e87d9a4e99e45827d251b3f7ca7bcc8e5cba56750eb409951c156c07af2cc93e15a8b4832a595246d90b33a167d9df737a4eeb865fcde766c12e5631f6ed2c99f26156b334607a55f111ab4e6696cf28e519876823ff842cb3986c9a6f08d5b116bcfe290e0433b538769229174c6c6e2374b438d15ba5e769f23a0af35125a06b776e1d0d0a8dd6ce2b079549ec20c999de7b4b8aaa4cf7d12c42c687543b3034f1b6c915d42ae72e8338e4ecf6efb2ac1778141ffb5e108cbee933c40af74ae42c1aed3c3ecdd6ec3c7fae2d25a9b07573a571a8aff7e7440d9fec1b8bbc9b88ce00df4b261da0fc62c458956368e5258ad0be8a31ac272605bf512aac4bee3045c925ad715c4c767a7d0ef93bae66552519b07e5a90709e28f078985063377f981ba685a4d70f0bdfa8adafd530ee48e953ad46204bfb2c5923b7bc418b9181750eb2ce457873a2efe80cf332496c554ecbd1a2a72cbfebe894bcbb77e3134fc039f252aecb385747d8035c3847d58cca816913ef4ed8f842cea79d05cd27a0816b17a91290d006b44203c1366915c6e71ccc8da8378fc6b5e08ea8c29cd5040a1b6b4e4d0a4961570908a125b1dfad5157db7f59643c8b13566c3f85850f002f5ca0d2be251b8c803e4f8ce0bd826194b2ace50542fb2ef7f3044e2f1761f9c8f3ed890bee22e8bb11260869f671be47b76e6e53adccebb50c675ca108bd5bde2a9b4b68aa0663cce84381b5995756dfc83cb29c9d0286480cc2207c38462d1f864c3474f9997d1bdedbe72a0c8af771edc798653d97ee3b0a4aeed585ab7793f21b6bdb63c204a2bbf6466b7b2364d49af0596044e4324a1b3b3fba144468651d79feadc2aab3d92fb2f5af07e8f87e9be4ccb39876cd6f5140127632d669edf8978dbd13505cee59ccd8e2d5db815d2912e5857d8be588c5cf8483132825da0e0f9379d801adb629b429d772e6ccfbcb4fd588bd2ad4e5f69bb58bb36fe19427a59ea8daf20f0a49c9033a2f4f25306a8e724ee324c18bc8421b6649ac55b92c55bb9498579f24430372fc364c2eb53406d25e63eab6ec0e18961f2aecd997d1cc63352dbcec066552e5896e99195481d52e40d2ad7d91c2ca5f4e8d0c92854cb088c3829f12f213b10b926ff846c84b80d94a55da5e1574e3d5723881dbc51e7d15122703cf95e4f2a668d4f0f3cd8ab8982bdcf74f336c6f8d018a50697ebbdc719893a38ac8e47ef2da1f7571702a800dae76b6bafc8128cb58ac91d9592bd2234f348f2b3486a8203b7eb63a7d8690e0c52211e4067207c1a1a4b5145ea069631f39a5ba5c3dffb0a9bed6d3854f2990c7cf1a01016091cd121cc4ef9b6ccd496bc5bcc0efa45aa85eab191f0f0ee337acc985b6816b817308089118f22081f8ddc9ddd6ed3f80495b02c8950679e7f4f45b54e4df6cbdcc139a3580c10d141ff2d868be237fc9ac41b616240ad8c92ec58f14660a5dbc07a7e93fd0c5e6d783bfecb1d0d3c8ba543c53cfdc012ed81336e722febea8cc61209144f5cceb3d1b382d5bf844a4ff2e4dbb31c91a41da022b24ab3ead7d711751095f6d5ee1c68e7afb0058559dc5e72e3c1263f1313763bc55812f35460555c7990b12528df2ebd158b60ad5e754db3a5b9aad76a138af043fa109f8c9324d968bbf8af1000f5b51c2bc7d582a2f52e8bbc4601e8ac51b1a8ff1061c8f685e9326d79f6d972be3bf2c0d245f9ab9843406fbd6fec1602102880ae43ccd5645980f6b3f0a573740a2bec5dcca498cdd0644e236a0841ecff43aac4915a5e39372d437db8891fb67811cb58d4e8a599035fd5c1412183a006e56bcc43aac5885de58acf125f6d5247580323ef502677bede3260c1f472344176c1725e4c929f640901472c0abb27077aed8b201e49784f47cb88a2b936e2caa3b90294c584fd6a8d4d403a361291d6d2fa3868fd3efeb9dc22b88fa49fbd9be885e2ed5d6efa2e8356c956b920ffcf7389a39021406cc5fe797a5017a7dc0692d7a73d2eafcfa6327079a973e2793ad1fe8b4787962ba2c3f6e2ba8c7259d13b39e1bdc5b5ab6477f7ff97770b838474b9f9f82294d8e6e774b99f421063cf13d6141a905f52cbc139fc65781f9ba3ce47e056742284bab621df5725557b4433d261cacd1f89510b2c69549f96375ef6625cb99992ea1ac2d793143ca0284d54ac89d94b5d3cd32370372e792c1daae47c76e8f922a94af9050841c15eb37c2545c215d76427ee98e9af817aad8d67c9cac1adf0fe1bcd713570e9d3ce764a10438db77fc7e21db80cf511b334142d30c837c355c1857be353fdd40a13b58cbbb30d8c1022b446e30656c8e611102ae7b509c2a1ec97937d30afedbedf83ab6ca2665266b3e59e1025e512fb5718b7e19f96ac73cfcdd65b91e5ba033ddfed0a141ca4776b52162cf23a491ba56826053f468043d62539cce4c4702ed8e42269ae5c82e3e461e6d3c654b098a197728bebcbbe720d51692a744adeb7610aece152b50e2bf09a30aeeac9466a6b821026d7462add8587fa2bd5fa3e3b42453170612e7e5b881aaaf887ccb0e3562f0c861a605cd3308300dd8098e8ad38739be84c9699ca1e08cdd959112d827fd17a77c3814ef5f1a14fb18825cbd8043f2b33e5129ac5c377d56e1c57dcf1b65521215702fa1ef2f4908a2e000caed169c92327b3c2d05332870a8f536c6ffb92f83a3754e49688b6ccbbc046d1e9e2e345545f95c68fb825b7402c47e9d34602906e0bc7bb795e842c449d5eaadbd319f114e6b2a7e16a21d5a674a11da674fb35689c8d2c0a3ac18164a3fe469e93439ef6bfc0c9cd75f28c77ea02c3c4733dea18385a24aae539891cb97c04a98ecde79f13cbf110162d5b9f6ea993578747f7a8d239cca0bc006cd060ae700295aebbcaa0c6cd7aa95a365f435565086559c968352afd11aa3a88fe212614ec086d35787b2e0098a3c65c7674d8816321da103779b58bb431284c2322743d3bd892ff46fc4ca68b7621e3228a1fcd3dfe3f23166cea7279818fe27fedd822d981801304e6250a4578dc435ab39d20337c885ea082340476711abfc2e554e695b27b9c8cbf023a8e7165a01a5f25ab140e009e15283b112d62c4f12a3983d42a698bdd65b2d5a1a04f610b634b117ed7617b094801cb05068c2fc94aec0ee9b86d171965959b252d04674c46aac601360d9fe8dbff4a8496548722be3dcc69f0d20f277d878989b050423197ea3eb751dfbc134e85da183cbe79917788e88da62c258e2a6c968e9e87988509f13b76808cd6f86a5b5eda5033b12a7ac4984240bb78d74d0f9f496484850497acecd8817bfcaf5b8dd03c2d41788a767a47ea0b4053130369058ed16f2e95aae95d68a3e1cc9d1eedf909cd5814078dee15d7f7d40b97c17c09db17207dcc20f30f92745a29c50c89b9ff478ff46400c21c37c48c4d35a45158d092547b8dae4927dd3386dc29f68be20abe3f6f95259e48a8a4482230464135676a5b9dc966453e9243664d6e7d393a61ebc02e2a2c649eebf804b176419ec53869b417c492cff37462e7425e40e5a24d9e0457372918abc4ccd9d70210029414fe30bee4d0867c9325d33c0e0f81546c1c716763b6cf71a5a4ee053ba9702db98ed82a2a33295a394fdd6f3136048f2a0450abcc9037932d329c598b8e008c8600323b84e8952a571d851869c20edea87348d8deceef9ddceab8709ce27a8a50e642d92a109f521e177d5a785eaa182eb175c297d360fc0b31e98917cb5541416ecec0437042b974e6f797c87025dcc211e1cc77d963422aaa47a7189f3cd22e6a1c0a1ef3291e9ce06ea62998a0ddff3efd67fd375f3fbfc2cc301fa1b8658db56792605e107833ced8d3c2707904f6eb7f55e99472e5d2f9a69ffebaabab2167d6008cb30da12b03617193ed1d834862ce64ab2fecea2668c6394a45cd38be42bf84a02c78055a770ecf31a2c09dfe6a91faec9d66a6ff86cb5c39d6b9b90741bdd6baacb04944d7007ebed74a38f43aebfce0d9724e39f7c56daba40acd01dca521a43b8d5614e605bff637e0a364333fa55869ccf9d08c83cb482817d30b570cf7c67b6eb226823ee73612c695ebfd24b9c9bbc5f38a1d30c6248e6d1ceae81bfa7774588a1f9f8c5f300bf0dcfe191df0eab90a5d042f125df1f9a2cc4f591dc3ffe63216cfa992dbfc98f67d8dce89fb329ca67c3303bb84d0736c9661d6efd366e07548062ce8058496c389a09351b630868d545c044a85c9971272de2fc4335cdb767f0ce0e7c7dfd12a50dd8f9282368896d85d25cc5197dd7da48abd0364433738be3a7dde5a7b87ed584e5947b846ec8e57f830cef83b4f50c23f72c65ef12350567570c7e408dc1c6e8010f1b711f77afc7349103bd058e655d39db4cd0c9d7a710ead76c4d89e2e097428772a415a207b58dd9f9df2c22a031cd9baa2889f2e722ea36e275b4e748e3d114bfb120954dd0dddc2e60184c4dfd0d5755fb62b849dca94fffa22db3009ebb9127f3cda32b0446ebbf036b29a2b40e9d12a6caac685c3d26e5b3a7feb09718cbda9f60da9ad5689c1681037dc67e5a78e11f6d8f922cad660a54f3204709df6b686fadb2a7a44833f4f87e35723f0a8d5b26f4f6da5307bb8e14622e4fa6f72d5cdb82de0b40a7a4c43a16f6171a810c33de413864127608d529e2e3bf3f9a7fbdeae5628547134d451b6b4c0ac874c853aab03d734eaac9c27f34e200e11c1ae20fbdb40ed9bdd8824106b1e0ba94f385dcf983d3ef5eaeda4bb6d0dc5207dd85923831e413f364bb53842dd87eb176460db7d6194cd1d514d56f80719706e58d19bbd910107d8cf1ab47bc5d4035da2562500aabe6c25fab8b50933970b12c15a384bc7099c000369772226b350c4a4db6bbbd40a237afaa4d44f9ea174f66a7e47ef9ed944825f9aa413c1a49ef5bc22f69a9160a1cc58a52748310e0c75c5382c5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
