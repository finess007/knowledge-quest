<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d288ab45fd7a296d12ffd0beb7f0f085a86b556d4c8b9adb2d229525d6e6b55dd90ecd593d5d7ea9b0c730cd0aa6bb8a47e78c3b992a6c3ac241891ab2300bc06faf9d340b6bd5009d15fb23060001d34957b686f4f3d61eddda895c4151014dae4737ae168f0d7dc354cefc8abdea8e4944b1e03eefd1f57710c90eb8114f2325695d22633a1985f879e5b1f74d0137f11488e3efada0de349c75fce865f3bbb08f454163d38812aeb1c5a6cc4f4fbb4e3b1e4659d2a8262a11288a1c8792d789ea9e38058ff2ac7ce7cf315bfdc6136e0444bd63d84c69213b764f5f9c5d9c3d96c7afa02fbb2d99f78b0528608ea889a20755636edfffe62f359584a07e6e48480ad5c0c17c9ea1923e7cfd5573fe68f923e8097c6bfb1bb071b6782edc997f5a5ada64985d71b0f82946e9c3da486e793ced004db7bc5a07a4caef4dc081782df53a7036c1bc797401085d1aec2f04676dd36ca7d3ad160cca64acbc621938a750a63c18af191e2fb2d531c57ef3f82e848bf86cf9d40bb2dce4f212355be0f1a6355b3deaa852c547b4f3e77f80552be8e13a5592ab813b7eafa662cf097d7742f20414868d6f6904ab956aeff492d18b058849c773d95f479d570057db3e5aae5979fa11b8e4436197d7d36361689d8df6ae602cb9cba819f03d62b9bd8e1256dd7e9bae73cb83553faf01219e75dc13533560f02988bad9c7d49d03dd54e7b4f2e46745668781fef3a166b1ae8edb54a34b34759789ed8e09190577f1c45bd21eac64dba32edc7eb5cc419c2f6596df0a4b2b181b9f0b8e3e3416cce650a4491f8fe15a9e57d2a1633aac6449f9363c7384b0bcac5734186ac8f239f6167e1d5ca1a2ede995627f9074d32f94f9014841d583f6d28a910e6276ad6aed866c772deed8ce5c6a8a4fc51e41d7d1a14596c3e5da2a5e1709b5454e00eb44404739754e49c548595a2b0abc1488a6633cd510ae43f7c8b65d1885545cb6e3282de08b61060a7f0fbe07177625691393dd0f2f23f0a20d057df6c984827079b053501d73bf16b2cdcf7942f7b4fb64ebd961d1ab5114cd00c645a1fbc0b46659d1bc472d131284e25efd509840c2af2bb97e3d2992b22f961d55a646df379a61fa994b012e888596528f2e01397e5ec90b346cbd07963d754fbb0ccc27722bc9381a2738ac3b0aeb482d79f6cbdcf7b55a04eddd212a05f73fdca1e290d6c57c6a7c7c03412ab837a8c060343e70a28dbb3aeaabdd8fa264de5c4d4ff674f0fcf6a65778f6f861b7ed61f58e7b5be07018cc96d7e5f81b92f836fbef9833edcf36171ccf664b76806242f15deef9eeac09b3aae7dccb72e8489daeadfdabd9db15753a8a450368d1a89e8c126f14983b5420ead77aedd3fb57c8d596fa0e074e80bf767dde9b5d16b7f4ceab4ef72e7523b064c4078f362aee1aaf3a65e09cdb31ebd1ec1480dd3d40ad456eda6e52ca34f403c60d9294b02bc7f27eebf08444a622c037af3bcaf652e8f8852c14b0a1f15dba664f0677e75754ae185f4ed26041dbb3d08d5a56b434d660fa554a36c7bb1756c06407ee09bd64ee5da4191c0d61405cfb740603f02ba9f4e6e875eab35845fd811cfe00689e7b7f6e844175e365ca887f4403eb5e6f9a2aed5e528c14355faa39ea89477c574db134d4b9abde8c810db91845a40d9259c4594c3836df8fc6633ca1fb9bf2ea7fdc1d8ae28dc792ccedac390b2911331ff741e4844f7d5462d1f92bb42d547a3a1b95411f6168383d7ead361a14188f8b842fdf41c2aaf3040ecd5c66ffac10b663193d2bb4f0c447881afb09b08df4150583cc72ccf45eeaa6cc7d94f519b9c652db55f53e84ba6ceeaf434a701176cf46756d60c7db80a1f174bd01628a825e630d7064903b41430dcecc49cbfa79a9474fb813105407e79caeadffc422be8204e9a8b8b46d848bfed7f97594ed2602095d64e4fc6b7ccfd91aea168e28ed4d51aea5497a76de6522559a9ec1aaa718382ea39a6b180adf300ae4ff6af465daed256f4a8a4593bcdcb2fd46f90247bd0604ff3cbf3b2de7b4b7313edb84bc43123f171a2755c6932eb44c5618a44aa073878ab430e76f6dfd743624426184f288afb9b0967220889f0a623a6c36c94aaf5da3d6ce24c2880615863f2e658779fac756756b1f7431c85c9ff677c163b6c4ba0993cbe80fc62fd2b60eb70b344226d06c5f068385dfd73f4e7578a9582d735f93a23f2c0a3ab4116143746c0c3b92ade4621321bdf2f72797e7ee45ec5fa71df5fad021ecc07ec8424e9a04e4290b20592f08e99fcd75fba3fadb7e6092d4d0fa974a440a0d1fff46ec1c051d6c1bd3d50188e9facaf281360cd38d327dc1516ce55cb39dc8e75b78da16fa52c6219ccdd2aa40ed1eb519175cbd59dd3a99639a5045890dbc3241c6099e10fb89f2c70fa745d72d02300ccf58246fb270913b71ddc60df56e4f4a570a37678d4d1fe00bcced612296a144dd59386090d5dd9c310135e5303e054ac960cca8be2b2c1cda9c3a4b9464118bc4a40c2b7fc833bcb14c0b96f6a788c6b3434b5d32bdd9ffbac980ff4a22c4d3579a7eac74b36debd96bd7a2b240330b231d41d362709399843dd8a34ca1116e0cfe7ebc77c226bfb88ec7632dd441727485e0b3c2e534c49727101404c257f412f6095bc5035dc10fc51fefd97d34263f3348560345e8c53201c87f8c9b9d115bb682dd3c5be06f8c404e3347957a86ab1af95ee734ed944c3b77e50ea24be6ca8b9bfaf9cd56c921d998483b2aec64015e7f6bb07bcc8be4a8c5a3d172f4cae34182bf6500909dfe5611fe082323b28968680e52977e2de98dcd597b196b66facd9eff71afb3f6931d4ee82cf04f9ef6d79882e6b648d572c50934f3294cdfd8b4c2d176f214a732b73ed09fd6877b4f21f26a68b8b44f505c18b488b674aa9e330d0ffe623a96f2038e0975c10186f5f89c6a89a277811be2e0ef0f9dd83a74627f685c50e934cba70231ad1537c2fd4e6f630c52d739eedf4b8ebeda82da75d2e66c70ed093783542ed2774cd6d4dcaf7a92bf0b621ff4945abac1a4932194d770ca50acfc7bb9560ff077ef00e1ac332264a395c5969689a47f40758bb859d8eed758f439a8245f1ec8d698e42981c7cca1c2e546b0ef1aea50d780846214134942b7ab22d8c0d759e185e5d811d7a8cdff0fe445a4ac5ecc51b4c0cbfd39580239d648892c7fc59211f64d527ee9cd407bd15b914bd51e0cea248edfdec5c6563de92a81244658b0e424fded2993c1cefee27e9d3dc4191aff8c14575ea7654975558b071d8498fd7d6fb728d321019c63396e20d95accf8de764f7e37840a18e419836b3a680b4edfd01800eaf4a56f36fa9207d86bb6b0e0fdde47a8c11fe638e281fd4a89d548fc69106eff8f9a22318e8ca1543922feff1ce913ad5ca913343204e69f3c90e00e94b091b2e7c0a4cf1b85120b647d379c7bb75622d1b83a84e37af843c1696eddd6ddc9e66fc4f4df5ed4c2b21507311138d1b28be6612b4005b2328de936b91538319cfdb43ae7626f8016fb2799deefd0e82e40adcf704c6ab897a2f7d5357355f8f2a0133066e0730db5b1be0aab1f585d8f116943d5caa75eb899988f8450072034970867d132ca458b636fc3cb91c923012ba785df2a4b22a8becc351dc7ac7b8f75da85532f39f719dc75a693cc7905018dedd300d8259764736094fcbde1b8b55d1bdad18dd7caf5fe3acc347005ff477aefd6cc6133c1310e21059fd0842ff9204ec2e851b50fdbd966a86a3f3179787b2814f1ecd1d5ee0a3789ccf5097d16dcabd75905c0f05f7a288adb1a105f5925cbe9ad7db440222e8dc1b1b4ad7633ca3e4ce603a3b83d74032d4a4ce6a10556da42182032b857134ee0bc3d8557113e0f1dfabdae0f7d80f57ededd71cc93bcf1a7b4c9ae01f34f4b9c857c067c16666c13a780784e34e1db54a3daa2325431e5791769cbf5abf3bee9c02efffc1148c619bf403e7ed59ad45dfa916ec51341f89913666ebb4c9d6bbe87deea1776d2e56adebb727f5bca86e570cf18b5f84c9e3957e02e3d652e8fe15e741723ffaada0c6dd9e0939f7f3e446d6ff4413b159bfaad617ce055bd50b5aefea2f9eb876967504a7052c2eb6e7dc75cad62e0b9a26c654503e0226b2821e8788feecbcee659eb5437600c79ed66e374cd3a835f5bca50851dc6b21f4a18bb5c6bedc6f59f078af4f9ad7568e31d83d846edcfbe22711d7296f68684e511d9392e568ffe99190e6a1154711b3d81999471e80727cae823b92bf229870af939ce5a23de2c25acf1922d790477ce82c73afd96a82b44cb3c1881ba387a1bb01fd78ed10325a3cfc940d6a9c98a39370299c4bc068a178d21297bf4e626630b1a9dc2f85a00f52298e4ec90fd8b5bdc2729a53ea01bee6b3cfbbbea796f0f5007d775d373e918d9977d75de4dc2c1ab73e36e876f468d88305b31f9f86a2b7c9398d7abeff52ed7273c66c0a3792f26346a6baabedf3084966048fb8de6a4cf666029193eb1d2d0739d8144aa4823ceb082567cc1ce1ae99166f24c3b7fb4493645eae09f58e776586ba7d4af608c1428439a91ff1d4f092dfbe5ba9c5b25af726db36dd44a0e7ade40be6b9cdb456b96c852d3d4be62ad2bdef1155ab0271be9014ff4f341395c2403979be72840b9effaec2cc53d6cc5b7424c33f6fd2f93f79f28feb5b1178695b370dc1b111d6569e34344b30802ee841f683eca1a4b507ea710e9db37c8ad90b6c14006ec87c6d675ea30e3815e12a650a7a13d2ddb57d5af3e381279076cf3d422a679a261543a48505f1475a50fb184b4b0bfa273bb33663b992f48e6cd516e350b50d1af9a0d3969c9bbab405e8cf9e599456d21e9633c20ac3fc0e12633ec46be3260700b344bb915689d5d7e700a640f13004e3d895a97e3a90922c28d0a87b132ad5bf7f1197fe1c767a41a6f527de2b5cad7c69a3bbcab2c39a57bb120af1b7f9bb3e4748b0e0e21affd95aaee17957275ef6a723423fd0caa1c1bbe102a8fa67c1a2594a4541f34e31e04d310536079a0221818b9088b176bd8a82ae218cd0f05b24a725a8f43abb24b4ec2bc082d9d147b17b7f1fb0bc034d1c772679da99a2499e26646f9d0fcfbaa142fe3fec4dc7532e5ef655b4441a9a6212a074e8f9665ccb4a57b86a403bede0222b2c50e9ef0f463b0a553f2a94a62472524177fde94fb37c04c1f4785dc1b34ba6c28a370294db1025f0133c9107bb29cf5f48f2d682b8d72e15a576c1273d3c4ebf2a6c4de5e1c2232093ef4260cecc683ae5bc29fdb423f7d4c77a44841601cb73f057bc11d78d5803172034f38a1af6cab56de8540694e25d282b339ea6ff1e6669ec0176e04ffa86ff2c01b4e047a368dcf0758fa7820168b704d5cc5a27c35b954262bde86b8dbd96cc48e8c9a992e95797c690928db0ab28c2e93112ac00a86404442644c96e0ab0fea306aaef67c456fde223b729d73095e8b1ae5ec77758c15dadd34f3fdd3b747a44ce91a6a4af63e64a16f126e677fa381a5ba2ab24cb7991faaa73808a91633b224ec2012572a8f525315af71d34d60e3b200f0c73762839ce069d17678ee37d79d1dc0d85488dccce3afb02c2447baaad9b30e43243cb8f9db1632ae3a7dd3a99be00e1715926dc55f49a0ce243f5d432d207f7c627b8ab250b5d1db8bc02a110c4ab5c95f2ef3ae94bc54a5dbf3be38721329df182b87ad6d7dd547971472ad66b0c892896fc121342590ce1bff1a2c1b2fe61a9bd8cf68ceaab2cadfe0170b6bfdf40f4527baea04bdcba4c9915f830005ca654bb87e3ea4147f2ec56db6282008cce79422ae64283d44f6a34cd352a23c47b42c332ffc9ed1d7f9e4f62690f044866fc0b214af80ad7987761457b41c7a605ff33c61db892ac89f12490c556eb988bc89f5d32583dfe7d3950e72df7c8a64064ebf6d25fc0824c778275a1632cfbe9e966e93a90818d6069b72319b0267a3ac363fe8038f184c285fca10c19055095a96ff7086f55100380739ccf788f9a15d42c08003cf44eff77ed026130e22ad64524d43706d70caa18d12ee0dd0ac94dca47e3f6f22e136db1aaf5b116a836b5f63521a656d937adf037bde38599ec45d210e1a9da7220477250dbceee47108da57c31daccb3c1f0248c51f3bcb2fb1f90205ea13ca171b364072b0cb2078afd7e7016f22ff4bd09cc6f0b8010dade5ede348f4766b3811def08718601ec4f2a9b5c335699158a6bbe6a2599c28170172edcc360340f5866f33a70fb211e167cf0f13b6687d6af78af26a8131a2b0e90a58d18a4ad6affcd269e8986ad7aeaedc5700145b5952494c0b3a857ea0fddf24a394dd74731216339bf095cc164e2cc34feb851d0f40fdaa5c2916452569b4122804f665178df15b8443263e7c2c54627a9d6150107b6c8ac9ee5dbb552cb76afd6c4123b25a61a33d370fa34c43f9c2998eed73875408b45aaacadda702a05f357ab585d6cdcd086b57cf7cbdc5972f4071ce7264fbf8969ce37c4255e08082b44587270fe9cf6b64624f2610cf2946eabb9829e90a4da3b9bfcbdf119b5722d81be1805df3c7415b2ed9c22494a63a1583d5152ecb819d7228b5791f82ec1b8ef6d24a8fa6ec76f939a42da19ae7d4e4690fb836234a7e977faaa6cd3fd720f67cfdfac9609d46468a8f626e4c5d6952f4f50d153dcdb64065498120b55378ab64e6c83a8da3f5da13d8f89778400d37001a06512fc3bad44a9ad5828771f0048c865af7f15eb2c874b39e0b6c60927a985c91d2c5534828d6bc1b8ddbcba1a15a47308ee9acc2f11858f5c4d66fd22375101a1867c85fa7ffd03f6be22e9599298a55b0fdb1d332aea792e541c846739455663aef9325d6d05f0d7b73b4fb002e02f5e538e15e5aad3d5fc4c8c679704059f4528022ccbba835a370b8539fdb32ee7dd03a4fe20d514fc3bd584456f806d10ca96cca77abe66509286195d82b15632118e3ad19d833da859100c57838a59023e26bc76a10bf12e1b461952d1040a1ad58379caed3be6d3627bb66389f0491f39362ee38b4b428a399e47045029f98eed12be69834130a78fedbe2753ec0aa6b991a8b25ca4057e8e8ccfca5c7010bcfd398f99bdfc5fea43521b6d3d9d334a43651c57ec081843dae978781134361cc98873158ecc599929666cfc5ad85baceea0950bdb15f8a196ecedb1d9f4361368f4aa69575b2e97d1bca0c4234d77b0cd42083a366cfcc5b2c3204d5dc11621c62e4980213e41041268b660df8ea0f8c479039aae58940a379f6059712084ad5abec53b51571a1cc0da0a1d70bce1c68a8f297963fda47c15e3e498d1167a5337cf09cbff020b5610c638f36842115ebdb959a8cbd05d0b30846ff0953aaf16e7f6bded40082bac933056bc66cb649501a170d3fd9870d12f4c96b0c20016e1c13fb3e41ba83817b6a95d915608cb5d12c638b54c6626a7343337095d97d1778e10c9257f0f18f7b0c76f5b94c93f060c46c23e61bfdfa101fd837eae6b7dc6855df283e36a53df930830a5aa7d57c15cd2f116cfb82c971deb530da3dabefdfa7f5a1997d77d667458b57305a40525af7220ea7c7bc5ecca06ceeba23f3fd0224554be40fa199dc8baeb2d7f3e45bde123e0558393369a9142d65463bd0015cb94b44eef7f045f9d6c2cbd7cec816f609f90d200d29097e22406b525c74c24c8f941be4428a456f6c7314e912ed6ff51e3dd5cb4d6de7c2533d40ac96de78b246898458fc7223b0ea4482c9a7928ebee3aea5e3c98f2f46c6a18ad6392b00775191dc45e2bf7fe409a568806c224a12b21a50cb885913945f26c1f7e7de4f27369c99e718b21d1c1ff9152ca531bdf806902ee5eb4a1643f924ff0d6a3b60889509db106f8bb441da218283a2bae993c3ce3c52b7e154b70a43c96500b6b41c271588ec48913fbd14f110d38adee4e3d09728e64092c88a38e15d44110810c4e051d9e9e4fbfc0bf25c9eff02c0b4fb580ccc0375ac408dab23495080b2e714c54d69473149924260359c20dbb5d784563eda9afab09b56f6126f637cd1373de4ed9b1df3c91f33aea451250dc3cb0fc437f07c079364a25b47fbbe87eebfe909c89c206731d49566ddbf3617e7241dc5b7bf7f8cb9c15cb19ea76f001262b2ef12ad3ada645922aaaefe076dc74d5e55e3d0e376fc9767b13ef1353572e042b6d30c051e722a6dfc1719b252bb2b9a7929a82d81c678f359618c75cce77cfb392c98d845d5d1c5804cf272ecb6594c1dabd2ebe83e718540736c5659e56e6ac2479f33dea11490e5ac77187f0b94e64666d71c44065aae7a4e6d5ca284cb679bfa4290ba0a3d57a48b045170a49824601139819e83d2920682b2547e09eea2d965f3ba236404360dc566546cc2eaf1382de24f8b2121d4c8b77e9b5e830525aff375a4ffca3ac453a58dd460ef8ee588b2da5caf366b2d704486d1f8d203b2a2e5ebbc3d6be9d5e39df0de7c1df84734d25f9343a7dbe8a8306622174d74d5fec4f5fe8ce50e43364c3117bf72a170b31929434a0231bac6c7758a5341733a438fe244d113e1a5d806fb26eb589fbb65849299dbd1974221bd7da833fe78d571571dcbb8dfdcf70b3d393452d8230f56c9ac5f3ab59bd17e0e9d5c3ba784a2cb69e1d23e81bd43921b6a778fbcd617f0e1af9f11d627700ba724c1e44502b5b4aae7e25da0af0806e8437afe4694ecb7cdfa35bbe52ddb9ae61f32a2c860ee1bf0bdba84764bae831757a982dabdd232c57d474dc265a92ae55da80946bd433161721680cad9fddd2fedeab8e1bd86e51f6537cb4ce30c1d4f2b941103f439dd71b88629664ba9b7c822c931471d2e3284639e835c52cfe765a2695e6b6687aa6fbba85ff33c2b789f048ec7f85c50b56cc1ade6f0bc3b91ff2bafc29c79db77b63b63ad43cf472257b5a5b9ebfe44afbe825741f0e5c7f8945b6af77585393373e5263f547baa36c295929475a0e712b0415ab8843888f04cd782b1fac0df0dcee8886400539e3d77445d24682b3a36e180b08f6a946f005e9dc790576ae5e76faa15d9edde6da6dd385b6145f51e22204a3646b3c99c061a3c8f3bfb37dd921dda4e67c7424ac2d60c80e57faa6076ddbaae7df56d727680937f02f80eb067d395d3e7f75dc499814987db9b62be26eabcc463d2fceab76ad12b71a7f205c8d73f6765e2f6bf04ddc18d64a817b208457be323b53f811bea43607b5978613116b67976de8c9acdf3a977cca6e69adebe19d98c20d48eb2a31167ca0b8ce761e98331874ed86ad0847883d8c968c6facd9d22c463224332613472b5b8b47a8fd7ae48c8541a31087d5cc1709609e3a5dbfe0cea1ec9c41c2a41c1983aa14d67388700b4fb4823bcb8732e8a61d3cfc44865a6c48e1c087b76c2ff4b4de2af11b9da469e5f28b49ae36efaa05d97ed5d76fd0823290af0fd23613a0c321b206b3b511bae7bb058606fbc08b1a85de86ce74a86a7b58cfbca3a3766920d38d3a744a2b2dcf3377bd6eb16ac67dafa0fbd56839d007752bd33b2c5248d3a521b19ea5bd880ed8918980891e8d80568445807be83f4d15e664ff2e93968478553b16eda1879662735869c75d6b207fcc308a0b4970f585131864b360ce078ae64fed7596a7753d75e1e84dd77cffe1403d85a2f7b342dbb5443548122168b43243968b265ce8b9310ab9e413b38489acef6ba5539eeca698ddb54d0bbfe12ac753e4227d60e77741c1ae588a9343fe830ea3d0bdbee1785122cce6bb6d1d40da4d9bc06505c2185b674cd6b4ba8b6a22c42d4d4e00dcbfc1082c9fbf8f436b5606e2c627d33fa59eb42645c76d1e3ee15694d1e8cbc04621bd879c97fb44d0ee2bdbdfcd7b681a6917b09d089f31b4f5d333ca567e21d0a500261c85d92c5c4ef9f5002c3119df7606e2be20bbc7282de5791049c415da21cbc37a82e903f28a6d75bfc4723c2a9acc6bf0e7c50b1d8af195c327cf41ba11e42264548cf610a3475f1a34bb44c8bb06bc7978868364eedeaf8cfeee17b5eeb42aa524ff0898a69ee55a882128d9bfdc7a2e89bd765d1755e665383ed6b9bfee67f612792b755a5892d655d80866b897a7ef0014c743f1a7daeda165e89db95ba81a4842a9f68bf026fd49e8ee57507500403cb9ae5c1ba71f76c79364916089f1cec8b26e7f8e241c7cc29269ffeb4573a3b46bac823ec62e9e7d3fde7702beb51d3ca40a92ec1d29b7393143ad562904f50166bc7c3336cf453cc9922518f668bad84c59c670387ac96159eb1845f416146363821918f92bae243101ea8c01f15a0a2b4a5b37364f7b578718ae61dc4c82b0c412118730d9154edac6e80c399897b401c0a48aaa7f860e970d2a0790831e6467571c62dad838b56288cc4b0360951d9adbc58b1a0c4964bfd879e3488bc8410873539db8afa0215872f0a88ab310859e961f595f43a8136ef0381ff72ae2ff0aa0806804c06cf40449815f9147aeb98b09c46faae249d4ab729492f4383e072a7a9f3818f83f0ceea89a623c144f451c90112956bef4bec128660793a6362ee6b0e42a2822ed5dbea69320f94a63bc985f410ee07e0c3eb342ba8b606e3233efd3c85a2908270468a4f84a06191250c4fb2d58007d4a432719a3e60d4196eda514a8d93f9b02417a4b052af743f3a16d6015f6d079ee3115057261072819a6e350983550d0aaf312f3d787565529c5b9fa6de7c0f5f4d86b5fc3bd39c8c817f9091ef71d70d740b8eacb9127b22d532b6f984170c008b873b9a2630feb01b7638a0d069998b3590e0e1309f926f2a937b67dc392b657bf93d18b83617182f680e7d441ea600edbb024ef5bb8c841d1748ae4c3fe8a47dcc57786f682e284964be885ff1dd75d12bf96aeb3d657ef06978ee87f9daa84d5ca7954521a6d159185a50261e21b1fa63d184fbe55d1ce0f95eea50f0207c33dc6936aeb19b28578fcfe6ff8298a9a3d032fb7fcb21d112cabb12014e8db8afa4e98cd01a9c5dcf09a539587bb44f83d5cb7f0806bd5ad0d1a1f31f21263be02f0e0900a71dd2d52c6098cde9ad5b2bb7216f4e50b6388ff576640fef4592ebfff38f795f4443db9264b8250a528873536f808c057f4dff35791189e7a09ae3fb81b3f45792a7468707cc148dd00fe5f67622836fba8a2822177941ae081e59ec11db1ed92e60dc1818e6b9c29f4c5097768119a9e6453c6365d11d030f72ca66b0a5836a8516e6dc42e5ff7c4ae86fd9799760a877f42f4794ae4756d6ede91c7869239972cf5698f50d1bff80b8f9be920ec7b42378be2f9f061fc169496145f47d307f293df4886257a23c140fb1729b2dc6963f8c071d5e69f01ee85775dacaf46f4b1f204243a2ca5bf196c2db1465c78f61248f98d5bf8253e035a50cac07e9c5447eff904a942839528ef0188e91f30bccecb99b0317c60cd5bc4fb58118c0eed6bbc89e2f634d9428df6b787c1b238dd6bb34101d91b392e162bfbe9c79c834a0eca7f50acc6ba223402396adf4c3c8faac1d5338f398e7452f2b7b498708ca24ea90ccd3529094a4818d3bbee262743fee903985910a0caae0ce9b9d2eecba9dc9b2889db8adf0b45b667ebec28d20f7bb7fe9a7a728acbe59384aed5c26cf164b2929edfd2523a917de0481737c8caae95f36c5c20f8dbd416ff446f6fc3edc01ef47109f18626adccc5aea32da55fb9232f43ec249a5d25dad2a1cfc03579a178424390033884287d5d3d82135359416b27d542c4cb481afc8931403b329e9ba80cac11260f4ad42a27af88b8cf7fc00ae057a3f2560acb1fdee98b4e645fe474f8c6825f567cbf3017216a307477a17575e13b2217527db1684eedfd513980ac7bde576dcd46f574638d0ad11a868ee640c058e4410e8bf517d2cf42d85ef194d20e05df7e99f5b4d4f87474b820b56dba02c9c9d421846c13b35f957c60a4c5fbe43a2d309657fd0a862589001dd9f0aac6e67c9982c0e52866645a0c0d1f09fc0caf2a6e57f879127a7a35eb4c2331ac5c66676b6f3137fee59e4d9a5a3ffcaa14a2fe82925338914a95c51c139443e233919f26dfec490c3b84d50ead1c7629c153683ee02278750bc7e704685ebea9d97cf200f55e7706f5ae5fd1e0f6d90ef9151cc83a4dadd6560e310a238f56080a4a7a973ed3f43e1181031da522e32fe449e06db4dd4b9c8223ac095508d512d57df129d71b987f443c2df516bdb5f6c46e1a5e1cff80c0da49be8c1a018d9799f6580d1bf54abdc26564f3141795dc56b40f80490ff06ea5c40009e6abc14c4f3672d7e6c4622a263408a8413b9a787f48696d4ee0467444c70641ee2461b9d04c871f2a34f2a7657c84148375714184f30c85d8f2fb94e31eef31137449faf7bf8fe78757c60d2f8f79a172d04dd70942616e18d6d82f365249cc59b92698f3be60b360146c9dfc7bb7b5250206172d2a658dd6d7019d3e23044cc447573f9c35ab3bca1031a93185ca68fdaa8cb1908756dfa7f7151fe561c52d20935ea786b06500acec4ebe15ba77aba54df8ac04ec40d4eb1f6edfb8f18c432a660cedb3739b30ef12688394bcb8ba967bc1686fa5ea6fb92c6a80969c20883668fb8893cba57e257e1f7988409a1f7aea1a65f0b96f726bcf4325de44b6a00f57aa0b69b746e239a879cb72ca66792ec5983a8898bab8fec04cd0c95026c9272a478eaace29d049b9163118d02efde4eeb1f73e1dde606eef8476f19f22047f6a8b4c3615c729ccf1830add91b0bca95c1dff81b1ab49ed5671fe30385515acdb4e633c05181e5c6bb1a43407e4f19bd2aed136a6367824805e4d477c0199718dce537bffc2df45f13dcd2a661d6509f1a4d66e7f121305bb734265932f520f40b7e1ac2db5d2bee9da066c360ac30db73a81b6ae7cfa7d882874a24e24e71ea2db975704f87bf146d5a400a63a5c777a62e6eae3a7ab892090fb2b6eece5bbd2f897f147cdceb1fddb6cb40f65719d6168a2705d1d3a77693782a96076df6e9b4b5a378e8993e1c04a99f2830802cb88aa999bce717eda2501bf7fe88ed00122b3528bf7363d36bc6b5b1e1f979f3acf765eb8e9f86c1512d7572918accb9144b7f9908325049c6b550cee3564d690d5f9995962cdab87c13b3c244e1043d41c8a1cbb293fa6156c4ee2db8b1b52e1cab08ed0c9c02cdd7c69e386872c27120fdfb3734a3c1e8acb86e07f65c2272caac87a2b49ed434031f06307ce83c923790cc2b989dc9df4765512c2d45a8421fa114e72dc2d58a118d0df0825a8411d13dbb27231b8fc78e607555f96a67ccddabbddea1b16992c9058c41b384050eb0c8402cc0707dc02fc7b4270f590a41023999dd47579944afe4277341193aaf076068dfb6cfce92b6a8e4419752becd8746d1ec4f6896b12b8e5cb6d918cacbd0beca01e92a10d33b11bcee69a00ca468e2cfc49cf6449236a661b96717a50d38aaa2bfbeb4ddd7946a6edcc20a1302ed9fabbea8526d4198c8d09f688eeb13e467313442464b50b84a63ec19bb8ba45acf1b714c512e068251e334ff17efe8b8315f9e318bbc446aa433545f71b8b32c00ffe613c8200023a54233ce5c967f8df3b35cb546ce8d8cb434c17ba41179bfd6fe1483b57440d191f8e193b516bc26e7ede519952473c01f982c86ada1e311c17c7d5e475850aefaf2d8da9cda0c6a3bd1354d98c6065eadceba55191014700944f8cb7cc5066d675da6ca1e8f1575387113e23215d89583ed69a053b7a65cc91283d463a740841294d3fa90073ec74a39b423337b301caa274f9e7dde7831dbe120b9f25474ab4bc28a8fc7d81486f6a5e934151d445d31fec4f83a7b1eedd44451c237ba0578c255bd8dae9c003b41ac359acd02bb4e1eaf3e646bfad27d7613893ecca0c81a592dbd71241018a290004639eb79224d4006169dce4d4f14c93e13feabc0780075a6c46b594faf36b0f6d6993032891589810c0e1f82dd9d76d02471ae59b4ccfb4123f61f6012f6648da9d9165847ec33c95680c052023f26747443dd79ab9d7da9825805c3c631f92aa923ca0147c8bc8eaa3047d5de03a43d94f89440e8cce108a536ba87b4dd28375465a2d797d696e1ab5b27371ce6bdf75b402948875e8b8b7ea9c4de5e4039954d72dd05d92edec49a791102746fefc88a8dae69ca1f79cba5f4f6e77987f9b86234fc9dcd1b5af233803fc5ebd98950aeb9cdb5d7c5081ee406b860aca18583710605e2c279e4d3cf0c57ae775673747f7181c95094c225796ecd54332453dfb541236a879189e869643056a537ae9c3ec8c613ad99e2c303e659f9fe2cfc4990d115b0940270fb30e345a2cfc1b1244f1d7afb92388b3907a4","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
