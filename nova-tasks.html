<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"541229697dcc41fa2f50fde0625041b393be50ed342060247337592a4a7710b9ab5a37c3fbf4a7c75082732c12bb0204e3ff7ca21f4fa2e9cd0d077ed005964248279366864a5c592611de21d1e738ec989ef36c02dd5232823ca0db5885b6a1061d49e22f7cbeca9f40e6b328aee4be772992e456762298d49f6edadeca03b203b1e704f6402929d5b5404a4f5b174b0bd6ca71a1db0bacd4f9ac954e3a6eb0a7e085b6d916ad4688e4a460c23af7ad185df5e68f8a92708b4d7d8d97766693628425271b74f33135e9054dda107b839bbfb7266df683690d02ddd0d083b7fb65cab41d6d5f7282b9dc4310c945a92723ead014eb96be335381f0ab3ee1c720570795a72bc9ac5f497a22ccc91649f6d25f385d4c7c714d5be06a8f72e70853b64dae92cd367f2e1af3ee19958b08db663a9ee5cf52668381cd626720f3206b8eef5415f8b163d2424180d6cc20000c26d53526c7531ed50d1b1ad5bfcc66997b76967682657e90f7bcc6e71c57b259bf3516c5f6c932be3fac390364a1b64584ae88b2575cc53d505282e8fea93b5130a0f77c45a29f7e5278824cf0f23b913f87ce6d6c769bd34eb50cfdfbf3fc49abda1462ade7029af93849b7f54e990f22178dac67c9a6cedf1fc42ccb50df9f7bdfd14a1cd4affdadd161f97724b49eb484a1428c4824f95227d2055f29a432f92513ca88adb9f17b4c91dec35e2e6532b46e3bc2554f197586e8dbc86106e7dc0f82783e41455107524ed34315bafc41119c76305cfdefd3fa0cc0190f95de67f51a3343efb5c01629517863125535ee9acf9453923b4e3f01a397b1c81210ed20eb0ee39e9aaa41f702f95e90bdbd31932296dd0b8073d8e3bb275e08f2a3f3f5d383953bf5b9829a1c71fff8aec47b631ff6135875f1d48bcd6d8e4825398cecbad4743dfd96c7f7d19046fd1a9b1c1c88d313632908d03928664b0288141ad1dd6359ff0a662ffcd8eaf15aa9cdc31c4bba7eb2c8292d9346a0d4711a85f06c68addbefadafb349e56ba38fff5137736da75993d2acddb80d2fd814c8b1828e893e9e61fc320d0c791ca2d9b1da32e39a25ed448a8b84ee5c7bd461eaf3c67769c5bfc919d85b791cdccba363a52506a66565907195385369d76b717989987bdd7ff68abbdc706d1c4a9e190e4410a3a540a96825dd1d79cfb6335e3b65eacd533936bfc61c0223f1d4932198350a505305e638ad3ac0ee45e11169842b08cd51ea17d2ed983edcc0bd9bff8e92323f1149f71e0efda3c14e09077b315076438d4619287b5b2fc80349f0f788336b97b5766f5a80eacb56b8d2aa72ffa453eecf7a326b005b8f83c04115a1ac24449a5a9c345bd453eba80dabe48f06af4352b9a1680025f6ebd1a90384c0befc59d335e74f6d7a30c89ce4c72dd70d6b21e49bc916418e5b5e96934eedf6bf2827971b65083e0cf7b9bc2510f1ad0e5301bc338e5c39c531148ca7aaf38433d2f4d2a5ecfb784d06fb1a9968305a9abf66b9e3ac33fb0eda59d24f35a9f487340c7ce7f01414fece7268e390279158c10e1b3ec01d7c97a750cff5ec2623403d06b64152192e7488151bd874d44e4f7ad5d7456124d1b292a460ad48943cbdde767459a0fd20d6d1b291353463766e1827bc42a197b018650c08417ce256d38cafa3f655c1079773f65bd4b04f1184b9a5b6c4c2217b5a1ab2443a8b5ddd8b95240f37b54ab303e1214c410531d4e59963791745225c6d869f175ed4a76dbd459bff29d30cc9710888da046acaa40753ac8cdd29ac8e57aaf129e246d71858f838c5e0ff0edade071110dd4ac0a217f078bd365cf013b40a03bbcadca2fb264406d2e428103bcd33d74c338f8c0f38c0739d8b57c641f86abd9d466556bd6f2bbd34da475c22f52397e32ca82f13bc3a19c63a2c30200dae994e1fcff266b8a55d558fccb126ed81f5c2feddce835ab37b63aff7577a8be499248405b15bd76c9de16fe981bcaaed117d96e7772b73beffc2c66bc094ed2c3612bbf8ca44d2dbbb20a1d318d3a1f7c19cb420ccdbdcf0665abb9808ae5b18734acd9137e72b894c5129f0681e91394c6aa16e0bff54168e9f5993bc92293fba885d65599908f014bda3e9b68980fb10bf8263f29ea7d022949552f6752548b70ed2ad9ed23b8d9393d4499352d16ac09db34e35f58a54d6fa068451d9f07a335a05f11491d7e4bd6f2c0ba85e8784f44f545a3c5dafc8359704f92097b34103d58a5ec3801b90a813fdf6cd2cc0e78594dba28654c76895ccc5611d11eaf0338544a20a3ba0b7884dfb89247d0832b7de21169aec5b2c797386d6f3038c32bed206e44b51807faa0461b44f7e7fbbacc96e599ec7aa71cf8b96912508e6e00d8f3ab882b0fb4959e974e4b109f98a60df520cc65c0503e0e911bdbb209647a03c56b54ffada791966324aceaa06449669e095eab486f505869c32e906bae95f130f10f759aa7cb668cd0533db12cabf5a5ec2607bc10b335bdb3b4b6224be3200a377fd20623c9a2849b18128e991b133b005e8c04a356c9f372007a6e21bca0db91d251e3837c424ea33560b05b0bf2d258843cbbc14d6e60d7edac9f47529d646b50b3f476e7b0d2bb49e1b735c4bd7eeb3c401a0a9eb6da6b952f019aeabe7bbb34d7408413ae768f43e260f726932df0332aa502c020e2ec6d3158b8c8d79b950a83409e83fb014775d7192f97c10df7e12d50d22c9038f29820fe88be5d2e3200b6592f7fbae06f6bcd5eba1c62dd11e14202b99527e6dc1102326adad1c7444a202f27bd90ab48d9f34ac8fd5f7dd1e7ac155c308a6645e45568ffcfa905570731de7d73b164bedf02e51861a4f0c63ae1f834d475eba2ae64e3fd022835792fc3d26030f9e6651e2e42c70926be9915001faaceb20183a0c803e85a2335f19ee5ba5dd16b6ca9d42ae341a106bad4fa4082bd85747511f69509e2411d965c7756dd70ac9c347c08bade6e2ad58c93b05c17eb526b8c330942420335d43c555d9df7b0fd0383078c4a9f002246b94f0828a2873be2e3d464c770c3ea9ac2818e297d6367261115c6d5f81875385dbe608a247eb9fd7d702c0f27f7dc3ec2fe0fe16abeedc64df5edf4ac5c56d774bcd02de78152238d86077f43fd209892a6f5511b995cf182bea4eb8d10c570a805162c694d31c258f4d260bae6143384857294abce95f2198ad41d16573f99c10bcdc849ffed16dce298415811fcef8640e6a064f7b27c103b8d5c41b46a028cd8202f2f00ad5d9d0f14cb7c65a076b2f310150de4ad770c677fdda0935937c6fd69f4e5a74bc05905d4d372a1acaeea7dec1707593819b58d261b0f3f2889565d99d3c63fb7d6865e619c3461a44e8c1e5713a5b3336c11fee7d0863054e10de5fcb42d182dfdd0d90f7b7d88065b10329a2507f944926148261aa62082603773353bce3acb2fab9f1a5551138bd8fd2933778ab835415fa918e1f64c381ed1f4625657da7e9bf062c55cff35647db501e54d8e37f8dc0b6eb660c059d9924824afc2d184b00cc13e2188e8a5173d5331900c89d1bb748b00e38a1f90e01abc2a4a460d5436c8efdbe6ece162064a39d240c0592e413321a404c3c1146bb21df1d8d723092f8eb333b49b7316413eea63de3d43649ea0ab36d22b77f1038d7e82d00635a1bf03dcd97856d5a61656a43b65c165a3bdbc80207851b32d156f9ae4ba7b64baa4b21b91f6e71ceb956665c20af13a67ee4072cf72e38a684b959f4a98cf6e4cadbc8372fc9e4b6ee6e877e2962b57daf456f7a758b4b5d08055dbfd009cfdbe9f9d3d698935d03332eaba2a1301de00899603d501c75fe5279a80192312653538ea45fac729c73294555c1a1b5aa29009804e3bf9d475fe31ee68c46c5ebc9c07c33a41071738c7b480ea304dbc3cbc125de96eccb2e1eb3a4ef8fcffcb8afe8d4888ca062b72977dee8ccdf378f21a3812883b7cd070c40b3d5a9da7af0afd2efdf3fd458202ecbf310c9de90a84d2185d2a4a612d4a6c3407593fef73cad57622ee93ce6465be449d167b7b4758777dc3a7e9b1e1eaadfc343b33c11f59067b7b9f0ef226ed74c1a381e835a829ae3fe64bcff0466486186e543efed351e33ad5a7c29f0c3f6bfbe9d42ec9200f4c0b8e650e404c40f91c0380cb502ad2f4bb122cccd6cb9ba65c9757d3404c8a9f12459b567c7e6ab097c2c2757ba51bbb7093cc5ac4b424c4b7f75f5a66becdac2b63dc84ed1677918979cc1a49ae6c9cbc10d37a09692d74f8666435e6f08adb36dd2b36dcd46a31e66420f205cec91b34a8a60e6d53b80df9ef2fdf5fae233f6c8e867be82ca86f72c74d05f22484f176b9d9c00f1cc6b36213032d0f6bfa36ccdeeab73cdbd681f822ad7918e1aa17830d2abe7c8744fb79f6aa9b296d8b7d0ad6624bdf043a00482bc873f5ff5fc184f5d4f65c1464c777d860ed68132a5f7fa982eeaed2a5ce6b96838907356bafba7a4d9064001d445b5c23bf33ae295118ec3ee47dc50b23b66b10a18afb02360aded06cd4210b42de3b4949e972d77f2dacd725475d2c0fe2d150ce654dfdc5c037fe928e8a628319fc126305e8697e49a734fbaa7cb2b52235ca98bf6ea7454b6098e045ece4a8cb8bbef7cdeec8c163d08a8f494387fb5caa677567d5e43e56c17aefdd32e5d35da643255ff5118ee6188e0a3eb2b6eaaba00fd8e0394c3c29d51dcec0f425f7c9652e4cad87afca74c8757f02d86a9cbf04f84edf49e6618b7eef24e7bd90b7461bbd3f364a63390aaad5e5f752dbac72c09ea5b07c367cd222530534ecf9ed17a366df5408712f425f5706e71f4471fb3679f4476441f7f6674ec0ec1e5dbc3106e7329183397e27d2194c8fd6195213549bd79c7ad91b7e5dff7989236d9fc61bb85ee5af9953096d08b9fddf2af35715674de1bbb7bb32f290b1723e7af2ffb90d9c3a59181c47ebfeb7f878db7aa2d2e7d24640626272490ff75905d7b2ba75539b0498ee5558019dbe5d66c78c433f70e5a4fa2552a34dfaced31cc94f037544586dffed30a9f9e26e6ca9c2b733de4705d711bb83329e7585a476643248c67490f36b534f609c1c2cdef467bd0d1eb2890274ac7b00b41de56a5723829e29e846b634600dec43548b3cb1f17316417d189d82b8af0da57a3282935bc6bd52a76e8ca2145c121cdb653c71cb1c39b506a8ba76d340ed7c84a97d45118f83dfff9ada47a857635cdbfdbb0c002a2fff66f916e60fbc42a01f360d71ed812dd228e777f7e0a4898193672877895f97091ff129addfdc82a0ce36d9030de5486ed6b4a1604501ac3405951051b2cb3a945d08a41f82f61d79ce069425bc8c6dbbc672f967b678e114ba1e451aa86ef5f5b8ed1d056a84afbcd85a1d9d8c0ebb9fa37ab8c5fed0fa345503caab9080a476fd677904c189fe43ff14c7afca1d1c5ae5c9fe4211f75daaaadde0c2fa2db92c3333eb1913ae69d358c4eea260827e38e534459c7604f9219f5d210a8d1439805a5956d9ecdbd1ace5070085b67d8692f6b60ae1e2de35975c31e47c98733de40c2d02766653c0f3e2dafe2d36c257ba42668c015e284b4f53daaaad075e2451504779586f9e26a3649d6b95a73e499a18002d54429257d33fd8182b9cccee87f13336d400ce99beb8dee8cc255ad88b3662915b595cfb2be380f471af00d754760833b466c4ae51132a5c9a758060c2429994999c190d16d7feb1af4a7e1826a0c90b0af72bbb5ace3eaef2736ea70b41d7ffee8f74b018243285c1a7f151afd0bea68791457684b7ab2a4d4866d60366165bb4f2f5c3948f2f5b0dbea7d62137a35cff458ef94e59da931fa2541525e2814d57198beeee4ab77e0ebba8931f6c4706cc0ab978d50c7c5e64d1295f2f83287867325391f035d74a979f3fbcfeaed73469eab993fa3438cd78e859bca4c221bed68e4547e7d67a7c3d79546c3d44868f2b367d0f2c624d195e955e91981ad81e8d6a7a72e11b0b04b5c6d0f4cf596312399ba0567090282dda732ca1a310da9ee5b8471454a3f0792de2b3599cdee39629bd209f71661174208b92adf26d9a5b2873e33b3e1d2821f4e59a849721ba9d305a39f3ae74d019c77c432e707e73b2118cdc93e4bf16d7b89718980d1d46580fc4a7973e0f5ddffea407c06d70d060a23363313fd31c54e130e4364b7aa3550d75faa4331d3e01a82e4b8cdc28e7331e3af5229a6918afe9455544efa6baf15e43992e26d24794ba2e9dd7678a2a26402bd3684bc40a145a6594bd2cbe74618c8d8b6a0f84905ebe18d04188ee241c7dd085a178f91565a66ae65da8d4f8d3f37b2c0ab474164f7902545e56f091f0f2a99ebd70c01e415ceca7a7ddee17fba945cf798b6e395ec8f279f6c786a5d3938e5f51cbf4fdb48aa6ebad6b4ed69b3193679bb3350c6b55adf5d55f9809decc759d5739b3d70464671690b72a576ceb5cfe6189ca078ce2ecdeaefb3def2e4fa4adbee7e00d0c21fdd147443e4bd1740f7df1d9d88073bcb66d2b4a1b54d1d00ed9f4ad0e2d12bb917b15d728d7af634659b3f8e5cefc97fe912803a251d941d36e2cc63013b36bc41e6792c61e5d15c1567946bd311c42f1293d5320cebac0ea3d84ef96f933656c690d4bafa00e23e4b33c08043267d7938bdc8edd8f98284ccba47e3a2d9af54ac4b902f4bd0a384466d88094a568da4684171115ce73c706821c3ca63a953689a41d99f239a86477015f4266e0f3ae3185b4d0c4797c7a96558cd35ffaa1b2dd30a862bc418c3c76f7206919e81291e95003c70d750a4fefaaeb96f3a02cb6ec9e50c9cb85f4ca17b28eaa446c0534f04c988b2073b26b0aaa2cbc7aba5871c8c8d72f59cd0ccea51b4743ba5462a9aff7836e20661b2aaa37af599a331047ba2cb97709874bf98a681101bcef356bb2ddc4a13def688af534ccb3228896f106f4811196379e98fe6591600b1d23e6d4f7c42337ca002bd31f8116006034a606427502174adb67f82f42318ed4903d45288c78d33c417f00a0a42c925c7f4137217de77d4d066c3948ba670b54a9e5a3baac5afef3c7a4c4e9c505b148d83cf50e820a39870c7fdd9167089d9478f985e66a7340e68b0438ca3dae69f9b0242c3bca0183bfa05ee97fbcdb8d7befb6110b0a98c95daaa17217aefb59612638a0be508dbeedf2fad28800aa3f8b8d6543036c3fc999cd494b735fe25b9892b925832afbd86eae970a74ecdc24dfa58913bc20f2e75bfa5f707edb3f463b1ed9e5359771837ca8ee2e28f64703f104b05981128d78240c62193785954354689c2422ccbaf551c7d7896537fb54a89c5435cb7af060a2c3893464e8beb971224e61f8ebb369a133bb4ab040b339b0a1e7dcb10d189e8692c4d533cc73d97cee19f9aca3a4e134f8ac006ef1ac821d73f728fe02673e76d21ef93fa1c26b6b2cbdb6e86648f8f26ef019d17af116244c48754257b7da389521efdb207ee792e17e9a069a40f36df6d623d77b8b435c6bf810358f432b3cd3dfb27bdb44a10f934226962a8f1cb0dc2908352ef72310d72e7e2fa95ebb5183b12304fc63d9688743364e356f3af9d3cfa04d1c7d859a74eca21a9e54b52b3cb5e0a8ca1ee4a3cc17174082ef32505a9cd6d76f94582a1fce4ddef07de227ff4a0131c4391291654576d6164fb5beb598a6c0da9d2d0f420e1f7fac9de39cf6d061a4b01b1af3573f97e0b87cb4a37311a5b8b1909845aa89f4e99a4cfee286e5152dbeafa3d5b23c9876cffed1cced22b4638595ff430998aa9f4e492505c2f58d129f8f8d6f5f7fc62a573f025dd418fd9df8a958a786556e1a19b1fcc0cad079e5b9c0fc9e38d2a3f42700171183cbafb2df4ce4a5f751fbe0c6cd2258ea33317407e3d5457d00f8457753ccf1592812157a065ce3198fe0090bc5c2d8573bfa2df222555825bf4d771f15d025f35a2c5d49d0bb13c15b82a05adaf8232c3ec5480ca9cd980317ec1fd8181afa5856624834b127b94713598f59595b121f1b3806665c705a4d606c666f9840a6158e3594e1b2ae52e22dde9b7c5dc245affb636505b22c53a7986f627b4743a5ca4dd0e4aa8c49a0ccfb894d4ad9dc5040ef222dafd4237422a69808ccc4bad9317d4dc5cfa78e9a6456051ca24e92d0135abdd9acfe7e3b2c6a0e197c492341a7e08f082e863cc7f8eca0f877cd9e9993981beebfb8911f2f281aad884f2fd0b3d606db5c3c02c2dac52e00ff9a0b73c2b1a85996d0fccd65d260aab5b607b3a1470719b769d54b38052bc73a2e9385a2cbdcdc66e13da73f90880711169d38d7d6cace0238a2b629f864748f331d05c403c35fadc956680cbba042a8ca051d2ebafdd414e3fad9d5c8190c0cfe35c2ae88860ddf7fb3caf6197c36e228f7c452adf1d98ff399011e98a931e3d313010b2febe6b890ef633c2f0938ea33c27bb5ef9f32271a97eb287ea1aaed34af8a91c9066b15b250812f762a30776d15d49bb40ac7a20db32858dbae27c6602e2fc6eb43c59817308bbd05b31217b35d631650c2f79de036e4d0c8681189e4465465addb6a990f043d7f8f7c059185dbad408ec91e421bcef2a68f458a154d9e4e1f0847344e98e7043758650bb2d1bcc2424e2092da279ace9f9e41e8ffd4020d405e0964d6984d340d5251e3f804142a533c09a75b80f1edeafad543e36650c4d85b40618460e0ac9cf229e1e10ee50fa28fa9562b0a8079636865750e4272adb84e86244388f4d6404cdd39cb1a27e980e1d8262feb330f2e5f746584aad89e48a90b7bd428a9fde78110679a696feb53ce1323f99beb74aa6dcbec78e88d0d51d7dfde4bf3cc7a9fc67fb705a7b964556e60f5eb8542e92cb687d14d3082dadd2b2a64f319cad86bc02223e40f472003b52ba9394e8885e3580504c3804feff21aa03c97bdeef275cebd3ffca53e9ce1b818424927c297443b8f796fef23705994e7e0fa28af5b8b9ebaf76b647682bb0c15298fc1e73c6f9dc568969e107c0ff9d7c43828e2bbe518a70b3be9d2cb0415a2900165afbfbc960f3280a50ed99326334c39ee06ba2968e19f75d8983e43058fff7dd4080bb62b1d8f4dbf2382e9fd453a8cc2411b3bfb0f67fc7c1ff88eb0cfb3dfb350885d4004770997a7849bdb98d03b06dc8c532da017a6eda90026fd65979635ea94fb4f2474519c638ccdc866a342fa817365f61e88957446b7e17a27de924064c50bbaed47a6119edee9258c05318084de244d9d7794112fbbbd23f68d9280c0f0c8a60dfffa5b30d870684bdd7d2bcfa38084c4ea4adf4304aec073f746b896894bff5d4f3f1e88a6900f81a4c17c40aa047d54bcc04bb46b063679a6b45f3c99a9502e5505b146ecdd01cf683f0d6d59e69b32d9e6f7574d2d7f21012298c004a18e7bced2e5aa0bb8988c76dd30e0433b0203c0f50a8317aeee4abe767a26b950d669c275f7c8b342476750136b321c88ee3359550cab1038e426e7de76285f5d947ad8d9e6b6d6f66ee3c1a7da2c61d355fbae67ed12631a3561c4cf4e9f1347c9c5883d33f0def71cd99b2824161f035096fda151580f016adf84f2f99bee6dc6c720ca91f82afc02f8e21cbc9593f7351eaeb614879d7f86d0d8d9e9b41987e33503c6bb9b0b27eae531a9b3824dc13f3f21cd22636adfa4439094048b87fb79b68871b36d4a5908ed3d380edfc65ae7bb7e3b113d36de30a7c40b2d04935511eecc4abee00db6e7d44918279420c3a0f499de973b2cf2eae6303c2d2364f1a52adb2ffeb0d38e00c8564488da2078cac4d44f87e5a2f0d50d2b68880f6788844611cbb1752a24d4f96536823efc9c717aded15b1074d5c5f912ad64d6aa1c608893be4012f1d979085c2d54f900d30fa688dc9ca27540f7d2e2f37d80b5f168cb5e6f191d08db61b939e2bb3d6212d94ab488070347e1bf877aa65c61b78bc29766b3250f9a77745a903ae97157218cfb0097f2a12e7077579ee3e4f76c9f2556cb40f1ed150a31cc669d8565ca1217ee36bae0b8e55f2e72b5daee081ab9bbde48263e2acce65133fb816f3b754d9c1d61ce7185efe61250842947487e8b2428da9a42650c74e5d25197095df18f6de2ceae511af039f22422382c1bc896d825d0539d3e215a10f23fdffc197545e3c3d9adf009e76067c52231b6b91a8dac3dea71cbed2b69cca66ce1ad82384fedc7ae499a1601d5cdae94e7ef4f445341afcdfeb071c6bfa54551eb419e93acc48535bc6aa64e277ebc7b3d4761723ca4ad2dc4861868d59271c43533e30d0293117543f714f034b4cf0837748e917931f1641b222caf41b9741dc02e2337c9e51b6a1abeb33f4df781cfdeda4d15f0f4bdaceb06ac00531d7ee25b94cf88494d7ea904af3d80add84d18635f314cef8f8a346e39224527c33c28cad7d6a92bd54db7f52f979c864310c2dbcb860ce9228611a9bfdeca772db65129a6e897afb1b90a88c357b76f986401c37ae4eacfad8fbc1baadb34a4fd0dfd19d6cedca9c1bcb02a59413cc611fa7127ad0aab09721218c3d6d251ebf8aeac46df63855043c4b7ec1d39d243303e681db0e1495d9a77e5d57adc22e913b523231d4823ab2c29250e1684a10d73cccfd33f04ec390d324fbff4f6ad794e9f9679c6e95259f94cdf3dced1c0c9de740defbbd01c5e7beda485b1cba90b78422fcd3978177a2b76125fb8b69c92f2271832a15a360f325b17049fa53e2ca134cb84fdca7e713d47e0f4f10661313c37daf0c0ef5dcf93c775ab65a454048bd1739a6d548b83f0cc763e3cd48cc0c92bb02134398098c755acd52206bb034378d8c7084779c57682b90131af22f300b78ab2bc81ae2b43d5319e7146eabd725ea2d819f20d5cc14d5a99ffdc7d280d7222df752cb2b84d60f28d4fa2be8949ce6a317a042753363cf6873e5f3b02638d64c45b4b805ee45bf93e55e5d0012180542faf3a8d757e4df8ac96a28795964e93def1b1710c279e27a005822dd0fe416297e23d7842b5ce8e5f0fcf642a03c8ef018a7a4802f8643dbad9c055b5941b547ee78f1f34e242681edfa9446fd561a7750618833998dfaf67823f22b98d8c0933deef2c2f6446ace32a8b239c78b309abc7e3a8865fe3852b386890ac6772faeb663a5fc851121946dc9194f7b09939fbf0a67bddf6741f2da5e02d1933cd915b3b080f6fbfa8737978fdf02c5d55ac9c6a8dba77c3e8c2ce169887be8c48c8c316211d195875b4d1fd1d41e40b042e0f177e670bf44359aa80fda0f2cf0ab0accf60dd97ad996edd4a088c912c8d22f9b8469f9ba384216cf95f7d30f8ae97a58a791a6c08095a39ba9d9d2b98f98e769ab303ed753943cb8cbe988c3cdc4bcb3158b2bfdee2c1a617f6c0288eec786a71f57d7db308e3ac84539f6af325f0839a6888b959514039d9e092035fa11efde5ae31d43fe94717666dda50aa1c8f6479811538c5cc3d2fcc8e5408ac3ef2268008a9922860eb8db0dd6e5802fd4713662cc6372c66ebd9e4d4805e1e2ebf28f11b7a9eb06bc157826b680b7114386572c128c7ea28e6943b447a5f498b5f1ba0146c5cb93ff0069275c16f25df9fa1020471271cc8f35e84ba79b47e0d16957109f08ca1010e3875d2ee78e167698e1e5ed05a7e4c7803ee6d962d8dafb18e8ce8c54768615c2f315c87376521a7d005fa2caa5d65b9a496cfcdbdd3a988142189c60576f2421294613a755a095ebe6f494ab58c54c50530788c999af59c381e724f7d4668a7741b0c8fa41d150951a074b61103baedd794b09bdec2ecefde4ca83ff21de9a84fad9ee7afe6e0149175ff70191743ecf79b1e942f478bf33f07e556cd85397a4b5d354c6ddb44c212684509cbdd7fd892b392bc66693df0e35ae9eefba8e5594a79221dbdbbfb507da7d198010be0114ff4745fa409a16a0386458d4a3836b0e89c302e97403e1c8bd4c8aec8f1342d558e2820380958c55305fd7e90d6881f5de8b914978b254ee18ee44ccab079a34a86304c076c35ae1f15d986dfcafe32e08535dd8de145733f3d80af40ccb770f4899f54cfb26faf2cf7ae96180c321a474beec0b8dcd8cf0000275b82de2c0a02ed33a3228775a21ec4190cf17088a3d44616e9f4c7b96cd448235ef590852590ac6eb24c4895f31cf070c1a37e0e52d976c69e0f125365c78cffbf1333e71ef7811c856fbd577ce00bfc49672eefcfa906ff8658bc4c449c1c2781e964430bb5ffb5db3d7e9022c5d8cbd75097e7f16c7f5d3746f33b6619f769417ed85cb5b6b49e22bb35d9c444f36b8089f9c6f71cd647a7b8bfc2bfad86654a52c19dc9b4e2248e5b5e8bc310c835cb000088fa87d97896876f66a1c24e5693c2b751948de516da1de31d940d6b67f433a327057734015e8eb08ce705e79698d5f3a761ac0651c565d25186aea53dabf95d4fa90b8c259ab6787df0a131e0d19999d7259f232e87c9682881ad8aec9dc0a777c74061dece4dab1d52501034446c4fd32bcfd5a3c1741f1f1eecc2ee5cce29efcd9f79714216ac10a8bc99c05180d3e86819b645f24913a5291c9551995d5eeb07d76b611a65f4eb334c179f41159e5c064724b3b87d2553ad44544a62be3f338888bea6bcbf13d155cfe79e6ecf5beadcf2f9ad7068188e796d8df981184fe5c1b0df95fc710215fbbd014eb72b8b2bca4dbe69ab59b125e1768edb6ac3c1586b907bb85ea351182a065335ca0a0ce34d41ebcc76a5a6a893aa9fb1488251bb65d8e276769a015aa91d0ee6af92a2a6af87048064ab4dc1f37adcb6d6819481fe87fd40de337ae019513c4f6a4b1374847e037e45fb7f5e1f314572755c1f6e73b01bac03baa2d3d542b81ec9aff550d1a3cfb2f0237f1b57dba3e46453052ff95234125238652a0b73f2d1b09a80e417b26f418716b951ef02938a9586d56abe824f55e8aa0ebbca0e57f3fa87ed15fd8aaacd07c1e60649832c25fd0f334048c24e0cbc0092c40a92e4c1fa675466e8c2259b2e358e73c7cd9d7df73f710dc87b18ecc112c861be63ab0483cad8596b3c742d965454a1fa7bdb56728e92efecb07fb3330dd7d325a3c20c677e771a7d0818d668ff69fee45640fdb4f83acdea642b7101417789fae1fc1d9a0c596152613589bced374c2c37564c8efcb764837b94a2759740c00df439c5532dc4485c51e08e8d462753127ce0085c9fc915e21ed9125de49abbeb190ed9cf2f706af176bae13d41f02e8f770a0c6aea5d240b3c31b5dacccc9281a7f5943679085262dd234c406de277736aeffbb6ef2dd54eedc5159d083f2c6bfa2735c9c92cc6b91019ea4779dd63a960b5ed05616f77df6220f545d7ccec7550e8a27f43ea01637d1f427f1d2a18f6c004270cc8d8cf6954d017c8bdb0e35777eae3fb6b9f058eeee9dd082a00c9538affe23c785debff1b0b5e240fb42aaeb5b3c40c20206116ad240ceb65082fd45c3bf54a41093ac4e2396cf91080ca50b25801d13a3e250b5f009c036cd2da75cc75aa02c2fbd8837aa91aebebc0e8d35554f6e62afa09ae3f33a7a2aabfc6efbaf9ec20d1a42497ff5d6cbdeabc3d915513a9f3340c2ebb57d289ecf7716787af8aff926fd0c58810b9b79c31b8a458726fa0547f208b6fab4f40e957ba4f9a8fe4d277ec2878b1261826b04078b10f7e9718412a71f33176b52b3635a4fb59276815fcca3ed3f357f4557a500c31cd17ffceba6430c691d14341856bc75b5a24dc0b562af4528d6f6f2f4a68198e709ad517df5e84c0daa04afeb63bf5df817b470ea7907b847dc1c2a4b2ad9cfc9e0cb48b474f73d3047f8642036fb702f8dccf5a7c37415bd54f7e32ff58596ad9650cdbac14cad344705e78d247b7ad0211dbbc1676ea659ad8710689db2b176b6c7cbdb316d27ec3944117f168d653fc839e2464a9ce7db2b35bb6ddd376caa1e827c98c8e612ee60709d799e47ef1cf8e40b61b8afc96cea5e72189c339414a57f993599ed85914621cf1073706083373ea49e1c053d3618f4cabc1785fcbcc3adea94184b9c6d77d9b2a2579982503da293d6bc61573f7bd7001f23bb154dcea53ce222fad6cd83cceee21a16c2bfe28d026d6eaef7e9fda95b35af3af4bb3228edf96db3e949dcd9379ceeca3fd3cf1ad931184803161101d19775f1f1873781f069740516d81845befbd2a86d7019f8c70a544da329fe0c0af9a30e889db54ac04714e2c9abb9f3828e2eb9e133e8d0afbb0d5c831bced21e00cb7a840031d126ed247762c382e78e115e0215baa82f28dd7650bf6962c5dc55e6b160d2f31415804d6c0f4801894060f827a47591eee2656d18c8baf2854b6b76f132926a4326cb7ab11b6a87f7e81fc2255b322be107e0661ef180a280fc37f59845ed1a","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
