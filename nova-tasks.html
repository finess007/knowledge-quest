<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"50fc5bba5641442b63456e012f7770e57b46e40aac34424e39d0eabadb3e8c070d8fd09afbc03fcfeb3f8d683c25655e716bd88c2e2b2a387d099690e7be5ac6a1f1f992cd91f525393deb3578c2811076ea257a12aaade1069d22d7921c9dad5e52a18f76091ffb5965f4c9ed0cc1b1730226cd6dbd15ea347a23e5ea3436f4aa704ced2951c64310a7461f18f27f2bf7cd51251edea63ef401b7eb2433d67bda071784093b417d94d7d3e17dd0a295962e4a049a4c26582a5378fe14cfc269c37fecf3a37f6515d17a7518e3190e33a343cf4668bdf28c7e4e64e16e3a061a038740bb5fcef7a76daee9019978b75b7010d85b49dff4c445dbaa8f8ad9241d92ce41d2d6c587f5a12606160a1d45d7aaef5b81d9791a9a5f0f10af2e0a27e38ec797e3963858a0c4e4c6f3b66f1576d1b6400eda9676b8f9b3dab12ce2fce42c54a95a296b294a2d9996a9410caea80368425d82b87fc8f1ffbbc0c3dafdfe18134a168e101dec2722a271f0dd16f47b53ec472913848924b9f8c838bf4dfdc1c9ac8c7c11141e4f8d0bfb55a37f7ff7180dd609fb06fd070628cfd4bba1f0e61189ea189a3a1ffd0a9f01ae87c7f406c3a679b7a67cb1f73e068b0b34e5145b1bb350d3ca7f3c306b288af30495d18d15da2a3ddf0c27d4b018215c4935ffd9c8e74444d085bc2818717f66870fc42e65dc24520df845de3e2fd1f1f9459578580b39a643cab0f5488e75851cff9ddffd0b90c0a3b916ddff5f0427fd7218abbf884f28091591e285d0062bab0bab184a3de441b74e2a1ad91fac941a0ab6e7b8813dbf6ecce86d62476d3f4e7e70a91776c7ac41e70bca93eed3c2eec9ce3be467ef6fb47d4fccf7923393679f38cc0778224d34d46c31b8d9d6076fbaa66458951fd1f7840bcbe07217e90010f3971424f775359e595425f16fe4fcdf0872024f903c64b2ff1802c832b903ee2ddba6852677598713dc1d181d760bc04c3d09afa4c43a1803b065d43daa45b8262895dcbc7c091040220d8ed83b8e77c05fea4622db24128fde7303aea0c4268e385cedeb435dd3e1f6f54ecb404ae19db8d657cce4e005a4252f6962e0bf526646f342bf49de45d87d563755947af494fb92041b8141888d3caf960f7667779804246fa0b538fb1f57596b5a2faa33aa886be7258831c8edd5e90d2a6af9f30fc906e712b4d740c9ba326a5d94a0207125d349719b9587acbea65d947bbff5897b2d8ea68d76922df082606c36b681985bbd6e9c9e59eea14eaf0a4300345d46e1654fac653dfcbab8ec5cdef2d327499fb38f08771825b7f5d59f266f69636a4d1a9a4f9c4812fb726ae09bcf368fe0dd8cb2a976026789c784162306688d895dbbdd111bdab1769f6ea9241ff2e570242a025d0ab2d8f8b3180ded89ea9da0dcc7279d5fce56c8231a9cf9b2db6ffdf9a137fff161d380357e74047637c3b49f71c8680ab00c4a54c62eae1612941c06b05ee662f967a280698053de2f178f74ce96d7759d6292a20a5d3e9f651537465dd37e6cf58723231523b901835b9dab93361af1c4dbe31a286525d7ef318031cb2fced841ed21d0632f62bc8d2d085ecdd79d13fcb787195052152b07d464466efbed43e70b669efe7b664cf22e712a7feae559a9fc668d4f26db7c9ee00f6779521dae4fc907933ab5a300ff6d8ea76a94fefd7bcc6136f091d26c47fc81fd8a4c7396db3489d782bfd238c30c7d8f6910c66801f16da4461884eac6c0604853f9f586907899c8e64a57418f54d25f558848ea1c0e1e7368022ffa2249b29374c0cc6d3cabb6e2813e64393d1bf20aea9d3ad76e07d885e09315a5c15e7aad9f838a2fb4b25acc435d0ae40c453f9cd0e380f1fb5ad48b494546c4d652250c0c05020f14a90db3fbe40e79868b73502be304d777033f2f3a7b5d51b266f7f1505e49c69fc2d479ca24975939afe6e6aaec4022973bf52b7ba2b82d7d650369e5c3939ce0a27b33481dbb741d4b2de3c395e85fe78a96ba4efa8e1f12ef922a25dd600d8b6d1473ec853ce0f5f170a4ec47e7fcaca668187b1eac2e3861abfe966bc416a64ccba49af5de630dcb27415e21cbe0e3baaac7ec24a8b27044cb7864b8263f3529a3f951cc4dba0ed15c7aeeb4e1e137c758161d5cabc182a14e2ddd272870743770e9fb715c75251ec19c53cf0a9ecd882052f7abe454b857621d278827dd176dcff8a90bfbd6644fc4cb2126b4f75fba979eaa8cce34268e878eb3383aea55bd769841b36c487d6575c8202c3cccdb458a29bfb8a5475c4c54be52f2fc2dfe0e31bcb4974013831fa5d00e74ee63d27f6eef88c20ccbdd9a3213ab16f1a497fec90516efade4c5963553e433df7e3c496f1ff73d04d4f42900533c93779b5b0b049e4b2f0c47eb3337556e43adb713708cb089892c3ae6a2f45b95f3c7aee01e02c6fe4f7346aa8b55a2a739bd15191a64b5d0cad48547be58d4712d3fd84b456e83770da1ea29a97150c8adda54805677e7bd483c5efd22ce925a08adcb42e160aaf544a0fd49d910c1e241c5a216b0adc29420372333ba80270009f4312bebfd15e1786481ad2dd81edb73684961e9e5f1b59c0bf7dbbcce20718945d00b4a509e21dd297e4beaac1a230b9614957549356c59650efc0f555a3707b0dee06f8d0f5c6523428a36b50ade87c7995293663fead6ca4062f200f430dfb235334103614d280a75d22455ec09e4216a7db2b794ecc3f15ceedd0b7fd8d2ce798758a68195afe95ae7204bf1fcc1015bf9c8a79c03ec8811c2b807920f219907817ba23bd65e0b83cd98e53d7bfe236b1418eb76a0754587af512cb3deb8c77f6493ba9613c4cac9bfd242aa8bf4b553b520404dae912322e42925a9926049b1f3d9e231bf7a0fb718119dcfb42227d877acf1c2baa56758675bcee873cecaf310782bb5d1b23733ad6e9d806366bd691118dbc8d2076a9a52934c253ee8ef01c95a4edca0c09a5b9d208d3147a8b3a330627a8003b36ba2bb9676a75ee89231eb93bc752357312a7dde1c4bc79d78ae465473b39fda4deab10e18fea26567f6e7a27d90d6ba6201c165d4febf44275db00dcedb8bff013c299bab82fe95baf546457dc457183918cbc4ac5763fd69f201f9c2c2333d127506f8d29c24657f16a9f99275c3f1b04ce80839bdc44949b5cda090cc1580bc7edd65666a4528f36753d106d0d63767faa7f0b3c371434de5b115feaf745b504dd5c5f5e0af9ee544bb38e2ee42a058c38253a2ecb04e37408d81e20ae7caa72b424bbd01604ef5b2f284e64014077141ee15f9bcff1bbf03c6ccdd0352aa8bb4fc6e8b9808c35770b623c10ff529d2cc60d841e339c7cfcbcb411bcbd7932662296831f31ad9ae181fecb8274a31ade780303f40d12d080f03a56b0513ab0690cfc6746c3c24cc831426a9af580d6754e6b842835c1f71e2d669e71376e0648ba903e491d219fe1af01bb24a1ba92f8531099cf85f5e558f28a8e21b7e11841ae303077c103f699de8229633abaa38a827b81b63c90ed7d4452e6754f772c081b3fd8b349c5532bee5d38b4cac1a26905c3d0cda64f3edf8fd2e03603ca8fca70a9d4b324e7bbf1bb49d806d151018029ec0a3bd7de57b10df9442c2b7e83b469da72c1911568259d67e5f23cd7a17e25c10494977629c18ea65ceac2e91e726ecc081aafd85936f9faf86e3643a3af82818e7a6f0b5decc235b641dd8c3749b28387b38ce87a78af5533efe548f4aaf61c1bc56ae75f6de0208a2b396b60c98f3043ca62b6a70097dea38095714fbac32f4a8960bb3fb93b0f51aaeb1def15991af45a27a7622f4d86de9a22908f932e0871b5a9616186fa0c26abece2d7759d7067d6437459cad3dd1c5a4ff51912ab0d99b47a11a22e7405be3920ca342a774dd68372daac3358c5eb8ec7b3578183c3bad8bc1626bdd23df862108b856112e7fdba5c545da8b9e4a16eac6268697b817eeb34aebd82f5ef07bbb64e6312ddbf542035670255f1af609e1434ebedc92db6dad9639a75e406a5f12df28993876b0ce29d58272af25fe54dc233033961ddc1863a138ffd1eef35d7a85e749411121b9d91be94ae76d5acebbfd04b2617d4b18bea3267a4ef69828c0a89d0d391282241e2ab241f9f5c1e85d7cb576fe8935b2f041587333b60b539e611789cf1de7d67e5775392a7ff5ca2f18251f6a9ab5225038f046c0ced268028399153aba92f7456e0434cc4935f8c5ea9502f868b5581e4c6e31e1464bb1ecf0aa54e0b9217925b08d4a56b57a4324dae9afd61800ea73a002fc69b53954e5e88ce86057df0802d69e077fa3bc558921008b37b0f8ff6cba6a3948ecdaa66a0225f249f9a4d1617cd3012f42af334e68d3b61c063b0da850bd24e6a2921fa03c7bbe363908298612cb6040ae33f56f1d8c99ba10f73b6beb48015808f817726a31b3b818ff4672ff2d790312478e2c15a0256f0061d6e8631fbdc0e74df8f23b543b2c760181480e6e88a1db1d7d80b500f758d99c0cdade1b999af97fdd6d24b3bdf6edec6b5e71703338550328bf56a1346ee7efdabd52a60cbf3ea7b721ebc612c34cd6f1a8562301b2c53b2a1956e2a49b5b5f564d4e6445270ece9b418db79bc375c5c99440c91f0f27a29e4a83d1a6b29cdd17e8f02454fa686c8bcd97f8d9777b5d8f69a0f68be51adfcbef2eea7a6c65e67acecca47c2d1c75f955b83ca87fc191ebb5afe61076ea1068901eba45fe2a3709b06ad3e15aa4cd7bb320a074fe96b7a8e084853891dbba731c92936e5e60ce1ab224e2ef972ff88ed54d028ba698f60f333f51306e29a482860c05fb307149be4f66bd08dcee2ed7100ff1639f355b132afd9defb0cdb1ce8bd7f8d7c8e5d3e8b5899cc26afeba3bafb6cbba86418d189538ba98f71bfbea8bd3eaf9ce3e8fc431e3747c7116cb20407fcf27e713266010299b6c0dab804af5b12a000c4cf411e86ea03e93604733372e559cddecaeb6ad14f32c98a022ec8c4cd0e748553f1b3bc65fffee7afe63aa6fd5cbf0fdb9aef098bf2a761a3bf84e735c81effa4258c9c5faf9075257cdbf0fd96d06f99f201752909795bd9f25253f2c6820cf4e099b1511cf6bca349b1f38169b07be6712fa2851492de3fa00ec146ba753fd3a2780ebc35fbdf1c309b6f858d476469935fb277aad1e7b3343fbdfc2018e5c13c3b36bca1c0874fc2428ec5f04a5f221eab3a452e90390d3b2e5c4424ab609f061918c28558164321476c077b43994a63f966aed69eb3249f964246c79394d54a5bc524fd18249af1dcab75b57c8abf63da0a5ac2d7c98e19cfb786cb9ad0f413bc093a7079ca9ff18aaabee1902f3fdf4efd4e2594485ac9d9539eca0ab7069217b1947d7d7a27c3b364fd4a422777e30f01f997eb0214923e147602dffcbc0f44e57320eb19f55218bf95876219e35f4633d965569df855362f29de9be7c8da31d9b2a09af36ef8fceaa61caae007a70a8b52bff766ecb4aa8c7b0e66496700f842049ba299a9cc2db14be69b0a787d103b943121fb2db7c91c6bea1d9323b67934c909a807705748b786f4794d6db702ce3de009b2336ced5c76cb5261f651443e69834b33b1577b82b4d43b39e4f090a0827f42c37b417d9b9fa489e84cb8c6b38ea6670a50eb17cdfd3aac09a6c7bd7513679c3acba43a6e85b1114446c40d7f3ad107a49cf85f0f2027d76289c600cadef2b7442d69d4f117578c5168d60e063d322d2330e18ff9c06695bc639c6644deef9fb98476d687076977b513fecbe8e5b3eb1fe61f2f2f8eb9c2901e87f62c95eedbca73895ec766385dd8c259ce9f0d81ade1d55b9e0a8eeca53f062c59a6a796b5f0a802ae1cbcaaf9319b452332b3f819bade8396dd21ce41e52c087e2d252b7fa04dcecadcfaaabac9793a2aff967a28cd0ace6e4701eedb8880faf7ef6cacba65f27e255eb0c0c6cff9958617d23a0669a7694f9fa87a58b43c904c8b13e4abbceb08be60a89be5d8893b803aa3a164a84741f53a295d6187d88e54b5f9cd432c933fed9514e0b7daa081d8f3c23cd964c5a4580c13af5d74b39d44795550a7e80973195a6a8699f28b5ff68b30717669d828dbbb28f76effbe1d54fac11361b8652dd7c07a7e5d7f467346eb484234e2570d162619adb46220117ab13afd73fad8bd2aa3d8c122a14a0818489b232bc33c43af81a103bcba9d2b7e2ba1e4386ecf66a7ecd696d3a5af8d149f11b093ee8afaa36025f5065a39476c3d88b42876c7f88f56554354202afbd5e1bbc494bcb28706e54d100865f2502f70ee64ed10166bb1b89e6ce2bcc342af8bcc612be38f45652c7201778c4b1cb41dcc7cfad638f518b38e1e9809e435921906093c170eab767eb6d3fbaf5e214c26eb07c7d8ad5b2d0d528757bfbf799c23c1519e43a6921d55cff728f474643f61f7ce8bb08c73ef3044d7bc5675b6b9bc2f19be13b7f06f80794740a162ab0fda2d1db714357e88afb3108f1c039d3ecfda78c05bd6db41ca04b253141f322fcdd5e77b87ee9d365e194a3efd321231ed19bcfa44eb5f0eace8fd3436b6d77d273fdb9a194fc6bff84d8c4f321bcf06df718b1cf980b2911af58e07e12ed3405beaadfb6a12cf5afa550174e60cfbd6ec323183adcf3dc9d96b629c1dc26d72244cb720dfb582e717cb3bc7e3ec4c9c109feacf1e671ce6f893192485936f29e939d777ee1482d34784352f9abc3f2b283290d339ceb1711ccd6956cb753974f6504324bfaa4a60c03efebc6a927d2c88671e6d0c92bcb13ab319c2b43cc52e272a119e868cfb34bda491ba346393f26fdab41d5a3562456ed2a0243ef5eb2dc54603db611c1e39c334b32a38538c91698a04e270a3671cb2ff9b0e5f2c943abf4787728ea62f41e0b73603c45040ac6c5d4500308f5132387f38cc814466d0480d236ba0b1339c7be65d4e10d470b7cfae17f81b69272175b929a9d8d9c972d88cb30134df0c360949ce0dc15fb75d8bd89ee09192ca82315e13611b9701cd33056c645f77f8d1b1278e0fdbf9a05a1856993e2c04d5b6a198417c4df8148c48ec3567569080946c7446f67f9f8118470dd75ac0bd5115f8c846f29c2a1481f5cc9540cc726a6367202ef5dbaf01a34b45f4eae6b976abdcca5b5726270375c94c4981d5f547b732e46130df4b7dcd7bf7db9275d30fedccde1297688ad5fab57435565a126afa254cf1c372b2c29a52c79f66d751961bd61ae414e46b8b07537484fabe0368c02a53d06fd32d2f3a1301dad7a68592e2a3a866cec3641208bcfed2fb6759b9dd69e58da1d0405e6b1fdf2d1539bb25b73b0baa4df18df7ea8b51b64578492b7eb8df1157161d4c356dffb6727bf9b7a7e381df10836c1d46bd2e2c2d8a10f1e24253444a9c75a747681165c0a40ff59c6552be96f0321580f30b5361dea4090266432cbf7aa0273431f9cd0073ee956a1040e55e6353d6eceadb56b084ab725b842784ab09690ea2573a8467296e7dce13b562390a7ba0b442c049bebb74750dc69d50ce4a96651a594f7e4f67a5898150951c86c97a1735a7ed7652b058453c2fbf251112e3488a235b6b0a344b4adc53d84a85ee4efe1e7eac8062a6f54f648ce7ab4448758cc7e0a3f9560083b64ddf48f073ac7a66bade74f332f578664f2b481dcb711430b24582f921d7522deeb80e901dd167482c9ac3bd3247586dca333ce5dadfebcb1dd1e521f4b8bab14982d41fe44e15373b9fceb931392ba258254020a2d5505d2db10d79295b91b68ee70628634418ef1088f5b06aa5404d2dac15c5c2d8e85c048fbbf352abd569729724af48061beaecb673ab7ae524aaa822a6e9e065173592abae808df85a688add0f1bd8723d31091f52c43072a16f3f86d513bd424d47d66c79f6b04e0056ccf3bf231aab04188d35054f1f1bc9dde2ea36c04c4926a0788c0c7a54c09c892a4ac8f1d791dadceaa71c248abae0cdc957e15cd8f8f8bec85eb4b01b866123b44f7ffcf1efa826816e4bea2931b0480f0ce54d4f8f508fa703eb2fb1bb4e94b5afd166e62443bc2fdea7d2ceb105aed988046d90970b82751a1641ad097680da78cb6fe92660ad27152fa3ee3ae55ced8ad7b714749100d0b8297b394642f613307cfafcb20a938f4e54cd1b84c2d4d70d35c56fb57b6ea5b5e8f3798cfe92360785aaf3525efa7b3906ca8a8ce9711a5565d32f92c0073a6a54fa3f759c578b06b40acb1dddf9c98874ff69bbcb1393d85b96ef613660439ea5055811f1dc1bdc404c28c1d811c328b4b8da10c57aae591346d90ee4db2fd11adf242c29bfa20047a909430ea0e4d51fff8651cf7ec1e9fa0ecb0d5448b83ea7df384ca791cd93a83ceb7e2dd9f63d22bba55257427e5e9c8fdff40824dbb9b2e638b6f25210268b4fbc42dc2622f705f231a31d509befeebee906653cc0ee2b94446d946e7d7bbf5263d02960deb1795dc44800d9f4a5ce6ca34c4ef8ca5842f60192fb5480748ec769c2fe9963dbaf2a355583ebe930ed213ab593648623d8c03e160e69016e23d8f3675ba028539fb61168980b5583c15a07979561483427f18fb707a8a4f80660140c3772aa51ff499f70ed2cd0f72cf187b2078501127cc81679f81acd2833829f6ee80f863d794276a37d59271d2711ae2c35ada8ed575d818d15622be60b8740474c763cff53a13365611acfad4b256d780bc22490a8d2e9f579bf6baf2f629a77d4e71f29a8e669560be0a6308962d23b9f54d9c7a497e10158adec573505ef9ae5780bda2ca7347cbd6ac5642e1b37fb68e87e18f91cf407c7b334a3a39987169df763dfabad1f1d413b385c657072c4761278826a0a31e15394ace935f89a7b368867a1859031cb98c73c45eab3e1e1300d738c66b5bf469f435c9fe1a5b6f46e954a8911bea8e52b3d7b503defe837f1b992d8c42765cc1ea1ce6426e838f13a4b0cb537253865a9222fd3739109f3eb98fce86a19a8e41451be71f2329ae076ec4e6e1870bdf403363ed4a35a84ebc7e0216e3b85bb0928120d664d4390810a69b93c819cb577e98d1baf1f356f401baeb39d0c1b4e8e9fd281d27472246d97d663050c6fb45e973313b7332b1aa9fbe7102c0e61282402e9b7c4263faaac36aba7412404c7abe14a1a62d330627232b8b5e4eb7e9b3f48d694517fca9c114ee42f0ccecfe3657d13ad9f3dc96dd3763eeda9eb331bd4ae7141cb3f011fdce14701d09cac4fef83ea937ec0142c3f945bc9b7f09f99a13016985b3ae0ef20fda0cb8e9f3d872c332f25f73adeeda4abed552cb278fe8d6648a34113fd5cf6e63e46c7ee5ccd010e575d624716d004840c4aaf07b35af4068960f2ab8e92d11a418c0b6a8866086386f6edc04bfb2a56ff08f98013a0e9b4a37575a55a5af93318b1cd81a23eb1770b306b27349168aeeff9750d3297f37dbbc5b620edafadb3fbadb2567fa28d492d87b6240d3ccae4fb7e6e62b65dee4c00bfad00d0df4c7e905488e2c159191e7229ed4635ea33c0c827dc897b281cc1a0e23609a9b2f956885a5cf70605080adabb81a9e1901c4fd0367157c0d3645b3a584f19cf75dc99f386d66a5dd7855337d37403d9a87533d3f54cf33814f332e8d9bd83d42085699bc8f2ef23b78f33c39f26a2c58c5e7de3cf463e54daf7ace7d4c0a3585519c5d49c7da99ee78c9d7aec7778fa5912a1b756f28477bbb150544b3d19b63d149709525dfe0f36a7e62edb1bf300772ff0219150d6bc16e2847d7769398c9f6c9512528ca648c6a05b1a7903eb495054034086490319aee27ee43b4c7f1ce110e936bbcc05767f93852c2aa2c8c12b6bf85f3710cb7c08aa11b51ffa406d0669e3387a00bb8410c3c369d53506b004af1ef6e5751fc35f8649f9968a416d90cde45fcd7314e1e14902ef150053319e232e7de70beb96c75e85fa8e1343d6b693e3dacf59fb54605c0d332fe0e94f713d9474ac5b3883b105be1c1c6273a5238ac97b7d147c010e331d7bd2c0250b420a5e173dbefb49b245f3a80943cc90d75fef6985c5517a7537428baebe5def49b1a6adb05bf7c926b23186d398a8681c0a128b4f0e7f396ea1676d3e6b22db0919e0458abd6bf904ba1ae1c4015c7d78553cce31ea3824d4465b236655a14a6dc60d89ee7b98b02efd2fa4092372743cf0d2031e3943f9ead0d0c38321889742df05fe826e4a12b5cd991438c4b8ac2fd0623456119024be88ce9d97917c8ccbbc9599ae6df99bcd71cc515abdf9c0110e5a5931dbcc66be74b9fc82f6160d47eb913d1614c48e59a974e718fe574001761a4abfa5af5ca503fa754fb5d3c7fc061fd2767f2f8b77c566007c9a938c83d85268c582925c32e1433fcd0c99824dbe7172a50e0213500e325e4861e78a8a49611a23b302ceb3ba525f68e500f44ea132c88c539f6cf96adf8ab83f6a9c428de3fb60d47f87ff00e599c0ae21ab1b1f8961e120fa5604b9fa8ecd3921c03431fa30b4adbae77dc3c1b44d07b0936e4039e6ce16504cdf783c8c137c0aa3e4169495866c7c2fcf4697fcf364209aea621a3df65d7b7a99bce074cb97618f9c2e679577bf9f738b8dc5d2e2e5da3548baed9e7aa8b5b1ce5720f0ecf2c69b265773aa0b59b99eef3ce8976ab1ee959ee06d17f5096865883ce769f11919dd1742c5c67e2b822669864b713b0df323ecaae5128fea738b175cdb980692e092ef424767738c7f4b9968a8ca84fc3f927965ed92fcb62355e091badd0636482364e10bf2d53afa3b8feebbb4aeb230265a99f3ca96b591734ce33bf16bedaf5d3f5da7903924fae44f4d5068757571b3d2e1de6b7678e91e53025356d2fec2983d2a71e36b9f7656464ad61e61c58a07dd4e08fa189d0d53e58284c25b8cadae2042c0b195a7306f4b5f6afbbe9a2e85c3101da7802d5613a898cb1cdac2d324cb44d643eebc336f183d291ae48ff051e4722427cf3d93888e81cf2d8d2368218e222c4ec3007b0dca73deea0e274acc57ed0dbf7fc1d3b0995ad51b61c09df46f4ebb5556c7f0bc34d104f00010d6741fe97d9d4bb898940068fbdd0319ab809e04df77caa6d1b6cd6ef89a50f7ce12bb3232e7d81e1e789b41d5229dbf3be793f0712ee3648d8df54f8320a1790e4ceaaf16bd78dd28bd3dc306f7a78ba2a6a77dea24361afed16180f19f6a4a298c8039c0645ff3d410e3abc5c4de324e861f178da3459d240e434d03d338bfc85c4e531378d71f13f4a25953232193ef6427c3c851404e13765873635308b1d83111b17259c38bb07990bc11d86f50fddb9b8161a4edfd3fba45426a76f16c594edbcb787601c18841fada47d7d72200940276bfeae506c02b885ae7ca8107a3f1454d1d339e12b92ca89078f422011fb8ff6f8c58e047891326599a02f85a8f4a83a0bc24485fd1c7ac5f30e5d45efa10b9a5a81f906e91abcfd016efc97ab289c56c53acd6a43418614ac16a295e917361ac510a8df49e3e3d0bafd52f366d79ec9388fffcccc70453f0140d8d1d1aed6e6e225982ec78249ca770dc4c99eeb575f42a8f203662519272e453299e094f5a62c5e0c7ab2d69f84e4203210cdec6ef1256668d7a77fc7155763982d8c74f00b474a94fef3ecc4e0160fd797216701f8d075077171f321b36c433d57d904454708543cd2b93fa66d60a00931285c7eb6b256820f212e11a8e5b87747672fc6cedf1a5b1dc90af76f07268af3ce25c7cc36db8b0f8f25251e84f1050677f59382529af42df5a8c67c3fbee795807f1442e0c5facd43b6eb682eb3a43f048273197727d052f3311f8d4498bd8a181380a039c083e96836ab21442408ff270af8815a9796eb276f058cb9124476c29d61a16da4223b7cb2c489b04df015d4b5dfa5059d07a1b44e664069a10ba202452cebff27be7418e740e14e6b97c5c2983a0b0ba2665633ca7c3b3b5b21fee1636b97fcb6eeb554c20031183aeb956a7661c485fdd7332e3fb287b78bc85bbc721b87eecafd812744f19eb91926bcdeb2203efa66c9c884930b50445990ba28e2713656ddfc52766cb95c195a7edffe217cfd51262ab23563c67f0862d2c8fcab0c60716c03f565584d34ef02bcc0e19c45d366d5ac71ec8b44eee97cab82cb8795c8df2a3acb889ba73a08bd284207bfdbd826898fa1528ea093d18b0a0e242e69555a75ca63e0b13230eafc095e5b81d1e8b504335f45249716f62cb80443e1837433da576bcb5c5cb8ab6cc5f3151c921f5195f33e203f27de2a6dcc54f44313b2a850b283cbadad9e6f35715b740fc81cd21a61ab33b681e75ee605d4c070a4fe7148704464bfa4b72680579e24720eb5a774fc2e0f14d6d5e0d0f2ee7e3c6bd05683edff10a276d21c233a5b6548c5a4ecef6101ecf2139151a362e2c8bb078cff0fcf81eda11c268e992be71939e0e5230c30dc3087451d142504ca63651e4fabc58c0dca31d187f8b74959efbf602e6a05677f65862114f7b21096b960a91dcc2eff619967f8fda96782221aac9f0271e0a734daf45499d65e7d84bd69c12aa0c3156a67fe4f076fa763d47bc6783452e193869fbb2b17a6de2f889fa46a9b205afb23c8c624004499695bbe1c203c5d80ae51e13c69f1f74774bb6f59fbad1e3ccd4987bf6e8f2cca5e86b96bb91a22eaf6ce8f68e55dfec363c9d5fcca4b0d0c43314efaf4b7d2afdea74a39f7abc667280e27e66c0d6977ae53547fb77cedef1e0961a996ec52abda45ea463ce8ddf9199d38b6cc555e709f3c3c9c8810e34f4ab1c76526fd879c5000b503b0ab04ecdec436b1129e8cb256c98b606de17a7800dce28a8120c3cfd6747e8c74a04304d6487ac62b72575d44200d6dbe3e816a0f8365e0a6045a12bbf173cc3fd4c17f57c3d6d49b58b335f40827c5ab93271b69f8de024db299720f4254cd83c21330ba4988795201fba5d39acdb1f1738e4184a305dbab948137cdf78717d2587994894217bd9d9c3b4908dab22736ea4ddd5b963ec2cb58b561850c569864d010bef665c3441c3dab484e60ae49834dc979a86f223274491ee8c206bb3d25bc286e038907bf7aa7d95a834ad6bf6ebe72c1dc461710fa4a45bc33ae12c75a0cd9ee51569c758c0855119d992c5ec6902dccbcda3f056413d5ffe3393eb142006e8847815ae5c86488f824bf996976289c382d5ddde6edcde1824c2080d205e5da7c062bf650868a5de1ae75788370266ff393ac0ebe37497b617a90d521c7ee31c6f406e5fb1464ae1ac8ae70d1b958fa99feb681334d8a2c98213c2ce4baa49c37b060994bb1d5cad8cf335b9e14c493f669950eb671d28485f542a0be8578fe5774677a0b22873383a7926d7b1930d90ad7d00448f7518653200a704e27f541858ddb9950b9a61547aba884d336a76cbebb0fd74fb541ba215be6ff112c44dc75eb35a1c2a23c3fb2c1713e55c9dd6f083f0659cb1572bf3b697e0dd366b4e6c332899b9fcc322537c48446961df22a21e5e51137ae4a09f2345a688da8c258c11ad3060585e15b0cb58c104284b14007bfc4e421b75c7931cd14781008d05db9ccd16abfca2c63c329ed3247e50a7b1f5da831ef1abff5ed4184376518f0cd5d8325c6d113771f403894db19ed8c3daf2d272e9a071fa5b4cb073afcff3326fc565664922ed9b60b44893998dca049761c935202cf4ee86e5d66bb78db3eba8d5649dd606d3b836bf47db67ee2a17bf20467330645f56652338cf1cf907109f88e4c6a5bdcc8cfdbd3f67c23150ed23dd6e2aed1de9198a917b2a4f83eafd1ce02532ec6bb866ef6c0dfaec9429f117fdc3131cad15c3cc64fbc8b0a14ce6fcca21ca512845c058f986b72117d6b857a71ed189ab725b18c895b1963dc8109b3cd2ad7b5033a830e83c5667dfe02d34781e68d4e95fdaa00f0f955ecbcdebb21a248eb1a0204122a68cd354e7df232f4793b26ffc5afc6e2db52554d953f3aff25d67f8438c2bf087999d1810ab59ddbb4b783df588510c107f305b6bbae87ddf072adaafe297bab2c2dc456cb86eb5def8908570d050a89f7474c99a8ff6c2538653d64f625f11cf0ab88175cee56a08d","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
