<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"506576e9d10cef0385cdbe926c4705df0c60b7624bbc410fa6c6958d53a50b503f2ee4f9c96c0dc0d1e0e3bbb0004a2ceab39f220fee3646ff7bd4706379daa270d6d5f7b2513195da2de8508fd927dde46211660e14be783afe932da753e13ddedf49e2bbea290362e62d7dfbf1c2b6b2893a0ebf6515916cbbd7eae55e693efbbcc8ad3b46242426899f17a56460346bb7931235512990d267e90d04befa265080b7bf93841eb0eb47a6ebffde58ee250c62e48c610bcfd8232963a4439c7552f8f7414ec0fc6f35b53c2b9b656924de25f74897fa363215cbaf53b73b8967a4354ed9606ab69bd119205835912dcdde92c998c19e894ecd684d15b76ab54b251a975d868b3bfb5fac598d5e836389a4c0a835a084965bc50c9cc52dcb2f8bbba13ac96e082dd384a4dd4dc6a56f80161709c7c130de94c6ade342ee664506852c53074bf526ab802d284313efa25c8c850f4fa542e75cd4a804ad989ce7096de3fd3a5a62a8784c90717e52c236a3d098c4f0157842e000a70ef429ff367dfbfef2c37b655bec6f574daf1e98682e8f9cb9568046ec3ddd5d9ed68e18dd1e29ac2f6bcababa608cd18f80721907b14c5a8bf9446654b428d704a9235814047e3f53336563392ad87411cf802f054bf132187b7fdcae1b07436920849a16486ee2ca27aa638b1841fa24ad33abd6f43a089afdac7f68e55f5cfe1fd30d0ca34e1c3d84a25db1981b9baeb78576c6fedf61af7b3fd44494f624bf5c333ae35b4cbf4d502c096a2b3e1e8a3b575ab4c7243338692689c3fd7e218c871865921608b4e88af3636da43db8373b0277468cd9d2447d1b9313c99f22dc85557da2b20ba581c4e728709d6dde27a7616b609efdb3118eb3fd3fabebfe52cef8c992f58b452c68f16d17e7d95cd03ad65698d6e5aa9895b1654d46ba0b321b2fb10482c65f63c2d5e3c3272549230a64c80dc020fbdbe7a2d4f4aaf776abee4b7ac6db2ab0b622fe1ff6904acfb53f140ee9649240a6e1ebf9f72766598322b8cf1f0c813663f17bbbb551bd30f8363863fc31898971e44f9399dda5c5fe904216c9d33b8509749c179d5eacafc5b81886ddb13910275af44e74db8e5eabacc2c9581c0abf7efa8457b33ffbf4c04494296235309abe4be21afaf8d5573b326aa6ff8e553d0a452f910f697bf4bfc147d910720016a61a6ddd105b591d472ad37cbd7c154d166e6caa010bdd6772e414af8d0690d391f6b1eeb738c3ce4b26df5298fe800519773877104f110ed44948ce304550d537fb755744cfbd8afd7e68ecafc5462f184902db5aa08ed2044ddfe8cacc27fde66310fb2a148611af63e328d8f213d2c5c94fd0ae08e17a984089f3f2cc4fd9b96e590630ef0d2d48b6c974c227db645b385a64652f9c24d44561f09a534251fd35ed173d4d5c7b5321705329444331395e31f0545a2f7989bdec713dd9bb37ce273dafdb9224407a404d454450dcdee14a8576be540824814a94a4f6546a3b603ca382bcf94982a0124c69fdd0a16fa39da595651fcae0eaa5d16f2e24c931f729259b077bb13d16fde5318c3c28c3b0dd4f5c1ced8f738bc28df4592856154a181013f2937a11e1e8db2d2176329f2287cd2b908ff63c57686009b0d4eb37e1a177bc985429482bb5f59705453077035bea3261bdf7edeb03959cfaba0568b3868756800a42c7b2a4673a99341c16c002009c360b3a795b1f9472d23b3e4f5ec0c204eb8c1301dad4e73b25b0f7b1d86bcbd15a0e0de4fbb1591e23ce8cf4699826cb2890aa142c8052c5616478bb1f2c7be68f2337f72b8b709ec300164996b6ed319e97163aeb94dfe090be4f5077e8060ccbc8550a485b57542033bc288e80e5f88c249bf6e5e479e22e13b048d08a2085d5be694fb74b2d11b4836c44c1d59ef1cabbd8cfa0e1705e9f361ec134d23bf0e20b4209ba3d9770f7b0a145ca082c8a53b472131b0175cbe142a5c309f020758ea402a61abbb5fecaecf1a633ad67b26519b5fe4a9b92909d62a96e08c8f95c263f7d31226c8cdb4bf56b2206476cad78b89cfdf2139d6eb6311cfba26886255c2d96a0759b5fc56e49cf1ff6df4a8b2f3943b255506fa59a7c415e5fba25a72442cb630dce21ce8194396b017fe2269dc6a6efc5c6fde48f922944c92b0a0208d69901e13366c1578d2c39d07b24a474269e89aa1ad66b5a0aaa1694d68c42812f8b126015f32582329a9a6d02f8bdb3723b1e9083a6ab2ae25d29a93f227e60fd53005c2c985a6d82cd40d68eba7a9c188987a2f6047fa9f6210b530f39a2e6f5170b042e0a1f0ab06492cb90383b9ddaa89266f9b22dbb7d4dab74a9ca6e78852182f1b0bb7bc95367d40f19d1d56d161b440db18c961339a625fea6eaf7a7bcf1a0d5a3ad0b0439908024946cb32f9482c688f3214c4f6695857b580d691167d50a78306ab75045d0f9e2110ece863b86668a8f3257ffd7b5266b90149eed7d1add00c26fcdcc9502e99609c9d0194cb2e8976621511adc4292dcb82e9162224e3348e23fd032346ef9f9a5a0fe3d83e8efb79c5d50ab2b783691996ce49deae71ea34af78857e0c7978248457b61952500bbaee6eb163e44c116d459936466d731326b60b6454e5dd45895a790e68b0718ba4e07625a1ee06f88d1ddf631854a2ab69e379f9bce6554572498f323798daf9be3036a8cfb2cbe643f8d8742da452f2875b78ad07adf1c6b4c28c22df9c34b05e4a6569ed5905730e3762324ae9d86a2b0f361da4bd22916f1eda1d949076ed2e230ed5aea29b2f5728831f6d87f922baca3e77921b110e98df9fae4dc96f25e0fbfa8e5aeed4217e5ca099b8f3cf3cf1a9b344a76737bdca42a60dfe3341cc1407c48da85b3f3b64b82be6f85a58727b08873948a6256f57e214b924b396995e4045dfdb03592501eb94febb16082b82f92d3609c052643efb9f6f83438db77c83604b68888ad0b3f8f1152ad05766ae8dc452c6f323061fe8a00b4fa44cf1f187c5dafb0890fbb021ba9b1d12a20ff6a19064b18856072dc7109df1036177aa9884d1e4703de6692d38858ce53561e83ed9cf4fa260fb746f089f583c3a5245858971fe0e82a78732d7f470cbe953615fe2be79b7193601e670b53b5ee167cd516cf52e9e8f54d265e2d53d9a559986f4569172f0463c868f5b2f67fd01a0762606b1c0cfed7254b3caed14eb929e1d2d8974bf8dde2a118817974d274747a82fa7afc28d6c6033565619fa70aa491b9c57217e1d02b78c28efede1b676742beb2ebc5c321d7ff60731df226623770bc6d925a69ab08067ef496f471564292490cc6ebe90f9de4bf3e1330dec051181171977c6eb7542aa6658f11b85f56a5d1c3cb615688c113f7dd0c03984f96cfd835d6a7f8920ba30046a25de009a3613b04d78327ce238fbc904db7f509f72f5c6a1a6d1fed171f3e94e5a0b7f1f7ef1add84d2ca46a7f92c23f4da933cab989ae43fbd4661943c5a69c492fc13411eb4792f0f078f435a365be1c72065b0410c32d5f55911cc065b6a1ce0af61a7ab9eb0ca3a147aa230110c752eecf0e19570a56c3dfcfe39db28ce8e4c36a3d8f74ac4b7433480473a4c704263a4fc798501c26b01ee66a8fe9543f32e864ef40c292b336644c379ef8b4a43d017513eb96b78abfb940936b0ff8839486ae9db49f2e5188edb5275497ea1f690eba9a27145ab60f147ff7ed341e2f64c95c76cd442328885c5a5d238c4bd221cfa166a1a8e19b8b45cd04c3e2ecf975bf8e8639c46643827e63960c6d5cc1e94866e655e95240d144fbe0c6aceaa3b85ddb7c9bb0b6d9ba81dc1a6c5c5f699203b39b42e03e0d9a3bcc0e0a3f6645f0c0144a2d2989d1b98785459bc43a474b3a8ffb604fb1c46c9f3a5f76e6677c0f5fad07a17d272a40374d415a04c17a0a227625d7ee3d4370db4ce7a90a21f27c6de8e16d886c4c4aed7372c0c8de8267ef6bc2ce482e460733d97da324ff7105da4d9e34b3ee60a5c82352e98d36af90e7c7f84661a52abedb1a566606a2d1f8200e87d7240a3252f9d9192001dcc8df0361279700794f4e80e326f13362707664f1eb3d6dcda4fb77e52292f75f46fe912514cc1c6c81ed1f9ee44385252e118ab024341ac7a1a427d32b865ff9df4fe9d99e9ae388f130c1a6b3f277c18b6ee0f39c4e51d1a2085921a5d9b582be5de592b9de5d33b9b095a729168c15b58a42974fdac57c11f388039afda8eaba6f1952cd956fbd0616f3168ff1880f167bed72740c906aabaa4418bb9b5cd9a6152f57711b870753c9fbe9d48fad41934e7807b6e9acf65e6f0393f5436c87616b54ec39d34d0385ce62183e73563a4b6c6faa7484da2bd2d1c2288f795530b682ca8351587168a9c42932ba9dacde7f07b72e7d9ef95946e4e26915c96db37cd608bb3267ba1d66f0bea38ae11e4e64b8feedab200458d13bcbe42526dc3ea4231aa3059ce8efd1a94840058bdb5aab7f0dd4c0936511f9d2ba6d417845adba966885bc8e3be5f3257968b6d1fcdf7a983ad4471a5c4989ec3b4cf7df460e38ec4b6feaa1577b172887eb10fa66b3862fbd94c6c238ffd9c644a5e2dc0540025ba65e0f73e7da5cbad88aab7d1a6b74e0cad09a9b3b258367a8dcdb760048ab1426068b7ca793ea9a8a261a0774d61a9bf8146e69c9f11dc357cc7b73c7d2e596b8b0de4848e24fde66db1e148ce0b8184454bad24d70fd6ba5f8091120a369721cc7622cfa8576e22679dc1cbf29a29f185576b88707232ee31c718d06846e634f36c84ff1f75d66a0c6c7315708968a851397a86063d076bd9640ff45d4fba5af3deeecdca6eea7994b7467ae77a5b3a330265f846a36e5d84d56566d676371f0a258bc7455079a0a04febe4303209d64ae85e634324bc0985cbd9af7a9557859f902d05025ad604c1829108418ccb6c930f1d62e5ced0b71faf938cf61fa97b006275e2821d622822f1a978b64c3a6d93c1890cd1121b5fcf8e759b10474ebb7172ef2999c12b75ab93edf6ac7eab5ca521256de2ae390e498f5a11492cdd138ad31c4f0d5e12b6c2ea74e835ce804439d10eeee7ba66f67dc0c4b8e9362ff710868e26ab2052290f0d2711c19637ba0a93907370f85c96c5dc9ecf54e103a108a6cd5e6ef5ec0a4d70d097366d9a6c2a22a522331800000f731c529763ea8909bf3e6f5d8de4ccdfd875c1ad9a29ebec881e8662e498939c9d3d8c3b671281adabd5a3ccbf46c7bcc8b3e60f37caf710fbddac4fbfe5369abb85bf978a0c01ec8ec69593331ec3616b59ebdae10bb500fc8a7a15c23b233d696579039db198cbc08b7819758df70ea6d66e026a55f55b804a90fb4e24cc7a9042f97c46d8f8904e8455decea407e6e38ee88a72c696407fce29cd55b724f5335cf2956501633ca40cf07536087163e786a67f906abb8fbcecad368cda591c498580c886536b9dfb6a38a855decfa17e0e5f0f2917e6041fd0e2ed0b55572f90ad0276f8b75b58470605df022d6c5567c7eeec51d89f47686058b79953be2953a18b30980bf519eef155e76ba9bd2274c5f022cb32f4eb51cd266842fb65b54d8b0315ecffbcd7388116dba717f83ab377e7be5057c616dd8713e5e55df4678e8c659a5a826147d512b904511335430610e8b479e76890e79509b2fe768caa055c7e6fdb9bed6f3037b663eebcd0e35eb4c98f546a79d78c79d2e445718b9db62f8db895ea304d4313d473a3f260bd4045f12445906c35db1584e629b0250994aaec830beb205f2f6f4be152380287cb4e7885aedbb29742a143ea7bd162940ac8c044d5263d881d56714e9a78617e58f61ad4eb228ecaae992c1119decdf949005ec4761513611ded7c05cc78bcfa97a78da1e31d0610c2aaca24baad5d9238ef545a61775d940b29554f0d563819807cf990de36da03ef779cac7e247a7224ec6bf560ce9e1a515a22d96f05421adff7b991b071eb5b578e89f870b5cf34e6e5c4eabab95003c8406d41abb15a9ff1b73ae2a7406ca14163c7918e86eea4a474245eea08f9978204c735c88a614c810bbb71a956dc0a596613f648e73b4c50247660bab989fbc70ae8c9a79d832c47c761063f188d2234bd58917b0d6a37f36f04142feab7b5c8248fa10152ad5b961a1a69c76f3a3af94b3b99c313d2753718e5fd42615787ae3c22784302c3bd34bb6d3a7731ecab9ba993579721e06498c8169ad22c9bd2a625ee84cfcb1dc3f6306e41f442bd33ea57a3368b5c0d2248ec1ee76a7594df8180179ecd6d34dbe5462245992a57b18f8703f0103fde1148816ab0da80ec4b38dc493181baab39d071c0793e7f3c282f8754371b448fe5ad8190db49a462d5523bd7a58b78f2719078b844b407a5e15a40598db2e7d860cf1b8b5ef96c5e11f7be073ef3cb9472a518b11e6a49eb187a72895d3230806ed53f177f334006405fa48f5b074d3b565f1b447e7281c8762765f31a372e099a159aef957ff5840b45979123e67e7f808dd1cda61d53a7d4cfd01718d59efb4bda26d4d3c0615908208f3ef0d9e5c38cd41372be32f5fe368b86e0a95009ebcefd64963a5415e4441ab79d537bb072d9074b82b1bb0d42b48c8476030dd4e69d746b1537ae81e3ce7ef87d8406fe0da473e03ee03ac68689954a6f80cb13fa3ebf31aa03c69c83447daff38002db163e29939b961e97d25b00f66fdd6a778f66d408b09952551ad34346215edc037fdbdb89115dea6b56553fc4e99cede8592c234b4bc0be5225404eee3726fdf746aec42978c1a4cb9a8139dd677fb70839248f8fa08ad99ba21ea04d0279a1d124fb3523f0ff7409e5523766f3c927abba88df5b697b0a5f8c3133f232cc99e8c04c0d0f1bcbf19a18f5912748f51851bb95e0b81b79d468d75459ac04cc6f1bc2ee4c9bf982d3731ef8cee7308842a093f68461bc6ed283d788d282ebb12ff2f2689bd00ea799c3ca3aced21823cb27cc725f84d8e4bcb0775418faba612de75a52c689b3297a0a2294d4123263e4e6834fcdd01feca030ba689ddb59ea053323672255dbafd5038cb029856d3b875c38cbeae28a469c2871aef0a8b99e0ae95236df3a31cdf6b20a3d141a69c884f21b67ec867360ff6a5000e34263e02bf5222becbee299378d1e5fba2f44cfd89a8ae22dd8243ca7c6adffc794806d2379005b2ef012743c6991eae7a97adf32e1bb0c7ad3e40a2ece51bbec44f7ded8d3a3d7feab2112687cce06ca489a00c866dbe715dafbaa8c1a76545f269a82f83bd1257537c909602dbaa7249983f90e7309f5eca56c5e710e08ccb1ea4b5b5c10473678b7802f5d1fe08ff20acf2c5ec2b290d629206262c777085b6cb56d8191f5219c11eb86b78fec1ab5f92dbb97f4cbb3c356bbf3c43c9e27ef55b7a4a42593cf06299bf7031a09136241a48b61e914b029bfbfa7d3868307d48186fbe04e3b6d33c692fc0403f7628ffa63aaaea182b62f36fb34c2eea9a2f9e43f93008316835f9c95d539c706d81c29a53d6ddfc5965cf40160cc479e2e60d85c40f370ccd7bcd39771250aca0b08d97b39c97da16f5283cb07b8e15f7d722273ce27b304d3b5938d1cb48d57fac70ab443f918e87dc7d788dce758ee136313b69ae4bf113e569576f25f8580d710af255e6fba57d70d7af088821c3471de1448de11f3d6c14e8208dfa777801395fad8cff134baf44dc6196d07719e58556bebf8a3c44205d343b9ce1e09b72e7e3be5d8597e2f19f0327a30ba1b09f0c3014cd69293a8629cbb92735ea8e177c14f6302d0bb1ff818e11c2ac56336204f1cb541a2bf742f3542b74549119694e6b5748666641546c830845a6d59ab238278636b99f92044285b84ba6df1a47fdc940c17e63f8166a4fb8357d2fa32cba472ee8ddbfed57c3f452aea136fa1993bd3fe0d75dc9e785668e011a4faf8d754bae5895cf4ad3f7d3a6ebed28d24382aa9f97be2aa03797f70edaceb639469a40c52953f724266a53dadd7b987af8372d7a56e978ba855266fc0ee3190fa3e1415909cad0ccd433cb81f752eb7b902369f8fd63f74c70c53f85eebd8daee065c94050d750862888ab7a63af33609872ba4f41f190078d1f2d922b26d11e2ae9d7f1041912e725fcea68d4059f83ef4b7d2df6286c42c8fa85cdbfff92c00670c9b17a88a4156bdb4ed2d6a9324c448b2d1eb1583aa30dfd7f85b179c732d6261fd1c752fd3bab12998f114dca296a8cfc55b92f0beda538d671303ca4d1d3bcdfc0028c30887f62677c85c045e8d5f892bda13bbe9045dac87a6e84a09510fbd17acba774aec511a078d29c090b28ba3ab3454960f78473de41b314b240c1cab6a7b7d98a251a456dd19e757f923019ba054a5c13fcf359496de3b73b16765d99e08d709dd4c2ea4fef702d6da7a2406691c0db95472d87a0f5c03ab1c3c973de263fe5f3a84f1a7e7273907a85f496840b19755bd7e55887d9682bc34c59f8f7bdc20f43f41a3b0008e8f769be69915b9dd6ea00a7347df0934d6545c36dc37b29e9025643e1da0581d8239f9a0bdf046faf2236d20c4a46a855a08dd24e29e8d34375ddc6b5c837311a7303809bd2a30a569f1f645e1c858d261bb389dc8e6957ee6055c248f7884f6c47348e71388afdb9d7198f5c798636174da480ed171e65792ab32a3234238cdecea7e2cd8f8cae466aa647c446e9d0b38c61038912dd8124cd0334e80bcb693bd5c2cbae2f8f373c096e2cf0c32b3e65f69d239711ae21c45273fd84ef21a98cee78bd495146332f8a54da0c9ff89c3e8df78ecc31cdf5fd2e7fa97d2c44b06ec3bd5131075e4ea4a3ab31dd56aa171d73bfa4389d49ed46825ae2401e7f10a0085d882d9aedb4a329ca0b386efed4a458a70212574564add5d26eec7f12a9c79d33382f68d2490866e1aead219f893d055d95a7dedfc3292471b138e6f2931880c2b7fbfa55ce7b98d045e7d01bf8a87f36ddc876afcf81f4872a6cc7557266de7f7c41dd05db7f0328680b6a19538b826b67e32497f6d1c0ef6e94308d0296bf64d5d61ee5fc9c6f685e3c9bb859191470b2543fc74e4e75231ed343671b53d365f8f2787af7149cf75bf79c3219a8b2dbf6e1441decceeb0c21ed562931f8fc6c59d6dda050895746f72cc54e6f67dfadfdbb2b49c113aad26fc1992c7663aacd4cd2a7b6fd85bc2a0a324f871ec542cfd7446314e1bb66c9b66a1cae488c93b50838437075a306e10885cbe22851741b812c1ccca931dd2a26be72c338bc5fc52c7872d2cd80ca273d616230ec14480c11b8b5dce692c1246789f8f2d02eb0238ab790b9e760aabeecc7fa8f4def1e7c10dc38676d43f18186306f86a00709a43f6003d7c26475d5ae12fba25c331c251406d65ce7104f4562c44547a1e9f44a377bbfd7d0aeeebc2b0e29369fd8028803ac0f00daf7530b7615fcf0eb49770e77519a88baf5d3e7e31f56164ac5fef4d091e356e9c1375023b2d11b07bbe10d7b5c62aa60a527bd0d24b68a392602923036f63fa54220e800929aa19234d72c07e1b14c3078fe4d97fb3455abeb225d94a1ddf551691bb203e25d596d6029e7ef5b4cf2a49a6963f1042eb6149642d6c30747d13d29c50b8e98bf2b24055f1970e5b4d0eb4c3b93b8bd44fc63b7f3d271e0628541a2be520fc22fb50af96d9b81acb423bbdab7473affdc29a469e291134353b50d685e6f54546b20a89f5b29fff708564ed6ccb2c3a63793a936381810c4a117dc088f5ec2f4f99655240c7171ac79111a6dd434358fc859eb38e8f781a1d17a3c4ddf3ff4c2fe5b81417c66c68fd2136e0a39a5bc46cdac2a0f3a9482a3d1edce50d52baa0d65f3649eab8726da31c9450f65e1482424a69b46ef0c2794f0b538cc1f8643eee9acb9ae04cea75e318e73bfdcd72a71f408dded6cd8e038140c10639b7fa2ba5966e713c27dfcd86580ee53d6e6b04203be8ce155a9aa0f0070e59ce8c61632f5f1c4a1705f9eb6de492b4b3a6283b7d5b740441e3d66eb24b4545d2432e884b3fc9d8ddcfe93d728c3a99bba97231339a18e3ac32b969c6d438e267e9c5d5927de97aec39dde63d5f06f7599e5665c32c9c76f842bd2d280f3cbf1b3e9a1c86c8e26fac40aa91ed25db713502fb8ca70ac6d04ad7eda1d2012bbbc4dadd93b2b84047e8b9a51a05b8e0fbb2a87b453f1cda5b599776f553dc2683ee593b4089e3039371d8625bdc792a84e70a3eecd4b94001e85c1f7128e0855302f76e74d0f0ac6a8678b2aaa3883a15abd978ab8ebe4a10de5fd93cb01f5c9fb8998e7ace70a15576a6e2ac5dc4e133e4ef14647127e052fd1e849a831d2aba6b0c5d26ae1e1e7944fe1848fa926939380953d6fa4c480b55d593bcce5d8f982eb74feb6301172566b1b5a6e92b4491bf1a9ffbf72ae4c72f5fbd0eff0e7ff97be4db5fb699b14791ea4fbd2d8f7a904c0d1767684b28c12f79c558c3f71da8ff78bc836e40f400f6f300c0c3c24ebcef08da0c9fcdc79f1daf8888dda82daf7374bc8b1fe455865e7bad223c3071c96ecc642543601e0fedbd7e76f17fdff47018072f1ca89e9e869ddc115f4108497d346cc3171e061fe6f94e6c50219676589e75c7e68153fd58edfa0436974ca72309c367c1bdc06cb8f3bcb9a9a9aff9f1ea573139b7ee40da495233612a824111bd0a740388103ee8061c23dff1d668aac71e9dec6c334913c27ba1bace6f10b41c9a5f4327e2ddc6030531a6a63ed9603891244cab2b3d87fb7ed15724bfff69a69552e195ed93600e421bf3d593630d77967063861671b54257e97b3579ac415d88a7576a89e9dc9a778d89c342cd0f22afaa7a61bca6c5072fe27b5af9e65b2066d173c1f7cb8ba5e27663f18c62a9c0bd28d0bfdd7f332c3476cedd1c7a6022e88bda7a62620875206425ece2ffe28b5725c6246b77220981c255e6b81567e26b1fba4ab79eb9c2a79e12d7e7a03eb564dcc7e566f98be8f5f382d486d8fe095d19456cf358cd201725414f803189453d7cbf2e42328b9704708cb3fceaa628b30978dabbeece055395deb0e4cb2c856c3d3acce4e2d503b9228af4feebca3b6baa358bc01b25a071a00b938dba3bb7f4210cb273e8e517af32d5cf0d7d5f91b9c20cfefb2f9205cf76c9092de2e231d710fa810890f389c27c61de9ccad6a2df6af4f94a4e000bf239895b31dc8f57f39d5b8e9c0cb6429cde7268b819d51df10f921a5eda1c88292fbca20f3de249d9f36aa900a04f2acd6959bb9a75571e151446f9512aed6c7db71674113bd57c8cab3d2f065102e506aafa4f9dfbccd3512f835bac19f26bbb5a1ec8dc5482cb64fc7a2af4ece45e1a1f8cb9d343151873c098e5136623a8f9003b18509663ca59ba84be701bc7c7e4211ec88cce1c29591bad4d1302630dd96a65ca9918e5814eed5d2b67833ea5b4fd334aac1c94ddd14246ebd3798179af8c52bafe33b03597dabad7f02a80d732771cca01c849fd7ba341cc82c3467a6621cac6186ced3e7426225dde985556b0eb07d90f1f731066c272e1810a67c5fa1af9207034b5783f45c26b5cc5e3bbfcbc6cfb189111f860d1d547002ae6d3c9c1543c5a85abc162daed73a04f446de8fa707f532bdac93f3c8cd0c33517ca57f624e083a0170664f517404b7ab88d2362674f63129df473384f3def53c8b362a9a4baa2bcc603e6582d7580cc02c2a3b252f7bdc15515baeff3fa103d7d30eb342af93e9a91d29e87e6fb2fdfb496a5a9610d8d1c9e1eebd6f54ef5c8d9eecc2f3c3db53e1292f10d2b0e94d4604d65cf0ffc5e2e013ab4c93bdee46dda6fb5a83874c9f5b183e5031c5e33e2ae0af8b3303a371baed39a28fbf20efe23eb310fcfd20dcacd28f96f3e302bff69bc67ffdb3c933b9ff25f5bb3d5a537a26a6bc7000d116a567eae123d9e2c3d1fa2154955ad98dfe268fae43de38cefe160d17775cf8041c0a42333043416347f246651b59bbe64492a21511a514482cdd4d0fea229e59856aab60004259f619ad5f5ee059639bad2cc817ec44ebfbbe717c290d13c478421204fb2123b62c9eb62cddba3a2d6952cef86675516a0d169ead3a01bebecd252787f6d23bbe1ce85e9303ab65bb6504868f29f972e6d6a038968d16108a9610cbe0dc2886e5e0d0fbaf6c330052370790b32bb83cf475aaf3109aec59f6e227a74e64e6ea437c47ce448e17d3fd26f40d6adbeac9056a451d75a6a9341722cc1fc2d79d16164e4182a720c889275608b806938ee906f112431cb4844c22aec11b6dc67ffcfdeda84dad28a4a70ac239fd0c16176d191b1f1cd5159dd1e93391cf94f0cfa5d8643f7cf26ab1637b01be41ce2998a4c993d954d75fbf6645e33d7914891d7002e50a253eab4f8b7360f5d45e8b26f0adf3476826f31bcf8c0ed611a59cfd87e05486c015af74e66939c8f676e034fe09e08a363ee4dcd9369084d227160ef4c9a90dded67e6663d43c088660c1ba83bce0cc04fc7a7fcb3659837afc7003a3b77e762a4e838cdb4ccc13381ef6da430afe7efbf16d5e8f8cddfd84d24e0a317445dfd6430a1add22abb0a2f4355e8caa8bf8aa5fda36597e26870ef307e2307209b33954bd3a3c38b31dc7594b74ab5680617329bb8c2fd16721359075402d2625868989852a939a90822d23d9ab005bc732e0520b384d10687ba4f3da85323696fc96f281b5b0b42b54de309a48c3c185db0beb6e8acb7cac92603d3c651a52f6679fc4387a6dbe06ae2845162c0f06bf5bf70e995e6530cfb683dcad7c7e57df6c2762dc98fc05e5a32be819bd937f83643ab2183ba3b705d6d623d960c49813dd457ab566b56f31ebe5846d74e4cef27e892d2c4cbfe35b72c14b4c501ee7593023fe5a36951f41ff6be81388da6572837b01b05c9e655a608c4828250a93a2665a2f7bdff999802757e1bc5ca4025d4959a59c8ad2f6546f3243ad1b3a371c7b1f8da164288827997a56514836d9b6b5a65b7bf359d955cb2a447d426db9fc242ae43192635b97a3710ecbe80492bba72dd81addd7f681ad309229e3302c381c04806734cd258a946981f921b4abd606c40d6bf83f343bcc77396e7f6350b436203c44839e7c9716c7e9cc417cf1ea912ea1be8055441d5000c8a074000a54e8b1c4787fbf0b6936ce66276379bf43af212ace044b8392a6e9de01930a1019ecb8130364e64bca8b4bef95ecd0c67e54f337ceecd36a9db5fb6e8b1915efadd914481fb736c2302ad0c586adc22e3f08be5299057cb93257eba5ad358e8daee48df0b41f90ac169b02cbb127c050a9d743f6afd97b5c18d8ea840429ad8b1e929448a87f4b949a7e4622288abb3d55a6e6955954b904313fdd551305daed214515b584f0576819087053811fb2b26cbb761eeb4ee6494d35dc07bfb5db09b1af527a2735c1e0210bf3de3539a0278db25c9bebb00c7a9f3d8731fb9c95bd64381399b63a8bdaa6c10faf266d940deef4b8d1119f4b1b4543255b3a5d4159a57f814b5539c751e272eece4ca4e215dc84f191aab581e3312db67d34ca68a8e99c2cd3ce87c77aa8ca83f6d6771e47144f10365178553696f9355b2a96c15779b0c78e32baf88b484aa1a2b2d731b7b81e8f8f6a8d2107dc5e2a7d6e5971f972a141c5085ad9e4d7b993ca4362133c489938994184e17d982b97f42f13df76d6d49955a12d0c7c2854341d66d78694e81151010d3a37fb480321c64c6f4682f144ab474fa072f59cb9cd4e527d98d899321643cb3418079339388ab0f36e279c4bc9cb553d32ed73f2594737f86545dffc0dbad472c92f991873f5710baa2d1dd1d85dd7b69016a6428bb8ef72f30227bc390f01ab1bce6d91fdaf1139756a0d7bbfe09f52991f40b70192962c8ca6cfc5371d15be39352f7cb0ec92acb71d39d4b04253c9b0bbfff4992b59cc049be8a3ecb7eb21e204caf18c466fceb4dd6c9ebbd11b073236a92d0099a7c3ce22b11fca15ab798ff1bfa3a5198743bdc2e6551a1b1c94765f2e0fab14dd49eb741727187116f2ca262a6517499eb074824445050979d1104fcdc42b9637ec0474f00abc062e4c9f4b63ea9f9c68af2bff11ae26c993ea15abcb3d15a907194dc63f688683799cd3649856535e85da59715593e8462e8c29df3048ea0ac228632998c0c4f118e2ccc3773504b2430eeff4d7f848f9b0880f863f90e13709c7d8a535fdbc2e87db55554080073d24e44840bd044a65dd2c383b0d17ff9487a0a4f1b1afd5b55613244bbb0fe32711c1dbadbf0fe4e6417c867982955c5412195e3725a45be694c1ef262246bac2e1ce08331df957e24bb4b476d7b7d9879e9b7606e3a5ce61be7a9e4799954f94a071596249de32cb3cd3481002e26924e2cda","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
