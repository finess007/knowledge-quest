<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f71c0d3cebd8cd33d38c737cb73cfcb99e08473e4377f48af96de04341e5453aa9ec78010b304f6e4eb679518d9c88d01aeec871ef7bf03298b4387a15a8d33a812dbed8d09d0d2b4ddaa328c1b2ace611c6b20491304cdb7e4944a88cd20550c1cf2059065cc9613285c06967a549fa27cfce43e9932a67441df07b03329649e18f6ca8304f209da65b1fc203b3a2e87fd06f252b652423597a7861ccf76057a49b9e013dfa88910d4c45d118ab272fca4661bf725e66dc23846333ad716c639065c7ea71e5c60f9dfc08d969fdffd8faafda85f51dd7c0d0e0d0c4c5e324d1eb2e92b2fe39648c669967dd5c1545e36358a2c2413964e766750e33ebfe42390fd141331b10dd68253c1ce5d09f8a454f0b5824d3208c3d0f7c84e0c8de75ce62864b6ca2086f38057e4956b8916ad857ffd061ddf0fc6d37ed592726867326fe5ab6ce7cf1f8b0af1282dee3907b7aeb8ecb74cb33972f68cd8d2e044c294a608523531983735f216801e4574c220d37754a492f35abad757bfeb688ba1dca75302ca10b951ac40eab716002c8eb47395ca466144d257eb318a2c61ab24571d0011380b7d05ecde90338a9937b548c3592101042067838fd2072b4f8d61e711c958aac696c5289f1e5d6a8bd64401e3cb5e508a1dc255337cec8ea548107b19f451f8a6184138df4835d04d28ffd6ee5cf21ad612a7aeb6ee8c44d3236c6a0ccafbd86cd50a858d0583858f75a6917444528db32cb5fdd4592be5d6b3293f9e5df8c4bde6a94282d7ac819d5a79db68ba856c2f241c14ab9c7bc79e232e6bd4d61b968101ef7cfb6f7e99e080c987dc074796d747d8eed9ebc4c6b8865284a17e9bb12d2baefb3e622508f35003b36a3206620c86129323c6a6c930c0777ff2e724218181a68ae60ee3d87f6fecad2e53f5805a820dffbab888e440aaba07774388d8bed5322a2cc37ae0d3a695d358d1c27ac67439f73e0afb7a85e78de23886a11610317658629562b31650aec5325f76cef1857549d5cd8ab3c6d7da0363f64dbe93643a3259e369b78e3537d565073a727a2778c147cacf4a2f86032d7f604dd9caa2398a077bb34482f930310cfbe68ffaf8789017f98a861359511831b782c68c694bc11c377eb8ca12fa17d0b08620b1f207baa86cfadde719752ed25c56f1396f33404507f8946da9b5486f8ad673f2473a281e0231f8d41cd4ea30cde0ce04adde0fb533025938f9132a408620ecaa6dc085ac735014a65fe231f55e3b08c65e690d0b5ffb2f1bf9558b263a2c03e5160c87f1cda36cf7610caaf7a29db0ea4297e167180360528667f42bcacf63ac2778aaec9c33a591281d98b934e58a8bc1e5eabf6eaa29fc765dca426b374aad2ffd768f94c29c238ff3bab0ecabbe7bbd333907f695ac588178e1ed6283c267f4bdab6c2e48840351d0bf1fb168e0d196e8d259da7c0a9f5db5385b76922bed649a170f42972475e02ab8d44c20d321257e1a122e181a7a34c694d610e3d864928774ad807be3f8b4e06bbab09baad8fa1bc94ead66f40fdba032e6f83c116ef08910c92007cbccb610c250068446073146980a62631a6658139d79ecf7b9a94518724dc4c8550ceef4bc4c9aee852da0f2ebc3f8882538a21ebd486042dcf34d497895aa261339cd7b17bbb1deb7e52c021673e2b5f3fa83e62e66c764032899d4209d035ed30cb9ee40e603b3729aeca6d3e28359a228cd1cd03532f092ac7272ad2aed8ad875ca2803bd5cd2f6f808cd378250785e5019c2bc5f53397f1a6ec52670bd01b8411aaa860afda5ca521fb5670b300041a7f3b8e5e7df6952c7db890e779884f2a9146e4e28ca3eab4e264045898007969c87d5f9947f8e9fea5b715269e12ce4ed0a50465e572c1fa329e77ad2c9c0627e2c6924f1852ec2b66fec81fa2defa2e3dd39d7f15a440ccc781f023613736f6fd5a4eb5f62b3e3438bf8a77ac4e89492c30592959f266bdaf2a2397c8dff37246f93476003fbc84012c84d246b33c9cb872cb35df70b2d8a4795d8ae2a0255e98c7e02a057359cfd155747a45ea3fcab0ecbfd24500af01e3f23bab2c2a08ebf2676e14f0f8c6c5689a227bae8e740332437b8f724afb197f38c3a472a6e6291e2d28e2485f4db968eed866307f1a3b6319f00827e96fb87c3362e3c0b52e31e3ca21def4231377ecebff10c288633c5a72ad40798187380f1d6a1af928a6eb4be3b7ac2987382d5c2520613e17fa9ea91aa086a02c2f038882e6b941fc293fb84448afd2f0095b682e86895f86bbaf6a6523f6ebfa0044ea34cd4862d04668092cb5d09af318d99703708697f14d36c533b758e410b45c0f860fe4b0c241082c7e7cacb12698f8c25530dffa7b50b3fdee0655e33c1c5a6107c80a5ebd703808d6324f454b33c77670535433a6fe3afde30221287946e12d872007f9fdef7414fc4a3c9d9965ec5dcfda9bae3d6a14dccbe2df5d7a22e7eff2404ba97bd71241dc0df5da8adc9fe510fabfbacdaca8d15cd29bbbdd362b369d1df7e01512a62629c31b28e0bf0dd248710b8d3170ccbd5b93eb38e3a5cd956cd24873c0cb015eadf54732ab94705b8c9736bdd237206067b1fdc12f14ac97859b5c3e9f0270d45e70d87f93c8bfa89f3de9f8713ac09a6a329ffbddff6931ce1c2822d6c55cabdb836fbc968b0c8b282f67571604790b778b22ea5998adac93a159060f25ddeb0b4298503b46afdd18cc7d79171a1156a40e34b7215ee1df10a9f9fea322339a53b789fb84d80ae887f4bc1f66e6955314ebb5c02d749b2795f56fa2cae7f2da3fa5392b791ce8ea35639dba87ed11f4c4a56d96ccdc17644285df57701e5dbb59d4680ffc614f2974c88b371654b8385d0945757b41d1492450acc15c73f19d0ed0ce8042ada485c3e425682c1c054d343835c0844c16c37c487aa8369f64278746422a780e9c632639e6269eea6f2183e4c59fd0e5fe7baeb2ac96ab19c6cfcf04ca0b0c02fb4d8bfc5c093e9f02d001af121710b5d8db9af069576c269c5d08223a8ded32e668f139c23a3267875bdd95f903d0deaac796662f169d191288f26c1f3a20664cc60a817ea99e30cb8d5a25fda2552cbc28eea55a5cc3c208e1fca415be874cc3db01efe2a6a7be195304aafd1efec7dd350e2040616cad6d1308c87c1e28a2b007dcb06a8d4a1bbbc248fa77766a77819316db28f48f06580af27a26a139581045b5f615be4ecdd6d58772615e16c2d0c61a48c2d6b959889f0cee0c193756e840ccdc02df44e4b356fff90b8570cd305b9965ecfe5949f7aa917cb0084892911790d35ceffb95d53b29084e3c2ddf72a4c45f7b83343a66db7530499047d198714d372c82227396b14bac7778287b9ef175692d591bc1e5d77857e1a00306d1ccd5f763dfdb65fb6cd6db3738435be446790e9c2d670d280045166208085e578441451d7f5c68f11597e11245ba16ee2272c6be0939f52b3525bb3b798e31bdaf746a93f6075cf03d4350c585dcabef3d714a4501a615725ecd0310481c4d66e55d28bc4cb0bb655d5bae10e5ce81c81f54512e30a46bfce868f3ad49becf741049e59c3908cdc4c511bf1151c3e39669260d9ab8a1be73a1457eaac374bcb94c34dcf0edc8b77c150d3cc27c217ab3b1ee7a157b9611fd43f7e63c4ed0249064034ac7b1b4527200dfca007e0201d204131c1cf49f9ef5d042ec88c31c8a475d1707a847e93df5a6cb16e4fa6de23f833df5ab4ce9b5417b6aff1c75bed17bbaccc7a6a491037d374e19c6a085e1bd95dd25953a4aa77710f124ab01b8e5b88135ca1f86127a618693bb78bb7576caf30dc8db45251498b362633dcb0740eea33765c98c1d3e2074ca1fccbe745da416e809bbe0eddfcef5c89708564641478d36c7e99f1d97ba44cc4e936b8273e232c05bb65be08f3e9c8250c5e1b9012531daaa969c9d7fd6df04085091d5c207425be5f0886eac6de0952b612a8ce1c187a7186930f89d0eb5238f21e91b77d33228f0469d2dcdb80a6bbffdb5df36a7462539715fabd2621fb0db1f7f74e5398d43d4b92d0b71d9b7694d629b5899dbecb85e2113f98e84adada6248c81184892586cb1b4582c3ee233e02296ec3739334547f8e9f77d44af1566901e871c475b8142b128bd47c9a6cde90be768fc3575e93844c6a17fb7d61068acf92beeec8737b3c31343747f4429ec8cdb3cce30f6e364560e9ab5706299de2a428de3df774e545f3b0a697984d282abbb99761c51eede933ccabced2d7cd7599a2aafd79c3bb2ac5c6555fc1add7d6ca8197fc107fd281e31181fef5d326277fdd921a1115cbd09427495d65b3f19db42073f5e0494d213a9bed835dded744b1d168b11f4c9eb61d68ef6e854a59d74b4fee6efa50144fa5ba548e1ff3e12d75e9a4dcc205c1c9d6efde8373f2cdf9e6dd7a12d6906382926a3c2115f382fcd644898620c25a4cda799f25e0dcb72578d212ebbd584abbfd3a1be69062bf14c47883bab81688293923edf116fccf7cc5c1c6a35da5300bd56438e1dc880bfe1dfb4cc96d7d158208e2a2a910d2021a2003d639ebf5c958b4e506c1157864bccc5dc7ffbf42a71f476687387929e9569a7889d7e1cacbd742fa0242f662db6ca4651c586b4ac0bb88713e216153ba5e4502ddc4afb2f0456a9db7d56b7730c5294c5c6a9ee8e3b6cf3843f3ba84316db5958644ff4c62dfc7e27ce99936cbe2d2f6fda21cc9fb1bcc84c1d73179acc9b2ef5d288cc34738c280d12ec297c630f3fea5299f5ac48fb87fa65dd406e24e811941373153d363dd40fcf7be8e1f5c2c46ce92a68f3bab68e23adac9e72b3d7915a890457a74a590d1ea1bb28e4c836136d801dac7c6a82fc489fe526a3e92dec6d94f64eb7078072522090dc79d1827c7b4342933ef41fa75975c3d0d0462220560de7cf5074de713d3061db43b8812551f53c91d718cfee355077b8984e4cce8d0da07283796100b24dc7799fdbfabe8e1539161b7089707d89fd0c247f89bed9bfab5e2355023a55786820650a537b57490e707dde94847b379ce89ac929781f0c08e63bde06c8a64049aed85c30d49d0587115c32916d59fc2080d123f2c9bbd1a8a2274cb5fa736de23f4bc44f39ad6b68041d0f65537dbd7fd1b9cb902a5e206f939940b92bc3b378c9ae298fcfe3a8ac12c9c8815e5125cf2f04034a22d6ad1b7dea5f3ec8970dca3f6ea7d4911005462980a0833cfb508274e0ad7ffdd8a26f18bbb5873ab2e8d016c258612087af9fe2e2f9942a4b10f2a098ed88e85b232ee2ccea51f4d474d1dd2d2dc2cd1c7dc8aba419b161ea7c94c488b4cf4f64e9df0f8151b9909dcb0d7d3f7b95f9fe71226566f5d84e1bffba41cb5f8e3de52f781740407ebbc8b94763d628140be479378734c8ef4343bec0d25e4adcdee582da1d853fd6f18e398d953d6d37e6e2520a5daacc7c0bc075d315c7090b24d1733e68c0f47e7cb9f64eb249834cd31a9d82df0eadd3f870316e4f254df03d2f32e84813ed80aa06b9613b997fdfba7ffa226d12cdad2936fa326b768cd6885a56d4cc2cae16dbd7b807c85958e46c64d71fc70bb4ea9d686ddf3014fac935e574245a10403531e2c07aad6d9cccc02afcad122b3ca7cb23c3b9dbd670f4f036bdf04ce1ef4ed50bd604cf98c274f42940aebd31a77dc5c7cd3f1b0c6d30b7e5e8f2f9952524615a15a93bfc1bbd2edd500a43694d5ee13018c9c9057ce00296e5d4b1fb834ed06853728e304963b959667c5590bac71ed94a000ec3b75534a978429e16ad6b37f2e873326f6ee4298ea1e39a18ac15bf6d0ba3f8f215bda9a58320c83c760a5b859fe40942cbd0a78668176d4e9f39a68c6ac9b8f922e9e97cc430b3e56e8ecb9e28e60eacc1389e2a34f5f0452e9cc0a31fe4b17832345b65efc59bc52d55e705f7a8c771412f00367b88a4ad6dcab7e76e602f5981ee2c008d2c5930442d97fe2ecafe3c8df316b13435bf3af6e843c92969bd00d09299edd3898829424fa0176de83afad2739414e6149524bebeffc09b2ee00c88b685b99d81e51c8024b7ad901e58fe6224ea6f9e2877ddb80bed097f4b9a63bd63af7e981e210a3131be61a6e309857d2a195649fbfede7670669515a356462befdcbab70e6a60ae59ef6a077073047044b32b55de563af1fcc85f2bf6c0200ee9c732bf46b1b39fed91349c5a99c6315ae5de03c40618beee114705665f5a0c2d03418c584d5392d10b57e789edcce6657624d29114d08abe08eb8e6816b7a6918666c404ccb54047fd300a82174f8ed78b8ed6fefb375da4147ea922cf92f27ca3dcb27fc6193e90e4c60cbf3da0b8f22ede8616a8378888326ac94f052eaad967972e656606b0129550ae1629eda30e95d563fec18399ba60d8714e3113809a1fc5e9ddedbeb6b863547aaaf47189a8b0e5b5ec23df973e09092313810f4708b2211614f4736092564bcee3c37c65fc562e7ae6722527c25abb1b574f1ebf6b8b0aff90e0f1ae99590bf28e615120cde6a5acb1090b77bfa5e173fdfe8b07d6e8073261de7d724344106fd46d2c8cffa63308e3c1bc301b1906cda2daabc65383e3a9f53a7c90c523349599f2a6b8960839075fcc5aea6b94c65603a0e278ebe5d5939b4a17e0f0f0065487733c1d973325fccc8c9ecafa5458e1d0adda3649ca0315f755279ef0e76ae81c664d0d69365f7cb80c5a4bf8e8f5b92854b72ab6c1e763c49201e4287bdeff6ead9d8b32b21cd1a1845b36c6a61585c4445276f5bc34da017012697caaf32772a798321b7dc64ec63cc1540047d05c97257a6f754b873b71e7f625c53e0a17fd782d7bde305a140cdb87e88e43bd0a5bfecffb3edb2c83a7924af31a08b6beb314feb3245927e232a7cf8741c86314185a047ec77e6f714b2abaca967227a86b75d9c04f928b7eafbb7a3feae82e871401e87fd25d2f3b6dc327ec47767dcf42efbface37855954cafdc9ee2b0804326da5d906636dc23073b3927e61144e0e371c21036d6e0579aa9deaf266c8c82e000256bbdef2f714423b1b32f7ff5865c1ae82cb99e964f114e9f655ce4757720bb3d370cb3bc79eaf2f0ea62f7c888a7ad64ed3616e8e2edaa0755fe2222fc7a3a34a4681abaa2e6cb1ec523346f89e166345aa9e054dde902b93e7c8f9f5990be6170e96ca0e82fb9d90989afa1b433a21c5f756b1a7fff04cf6f8feef8f7f3c3a342b7aa97e2e878e34189e8374fbbbbdca21aa357de5ecb75793c613e58124de8ab98219ad172a2e919e3929d25e7269a978e0a70a997912551a5e0a7ccc248ebd747fda06e587d218328ed9e8cbd49a8420018c01b8dd7f803837508e23f1c7bd81e07a35f5e9e9daa953078d44a50b230e6f64e8d29fd5625c082a07d21e569f8a66fd87023905073f131e2b573f9e1a4954b33adf10acddcdb9721db54fa18f92356c06d1b0501e65ed380fb15ba5caf8adf9c4dac7a99d3d0bcc3b56837edb483fba00657812bb9ea0445fd7dd5089a6fa1f23cf2e404e777aec9d138515ff11335db41a1ab003a04ef7106b7c4de9ab068f43bb8fdbf1dd66a552cec62cdd312bc0759d708bf29e71af3d2506067e897f3b7b00ee698d9fca33cff5221fc9cfdd81beb9dd6be26bcfacd3cfa5a1a58b83ae9401659be2982a3ef2ba46f5e93ea55a0d5e3b37c6d97c54bfc41d73c3fb553d0545dd136d46cd6dbfa21010d1e57e22804e65fdc4e65dede847127ffa152808a38364352ca8c3c53c31ddea5abfa77ac4a07a024cc1a55d7fff26d3beb7f33b9faddf91250ef549f23001007ab09d9c9d2dc3071178ecf25b3cd94083205ab5a1bf7377ede456e81a03175c992c67e8cb3d45785d0104a80a771b1e7a1daca1fdef287ea91b0bd7ce2a327e1e683c8ea440bc4b6952025a2e8c6c562e5bcbf709075383ba26637be44d0e23c703e9e930d8b37ff61ad2ec959fb4cb3d4bcd327ff852717c25d6b0365fa02afd6320f297b6a6da99dd910a0d9c1efaf0ff10304214dc4b7b7cba00940091b6415f4f30b7b1eb3ff8aaa489d0beed5b1616a64d16b05d0cd17b7aff41d42d36c2424da191025c4bfca6213899519c248c027d01aa6e5c852137647b4171fbe542b851ffcbc9272edbe8f8c48072becf948d335d418f6341ae1f5a46599582da8a6d529038fbebbe2ec8443177e4ee4f7607f7d7beba4e2004faba43f7b13a78fb02878267259830b2b64d85fa46e655205b442ca329a897122f811e5c7bf84bdcc95731048755b8d606edbc1d7808298e625c8c7a19cff4a0b8ba9ecfa5806fa5fbe772348e7df4890bf0d9526534755b85adc13cd2b1886f4d953dbbb2e4f1695f7c5ae424b8cbf03e83e2de3b68768dab8113e734cf64aa479df32d9e6a3d87115162512c3dd3efc943f899675dd3916868df8baa0601a4ccee7e8d2dc83c870697d585f55288558c44229e3da00ab9dfa3b10855767db69f554f727189bd51557247934b2106dac64bbec5f17873024472793cdb7723c08c324b932bbf6d2c7029357aaef896002c71c36685ca04d5e50db8188d1f716640abb98cf837feb6e2437b14b7f28967152f84aa71b8560e0ce9d43bd23c11f4f8467a1699872b2f71fe333f60e668ec11ddfda8c114f5d4c90acac5b42fb539d07459f52f926b1eec214832acf35dcbad26c945df1d48a49127d5185abd5094a3ae7e575188c4492f5778ba434b20f149a79aa68f9e0ed8a552481d34957d66521622453f0eb80e295e92bb6545e4f2a1b52a0f3234f715cb071d0668f7dec5ba4c4404544a0268f19f6d3745211d05702aa98a74d77c09efa2f8a6767388d4c24b6689386ab7e80b283c90fff65fabc4b0a3a8d1f3fcbf46500445414cbc3d64bd8c2f73e7df123d552ae01ba2d2744a234f45e0f815c08dcce69534a45e07c408c207f4566e9d48f8aa796a9d56afe135318bf17a4bcc71c24f2841f8543c67bd92ffdb2bbb79ebb1a2fd0f03a3f824505e20d5334b448484579b977fcb4890fae1d8a733b4a70c7ad4de4cc76a6a15ae3d0f4e1b6278c6184d7e29ea20ee5b6e77cdae57a16caa0394c8d304ca822149926763bd1865f8762c865a44ae7998237c9716f72379fbbd3f26569424493329614b96a6ffd2c8ff8c6e93fbade82cc9b5b03788d5d7bdbc46e32bc842d31ce0a99b6d0a64c91633007cb3f2da45a3102be6727042037720837426a0dd90e6d74ee7983d10afcc24cd03d253871e9fbcd1614e9092db2c5c88003f37478e1616fc5fc4bb7bdbf23669a187fc8294e4974baa361c799c1ae55af54c33967500537c8d570bb71bc0aa5dc89d75a30537e6a3325e9a51f008c47149ca8903a79116f5bbfaabd051c99baf08d81d22b10c66262691d45338f053539e1e151ecaa5f028c7d10c55c50a92eecdf405543aaf8a9c738791b29f2f19abfbf8332ea348ae4524185b4c19bdd784f661e65a3c98e4f5add770597cfa2583e3986dfbcbcf09243917d98ad50fbf6abe3d53716154028df44b95fa6388b8fcc5211b0604a4e324666ed44b1f02003f5fb3f9a84a565a72a888f9ed08ebe69647f50a77b32006ccfa2b9dd6298b2cd0372e302c36d732bbe6979ca8777e7f534dea10bdc4de375a4cb017921e816567764fb36492b42ac09cf97798bf1969f37b4de98523ee5177e08fd150be14ef517a0fb5fd53500df847dbb3602fa73818f63c2bb666ae7e40ea73c83994172fa9c2a3865452484dee1951cd72ae765d4702e7eff1768aac97252d178cfc6c7ec9df2454e9af2bafcd62cc394f30524fa5f2d50a7c894f5d1f2f611e83c24da5f0f47b188f27b3e2eae027610a8ff7c32e8fa67b9f37c9b7c2ea4621f9a7a2ec486c782031a4542c9b62b766e6946c27dd305a02c15ba940f613189931bf68d9376f54a3a3e661d58e91a6afab999d646965d2c725949bdcad7f80504613ad5b6c3e1defb76aa6df44b59077ccb7b918492afb595107f0018eba88ed3ca449b167d7895086e04a209ada627df8f678bdcf1f9333b79527918da83cf9d78f4c5e24659cd869b475de54ec15ff84fb3e13846e4aed4a6f39c78a11be938467bcb0330bbcd30703ae711914d9bac678baac6b6b140e0ef89fe79847833cd19a34ff24fae7dd2f53512a955d1e7e9c4c88eec981a39f483de74c7bf96bbdf1de45d0a2febeb32005675f244a96481641beec09e1daffeec17c2ac766bd1865d52bf49aff50403e45417d7fa46de442d674fab07287965b7f4a149b733578fe2aac1d311d211db0eda66c11ae6d85855da3eeed2b88c4d5cd8a8c73881860de14ba9b1c14d1d2262426c61f7493ad201581539bf0fa9dc23377d9d832ed4092840c480bb24c08f66a4afa2de1c89886cfa3ac69237d3dcdf976a3df341bb3784144a2c7f89b8c957f0bebb08b8f6f394b2a9f9833e11d167e08f5ddad5026056eda05c941c0990bfae08e5b67d683358199eb7fdad89712fa1250e2f02f8c05ef9dc23b18525075a9b9b44b77b9abb802224ccf877df5530cc69657f187b403dbcffb6635af5de2e202038663568aedd91374ea446757051adab465878dc9af1d52a4d7d7902dd7bb5522e449148f4ec4c6793337bf59da9423eda00b4ef11141f3c31564200396e0ef67d8303522ed4ecc49caa7feed43566816c95570c8114df2953ab96c91090abd42dc2f65721d6b30b3b6e9290920b67929e4a37fe15be131167c6d48de505b5407f8609bf9866f13b47801f76ed816e01328301ec9157fe4404f0af49f34d0af7301b1aec714f970fd318722686e7e91e8639d142bf4ee2f9f70d7ee1f06f95bd9f92bfd7fe1ae6cc9d04b62b6fb29adc767b29023ce99d1096cd27b5c48da0ab6bfb2324e0ff26d1f9d442f252c2eb66ad85d89d74d33dae6da2c7c6c37c6e8b0c8da1c9577334f21650051587bc39b2866229f87193eca08b8571968583732850a28467e0a6218c0069dba72cd3e01a408a8cb250791835e7d1df7edccd4e41aa74fdef7660e1138e8562aba54e94f816f151a346b60b230b89b5faa24d5f93e2cbd7c6de1bb6a48df57927b41b49b7de0aba343af37736ad9da02acb117228b742355e208f10becb38f4ea800b20a2d48787b9bc6393828ccdf66277f7f5352def819b9d79be4f5e5caf6370fc0556b27e2c0ea9b5e92daa0d058129ce6eafa6b117a3abcc49d19694aa43ee526c1f09db96ea1a253714887924a006bc7850f16b2614a17377a5fa2d4cbbc95ba6522040a9b2b54954b963e7fc1caa1e9b4a7dab9053237de6f769287dd1487b00ff4e0f65557bd1ea28abd54abc1e062f0095bdeed78701b7be7c4b74c73210c8d8d94f729405c8973ae14219a46f8407dd09194f0ceac408739f7b68b627ea7b46b8c27d417a800f7a0c91a9348a42f077c50978e281e9afab9ddd22b91e6bc5da2dc636c41bed87fa9e3bd65d562b03f7f4e24e22a02d13435d28d7d72d7f35d3b2c7e16dfa45bebee4c2f0fa5075b79a2a9e63b9413a0381879a838ce3a9c08e443a7b6c785e19cba933cca9c8c8e274c803733a9cd7864dd25d8494d8c2eb129f277e8cfe784d660aa3b6aeaa3f646f26bcc73975b77a654d1b200d9f9d2c90fa302f58c39e6c8cff3741ea6c8aefe0b1eda559e612eeaa17db9f6c7f0b89a002636128809046354cbaa6dce2e7465425e006e85e02c581890d6b86ea6085cb2a50ae10a34c6a97d8cfd5bc82969fe09e89aa6dba6e52e04c872f444890f58d8fb47abf3a6360e7421514b736efd0445b3e83471c080d45cb1d95a5c101b65ed4db7cd64c7eb839c7fe9eeeb854dbef5f49690587b16767d490d0f0fda760dd606d72bd75f302e42d53aa2dc00e9937c96f3c78e467ddc8883dbf9ce8d9d1008a04f0715bd1463ef926c4e61ad11ab2e50a2ab6b81ff8525e922e04607738a1e7e3ca0302f922473d1466d94a0838294aceeec6a00f8a5daaed7340032eb3042d6a7b9b6f1a066e85c5f0fd30395d67a43dad5b9dc032953174f2f0f95fcda4447b20cfbb63e1c019ddb3474b26f6634efce294e210df4c074d65f2691b843228b3ddef97f5fdb77de72f84dfcce5ada377ad0ac6d8bba35f03c664fb5dfb46c968e3e31b290d7e83a4c2fb6dc5ca1d68135ac5a4e4f0d5a339fbfc6c3445453decd4d09e1f12c3333b36649bc9ab6d9d963f1c382dee76c40debc61bec112f49a40c80181a754e425119b2840a115311862bde03416c0cfee34a5d485ac3d7cd3c9b204e17118689a9a0cb63bc1cbdf31bc4a8df36f853676abf48f60754dcd66a9b904ae7998e6bbb878a5ab28479730796e78d58b297db8410047d2221260bc48ada4851cb016c11f9a26d4892f1d35896a76d1a83b187ec0c1303f973df71a311133f38fc97a09c369b7748d49c66cd97a858cc00eed23103dcae25754a0aa620fb57d56f0433244924cec4816216f771088dca1b924defd1ba0be8b2c4128857d3f7798844df79b5227348d4e8269b378c9e758dda490f774691b6727b8151e3d871625a68d31ccf68c18912175acbb8c7afd19724b190659bf8335b9cda736a244e4a32b282dfdf32a42ac12bec04d210e047d32efc161f8c6e0afcbe1a33b83df405e46676b158d71fec853fb6f869c8c9b6fe3a822a5fd370e191289bf0586333221bdaa8f42d68d2789ecc6512256d98acf3704c02104dc90b1a079a3d569b76de11db2f0c6e83c4d5aba0088a1dbbc28a69cd377be3168662c56407172abbbb032d221a35e7bc3f0195af25f17b46781e51891fc50537dc1ad6fa86d688a2c9b7aa43f68b011214b3afb13e159b2bfb9f9fab77d0c33551b778c47b48a4cd02ae67977b26b1f501cb61ebeb90971250afcacac73398e7c8f1ad69b8fb0458d01d5bc63f881665efd581b9c81b3065337a37a13fdf2aba3030b9c07a50aaa9f68adf3a0ad8390e9d3b914bf618a2641c06eb9d7403a0d8b030470d11836eeaf7463c5e8d2cc9e52322fd7f25ce1254f4c09b0f75930bd77c232b012e4b59affac1aeeb54ab99003f73de9077cad292dd8d0be5bad2691841b294f4a13dea0ef608cf9d2b5605884a627c2171c5e695c5d4bc101ba88327ab7e5f23691e77110f21c3bf0527b3a4678bae57b146d9f1d53089ee29f4a3a8bbea89ff80fc9382f5c12dad6b437e6ff1c84e6b5492622282c1e4c5ed646b062689c79319e36d26d24c9513a2d2180304d90df62b3c7ed45d17c6441d06cc198c338616a79653e7a408cb73478388bb5a60c2c0d6f1be401062bcd76668055436e8058864760369414ad13dc0635daec77053cb887453ad371bc1c1d61912932cd934dcd5faed844274177bd0fa1f716dbdf76f447d2003d776c34745726a9aff9d10f260b7d779087c15a9a03404b92f883158f5476686d2a22f4b90331f3870b5755fd9235bb810fee389ee0114992c40e78e2e5235acafc09c404d7da64ce3c3c7f2408530fcacd3b154f40ddf48fd6c8bfda214320930aeb23924be64e97fa5d65f6613a40bfe15cca05b6f18b25dcd16c069e49a507d6bdd3e1cabee97b529b6a22f8ee4ec6a2ecff6e00edeae2f70143f01e8e50eb7829afea525e092fb012dd87cd99a193f2cd84428c6536620ff6b076e7fb1c68faf2992d83b8b33246d09a6e171299f360d8303b313a5470b06e70dbabce6e9bc8812d06eea602f4bbeaf098bb391561e1a2060459030a82fa3481357cf0d06e1c3d964f1c0c0d6c36ff67b960674ed1c8e9dd5049595acceeadc93516aad088311a8b568cc284dab198faf282b0100d5484b5c81663e5884697c2706161f083201e704c98c0fb3d64165ea6eea43e02f879081f3189d77b1859575b698b0c7be5ad5551b9cec6b5fe739a92a989954df41640daa2dc43947a954362b51f79dce118125206c98a073068adf66922b9e593b14ea126f608066ee588fd58456575df0b7dcca24120af1752455a9655c3e824729ff5f9aa99410d7963fc0c1cba4fd8b224402a1753b78e682b2d0685df8afd496a2593c0a785b4f4292710d1c0ae6d120b2f96afaa7c6340e9fc5ee4218ed4e7dce316c6cf6aacd4bfe38504e5bb8fafc72a10aba112fb9ed905e19d04ced6f4f6a162a40a4a7706f0fd95fe973314f2a462fefaad263bbaf2c6906e64381f62432c05cd1c90bbc902d364dd1e7fc7e586d4db093e42d8a0332f51000c7b9b76e06e2306a2e8aa043026f65060bb7bc42825433c3dd0dbb8870ac80bc11e94adeb24fe1fefeedbfd48cdc1ceea15f1276e02d8379416b95d2e13b21d276d056ddd96eff10884692346349c8ee25c025ccfbc6fc0de1b5ee9ea81e2f9db4a063e2e66c0ac418ff5053cb2de9ef645107c9c472604235383c5726da894361fe121fc5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
