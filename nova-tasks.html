<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fa16d0e9cefd27d53ea2fcd6d0f2142b427b9297da4af2d4d65556998c61b728d2b1d723983d5b7f769d6725e35fcd47c9a0fd297844bacd807f962ae045d9c1d7b25d316aabb3ec1ef323c614c0edee8ca2da005d6ff5f421d5dd33db158bf5cd9c3946c6f271b5086d47c2143610cfc60c4b8383fc4ff13fe15557258f613fdb87011acc384bb01b0fd4338a5d831afc69a5ac5bcf910fc2f14e91e39a849bb89a667fb1d8d95202a72afdb59bcff9e14ce61fd5a19f4f3770349c34aead5908ae75a9d9d1a3c2445ecd7ed4267e82d783106bf4b462f30d42591781a82c73a8b88ab7afce8d23ae1728f2076da2356251df22c700cce70be5efa592e3450ac029736d6e2870e3838fed3a8b2b6cc465ddcc42e11ccec76b32075f591bc74a9059aa50bf95f493b67c3966653ba02d79168716cd9d4d1117534b0641dba7d2d1867eaf45f73ea2f3f0c63076aa6ddc31236dca615b5fcdc422c88973ef4788ab3990244704add7610284e1d2ed21b72eaef06c85d3df1d9c6ef20443f7de9adcac794090128eb343c13858a5ce94f39d0bf0ed6c1c8632c01fc661e116b17bffe13790ca10e14360b47760085e2de0a5d6ca34c431f0820a1aee3cee0200743581d5201ca92d0461963db53e265605d10182d5ec18e09c4767ce38ed512edb2690fc863349a8999560aca1cafde9788f55c9d9209f8be6c7214425594d1cc71380accf203cb6f1096f924af84ac63364431303b8ae28b4f88924d7aa37e6cad870e703567b82273a732d23bc8885c40e834d10feb4cb978b4b5ac6ebaafd81d3e4bfbc26dabd939b5b2d699debc7d139c5e664fdbe6f59d6489e1bc10ba419e0446f16f20046921c53cac8d30906ee4ab1316abe527b58dd8f76a4f6d68cea3b17ca97e8ddee12782835088566b64be4fa186424153baa571258bd1c7e461ae60d328b5d7db003294e8f9788293db344abb9714cc9e1341a4bfd232c1409bc80ce7705a2d499742b972c8979c838509c7a6cde99608b4656a1259b60d0118667428ab6457bec9cc34f3e9cc604e83a69051e0c9e2a9c574e1691ea3b0ec21cbd2af81787338f5b26acb105b3dc0ee1b8e5f770fca5d652ef7c28394971fe1077cdb5d36344a7d9fec3bdd4af84c60e59fbd743bbc48d76eeb19a70629387fd39ff49bbf253f66307e86f4ee3cb12921c1562ff0ddf350c887bdec96fc5140893112675c441e7d38815232488ad26f4765fccfd3ca0515a775647bc5f138e2e11d1ff760c57fc79fbfe467cc12d9f25db47ceb0932cea93f8422dbbbb64e128b4258d980fb3f9dae5624b404e37dee1e7a84149a4442badff7899f42748350f9402993a538e1263a0bbab84fb454266ba680b32371999ea272bcc6d75933f29557df9d37f211bc44f1876e29ecf4c917322055a60dd1ba0a7ef73135f4592421e2f22f9e507d52cb93eb3e1aadff9aecdcf7c7f966ca7b146aa9976e5f85588c6d5726c2be962e06f81316f06632553cd3e5e37188eb2fc1994564617d7dbefd11aeb398889b0474f623aba6c5a8a561ac41fb8ab0840f22d7894be3dcb98c795273bb18547efbae7818aec97d1afa6bb8924a20cca0fa954bff472e0818c422835a7c3f464c98826211a323008844f9fbb119d3d2ff6740971fe10d5f13e5e00a3a3e48f74a51d0a3341600a9e7c1525388a093c23ce59e071f6b5ab6ad594ef92ca419d8782fb922d8dbea87f0a7c472f8014a54a5b63cb0dd08dc4ac1b7ff0807bdc07a54dc1fda0f1e49fc0a35034f78b64eacc679069d738031051f86ff93c8f6b6a8fbe0757933eec7a5150a6e2a5bf47e1d3146aee6103127ca7147554ecb3b93e43424d784ce769da11407d8b55a9786bcdba0c9a6093dbe3cf3d36cebfca174fd6b9949b6a8fb84b7361ec3c7fc493c16ce3c4bc42951b2ded91c49a60eb81999f9df6bead2ef7c18255212330e29ca1b445a0b86abfd225b7aa65e537cf1b7dd50ede702ccb3d66b753497fb71f9d72200bb593d023509d4cf55b15d9e13e5eb6f90d9efc91b1594b38c9077f0a0ff042a0091e37fda1ee5ef8d2ec6b5dee7dd941acdf8a67ab1ea7c2fd4b69e595d2e15346d8befcf9ceb5f42825f9bad20b434033d0a2c8e9d9162e331ca839a472a97ea3fddf5fd07f8d4817a78045a7867e1d6d729d8ac2743e1fd4acdd104d95131d49f203f36d486d7b39e45e8dbb8d00e64df68fc1ed21bfbe42ccd72525b18ba9a32409129569207037e606df88464a586504f7004c16b4dedb7c09cdb5c6e855ad1e2b8bd69a922c79d5326a47eedbef1cd0f2c39d4df8e75a07e20b7a91449a022884d4d4068530295936201dc2839d733fc4e09888eaea366c9a0b2740432a2fb04207b2be427afdecb25d00c46f93adf39dd9106ec0ddc12b2bdf1f9b47b57134e97fc78e03021a4188da5430f7e11b2195d121b7eb4f57ac4caf41cc29fb0e37a1de10e9b54f1b533e22b6380dedbbef66ace4444fe014b0448ccc4123948d10efd9b6ee1750794487e7e032f6d7a1dbca1dbae2ef4ea190f218fae5519029648c0629d63f8ddabe72203ca8471d5e5d459bf6d34b480800debc3df4c4f21220081136fd5156c5b1f5a37c68622241de1f28ae2d584e62b01c11b30e1a6057c048bddc2b14deffcf4f54959841e649ebfdabaccdf2636fadffe1ac4d810e040f623462a56c2f897d07173646df717e92e09a603bc8b49c0c5ed6c5385c40530778b33dfbcc89ab601857a7ab818b3a79219291053824d9a671072e9666ecebc9ec3a44ad6e1a128dca85d5b7024c786db3912c72db8bc0a28056a40c303a0204f96dcc9ad7862c5147e07799c4009b8f7774ce129f20d1e8f2e9689fda59bff86a6a1790170dfc69ea7f061e5d7103cae89b1932c0355c8cb249cda30fc188c9e76c069091a6ecbd444587016e5e89726de395162ec575128e77c4a166b53b7709ef61082eca8bd7376ddede44ca58779ab858712229e4830cb00076e6b812bbc4db63cbfe5dde20ecefcb70491553f28605c19a4d598c3dfec5e1002a50c27f35b946c0eacf70f8f271fa1e71a66626edb07702579edc5fa02131d6fd2bc544be16a4f961e66adc1be28eba432dd2d4b94bbe7ca096b75d766910c0856e39e3e406bb05e02681c1a1819d0ec245f73892d4c7ee8ee47fc9f2a60c7f277b00f232dd7178d2b67f22674c0538b3582e2e234ed8adee29aa88e343571f77f20f5aeda31ad4eb2d513754160b65b75354dcdb140204d4357ac18c9396bd37e1bbdfe2b673f12e15b65d8ba9ea305f3fa08e1316e1fc85dd2760ccd193c20b661ca602fd6c817bf9bae54e71c585c1ec0857385133efdb519b761e5043875a2b9bdb386aa55236dd1133cc19cac0135f054d34d708d3c6c3938fea61d9e3d9b8a9540764795c6d0f17fca1e591eb52fd9b4c4eb07524b39928b9c08545c4b8ae53811f1219a367b95e7be0195c737b82a97b12db60ba94b7fbbbcc47b615c864ca5db987110dde1296c5724920bc91e53ecd994fbffebe0558bdbe99733fa7c2cd24d97a951796e3c6a31a33c3c9c92a398d784260debd2dc4454f475a3f207bc1be2914e5cd51b0a22e3a61fdd0c991066f93bbe51f2515d084ef10e0fa405acff04b361708fde0ebac2e98ac633814b1bcff980e56aed3281eb2ff8b3d48270d0b473e3f4de8174a09b93ce88ad6b14ff3efc8ea5c58a76543d980d9a5ffa5bffeb811362241106cbd671b03dda990bd5a2ae083ea96d23b6e70c73ece8fbe95f39f4bf53d8277dbea1a4e397e35499d0366a552e42960e38eac2ccd796886bb675ba4f3cb9127447b7547de988b483624a908d631760232ec712357246ffd1155cac11c8e599cc937741b45873bab631bf82c579d66055ec3065ec84fde89bd2b81f295962095cf9dab0f7f7aabe3f3d79d2fc34e985767828e4eaf6ad1b4ffe5fe8992b0590ed6e02f66d2a8e5f7f5a7ba0e0da8bfb455c846d5c9ff371d96b229a0bc102aa7575336f76fc7e133d70602fa01dc5bc0c0acd05417bf8474ed50cc85b30b51b1da46781e5d23fa6c048779ca8626acd1880df760ec2a2621b491071c4c1f7fcb4a4bfe82df0bc762516dd049840b4082fdae32c82e6199420095e1042067097f66d43b6754dad81968b990fab0f34cb7d40de160bced72619e319cb75b1294a67c3b11ebefaefc0dff74c2ad7dede1dfef657a00f1a89653853d903f0a3d0bf4e0841067e769ec2ec67358490d3b20d0ec0171367f22fd62f768fd0dd90dc728ec5fd10c59826e94047a264671881d527cbb971e8107f890ef2ed5cb01c644bda219367f09214b18bc2c4987859e95ac96bc420f8bb8bf182725693f9ec7be1b2bfb018e378165d7021f2c0dec29ed4f1c18e98aaaff62e91a1c84b3afe8e456078a8bd61c8bd7c86a95f25c9da6a3eb3932b07adfbeee6aaf6b9b7839b2aeac1f4692f51e9b04e7b8ee194c377fd759084f575beb9eb1e447756480484ae531e023e37eaf7644befc6b0dd3422616c40906c6da5d425d18b59ae45a807e3c81778d59320f01273b922db89ca0545b60bc7bf51e96425312c5b217c6d2ee1f7a71373d377c15c238a6ec4ad5c167b4f7310a60cc21886dd715f77cb2ad51e495c76186b365adc20787a30e74e52b16493761c3387415568691f386dd02d30c515695160a8419b6f26e26aeab52ec7c32b1324e0fcd1346a7eac82823b3c7b52c3eda08671ec5f872e09f20fc215e1552d2f3e57493a1220740c2268ecc7b094d3ee9e6f5e0f12a9547e16ecc7778e3df93ec1c9667a062eca9eb24b56ee2110bb0382fcecc09fab5c38482ac15dac230a0f673e823f2d4b5f559ef4d7b2209706eef4a51e8a4de31ab7a84a2d8d7c6823288524cf2245788bca6709231b953b623025a995b2f0b24e6a7df9c7d9b27c884fe98d3e6acddf8ea0ee26dca58659c9779282f0f08783ecd06a7a347b1bac3c936bbaa3a515a70807fbbb665f8ead7280697ba7eac4ea31943b233b682506999fd9099010a508e9ddd95411e93f9c88f813275b4831b0a0d6bcf25d9ba5f56e9e85bf974f61f97bf92242e5b0809674fae4a074537834da86831786fcafb122d21b41a65a08d943191a12db89d81c6136c97ef44bbc671d06a33296f73f955e3cc1ae35ef34b0ff515c850116fc8406ae43de0000e729c51aedca8bc54aab15fc6e3dcdedbf7a4a5e33dc70ac1d1007ab5afbd384893d6243466ef49f416d680c5d23851e0bb9cf75403f7f8eb3a849de0d27ef8d87d4c629e5e6b1950e1c0a41fee0d235c60bb1decaa5f004e27cc994ba0139ebadec3a9e0d5b1b3f45b3d12217307a5e9e4d10965937b745fd5863c5ec87b81ccee00f4131e22853c973a68af9a6011b285427ffbaa86f2c93b7e218c72385358c42b8b181dff6dbb9d3cbe26fe87e204904acbf295950d57b651df0a49b7b3777689a3755ccd35ce13c76a60de15d7c337e6af0ad17d572cf3182be7d9e100767f587cd4dcc6185e561d098b022e17e9e65e25e7de85a68fb1e427383d93c357a1e90c6df34e734c99d0d591bdaeb36424b56235f23a1279871f7ace4a618a7741df2ad31cfb98542639d4219df11bab51a1b28cd992672755be205b1dbe5ff5d5e80226d600d6012f41f7cb8c0872e4051d9236167217a6ec32f3da092a513dc8bd546a1482c86b608661e9eada0c063a67db9f7ea79475c0de755e75081d0a47276c95adf7b1508dc806ca2fa1c7bddde448d8e3948dd1f3579198c24bd36a319cf2191c86f1ef9b95fbac9c4b9a4d805edd38ed4284fd4793dc0a2a139464c30bed1ab7463a6fdbd7b52611c3f6fcb6074d48a059d11d015858401a9529793ab6a28e10eee578c059410d2e6aa0d9182c49ae1a628a8394d297da9ca093f5719049f97967664649c052066e9c57e594c2666257151d68d1bf365a707d1aba0b975033d1791cfc1adc39a91e4b0cdfd9b6162a56804b7dbc11158deaa39a53b9579df773ff375029bc08ca06c8b43a9e108159792806bf8d1d58857ed316829d17938e7fb9ce9d1b423ee8e003b9a209a9c742c4cef59c25e40ffc22715984bfb03267924b1df7a6ede09d58fc4c919f556e518636874155c4e9b9e9f0e59ab7d1d07b5867802a459b17a9e7706d24c4d2798b02a77293920bcd39b370bd4069deaf88c4146b7d627f7ff1e5181d68d3d43fd5f961e8957a366631b99800667be548213128ef3d83fd7cfb3cabb535b7c6601e80e10085ec604cb0a8bafaf182c6d7e5ad6ecbb7d8c4c2b63afe4ee837e8787b4217a8114f174cab1b34e0d51d1bc2f2f624b818fcd95e0629c9f39001b1e2d31274be677fda01aac26f9dbb970b511ba2163468c33ac55f3938f5182bdc63392ad7c97f8f32c4f1c5a7465c571c8bbc0cf5ef2724f7bfaf58a1425a859e9dc3acef6b483cd8e2037cb2e2ef2b125f7b389d22afa71ec36c5f480757ac3abb670c94e5a8b453c8d19ae359eec07d7089f07c68b9ce65873ab8685ebfe27247cde96a3e52d903f4f2b4995050aaa765034cbbf488bce567329b183473cbcbd3f0a8aa6c0707cc8404a648aa036593e6e157f9d3f34f79575d5a464c59b0ee0f35aeda86dc8090ed1162c82e412181e90486711e745fc8f8378ef223887d6a038902ab75e3006d4966490a07802d1614445a3d6455b25db6f7c9daafde76307f1d002b6e42ff8670fcba6b9a6baf2122d781878c0d0f0d397610851a17b0b3c4230e5e9e99c3ad47d609d2cec7d3b363db27cdf02c37bd864fba6b7fa6e9f7f2a2b66e1d91407998c3492a75e9df955d0a9fab694f6b5a53574784d86dfab1ff3271d4aa419df834db9f4118cdc9e7cb72ea012fd60f1701184b86739d3bb61b6782bfd46d786dc577b47718110bb8d7d4aad92823ea1856c5fcffc8210b929d33095b75abb342c7a0a198371ed218a54004a298af7b9ace2fa1cbda6b74a1236cd069e746afb0ddae402ab4bb4ded138c478db56c53046be382e04136de343f95dacfd608288bd8a3282f1c5f9db1a0abab59c73bc2a05ea550ff399c2b1c7ce000f0a63dcd53f2e0856e3ebf73c83d35e7a65acd2ae2f1e708601b8e8c385d3f6f6535155886ea33f5ce563c1429462ba3ea2f3d0b9f2393aca2ecf4e88cd7d92e372499921d33b58b9c417f89cd102586d17eff1413922b6ccc10793a4604975dd56f9865f41d48c51bb500a59ef3fc8f5c37c94f5a956f04a7290b881522e384ee3bb51711069211bf419a3460540cf305f06365625cc11f9a80a5d05bd41d6b4fcbd011bf7ef22cb794120e2a01f2b8f91110d97dbbd5cacc1dba3c60a5eca16f1759a63878e64f774962687ac1366a6697a578ed2ba4096b7613c8d02ce845bde8ab06f7d97582ff680ab1debec41cecf92f54a456d0900eac41fe79965cd0648c678fc46f21b20dca5deaf03b8715d060fd5d22df61d20dd76b591c88e0212b44e1cba93527cd7f9445c12f38a18d458bd5e01d77762b64202c5d9dfc22c8c28ad2831713a980cac906f6bdc1049ed465843315dfef37759dd244ddd856a334ff1f5e96efd768d25d58ad7992525d0831515d7fc3fca8542b4c1fe54d2aedd85dbee002f4b242db753e8380f0c51804478e022172814a424610f34073f9350cc1e22ea4b2f3843e50c2799c54cf02dfe3dcb91567836f363770505e23596678fcf177e7732909507953cfd8d5808e974c4022d32cde52e4ecb3f8dd971beaa549475eb0afcffd14ea5d3a0e9bbf7473891c5732c31cafce4d5a341ff094eed5e930e140d51739ed821a26d671b3ff1f0527217e2c938ad0291ee3da4b7778e8380a1704c7076b48911f9f5450f6d9728f1fb74cb0e82bac33abf0d0c42ae58e683ef1fa45165a27b1c386953c7cf29e924a7397453962eae7ccb80f0f45e90eb9b487901334449dee4e9dac67090d2797e5dadee89e0b9c398bcc49bd9ef7be6d7b9f97ec2cb2f69425d2ab8e78dba4d6a8527724de97b61d2b5aa1d11ad9c69102ee9eaaae09250c1140cd1402fe96fde0e90b144c6247e211fc4e834eccabbfaee285ae73b2a48ea2658d06bc766efa6ee7e2e7334c73b92e8d978b008d33984cb4f12a1075e3ea7bf688211ee28475b4fc982c12a4476d47e9dbc9ee02eb562d5e3a7a9d95f8810a8f9efd2576ef02ada56c286931ed1821bf45dfca7e9ef0b180ac7c2c29a87849b29acc46b5ca953d07360e6aae098d21cb74d6dbd0578883b222da4fb50fa178d47f58aef09197a4d7f1df8035ce88954e1a5695c0098e92cbdd32b9ed6bb4c5f4d37fa05e99e037d376c9fab9ec8161112c52bbd02180b8ef95d5eb8877420a13221d79dc844009b50238913424d750ad7ed7fc63eabb1ff03c5f1926f016b5eb4d32bb1055cb99f27089077d62d2ba7b22a7b7d974a943383797b5935f4c708590b4f4865f13cce3a2ee9deece643652773cd19f351d04ca32de7a8a9e3beaf5c7388119fa884b71b938ec024284b78a48fc6ca73e4c9777c18eea748df8181ca89513ba1fd856bca64ac98d9b19a12e4e372df282098f6613af8607cc8bcc7074b94bfa4229831e6bb46dadb211497d7eff6035f7323056f09ed4b74466a08db62991c9ac3a682330570d40e93370de2dfea5330fd7289e938cf752d22ff956effd266380f7fc0d49efe94d847d95e41aaf35f83a54aaecab6fd0748da1e680d085216513a42955537fb92708ae6442f815f32846e8ec887a9cec520a536511fa8f58804ab2ff0fd4f86c846789dd4d12b0e1820cf46c7910fba236412a4190ae20053e0b451ce6214a721f79b575ab36e2d9adc8324e9f9330268f971a8982ec8191245c752ca12d9ee3717bbc9e497aaf8579e9d4a282577032c838ae8856b6e08079ce57687c86bd7906743149ef085415905224a5dab860da56d22aacdc8edfe00c06cccd63febbddb8b53c8db8d021d0087261f02653697a634bae4f33d0b08c814e7e4bd5bb0b3970dea1332f8c3099e491748ee93bb8e67707c14104de4dfb744396a04d03ab4179d7eb0f84cbf54a2b4a702946b6ed151fa90167bc74a35a0191ecd46889c2e1602cab7372ce5fb49be151b913443e317851d0da40ba08f11c637257ed0f6d37d20b760f5e267c1bd96a5b4e39f370faa5e73c83b63bbac29b47ca8e63a2c1507c244f7b281d63ad1ccf037c281c364c2513f270a9a5b92f46f61c867e0549cbe9e0d33788b492c4abe18213b15b9cd908529409c0dee5a5a572cd74702c47244bdd462a23c21576b68559655d2b3d0800a128f977ee5a689519094d3cb379c59c9fad0f0b8ce8dc4e15bfa49c8c13477f4c73f876146ec4397d927ab14239e51b776caf32c3c2ee0840848746fab1f6b7a5b492e68b00edc4d5e42789d1dd2d41a82758e2d895a04b07c43d9a33a88bedc8a1c2843fa5d9061429333353b1aea706369865738a9b9647070ec05bb898f9319efa95836482e60c84b4673a5662d99b73da7cb8a0ec588483b699de1d2cb96ff70847e860a379fe0b3bf0f05d7791e87c91a4da03b6fde2d8e7b0aaeff5a6cdfb86753eec04ac6282eb5f01ce61243826b337442ce33bef95035dbb723f898224d768e879acf97684aa736577e692fc13ad9d7864ff0c9e0532276aa14b73e4caa1643c322f5b16d81079d342121775eacd49409e574a8984685771948c1a8228ca92334fbf5c800188b7dbfdd7a9da78117b04a773fa21b9b1dbdcabc4fe701b99fddffefcfa2032c365fbf41aaa5e7f3c163445fb5eb87954a2b4e808649c06b699d7fdb4e9321d43c5be325a4051e0bfa62f223ded7be5db8e060cc04fde61b05acaf2ab9c15fa0cbdc4be0ebcb145ade725deb6f04f9d13f2d28bae149a3d7ffcc2c77df586552788ddf1bdf2f2314cb85cd056bfbbaad7e6fb6a73c11144d04ec73a2599c60503f24c6c218c4125a51615b3bad0eb960539ed62c12b6cec92ce297fa44b30206d6381fcc20a09455c87539921d9625da66d23fa700f396f92a86c5eced02ae402c0b68211383383f2167e7b024616cc034112a983d577a2720e3c26a4ad3524272cca898535cf75252187166cdfc41f7c1bdb3dfddf4a837355c22125182d4c1ea5f8d0011cddfaf1d2ce2d6c29162c33b600f42c82280edc624d1210813c882cee96f0c8075d262a5dc3e3fa9cf4c32fb48f672711b706e66599bcaf84ea870cfbe109792c410e20a44199d3531e9c6f2c3aff0337f454bb23e4705b58403a138898dfd74161fcb9a5e806bede7400a7e19aa10dded5d52704eb09b7b85ed188ff3641dc7869218643aa961f9ed5d741a96b72767cc6ae5d311bcc77e132fec8dd942fed410e8f2eccd9f8b0fc8e047b264f677134c7bac0ecc12416ce9c2b5a849c61ed8d54c0487b6e096487946d692c4384dfe34b768bed84f905adebb4e6976c233db82234f055fd83415240521c5509c06c89981f5626a65e3c5515dae6487b1c962b5f7807894d88380034dad2ae91e39fc68b018e5ef13cd8b29a2bbf13887de41a9c15fbeb98f7bb9c071a254d229bba292dfd3f08be02f426970a9b153b80becc1c6f7feb5a7b62894e1203d14ea28b4263a3b624ddcf49f51d5f274f3769f88de47b533e48daa1df82402846198e94c788089c9fcdd18e357c4ac8eee471baafaedb8024aac8f4600b9f2562b963929faafa406dfe8b86135bdabc3bdba9654694b4d04d9a9b8aa32c795d11d50e58b9c618c90bfadcdb2d06d452b0360317a31636e5734d381f8aa14a0c1fd1b4723b325521cffa551ae1047a8fe1ad7385b766b3a7582ad74ab2654322f2b87954919680bfc3f20f902e95b61a7553f881bb3a17fe9a42caa20b71efb2a78c0f7fd40132b2f65a891119dbcfbc62d612ae48fab6e63fa980831999ff1bc09cee731a2aa9310ad1b6a92c4421a9b411a7e59ad5c9d286e2f70f394d1e1c1e94f06ce8fd84a6913a1d8547872c2a22ada026e391a0077484cdfe8773a36e92d46095b9a877295d5e9fee05ba1b29e9a37b0cfe6d8be706a6b07b11abf00e4e7890f0033e88b72032a1631ceed60699dbcbde23aaeadeb33971305d48f4fab509d9524fd1765bb2ac6c70830db00fa678af566c6a33426d0bed1e97a866e7679cba46b31948de28e1c919c5957b1668bec38f3bc06c2b67bc716a115429b18e89beb25a31e1de2aa5505713e037364685260c6aab33d965e35cba5e854a5caca6c968d852448cb3bd18e4703fe5c85c64aa6450286b20af93b57ad8cd86c087d36e8b5b65920d0507e094bbbddb68bd757b21de74e6cf89f245d5c35a8d4cf3ec49d997b53d513aa6671d6899d1f25af3834566c9bea1db0a6355a11172915a8311a4629eec988fb983cc624e058f5115c0d54843a76b18c7ab3b7e0f902d826f283e001e414402977b5e906f63607025ff30dc3b401a114bdc6d0ca400584387cfa08f19753fb39a5c2528a4048861797785f273ef58d7b4dfefadee5d7558ff04edf6ee78896dc99da0e6b09b93ad971ef3ce286c8619f7ae106895710dc4da020c07512a99b48b1ff687d9ab5c37a77c00012f38b4c024ab88dd4672f6ce28ecea9b64d6395871669f818eec61484ebc23123e6ffdcb04b7eb3c5a32394f358fa369410c748d4696579b5dff56b91335e8f2ee7fa761732cdbd4aa3c761866fd1e095f3995907e5e9589b3037ffe10f666ab54d897d543d8ec1aaa6557c56b9da2c07f52be4d5838b3eda0271c2e76d5949c7132898418c84c0398f593670249150da42f5bb956106da76790e0495b2152c235ba75f24910167a77fc3f3f37218805a6df5828f8fb7eac834cccc51bfe9de239478060b902d1f9b1c80f9fb3682349bfde96fa0b281e179586b7c7286c7c60aa5237ec57772b5a744b4549542a8750ef69f1239897856c480b86f0a24ac7652e780a4812aa5a6aad2f36a2c1a3e4aad164c9ea474e926fab3a3a23382f8987be3e57ca1b94b89e49f75911b5a13c99cf56e8bdd24a157c5e819ed352265180976bebf5734f30f0cc3abec73c6e0a32f231ecb7add77c4c593af75e8458274d044c6c58b81b14d5f9684770341548a760a85c6361f0a098b01055eef4125ced9a18ebc4827c4bc3ff52a97de56f3291924448cbf31123a1f30fae402c60a688e3170e08a31452f9456ac5056477185e5d22595ca5b0ce040eb37fad13c7cb9b841c00212a230c3bbfe043ed4e2a00bc1422e6542b49120b3c5d8c4a2333ae6d680cd9047c6bedfcd4cd6f7f7c488d8da3bf0ef4429b08e0a2561c64376d22b3dcee00f7eec8e802ae6bbace580c20b0dba7831a3921234833777140947614c4210bbf8d988cb4521fe30b847601578c92fd9e3c92a94cf78e5190a67955fe05080c503bc421d16ff127c673199245a52a592bbb6b65e25c55acc700a1c64c0f2789261b888cdd8ee8ded0bc500cb27f60e5b3bab4c053b7b7106f2faf47fda7969cb532564796180c5126e039a97c01dac4909628f291f20856b8de15ff3b25053b3108bdd0842c759f89ff27b47bb6a5fa0c999cfad057b8f6ee49ec5632a6ccf587c52944c080fbf9efb32264f59746bbf264610d4823ea014c3d03d53ddeed7dcf404188003fdb7d8b9cd9c0b82999a408857b47becd36abe8c68f2e61bdbafbea064c7ab658523fc00552e31df48c20475870dcb8d94d09dc7525041cdb3e148cfb4ac9d59690ed428b2e56740a8955a16dd96fda677662cd9d86852dd2563fd77386d41d3fda0c3a61c88ec444d4bd1ae1e60ddb77d30779643539ad8ccf188bbe4f1331a58bf1cb6a46e778d7f4e339dd9181b65c39cb43cf56822534fede76c9bba4d25a6fab5697a3d02d3bbad2458849d8c476c9511090e3d9fa42f6ba075f935ad7633223feb1c76040ed450311bb39331016de5cd6084a4d064f74360504c200d8e7b925b288bce41ed88c1bc81cd537a8d07fe33167a624cee5ff087391b95f640457a79e633bfcae36633c07ec007357d018fc489464b9aaf930def9a8623c28e51947923a87ff7de825dd9e2d1ad30295927f6118d3f9de43031b81239330e2f6ea45d8795a87742cfcdf72b4564f64091874ad829773f365704779e55e9cb63691099bef958378bca6f166308973643ebc66c5285330602f0159d3a96ad80df2da99b929e0b4400b5ca6f3ea4b594392b394b14e478b6bef62cda50ae928563980ff2f5b4c4c4cf226cbe6ccc334b6dfba0fb003b71a99bce188d75c0f246ae9979d74e48ecd311b716f024e16fef7a6bead6c0bdf070359aa309abd39f251859f29441c063a0a8cb0077a9696379ea751a98474a40e42a363fa4312aca9e0508aed6b88e31088bb8cd5147ed924a6de881197a97ca141de3141eb54f8019c64dd4742cda0f0947abcc5d61bf38a987175a5e7810cd6298561b2c9fed796f823bf6c28e0ff6b2d19f6c46160512cd69904584d60ff1f6f7c1678437ed9a1858b2e7fbd79c581a03b17bb35c4097a6067a56dd211e0bae0206682c832f5ae1143a47e4b6f97b496ca38df88ff7c31813e9016fd32d088b58d1904aca16ee8c095c3e43479feceaddc46ad85c8f4387f5ef373497c12c15f24899ac1d52151cff1777e3c984f193f9bd772fb9e63f8d06d7ae1ab40dbda3599a3d1a4240d43def3a099ce0a5f3f40c2b771cd3efb2d5c57714971844e18743ebbf6916b4b1fd1b849932c4cdc27144c70e05a18f59e6ca352465660db7cfac52bef5ddc53dbfca02d18e65120fe08eb1265a05d9abb767cd9308472cb1537a710668555c65638bd7ae7137c19901091ca821354a4c6b60a6a8d921f3929c4a15d3c09920a234cfbbd3037e8c0f62de96b5d4018ad129173b0929fef9bea95c9fc464c84f817e9673e59882acec104bee119a958167cc9532ec5f4ce56626de256d2f560fa5ce6ede49a1b5097472b48dd6f3021f21fea64190a47468706574181e526bece5e5061176ac327638458ff8e910862645af68973999c2bf1dccc671943060c7384937c9921a47f9becb5d0122b94b611fec200df9872789f4ca44ffc72574d1ac5a3948de2fab79535345620ec60fc0218871032b3b02e9bdce006c7c2cb6a5da8ab8edb01e319e1ac348148e889a4f10afd9c7710b900f71eed6472171513565e6e837b330095670c93799948a4a37bccc1420ed1e77f8c2e38033bcd645eea5c30901d0a020b477f8437a223c01d097a5eb3d841f79a85e7f85e38743c3a7efa3418358dc5605f769b8aebb775802353df52d7a8447a94463fd58fe56a2b44a3699882012085f9318859debd96e8cb1e7674168a6a5d700cd552332a948bd1930bfa21c6b32d673daab59484a10ab338c38a802cb226959fd87c9c05e1220476e011e4d4edf65c02","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
