<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>V11c Trade Review ‚Äî 5,245 Trades</title>
<script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"><\/script>
<style>
:root {
  --bg: #0a0a0f;
  --surface: #12121a;
  --surface2: #1a1a28;
  --border: #2a2a3a;
  --text: #e0e0e0;
  --text-dim: #888;
  --accent: #00bcd4;
  --green: #00c853;
  --red: #ff1744;
  --gold: #ffd700;
  --blue: #448aff;
  --purple: #b388ff;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
}
.header {
  padding: 16px 20px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 10px;
}
.header h1 {
  font-size: 1.3rem;
  font-weight: 700;
  color: var(--accent);
}
.header .home-link {
  color: var(--text-dim);
  text-decoration: none;
  font-size: 0.85rem;
}
.header .home-link:hover { color: var(--accent); }
.header-links { display: flex; gap: 16px; align-items: center; }

/* Filters */
.filters {
  padding: 12px 20px;
  border-bottom: 1px solid var(--border);
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
}
.filter-group {
  display: flex;
  gap: 4px;
  align-items: center;
}
.filter-group label {
  font-size: 0.75rem;
  color: var(--text-dim);
  margin-right: 4px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.filter-btn {
  padding: 4px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text-dim);
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s;
}
.filter-btn:hover { border-color: var(--accent); color: var(--text); }
.filter-btn.active {
  background: var(--accent);
  color: #000;
  border-color: var(--accent);
  font-weight: 600;
}
.filter-btn.long.active { background: var(--green); border-color: var(--green); }
.filter-btn.short.active { background: var(--red); border-color: var(--red); }
.filter-sep {
  width: 1px;
  height: 24px;
  background: var(--border);
  margin: 0 8px;
}

/* Stats bar */
.stats-bar {
  padding: 10px 20px;
  border-bottom: 1px solid var(--border);
  display: flex;
  gap: 24px;
  flex-wrap: wrap;
  font-size: 0.85rem;
}
.stat {
  display: flex;
  align-items: center;
  gap: 6px;
}
.stat-label { color: var(--text-dim); }
.stat-value { font-weight: 700; }
.stat-value.positive { color: var(--green); }
.stat-value.negative { color: var(--red); }

/* Summary panel */
.summary-panel {
  padding: 12px 20px;
  border-bottom: 1px solid var(--border);
  display: none;
}
.summary-panel.visible { display: block; }
.summary-toggle {
  padding: 4px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text-dim);
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s;
}
.summary-toggle:hover { border-color: var(--accent); color: var(--text); }
.summary-toggle.active { background: var(--accent); color: #000; border-color: var(--accent); }
.summary-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 12px;
  margin-top: 10px;
}
.summary-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px 16px;
}
.summary-card h3 {
  font-size: 0.8rem;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}
.summary-card .summary-stat {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  padding: 2px 0;
}
.summary-card .summary-stat .label { color: var(--text-dim); }
.summary-card .summary-stat .val { font-weight: 600; }
.summary-card .summary-stat .val.pos { color: var(--green); }
.summary-card .summary-stat .val.neg { color: var(--red); }

/* Equity curve mini */
.equity-row {
  padding: 0 20px 12px 20px;
  border-bottom: 1px solid var(--border);
}
#equity-container {
  height: 120px;
  width: 100%;
}

/* Main content */
.main {
  display: flex;
  height: calc(100vh - 230px);
  min-height: 500px;
}

/* Trade list panel */
.trade-list-panel {
  width: 320px;
  min-width: 280px;
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
}
.trade-list-header {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.8rem;
  color: var(--text-dim);
}
.trade-list {
  flex: 1;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: var(--border) transparent;
}
.trade-item {
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.8rem;
  transition: background 0.1s;
}
.trade-item:hover { background: var(--surface2); }
.trade-item.active { background: var(--surface2); border-left: 3px solid var(--accent); }
.trade-item .left {
  display: flex;
  gap: 8px;
  align-items: center;
}
.trade-item .pair-badge {
  font-weight: 700;
  font-size: 0.7rem;
  padding: 2px 6px;
  border-radius: 3px;
  min-width: 36px;
  text-align: center;
}
.trade-item .pair-badge.BTC { background: #f7931a22; color: #f7931a; }
.trade-item .pair-badge.ETH { background: #627eea22; color: #627eea; }
.trade-item .pair-badge.SOL { background: #9945ff22; color: #9945ff; }
.trade-item .tf-badge {
  color: var(--text-dim);
  font-size: 0.7rem;
  min-width: 24px;
}
.trade-item .dir-badge {
  font-weight: 700;
  font-size: 0.7rem;
}
.trade-item .dir-badge.L { color: var(--green); }
.trade-item .dir-badge.S { color: var(--red); }
.trade-item .r-value {
  font-weight: 700;
  font-size: 0.85rem;
  min-width: 50px;
  text-align: right;
}
.trade-item .r-value.positive { color: var(--green); }
.trade-item .r-value.negative { color: var(--red); }
.trade-item .date-text {
  color: var(--text-dim);
  font-size: 0.7rem;
}

/* Chart panel */
.chart-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  position: relative;
}
.chart-info {
  padding: 10px 16px;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 8px;
}
.chart-info .trade-detail {
  display: flex;
  gap: 16px;
  align-items: center;
  font-size: 0.85rem;
}
.chart-info .nav-btns {
  display: flex;
  gap: 8px;
}
.nav-btn {
  padding: 4px 16px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text);
  cursor: pointer;
  font-size: 0.85rem;
}
.nav-btn:hover { border-color: var(--accent); }
#chart-container {
  flex: 1;
  position: relative;
}
.chart-loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: var(--text-dim);
  font-size: 1rem;
}

/* Sort buttons */
.sort-btns {
  display: flex;
  gap: 4px;
}
.sort-btn {
  padding: 2px 8px;
  border: 1px solid var(--border);
  border-radius: 3px;
  background: transparent;
  color: var(--text-dim);
  font-size: 0.7rem;
  cursor: pointer;
}
.sort-btn.active { color: var(--accent); border-color: var(--accent); }

/* Load more bar */
.load-more-bar {
  padding: 8px 20px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  font-size: 0.85rem;
  color: var(--text-dim);
}
.load-more-btn {
  padding: 6px 16px;
  border: 1px solid var(--accent);
  border-radius: 4px;
  background: transparent;
  color: var(--accent);
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s;
  font-weight: 600;
}
.load-more-btn:hover {
  background: var(--accent);
  color: #000;
}
.load-more-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
.initial-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 40px;
  color: var(--text-dim);
  font-size: 1rem;
}

/* Mobile */
@media (max-width: 768px) {
  .main { flex-direction: column; height: auto; }
  .trade-list-panel { width: 100%; min-width: 0; max-height: 250px; border-right: none; border-bottom: 1px solid var(--border); }
  #chart-container { min-height: 400px; }
}
</style>
</head>
<body>

<div class="header">
  <h1>üìä V11c Trade Review ‚Äî <span id="trade-count">5,245</span> Trades</h1>
  <div class="header-links">
    <a href="trade-review.html" class="home-link">V5.2 Legacy ‚Üí</a>
    <a href="index.html" class="home-link">‚Üê Dashboard</a>
  </div>
</div>

<div class="filters">
  <div class="filter-group">
    <label>Pair:</label>
    <button class="filter-btn active" data-filter="pair" data-value="ALL">ALL</button>
    <button class="filter-btn" data-filter="pair" data-value="BTC">BTC</button>
    <button class="filter-btn" data-filter="pair" data-value="ETH">ETH</button>
    <button class="filter-btn" data-filter="pair" data-value="SOL">SOL</button>
  </div>
  <div class="filter-sep"></div>
  <div class="filter-group">
    <label>TF:</label>
    <button class="filter-btn active" data-filter="tf" data-value="ALL">ALL</button>
    <button class="filter-btn" data-filter="tf" data-value="1m">1m</button>
    <button class="filter-btn" data-filter="tf" data-value="15m">15m</button>
    <button class="filter-btn" data-filter="tf" data-value="1H">1H</button>
  </div>
  <div class="filter-sep"></div>
  <div class="filter-group">
    <label>Dir:</label>
    <button class="filter-btn active" data-filter="dir" data-value="ALL">ALL</button>
    <button class="filter-btn long" data-filter="dir" data-value="L">LONG</button>
    <button class="filter-btn short" data-filter="dir" data-value="S">SHORT</button>
  </div>
  <div class="filter-sep"></div>
  <div class="filter-group">
    <label>Exit:</label>
    <button class="filter-btn active" data-filter="exit" data-value="ALL">ALL</button>
    <button class="filter-btn" data-filter="exit" data-value="stop">Stop</button>
    <button class="filter-btn" data-filter="exit" data-value="vector_exit">Vector</button>
    <button class="filter-btn" data-filter="exit" data-value="timeout">Timeout</button>
  </div>
  <div class="filter-sep"></div>
  <div class="filter-group">
    <label>Result:</label>
    <button class="filter-btn active" data-filter="result" data-value="ALL">ALL</button>
    <button class="filter-btn" data-filter="result" data-value="win">Winners</button>
    <button class="filter-btn" data-filter="result" data-value="loss">Losers</button>
  </div>
  <div class="filter-sep"></div>
  <button class="summary-toggle" id="summary-btn" onclick="toggleSummary()">üìã Summary</button>
</div>

<div class="stats-bar">
  <div class="stat"><span class="stat-label">Trades:</span><span class="stat-value" id="stat-trades">5,245</span></div>
  <div class="stat"><span class="stat-label">Win Rate:</span><span class="stat-value" id="stat-wr">63%</span></div>
  <div class="stat"><span class="stat-label">Total R:</span><span class="stat-value" id="stat-total-r">+7,434.57</span></div>
  <div class="stat"><span class="stat-label">Avg R:</span><span class="stat-value" id="stat-avg-r">1.42</span></div>
  <div class="stat"><span class="stat-label">Best:</span><span class="stat-value positive" id="stat-best">+45.15</span></div>
  <div class="stat"><span class="stat-label">Worst:</span><span class="stat-value negative" id="stat-worst">-1.00</span></div>
  <div class="stat"><span class="stat-label">Max Consec Loss:</span><span class="stat-value" id="stat-streak">0</span></div>
  <div class="stat"><span class="stat-label">Profit Factor:</span><span class="stat-value" id="stat-pf">0</span></div>
  <div class="stat"><span class="stat-label">Expectancy:</span><span class="stat-value" id="stat-expect">0</span></div>
</div>

<div class="load-more-bar" id="load-more-bar">
  <span id="load-status">‚è≥ Loading recent trades...</span>
  <button class="load-more-btn" id="load-more-btn" style="display:none" onclick="loadOlderYears()">
    üì• Load 2017‚Äì2022
  </button>
</div>

<div class="summary-panel" id="summary-panel">
  <div id="summary-content"></div>
</div>

<div class="equity-row">
  <div id="equity-container"></div>
</div>

<div class="main">
  <div class="trade-list-panel">
    <div class="trade-list-header">
      <span id="filtered-count">5,245 trades</span>
      <div class="sort-btns">
        <button class="sort-btn active" data-sort="date">Date</button>
        <button class="sort-btn" data-sort="r-desc">R ‚Üì</button>
        <button class="sort-btn" data-sort="r-asc">R ‚Üë</button>
      </div>
    </div>
    <div class="trade-list" id="trade-list"></div>
  </div>

  <div class="chart-panel">
    <div class="chart-info">
      <div class="trade-detail" id="trade-detail">
        <span>Select a trade to view chart</span>
      </div>
      <div class="nav-btns">
        <button class="nav-btn" id="btn-prev">‚óÄ Prev</button>
        <button class="nav-btn" id="btn-next">Next ‚ñ∂</button>
        <button class="nav-btn" id="btn-random">üé≤</button>
      </div>
    </div>
    <div id="chart-container">
      <div class="chart-loading" id="chart-loading">‚Üê Select a trade from the list</div>
    </div>
  </div>
</div>


<script>
// ============= TRADE DATA (lazy-loaded) =============
let TRADE_DATA = [];


// ============= CONSTANTS =============
const SYMBOL_MAP = { BTC: 'BTCUSDT', ETH: 'ETHUSDT', SOL: 'SOLUSDT' };
const INTERVAL_MAP = { '1m': '1m', '15m': '15m', '1H': '1h' };
const TF_MINUTES = { '1m': 1, '15m': 15, '1H': 60 };
const CANDLE_PADDING = { '1m': 120, '15m': 80, '1H': 80 };
const BINANCE_API = 'https://api.binance.com/api/v3/klines';

// Fix timezone: backtest dates were UTC but Python .timestamp() on Sofia machine
// interpreted them as local time, subtracting 2h (winter EET) or 3h (summer EEST).
function getSofiaOffset(ts) {
  const d = new Date(ts * 1000);
  const utc = new Date(d.toLocaleString('en-US', {timeZone: 'UTC'}));
  const sofia = new Date(d.toLocaleString('en-US', {timeZone: 'Europe/Sofia'}));
  return (sofia - utc) / 1000;
}
function fixTimezones(trades) {
  trades.forEach(t => {
    const off = getSofiaOffset(t.et);
    t.et += off;
    t.xt += off;
  });
}

// ============= STATE =============
let state = {
  filters: { pair: 'ALL', tf: 'ALL', dir: 'ALL', exit: 'ALL', result: 'ALL' },
  sort: 'date',
  filtered: [],
  selectedIndex: -1,
  chart: null,
  candleSeries: null,
  volumeSeries: null,
  candleCache: {},
  equityChart: null,
  showSummary: false
};

// ============= FILTER & SORT =============
function applyFilters() {
  const f = state.filters;
  state.filtered = TRADE_DATA.filter(t => {
    if (f.pair !== 'ALL' && t.pair !== f.pair) return false;
    if (f.tf !== 'ALL' && t.tf !== f.tf) return false;
    if (f.dir !== 'ALL' && t.dir !== f.dir) return false;
    if (f.exit !== 'ALL' && t.exit_type !== f.exit) return false;
    if (f.result === 'win' && t.r <= 0) return false;
    if (f.result === 'loss' && t.r >= 0) return false;
    return true;
  });
  applySort();
}

function applySort() {
  const s = state.sort;
  state.filtered.sort((a, b) => {
    if (s === 'date') return a.et - b.et;
    if (s === 'r-desc') return b.r - a.r;
    if (s === 'r-asc') return a.r - b.r;
    return 0;
  });
  state.selectedIndex = -1;
  updateUI();
}

// ============= STATS =============
function calcStats(trades) {
  if (!trades.length) return { count: 0, wr: 0, totalR: 0, avgR: 0, best: 0, worst: 0, maxConsecLoss: 0, pf: 0, expectancy: 0 };
  const wins = trades.filter(t => t.r > 0).length;
  const totalR = trades.reduce((s, t) => s + t.r, 0);
  const best = Math.max(...trades.map(t => t.r));
  const worst = Math.min(...trades.map(t => t.r));
  
  // Profit Factor
  const grossProfit = trades.filter(t => t.r > 0).reduce((s, t) => s + t.r, 0);
  const grossLoss = Math.abs(trades.filter(t => t.r < 0).reduce((s, t) => s + t.r, 0));
  const pf = grossLoss > 0 ? grossProfit / grossLoss : Infinity;
  
  // Expectancy
  const wr = wins / trades.length;
  const avgWin = wins > 0 ? grossProfit / wins : 0;
  const losers = trades.length - wins;
  const avgLoss = losers > 0 ? grossLoss / losers : 0;
  const expectancy = (wr * avgWin) - ((1 - wr) * avgLoss);
  
  // Max consecutive losses (by date order)
  const byDate = [...trades].sort((a, b) => a.et - b.et);
  let maxLoss = 0, curLoss = 0;
  for (const t of byDate) {
    if (t.r < 0) { curLoss++; maxLoss = Math.max(maxLoss, curLoss); }
    else curLoss = 0;
  }
  
  return {
    count: trades.length,
    wr: Math.round(wins / trades.length * 100),
    totalR: totalR.toFixed(2),
    avgR: (totalR / trades.length).toFixed(2),
    best: best.toFixed(2),
    worst: worst.toFixed(2),
    maxConsecLoss: maxLoss,
    pf: pf === Infinity ? '‚àû' : pf.toFixed(2),
    expectancy: expectancy.toFixed(2)
  };
}

// ============= SUMMARY =============
function toggleSummary() {
  state.showSummary = !state.showSummary;
  const panel = document.getElementById('summary-panel');
  const btn = document.getElementById('summary-btn');
  if (state.showSummary) {
    panel.classList.add('visible');
    btn.classList.add('active');
    renderSummary();
  } else {
    panel.classList.remove('visible');
    btn.classList.remove('active');
  }
}

function renderSummary() {
  const trades = state.filtered;
  
  // Per-pair breakdown
  const pairs = ['BTC', 'ETH', 'SOL'];
  const tfs = ['1m', '15m', '1H'];
  const dirs = ['L', 'S'];
  
  function makeCard(title, subsets) {
    let html = `<div class="summary-card"><h3>${title}</h3>`;
    for (const [label, subset] of subsets) {
      if (!subset.length) continue;
      const wins = subset.filter(t => t.r > 0).length;
      const wr = Math.round(wins / subset.length * 100);
      const totalR = subset.reduce((s, t) => s + t.r, 0);
      const avgR = (totalR / subset.length).toFixed(2);
      const rClass = totalR >= 0 ? 'pos' : 'neg';
      html += `<div class="summary-stat">
        <span class="label">${label}</span>
        <span class="val">${subset.length} trades</span>
        <span class="val ${rClass}">${wr}% WR</span>
        <span class="val ${rClass}">${totalR >= 0 ? '+' : ''}${totalR.toFixed(1)}R</span>
        <span class="val">${avgR} avg</span>
      </div>`;
    }
    html += '</div>';
    return html;
  }
  
  let html = '<div class="summary-grid">';
  
  // Per pair
  html += makeCard('By Pair', pairs.map(p => [p, trades.filter(t => t.pair === p)]));
  
  // Per TF
  html += makeCard('By Timeframe', tfs.map(tf => [tf, trades.filter(t => t.tf === tf)]));
  
  // Per direction
  html += makeCard('By Direction', dirs.map(d => [d === 'L' ? 'LONG' : 'SHORT', trades.filter(t => t.dir === d)]));
  
  // Per exit type
  html += makeCard('By Exit Type', [
    ['Stop', trades.filter(t => t.exit_type === 'stop')],
    ['Vector', trades.filter(t => t.exit_type === 'vector_exit')],
    ['Timeout', trades.filter(t => t.exit_type === 'timeout')],
  ]);
  
  // Per pair+TF combo
  const combos = [];
  for (const p of pairs) {
    for (const tf of tfs) {
      const sub = trades.filter(t => t.pair === p && t.tf === tf);
      if (sub.length) combos.push([`${p} ${tf}`, sub]);
    }
  }
  html += makeCard('By Pair √ó TF', combos);
  
  // Yearly breakdown
  const years = [...new Set(trades.map(t => new Date(t.et * 1000).getFullYear()))].sort();
  html += makeCard('By Year', years.map(y => [String(y), trades.filter(t => new Date(t.et * 1000).getFullYear() === y)]));
  
  html += '</div>';
  document.getElementById('summary-content').innerHTML = html;
}

// ============= EQUITY CURVE =============
function renderEquityCurve() {
  const container = document.getElementById('equity-container');
  if (state.equityChart) {
    state.equityChart.remove();
    state.equityChart = null;
  }
  
  const byDate = [...state.filtered].sort((a, b) => a.et - b.et);
  if (!byDate.length) return;
  
  let cumR = 0;
  const data = byDate.map(t => {
    cumR += t.r;
    return { time: t.et, value: parseFloat(cumR.toFixed(2)) };
  });
  
  // Deduplicate by time (keep last value for same timestamp)
  const dedupMap = new Map();
  data.forEach(d => dedupMap.set(d.time, d.value));
  const dedupData = [...dedupMap.entries()].sort((a,b) => a[0] - b[0]).map(([time, value]) => ({time, value}));
  
  state.equityChart = LightweightCharts.createChart(container, {
    layout: { background: { color: '#0a0a0f' }, textColor: '#888' },
    grid: { vertLines: { visible: false }, horzLines: { color: '#1e1e2e' } },
    rightPriceScale: { borderColor: '#2a2a3a' },
    timeScale: { borderColor: '#2a2a3a', timeVisible: false },
    width: container.clientWidth,
    height: 120,
    crosshair: { mode: LightweightCharts.CrosshairMode.Magnet },
  });
  
  const series = state.equityChart.addAreaSeries({
    topColor: 'rgba(0, 188, 212, 0.4)',
    bottomColor: 'rgba(0, 188, 212, 0.0)',
    lineColor: '#00bcd4',
    lineWidth: 2,
  });
  series.setData(dedupData);
  state.equityChart.timeScale().fitContent();
  
  const ro = new ResizeObserver(() => {
    if (state.equityChart) {
      state.equityChart.applyOptions({ width: container.clientWidth });
    }
  });
  ro.observe(container);
}

// ============= UI UPDATE =============
function updateUI() {
  const stats = calcStats(state.filtered);
  
  document.getElementById('stat-trades').textContent = stats.count.toLocaleString();
  document.getElementById('trade-count').textContent = stats.count.toLocaleString();
  const wrEl = document.getElementById('stat-wr');
  wrEl.textContent = stats.wr + '%';
  wrEl.className = 'stat-value ' + (stats.wr >= 50 ? 'positive' : 'negative');
  const trEl = document.getElementById('stat-total-r');
  trEl.textContent = (stats.totalR >= 0 ? '+' : '') + parseFloat(stats.totalR).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
  trEl.className = 'stat-value ' + (stats.totalR >= 0 ? 'positive' : 'negative');
  const arEl = document.getElementById('stat-avg-r');
  arEl.textContent = stats.avgR;
  arEl.className = 'stat-value ' + (stats.avgR >= 0 ? 'positive' : 'negative');
  document.getElementById('stat-best').textContent = '+' + stats.best;
  document.getElementById('stat-worst').textContent = stats.worst;
  document.getElementById('stat-streak').textContent = stats.maxConsecLoss;
  const pfEl = document.getElementById('stat-pf');
  pfEl.textContent = stats.pf;
  pfEl.className = 'stat-value ' + (parseFloat(stats.pf) >= 1.5 ? 'positive' : parseFloat(stats.pf) < 1 ? 'negative' : '');
  const exEl = document.getElementById('stat-expect');
  exEl.textContent = stats.expectancy;
  exEl.className = 'stat-value ' + (stats.expectancy >= 0 ? 'positive' : 'negative');
  
  document.getElementById('filtered-count').textContent = stats.count.toLocaleString() + ' trades';
  
  renderTradeList();
  renderEquityCurve();
  
  if (state.showSummary) renderSummary();
}

function renderTradeList() {
  const list = document.getElementById('trade-list');
  // Virtual scrolling for 5K+ trades - show first 500, load more on scroll
  const maxShow = Math.min(state.filtered.length, 500);
  const html = [];
  for (let i = 0; i < maxShow; i++) {
    const t = state.filtered[i];
    const date = new Date(t.et * 1000);
    const dateStr = date.toISOString().slice(0, 10);
    const rStr = (t.r >= 0 ? '+' : '') + t.r.toFixed(2) + 'R';
    const rClass = t.r >= 0 ? 'positive' : 'negative';
    const active = i === state.selectedIndex ? 'active' : '';
    html.push(`<div class="trade-item ${active}" data-idx="${i}" onclick="selectTrade(${i})">
      <div class="left">
        <span class="pair-badge ${t.pair}">${t.pair}</span>
        <span class="tf-badge">${t.tf}</span>
        <span class="dir-badge ${t.dir}">${t.dir === 'L' ? 'LONG' : 'SHORT'}</span>
        <span class="date-text">${dateStr}</span>
      </div>
      <span class="r-value ${rClass}">${rStr}</span>
    </div>`);
  }
  if (state.filtered.length > maxShow) {
    html.push(`<div class="trade-item" style="justify-content:center;color:var(--text-dim);cursor:default">... ${state.filtered.length - maxShow} more trades (use filters to narrow)</div>`);
  }
  list.innerHTML = html.join('');
  
  if (state.selectedIndex >= 0 && state.selectedIndex < maxShow) {
    const active = list.querySelector('.trade-item.active');
    if (active) active.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }
}

// ============= CHART =============
function initChart() {
  const container = document.getElementById('chart-container');
  state.chart = LightweightCharts.createChart(container, {
    layout: {
      background: { color: '#0a0a0f' },
      textColor: '#888',
    },
    grid: {
      vertLines: { color: '#1e1e2e' },
      horzLines: { color: '#1e1e2e' },
    },
    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
    rightPriceScale: { borderColor: '#2a2a3a' },
    timeScale: { borderColor: '#2a2a3a', timeVisible: true, secondsVisible: false },
    width: container.clientWidth,
    height: container.clientHeight,
  });
  
  state.candleSeries = state.chart.addCandlestickSeries({
    upColor: '#00c853',
    downColor: '#ff1744',
    borderUpColor: '#00c853',
    borderDownColor: '#ff1744',
    wickUpColor: '#00c853',
    wickDownColor: '#ff1744',
    priceScaleId: 'right',
  });
  state.chart.priceScale('right').applyOptions({
    scaleMargins: { top: 0.02, bottom: 0.06 },
  });
  
  state.volumeSeries = state.chart.addHistogramSeries({
    priceFormat: { type: 'volume' },
    priceScaleId: 'vol',
  });
  state.chart.priceScale('vol').applyOptions({
    scaleMargins: { top: 0.93, bottom: 0 },
  });
  
  state.markerSeries = state.chart.addLineSeries({
    color: 'transparent',
    lineWidth: 0,
    crosshairMarkerVisible: false,
    lastValueVisible: false,
    priceLineVisible: false,
    priceScaleId: 'right',
  });
  
  const ro = new ResizeObserver(() => {
    state.chart.applyOptions({
      width: container.clientWidth,
      height: container.clientHeight,
    });
  });
  ro.observe(container);
}

async function fetchCandles(trade) {
  const cacheKey = `${trade.pair}_${trade.tf}_${trade.et}`;
  if (state.candleCache[cacheKey]) return state.candleCache[cacheKey];
  
  const symbol = SYMBOL_MAP[trade.pair];
  const interval = INTERVAL_MAP[trade.tf];
  const pad = CANDLE_PADDING[trade.tf];
  const tfMs = TF_MINUTES[trade.tf] * 60 * 1000;
  
  const startTime = (trade.et * 1000) - (pad * tfMs);
  const endTime = Math.max(trade.xt * 1000, trade.et * 1000) + (pad * tfMs);
  
  let allCandles = [];
  let cursor = startTime;
  
  while (cursor < endTime) {
    const url = `${BINANCE_API}?symbol=${symbol}&interval=${interval}&startTime=${cursor}&endTime=${endTime}&limit=1000`;
    try {
      const resp = await fetch(url);
      const data = await resp.json();
      if (!data || !data.length) break;
      allCandles = allCandles.concat(data);
      cursor = data[data.length - 1][0] + 1;
      if (data.length < 1000) break;
    } catch (e) {
      console.error('Fetch error:', e);
      break;
    }
  }
  
  const candles = allCandles.map(c => ({
    time: Math.floor(c[0] / 1000),
    open: parseFloat(c[1]),
    high: parseFloat(c[2]),
    low: parseFloat(c[3]),
    close: parseFloat(c[4]),
    volume: parseFloat(c[5]),
  }));
  
  state.candleCache[cacheKey] = candles;
  return candles;
}

async function selectTrade(idx) {
  if (idx < 0 || idx >= state.filtered.length) return;
  state.selectedIndex = idx;
  const trade = state.filtered[idx];
  
  const dir = trade.dir === 'L' ? 'üü¢ LONG' : 'üî¥ SHORT';
  const rStr = (trade.r >= 0 ? '+' : '') + trade.r.toFixed(2) + 'R';
  const rColor = trade.r >= 0 ? 'var(--green)' : 'var(--red)';
  const date = new Date(trade.et * 1000).toISOString().slice(0, 16).replace('T', ' ');
  const pColor = trade.pair === 'BTC' ? '#f7931a' : trade.pair === 'ETH' ? '#627eea' : '#9945ff';
  document.getElementById('trade-detail').innerHTML = `
    <span style="font-weight:700;color:${pColor}">${trade.pair}</span>
    <span>${trade.tf}</span>
    <span>${dir}</span>
    <span style="font-weight:700;color:${rColor}">${rStr}</span>
    <span style="color:var(--text-dim)">${trade.exit_type}</span>
    <span style="color:var(--text-dim)">${date}</span>
    <span style="color:var(--text-dim)">Entry: ${trade.entry.toLocaleString()}</span>
    <span style="color:var(--text-dim)">Stop: ${trade.stop.toLocaleString()}</span>
    <span style="color:var(--text-dim)">Exit: ${trade.exit.toLocaleString()}</span>
    <span style="color:var(--text-dim)">Trade ${idx + 1}/${state.filtered.length.toLocaleString()}</span>
  `;
  
  renderTradeList();
  
  document.getElementById('chart-loading').style.display = 'block';
  document.getElementById('chart-loading').textContent = 'Loading candles...';
  
  try {
    const candles = await fetchCandles(trade);
    if (state.selectedIndex !== idx) return;
    
    if (!candles.length) {
      document.getElementById('chart-loading').textContent = 'No candle data available (pre-listing?)';
      return;
    }
    
    document.getElementById('chart-loading').style.display = 'none';
    
    state.candleSeries.setData(candles);
    
    state.volumeSeries.setData(candles.map(c => ({
      time: c.time,
      value: c.volume,
      color: c.close >= c.open ? 'rgba(0,200,83,0.8)' : 'rgba(255,23,68,0.8)',
    })));
    
    const entryMarkerTime = trade.et;
    const markerData = [
      { time: entryMarkerTime, value: trade.entry },
      { time: trade.xt, value: trade.exit },
    ].sort((a, b) => a.time - b.time);
    state.markerSeries.setData(markerData);
    
    const markers = [];
    markers.push({
      time: entryMarkerTime,
      position: trade.dir === 'L' ? 'belowBar' : 'aboveBar',
      color: '#00bcd4',
      shape: 'circle',
      text: 'ENTRY',
    });
    markers.push({
      time: trade.xt,
      position: trade.r >= 0 ? (trade.dir === 'L' ? 'aboveBar' : 'belowBar') : (trade.dir === 'L' ? 'belowBar' : 'aboveBar'),
      color: trade.r >= 0 ? '#ffd700' : '#ff1744',
      shape: 'circle',
      text: trade.exit_type === 'stop' ? 'STOP' : 'EXIT',
    });
    markers.sort((a, b) => a.time - b.time);
    state.markerSeries.setMarkers(markers);
    state.candleSeries.setMarkers([]);
    
    if (state.priceLines) {
      state.priceLines.forEach(pl => state.candleSeries.removePriceLine(pl));
    }
    state.priceLines = [];
    
    state.priceLines.push(state.candleSeries.createPriceLine({
      price: trade.entry,
      color: '#00bcd4',
      lineWidth: 2,
      lineStyle: 0,
      axisLabelVisible: true,
      title: 'Entry ' + trade.entry.toLocaleString(),
    }));
    
    state.priceLines.push(state.candleSeries.createPriceLine({
      price: trade.stop,
      color: '#ff1744',
      lineWidth: 1,
      lineStyle: 2,
      axisLabelVisible: true,
      title: 'Stop ' + trade.stop.toLocaleString(),
    }));
    
    state.priceLines.push(state.candleSeries.createPriceLine({
      price: trade.exit,
      color: '#ffd700',
      lineWidth: 2,
      lineStyle: 0,
      axisLabelVisible: true,
      title: 'Exit ' + trade.exit.toLocaleString(),
    }));
    
    const tradeDuration = Math.max(trade.xt - trade.et, TF_MINUTES[trade.tf] * 60 * 10);
    const viewPad = Math.max(tradeDuration * 0.5, TF_MINUTES[trade.tf] * 60 * 15);
    const viewFrom = trade.et - viewPad;
    const viewTo = trade.xt + viewPad;
    state.chart.timeScale().setVisibleRange({ from: viewFrom, to: viewTo });
    
  } catch (e) {
    console.error('Error loading trade:', e);
    document.getElementById('chart-loading').textContent = 'Error loading candles';
    document.getElementById('chart-loading').style.display = 'block';
  }
}

// ============= EVENT HANDLERS =============
document.querySelectorAll('.filter-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const filter = btn.dataset.filter;
    const value = btn.dataset.value;
    state.filters[filter] = value;
    document.querySelectorAll(`.filter-btn[data-filter="${filter}"]`).forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    applyFilters();
  });
});

document.querySelectorAll('.sort-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    state.sort = btn.dataset.sort;
    document.querySelectorAll('.sort-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    applySort();
  });
});

document.getElementById('btn-prev').addEventListener('click', () => {
  if (state.selectedIndex > 0) selectTrade(state.selectedIndex - 1);
});
document.getElementById('btn-next').addEventListener('click', () => {
  if (state.selectedIndex < state.filtered.length - 1) selectTrade(state.selectedIndex + 1);
  else if (state.selectedIndex === -1 && state.filtered.length > 0) selectTrade(0);
});
document.getElementById('btn-random').addEventListener('click', () => {
  if (state.filtered.length > 0) {
    selectTrade(Math.floor(Math.random() * state.filtered.length));
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
    e.preventDefault();
    if (state.selectedIndex > 0) selectTrade(state.selectedIndex - 1);
  } else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
    e.preventDefault();
    if (state.selectedIndex < state.filtered.length - 1) selectTrade(state.selectedIndex + 1);
  }
});

// ============= LAZY LOADING =============
const YEAR_FILES_RECENT = [2026, 2024, 2023];
const YEAR_FILES_OLDER = [2022, 2021, 2020, 2019, 2018, 2017];
let olderYearsLoaded = false;

async function loadTradeYears(years) {
  const results = await Promise.all(
    years.map(y =>
      fetch(`v11c-trades-${y}.json`)
        .then(r => r.json())
        .catch(e => { console.error(`Failed to load ${y}:`, e); return []; })
    )
  );
  const trades = results.flat();
  fixTimezones(trades);
  return trades;
}

async function loadOlderYears() {
  if (olderYearsLoaded) return;
  const btn = document.getElementById('load-more-btn');
  const status = document.getElementById('load-status');
  btn.disabled = true;
  btn.textContent = '‚è≥ Loading...';
  status.textContent = 'Loading 2017‚Äì2022 (~1MB)...';

  const olderTrades = await loadTradeYears(YEAR_FILES_OLDER);
  TRADE_DATA = TRADE_DATA.concat(olderTrades);
  olderYearsLoaded = true;

  document.getElementById('load-more-bar').style.display = 'none';

  const currentIdx = state.selectedIndex;
  const currentTrade = currentIdx >= 0 ? state.filtered[currentIdx] : null;
  applyFilters();
  // Restore selection if possible
  if (currentTrade) {
    const newIdx = state.filtered.findIndex(t => t.et === currentTrade.et && t.pair === currentTrade.pair && t.tf === currentTrade.tf);
    if (newIdx >= 0) {
      state.selectedIndex = newIdx;
      renderTradeList();
    }
  }
}

// ============= INIT =============
window.addEventListener('DOMContentLoaded', async () => {
  const bar = document.getElementById('load-more-bar');
  const status = document.getElementById('load-status');
  const loadBtn = document.getElementById('load-more-btn');

  // Load recent years first (2023-2026, ~210KB)
  const recentTrades = await loadTradeYears(YEAR_FILES_RECENT);
  TRADE_DATA = recentTrades;

  initChart();
  applyFilters();

  status.textContent = `Showing ${TRADE_DATA.length.toLocaleString()} trades (2023‚Äì2026)`;
  loadBtn.style.display = 'inline-block';
  loadBtn.textContent = `üì• Load 2017‚Äì2022 (~4,400 more trades)`;

  if (state.filtered.length > 0) selectTrade(0);
});
</script>

</body>
</html>