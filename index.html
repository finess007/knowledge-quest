<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fdf314d8de3eac7cc759ce493142a303ec4aea996f65df54556b55ffb7cc74ea4d4334bab198e04f1632ef64f2616540c2e76852c22bbe712438e436ced5da2a7f73284a801a923d4bc0f740d1b1abae009bda8cf8db2ea080f22b876c76bd3e4481765961d32a72d34e0408d8b5a2e321b7cc3852047d4d3a7aea37e48e6e72d878f10de33f9ca282aaa3f57bbd5fce1200b1c4ede154ecd7ada1dea92962bfd9fe3b2965a43d1d661dece3c70fca8b46dfcf7e5a8fb267f73c56127fd9101ac7a4a6d2f54daa5dc4aabbced8059087a9d40df8b01ca58b102d8dae5d09dbf6db37ca6fe15768d79a0aefe018d5851efb6998494676021fd418064c757293c91b7dc973f2653e5b84e38326d3cbd8e176881eb4cbd42013284a8085d4eaf45f278a2f082be362d13e185e159880c22a422224276977c36b139e71032dc443b61c99a16c18e198e017bf6532bccaed45e0f057667b2e324f46b0c59701cb30f7cd49958d1f68356f296ffd73b9a783cbfc6f74f9d06b6a03b42072dff92504e48c774759d1579595383acb7e1232a8385ae279fcb2896a57e8d7b5744b97aa8614cc4c0f2bac8e55c979c8d6b179be85469ccb1546db53438bb6e775390a19399938d0ca14dd597ffc4dea20bc52b8b81bacb7a0b3428e3ebf732135df46d957b8c69c3f3eeeeb5fef9d16e5c544ce03a625bd1775b51a73b36f4891f8e630a8eeaa6f489d85a07bda2a94c75641d93bf20f6ad86ef9f3a9788f8e822b740fee8c1586665b0fef8741ca316352badd4b6cdb80d38788123e7a0d63b5a879f4cbb0078f833c10be2e7c1ef99cb1ea5a97b1866520d904de736f73d11864683c7a4bf83e0a60646743cd81f105e3e392f23e79ab069e421fcca3b9c3d7685218b58070142075b7d0c5c98812e0d3e36d99c267b8e71f3c8b1d2eecff3e8828e93a93d80c7dc5a95ab31938bbe86eb326f37189659767b456d4276af2e11f103dc0b64946105914e327e86621d144fd964ce2c8e5ee268dceb2b5ae08743816a2cfa581ec170b1a539f64a1940cdc3668629e0ead94de0089d5d35190d7ad31d928cdda998eabdf3f4ab9d482f6d08569a8eafb5c1353697e91f13bbcd4dea005126a5cf967fc3fd4dc151c7608db0e6d584e6ea782b00baef1dc201bed96c65f0912153925e8a9098119e45e4e3ea803fd1c0c7f1464a2dc6b4775fdb4e6872c2ff4480b99611d0c80e45b8a72136275cfa4ee2cffe579499a2fabf22791c341eb37bc57ab33aa842215cebe345f5e2cbc47d08ae925c72817d9d271293ab9cfc1a6f19bae2b01fa7dd459d7a1cc67f517e9fa1a5617d85c2bf55e725c235c99eb9823c248b07cc43413064d42f991293b5f2284bf6e637f4a8e5afe8ef8991ff81be2d584b2ad2dcd66cbf1cacf634f55aa888532e9bfa4c7ab0899fbb3b54ce50bf71f19e645710f36931b777748530f9f1d3a5c53756842caaf41017532a2406c7ab432ef99a656d203eca1e912c51265b971a71337798bdee8ae10a175a1800461e40963508780e8ee4ddecdf5a17d136b6816a07c5acbc8ad2d5e82bb60567fe1f06450f6bd08a82a91a20f768ca2106e9b48b71a02776b72ed81b56d3823cdceb14dbf11e12da16afaa2c120336522f4f0e3e62fdf8fe4835b4bbaed7eec01d58aad6f995281e04c15d3b24ae04b7b4e9cbc5196d75e408555cd9a0948bd6a731cd91d2dd284f3c139dda816481d1d93e4ec04e14819afa1ee17f0c27229d0939c07d843b325fe498b74da224a1dfdac6c1117e11e640dfb0bb5da047a53af10a33d7c152737e65982239d9c89df7fbe10afc96b11b68436bd5fc003be45c9e360679ef976b213aaab4f33a2d0f5de6396378c7a665720c9a2486c352497dfecdbcb09e3452f88472fa1f70388d714a8ec7f6ba428d04c1d641352454b0949150b97c3acb6766ee9343be35e829db412d2d904e68f62555efff8e1db13957d36e936890a13054fb187b0ebe2268e0a034bb40b068be10f91cd7975a7d68ae0084a6028f8f8b1b6dbcf9f4aa7b268ba72634f57eb5c916401afaa694785eb87c4bf5595a3583c19b33ec5e1260537cf61b5c08481c317eeab88fcdc66072d9b8e41097ebbe5355376abdfcd4a609873e2c75e7013bd0c1ed3ef10169939d47170d6742b0f1cbc592bd8e2c8392c42877e3d23b9ad010efb4710d714342af272e241a2420643124e2b421373ea322b28d8c133e0ae45fc2b9e625545e59b1138eb05730a41c778f3d1b243b23f2b6ff3cb703b8f227357dfcf08e84684e90eabbe4b890bfaf05497f3c475da8cd1e73f66976d44dd082957d9797c674100f7cdf9338a39ef9a85eb2db155d9ec2b9c7fc3776b93de4afb43f644e4e5adad70fac49dfeaac9ff844eab76cc73b070dd11f1c2508cc1bba9af7d99be47228d1970fc15b9e79b2b69133fba77225d14c8a8c62d3eb65b9f7d549bd2df58b9cff29c9f886c3bcbff4aae262a963b731c84b2e245a559749078334ae02f69455060a0631954660137bd3ab296b77150288c1c0937fd9b444a90f7cb21381460c036f661569808e99016ba75311bc38f94c52c5a8c4210bf8a673e13158b8887632973f82d543f9a26e252806e2c03e2564ec71b0d9f392c95852a4b70e3ae8d4ace215887e3e894e2d0f41d46ade0b09fb2365e8f1d3269e87e352e327c7c6dd157e09d9cf2dbbec9acaa5a91faf3dc0b7d9dadd09bf3a337afb6f4df9e4691993b420be1c658c5d267e1e42ca3cc947e836af493ac5a4594b65220fc6bf59ddcf0f15a702f5bae958bdfd073377f79b59b59afed246b396ddfc4f3a2c4580b2b80851987569a8fe0b738c1c7d40f5376126fc2498c5c48c11837e2c4965a34b2788fe2cc4b252285a9d34aa9a6284ae9de9e10b19b54a89a5e8f56c6ea0e3b935b66f3a9942c36c5c3300072888e6ac0b54224e45a29aa65d390e9ddf2444e12e5aeae96c45c1b34c8d43bd0f8ccb7580a4f3bfda29b6a2690071ee028bd648bea3d596a59a1daad8b59278d709881af4090f658aeaec47a0746d4b18a9f8cd980640216d64e084f5450af1d10d0d7b488836e02a7f03be144ab314d597a43683179d127e33535b2826a564ebd1ef54d4dc7fe9eeb1d4dba26f4bbac2c3d949c421874283dd6835ba0ed9957d2855388ab5a6e255f96cb0645c21367bf995c0e881388466b8a56bc580f2b324ff923d78cf3cb63038162030d0d67b518733efed13d97296714b2985e6d2ca611fae0f374c67e2140d8759ba329b2b366cb8977b883d91ecd987ccaf2ab5e76c3a40062a0b2468ac3cbd7c3bc3a74a45634b5fd9d69a2e7105599acc6b071bcbe25448377a548b388fad4b934b761fdab9de2c73ea3cc7aaf5e05ae633e2bfc31f443e7077e89698173fc58743faf6d423f78b80929297af72dc4ba5f0e6f2e482ade0b6438dde4df7baeaea26a17103e09267dc449958021484d10357ef32e50af0d73864ee6ac56754d197dda411b62fc911b799cfb1735a9b14232a61b46c01102b22f35672a003105d99d8c12b247988aea0b9a45c599b3047d069c2f293f3b39fd510034c54cd386bbda5b6ba05198c605e46b58a03b96fe7a5384f1d9a6f132a87448e905fe9b269dfa087527b21e5bccb07e7f62d9d7d5b533c422e95b4808b0334153aabad9217dd8c913fa0759731bbfaa4d2dbeec9621c11f95c6b52157e335b0159b32d0d148fbb8a2260dbb32e2498512b177aa80b6a5355ce5424c09154fe6e4d519fa719b31b2221494040d9a09cc556cc3705c1a14f6c734c4559bfc5eeb541ebfbf785bd02ec787796b1d081e602e409f2c9f83adbd2eb351bf61252c1b7af9c486f36be9c148ce3efaff6bdbebc0e01e22d31b9e8162b07929ac1c540cce0dda646f906bb3cc2f7c553d822d8775680d469309dcd652b04a44c052778407b651efee5565a6f4ce7e6352db26991a3e843b71b7453166569940e3cf640b278588d4a5d33eaafe7fbe234fae9a5754de410b561ad0c96cccea8a13467662e61c66f0bd3424324c5d6f948c13d6720163143e6729fce845afaca3e46ed235bb31511da00bd363ac56ce534b58173562f5c3b000bcacda8ce97e6d4228c7952e5d4da09b1f01f35939d4afc67d5966b2d256e79c01d2f24519fa0e3f192ca45ebac63ce3a9c3bd222bb4ef2870fa56bc66ad69bf4f7fb35fb9855c5082a82467ff27203cff239e18a4910951782c01e448ca4544a72264d10ca9f3c932446e7526552bdcfbcbd3039d1cb639cc47e739fcc0c7f6431c395fc4ee6a87d51ff3a1b14745e470e1d3074257638ec48af7b6d48f071cb09bdd33ac1c428ad3e8805cbf28c38a63bea216a247d1baeb7792efb15cf68deaf1413ed5903fe3ce44ad2b144f6b48c37c49a22017e782266c5bd1746b34cdbc8481893133b843fe1729f48a6bc6b4e1d69203537eea274c6928549edd2420ba99187a3d9231823b433061ffd2b85c0872758323e076311d6b29163134cac8860fbe3ecf24ebc519832abe8cef0e60c453651cca67612dec1b108b92fe9985c1abe364927c5d5d8b8dc3763849fc661da859851259adf45a2665856633ac6826b8d3dc06eca91ca5dc38cdceeb49b1ee224bb69853af44aa4ccc98caeb65a722cfa11079401762b8a1e84512984b498029878271de6f9defbfa02982e6c4bef30a9ba61cc38f15c8d74a6b993fed8868d839749764b07a75874deaaa8e77aeface05336d52e5e2d5bf4f062b6e7d3e4dde6352ddfb5218203352d7bbd920af1cb25501049b315f63c05d1b7feac92a0d5c876b1933c933f6d09914059e14c8be2398db65409d3f492f470ad6f695b243e16427d49c7f95b0231d73e6a5fc8b7973f47a27cd8ccfd8d97c5bd5c374cb8bac222f9acc9c798110576ccf9c1d6f9ccd2876a6384df2c26f0e1959157a8e484e93a077d608884fb33ae16aa358903773343db7886eef9fdc5f4234941dadd373afaaf9d505c858e5cad784aab2a55fc2f293a09d3b0e4497780805b7a6832300a9c3e392d4feb8930e039ba7c48ba7fcea78206a9e8590e7e09111cc76d9c98936d43ad98411826edef9f6dd42a80df0067df86c116c66c332954d0cb5cfbc17c3a4bf6e01f38667cbd8fa0d47abcd2e9fe9e564795f1ad1927f29bd4859256e4892f70d42c2f87798d9ccd2263f844e5d0381df2498f046c2a454b3024934bb8e0836dc0eae77106212be325fbaf6c27fbccb38989091bb7baa0132ca3f3dc35983af7d567b7d4fe69946fbb073e4a1a952b66413fe8a8014ec8f08e43505c716359bc56933823a95d30452dbdd98d5c2474d0793777a70f01d4436f624bf7b4ceabe96e3b721ec2fc8179a4dc4d6c8a9f035ea28f69c21c37b6492062964d0d0dfa87fbe51d0c538ca31c4d6441b670922125e75ec236ae6e85a3a8303147cdee547adedb8710b24880e668c90e33dc94f38b1fbe75ebe945e5ea036e137e4bbb0623e7d36c1e129e694217d919d85b2d1b09b7fe057d1f001cc162b6e9f5585a8aecc351927f6c41d840b1baa6ccf9df77b13cdb9cee043ad78d7ad682564dcd1f9bc6efdaade77298f7d20790bc1fb772a5caf6250bb66e5dd6aa9ef16dcdd20d7e9ff045fb8e235d57c41f6ef66ce11c614fad4e5d9f313d16933e0a5ee7301ca60c968d474a332519a3656f565a1e8952e62d04cffdea3f9f589b23530ae798d7318dbabf8e36528b0a60fa5ae1aa2a052063a989b5c7b1018d9819fbc9d724eb08db91977daf8a543e015d5f09ce9c43bd7f5dd4c687b21e173f8a9a9bbb7582f82b6cbbe5c447d86b453ec6754577073a912b999817b17816656f7c789f40568d14277fcab0210f31890f49e5262a5c22dd6222b2a7628b5ea55feb94bd6450b2589587a16af1df24b2a941090bf89976216d4027a501d6b002bf28642c102b242ef0ad3296380d17cda21ae9aa8606b3d549e2e0fec0c0ba32c0a640825e99db9268736befb7d25f8ec40f839d31fadfd222b9f5e01e35dbce574b6e926fe70b4ba8dbeb820916a0fd8b28a11da6d624d863e1166d720f961053ed60cd94ae3ece97eb531f121c36ecec4916507b739c50c893f307c0093d0e3c2e18660e4e589b5220b2ebb9de43bbd7103f32b6a0e511c63b59a8c1ac8d8af2fa79d7dbedf03ed246d2dd71f62c6d287910b5131ee8c19230a88c5c97902755b697a4fd17f3abb4771938b44eb0dfb892023494479f41caebb8ea96689c641772348fe7dc1dcc05c9cce516ca51db2b31a14c7b38baf9e7bd7f1dda71fe0c5463bb4c8a29956e560f87beb63c19ab75182c9d06d55c41931f7b8dc219540c48be854a3538d031038eac972c0eabbf329e8591afabea465d9734858341c6c51532b3829ea9b893033917be78b7374f1388a37420308e1868209197925cf8061039d646b7c4e2208257d604ce387f1352572631e9c10facc96d5f20db5eb62c053fe97326514d4bc6900d81fe2a47b8a024191449df5cd731532c31261c1c4ab171af157051de0c626fee76222c8f48b59c8d49787e53879341a3a25b4b5338fe529661cb56341dbeb300abbeed8b1862d17948db77208a541b4d657836f373f453156dfd11a44406cc5190c4acf55f29af36f86bd90ffa911c9a0c26eea012fdea9c1c65b0db1df550491f038dd4d6b41f7ed775e21d455aafd462e337964ceb9474ccc7eeeb8e8a96a2160a5f7069a140ad6e0e00a14b4e09d9d8f18745ec833eed398a11aafede4aca30ce172ffe6d742fed2a09400b59d5d835d12f29f0ca552abba497ddf2947d1fa37e903cc74a9ca41c509b720d0d7228eb5ffcb0e4baf8d321e9bcb5d49bbd013a1543593337758d112c68b5c236a9b2502d0d8d737b75b73cbadc94d1aeb25fbbc0b5bb454a2b41a096a143124e09e047d9008bd4971a451cb6cee851c29bf5f54b74dbeb76e47634800dee832b63222bdbcc6331198dbeba7c7023abb6f0d872de12f965373e44656c409b31051e42ba461b3eb48178915917dcf0b71aa5da5d6e5c7bfdf9e255d8a5dd003683269ef00a7d6525978d8a09b88d38fcd3444e1094ed6412f731782071ee0a9b178e74ea55fabcfd6f2651126a9bafccc44562223d0ae35c4d25e636caad6ce38a630077428d5244846c1663fb2d58242b657278bdfe7921ecff80fb8296dc2399e74db9edda0b24ff3a39edac796c4e1fd09c34deabf2daef4d44211b731c6bdb0b14824cd9b0acda0469a6f63712a5d1050896607d4b32e557650e1893f62340a0fb4c37751d60057e013b6b6ef3c306503f78e78da66f704efbfc6ab8b7837cb666d7845a604788c0b1eecd48b442839566d47714f21ddfe62955993a1eef319edd4350e3e7751d35a3c8592801802b4a18d4069224f7af35c4ca18eb6324a03b5763bae31a35463d1082284e7db75a6e8f8f57ae16a833b9e2dec280ccea23ebac6acc7691765b10589f51375db0e37437168a7719df33c4852ce6477eed8a1aed4b9c0f81e51540222e8fca7b91220102ccd6168842dcec2c1641b2b3a034388c1fd7d024db46a9ce58b02da08e3c2d7ea92a5da3c22c38f0cea98c838713ae618dd6688a343a083842293262132b22c6d01b7f2ba674bc99119749d4cfbdc761a55c4ec181df5706b07941528efa97bfc6c4c6bded95c8111e47749940d14492571b574ba91c7def5cee25bac88a13de2f74abf206619de24c673a1b6042827c5738c6153cea7b6ca6211329d21807dceb298c1e0b79b9f43e4328b82580f357196de7f71ae8ed59f8fa2070b3d82cf763c099536978c7d74f02d37ef2f12d324d442da3a8bc2b0f1997445307b28df9feee49a57427669a41d1ccbcaddb2e87b70045b0bbac08a53206056af850833821db55dd3177920308351893c2ae47f814bd7699718c96f660623f38a1d2ac8aa76157cbe9ae3d26566b3db6f69ecb217166fbdb3c6a30dff2d92975cfdd5fbe469b7bf36ccbfc32fb51ab8c22a3ceedac8daa38d2cbf5bf5eb6d235bbff8d83135dc9a310249c66b8afe539e9bf6879d9615944f2a1a6bceee8d351bc9741dab414ec7d96374bb272d804fa4998f0741f5ff72749fa0e838b4b0146d0775d6efb86692caf2c7bcf617c7ce20d94691c9c3dc565ccfe18360b5416da389ee6ef0590276e5552bb8bc0f846178aeec85d08db836a21717790f5349f8e8e0d2a1f2322772ad508797794429952490e7c296281f41a9906dc64d3a6ccfcb9ed67f59744b6a3ac09d6deba36b962ce2167a0b5334bacf7a24573ff1abce682af0aa437b4cc454352ba128b9b51182292e6c59e9ed7039dfbc3076f421c2c2dc5558b1312b2db7e3749930e75696eafbebac537a014565f3ee13a43542dc2701d4295bbcd84a7c45b031ffcb37d74f9b5911e02d70bba207ea66944339befb6dcf1549f858357f8791bfa8d4ca6584b2041be6fb51ac7717a4fec6f9711827997e5b3fd94dde07821182d97b354fc0694539f0944f484d01ec818dd02b0d0326b6bfc2941d0a88fd26803fa4dec3e4550a24e7b1942724f7a1eb06c5d4aa39138d674050d68beca61250f02a9d40905c6e4f4abe443a9e0712b5745c8ef665894b56568cfbb2a439527c2ff6e64386873af6c61e156243c06bd4d670b7714b7101f5e59743b9fdd4d55e918e31081aa44beb206d7f6d16a5fcc70175806f011d7055a461675d7fa33044dc6fc3c5872a0c38bf4800b6645f247f1e4eee8086c3937d3a7f532e3f31038b9b831c36694ad625e1bc1698f1ec57512f1d552e2549a9d9af5dc191765be922226512b36426e1a7e4f3234e9a3b6ac717bfa95e779fb7da525d93bd48492df24dfcd569c6f3ff699169a36b35db0b5ce2d5b3cbd1b85bbd65b1b636111789577d9f14b4de62072e49cfd28c4a05b6c9ab7871dc90615c04aeec9bd8266cdbf68ca0413d3aa6f8937ea05468c1823f16f5cdf6331e4ffc3c45cba3ae326b27bf5e68e4ca254a06fd5ec60eac5d8c07a6af748206f9f5cc2c631d43986ffa7120f9b5569c95ada043feb106a3b7f913347f5962b480d484a5ec4d1fe658bde3027b2ec6aeb178066f08aca33eda5622cfadf38a8aa526315e0ae99f9c9376a9592d1ba62e1dd1a372d79d4e1b5dc9939b17dae0a4f546eec4cd18b9d88d9dc46b97d3afdc6b57f7f77e21e9d121524c4296fb737966f0479a3f337f65a3e7d2c793047a5fa6a08714894d7161ddbdd29b12ac40c767529cd40a395c4a44e5c218dc22e39eb70c755349047ff2d3547e1a76e9712cb1a36a9051d2315c7cf653eb8d8c0cf0e70e3b8d36a7d71847508a205955921f27d1a604b751ffd083cbbfb9e44b9e13ae59bf70985d1f2b491d8df54ae497983f3ae2df4e25d17d5023b8cacb076cbea801d3b0b63579667df9e07f0c95a44baf7f2762cebec9caeda65ec6345245ddb0871adf27e298e42e804cf458f1900f23a7df38756ca5a8855ff771479047735ed6d3dc38d1739fd74258d41cd1a6a66eca4512f23cf212a362bf71e5bf513f466be131a6fba8a7d3a5ab0e9337a63503a036b4b2f3b66e51756ae5f47f1aa6f7048be32c53c060cc6279bab64dbfd7ca4ada79fd67d6a2daecbc52bf530db28ea6808583f4098cd8ccbbb485ea172cb04bcbcbbdb5259eeb377be8bae5b9e512a3438433817f703c1c402346559844546d591e56900b079bd4a1eabe24578a921dd41d74a6e0f99c4d14c336a265ec6092d002efa321ac472725586d6d3173529671bffe76879858413f23fc5e364e54e2e2be96f8330a63d653175afde3db1a336be726fea7e4d2f650c5483b1d9cc7a69a8da1ddd7eec361212409d030f8f43f262890c3a149752a5d1b2d49730e3401eee9e8193a4f4ad4dd8fbba12d8ffb42567c5ab5ce5cf0dd757f2458c3b835222429d36a1ccd2351138a1b10359f386a58853841829a80a5ba0b9fc5131762828fe71090fed882a4e2fb9c77bdc182316bff9014020d967befab45ba3baebb24cccfea4df6369b16d9c84ebaa9a67254e6d032d265a0e28a8401d35dd197ae1748aa1ef60909c671a7666fe8c6735b864554a5210081a2273e72c3fdebdb747487ae3041cb8f9c7024209042e24a707631f1e7547eeab1cd33e19c8ac2a30df838a7c5fa0dc4cc7e67c95f2072444df339b8e83fe9c1e3a967d1e27d35b0e80be717021818bf9b02fc91192ebb50d3fabf9d3842a77c4bbf75e86b1c1ddc8834f02cfc2772b138410f9d1eda34c0329e7aff5c20ef5541a1da5e042bb4d6177e0f7ab08266268ca89e2506fa67b33810299192e55de0ecea4ceec35344320d719f0fbb8cf046208d04b27e12ee3401a55c4349b18d9637ae902a58207a575239a75b0db7a3f5e65529a291e0a6abfe5b38ac1cd1f90e0a18fb4b2c3cf5518aeafa88aad65fc23d195af6c4f087fd29a143745465e78cec98d6c9568625802189312908b060b3806fa89ec41143e3e78ede78f38847a693f6f1e53d9a291c9868ea8b23d61615a1ef249a1a764181369deaee8692a96f359be305546e2d5c6706371b3a52fc33a380a9b43de564dbdf8008b411164d94aaff67a4dd64afc18faea0f52500101498e0a9802edee37542b18ac8f3949b2e409aa2c8e4f0f0464bf4300f9dc063f5db6e09b69d2853ee61dbc2c114710d8899b334e6b5cc7538102ca28d0ae692b511666ae2b2137b153d402b7b53a88381e7d70bfc62f8d2edbdd84837ca3a175f52fe7f429de1956952731fb4493181682e3c5d1eee98d4e373986191bfb287a678309a8c27e9ac8761a44c5d6c039acb02415ee4f02d43e0870c4ca1669cbd02723a3c2315f1685da3779b7896aed2f0544a3dfb7b4e3e7d281dbfa69a6cd685dbe7ef1eda0bbddaea9a4a3c3d3e9a1c67231c722d7265290d53f61ebd4af2fbedb5371714bc9db0d5145ae266470d2a83bab9ff729050e24d091ea8db6edccdfcaf9b6aaf4d69a11a227a3a195654823f7dbf5ac082782901fc0eea64d9fcfc354a7520e335a3ffcc895519175311ba675ef9f435e87d5131a3d8be20ad1a9462cb67e6485e47beb933a7875e180102cd80a109db4c784db7e3db2f30110d2e088ca984f35528fccb6523d170fa408fff7da9ab118267f4d69129054c9185eeb1f3e24e86f29d2e98406b66a6135c3844876477598e68a249d81151692bc93f240f0b975ab81ffb8878920f5453275e7e692cd0ce86c261b6d4282e9cb626ad5f3bf9423dc6f830d8284a0aa6d69b8c8763127c3d613adf48c23430802c9454f44b26a493847e64da4b21720e07ea1b133939d56988364d76b09de68ef9a5f30133fe536810810ca99c3f6e50c1a5f4f9262674c1cdbedc58098508b0a4672175918db628bf05e8474c833d19423369d620a27cde8dad8ea5fdb7ecf4af71ac72a8e837db194fff6302e4569d002f6da410bc2a74a229ccffadf3e699727e8636bfe55070b498b83f9b294fa942987600329885ad35c98ac2eac7a363495c0004b8cbac9322e5cd461a629b50feb31ebab270b0a899257a720a2ccf8b386c313c905be2e385b6d481dfe93839c75a9c7cc2ba0d436c0055eea492036b612c8ea3d2875e00bfc6b31199482852cf3656e67d87cbfe021d439b00a5c0eff54cffd5ad58ac1bed5dd4337be15219f1a68d5f96d07dbebb24d0e45d9ddf73642002bda09f675da3cb69ebd482fd1710e5cc928edd64c320173d8ddc2a0602539800a3ae1cd94af5f81d292f1382e03810726acd01e5556190d1d05a82f04974ad6396c0e9b1b20a52133aba0457deb269a79d251f8aee904cca1bad48341810f1165277a82b5a1d98fcfaea3b8476b20a2cc4a12e9f7535261a94ca267dcfe3549b837bbce0db362ef162d4640c05d44b42808c9f9797da39856084c9947396888a19b555076f0573cf84f434335445f846b48b32126021e9ee4cda2ce91d32f31213bd710ae4c4e899cb08bf9e3d1a4e29bb81fa3031db91b3ebfd0273ba7696ba13107f579863aa0505f1c23ee8d65f9db0c7f4ec5369c4acd8b02c16ad7b5ef018dbbb6f9fe43f26f8021e62b4916124710ce38d3b1d96c304687337d6d137f200a3a70995fbb4576d8d96554cba05c2cbf852e19175d0582e091e22bbeec7decc0c9284f366e147278d5eed2a9b1902e85c8e7e08eac1a4cd6d4a4bd5e2a9e1953da7f91fd1f28406a27af561fcfd9689560aaec8da9955cddac8d2d741449cc4a27c705de6f8f1774bffb66e73cc3362b89b74835d120090f439b10cb3e28b06e4717db0de8fc9dafd0e75335ce984510e84cc90209be0f23cf967587cb6a2b0cce7cd81e8e179376cbc872997283784220988c77ac4920a7d7868a5c8e30a7db7b0bc4a455c172385a9028feb0d75537f29c574c2e7d9786922aa26788c5c1633b585b25cc5ec3e32e668eda3a9041a507115c80fd3c2a6ecefca86a77926dc3037f247cb0f917e345581d247b5e8d4ff9b334692951693357e0cf29b4905d9318884654b63db8bcc6e6ab7e3983f94456c2bc51f92a5b0459fe9aa8fc858c2c9209bb7bfeb2945f68d1359e3e54ae77cb40009096abe274d3a5cee107c325bfbd6b4716626365209061840b2dba92c8ebf7f946833c326dadfe0c8581284e74aa5e9c87ef7f00e12da1cfcb48760ba2c051ce587d72e2d94d8046a362919c4d774ca209bbcbad7221155ee9bcc1b467e83a36cc2b67a41645a124778a50404a7a16ccc289440b80e5ec6b62d5d91da1e9f11cf1b47e2395ac84a89346c5b1586991c2c5aad4a37a15026843658c12904236d81e2114c0c5a981a695ed33cf69928695d00363660dfc64c652d8d2d6b0c49329a6c087208c8066bc15b82e5f44e77bae9f0152083a8dd8b34520ffacdfb39ab663acc5e6ec55ad6dd5022819684bddf20f9fb4ec049ecea34375b7c870e1c79d899d8f1378de8d5f579cccbb65a60931e98ae098ac3ac68914dd5fa587a08f0c4ea1314107cd957cb3ab378abb78363687cded1c53d8a31844c2537b7603be350a49696fc551d19c3d08ccb22419e06e4e49cc160fd5907798d5d6cd4ce54978873e518d23dc7d8519688e2321425230c0342873012f1c727ee18434362c554186f3f553503350c6676db81f599d1e870afbb80cb1210e098cb35247258b6e68af3ebdca047a26d1f4bb67d9573eff0c1b44144644d58394855fc5538522879b25aff21fbc6fbaf0bc9d9cb1d0a51c9c0991221280aef3222910ecad0061d90ae81770d0a252a9eb99dec1f89787ac28cbcde76a7dc4992790b976d4434ad0ccac869edce9b96a9989131896769e9e518f5b9408e331d337335729869518532c6c8cf1fd0832fd5d43facff01f61c05a853362141aa6226047f795a072d6c3d50ce68b6a8b67ff0dde17098987491f50660fb15a885ca474848e08d835ba0a4cca9a5cd595d9deea78d818e68c35d483dbaf4138c99cae5eb1072606b0b76e1801a9c90f4c182b32b45e5f127938dd416258f8ac0674239fee8dca0521d093ef478c97bf97b5ff6440f6f2d0e8203fb600e1e08257850dd4d59b8639cc3b43c9672146eb059c69b75c3fbc55e99c00b81db56c6e00d2317b691d7cc50b28e366827a7b79d940e4edeca4ef313644201aa856e23555e2b421a68d77581df76591ee38e2400df6129bce2aa2a2abaa3a378a3666def9e9891251c846b883650f31c2764467576d8e37880db47f44d380a9aefc371ed146682d40310d97e6359e969c1b01eb442ecc629e2fb1078670daf8f6ae0063df9ee1516d82b1d6bb62f8b8c2a2ee136255ae60a0e585a1a8079e367e17689e06a0c665f2af45d4537e7af8127da7be717ea6f75f69bc68700ce075f360afe8a4e0e2117e421503de8a9aac0d82dffbd79acc1a015e4227d917611f6511691fb596c71c4b2d335fc9c35d75ca937dab4399a8a28a4bff204b1444032f7f8cec5b23648ea777f0191ce9cf17ee156ebbfdab164b2ba3499a333719d85542879691900030ad1c92b48258cff82ed1a25ca07f24e6af200e75c6a9c8ff2adff413d3e821477fcd5aeb1009ebb17f60cfbe25cff12f5313914eae7864fce5c2e0dcc09ed2927b00f867174d18a9c0bcef20454a26c45cb589e8b7002adb2bc561a1df52bc3f7b5711db62a5498bfc24092ffca07bceb9fe96df3a88446e45d57e37cf68378badef1b0164296d8d4536c2a9ba4bfdec776bb6d04363925d4b358d67322e534b93d3f10730b9bd6882d6a0838657e827e6bf4f6e1935bfe2b9ce2af152a175af4a3223a9d76b0e668e36d48070e76e8a45d51900d51128ac4c5443adf5b235433b8ba57f274912018414c232352377e15ca88a9f7dd9ba92aa8565d801f68f47a7932b05493bef711a88537c95c04e7a4f80d786d0e6668fdfdbe72c9cff5f7d01b33dcacc445ff5dc403f9c12c35cade763571213c7f38216b1b519a9a7a3fca3181b75b21501639a01d50b5221e68082cba3a6a1de39eb944a7eca90771cceca5c1a01be852a29a88623b56fa52d30cf9e9799632ec6b50e1d3dc3799d6f992c8815d1a8dea110cd4d18b62872e1e885f85b8dbe8dcc45f48970df98b20fdeebd381c065dbfce5117fe952e03d4121eecfba6ccfa0260debce8f446054a67dfc81a74d6c9a500b30d8fae14f2440cbed898aae4458912e0d6a598db043d93871e2f22ca53a79fdf55e277f3196d1494d618eabdc9a9a2d72f62cfdb660015618722c4f2c975fc3b284c283a361f916ccb44acfaf10d30dfd3be0783d41a6060eecc69592feb408484d6e90c6ad6e0eeb923cf48d18c217e86b5ef65c4d5ba333c5ca0fce4adeb7c3cee33dca1d04f48e78cc3641a7febd8b5ed6722e6c2ca1b809a228e2eb7d9172c3e4c15371e03511f4752fdf7e8ac1331db35de9b6917f7230bfcba69bf2541f6fc3e467a058bafa2b59222da3058b3a3e7401e7aa04021c42960218b6114875c8f06409859b6a702f06c8086635a7516e4ecff76b61fc6b39cd7fb2b29e74486158726ac3b9b9623431da0c2e4c5b0e587f8623f3f82fb1d9210a18fa9eb489dbee24e106c71fbcc485d3daff633a938f1ff618d5a3fab6ba4e2565bc39b9b66d5cde22f596aa9425609fcfd5bbcbffc24238d2264b3c27aaac5053e13101acd3ff71bb9f200b7e54a90c3e058bc6454393c3b3271de7c4afbe7f333b35fb8de7efe4d71eab162392a4ee19a526aeb4f6529432d479b531fb82b24119f004d6f04cc4095bab28239be46cd7375fc5207992490757e51a5cbc9ac8e9f43045fc0f859d59a3375e62b19c914b329e1c443f079d2d57ca4d9c5c115e65b04b524d5d4343e06aa33fdcf57140b604aff08f47e69d96e1f2c5cb9e346dd25b5ca329016939d847163caa4c55169d8fc3e79e62f6dc95be52f92aa635a4136d0205ed16ffde0b5562279746027cb892ebbea23744c514edb5660a32a70e3790099365c0c74eb0d498744a8d02e75fb1a149af4f7471563ff20d406518266cc5af8a5a78109363dc97a1cf214a4f16bf4e3ab18c8c072909393117ed7a3a0fceded3023d563da16fa316e0b881525ec6868cf5386cf60b0a9cce4962ae695dd447639d29a54956b8af7b33064759a49a9fe12eef89eeac27a31297e23c3bd61f80d54479a4e13cc9bf4ecdde47e95bacb47fb8825efe70a8245d5bd52338e855111c254c3084c81d41f2fe9fb0349bdb59d30be9af4c3f545676238190e55fd32732a9232c12d1c618fa46b0a48537dd96811cddda930f53a89e189a8afbf4ae8da69cd8a71a917283afd872cf2304c56a437e8d1a3c0669ffc7d0fac7005e9740fcfbbfbcc5cff7da657b6c49d0b9a7b1d6cda5a604b3fbfdb","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
