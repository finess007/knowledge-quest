<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"478a02762aca6cf41b353282c9c34f541483114402429b661e0798ec9223fe45ce34924e3b8c60501f108f31c45052478dadf854cf546bb8f4e0f116d93da82ad79b3ec3f0e3c67da512a4a00cea205c589500beb5728578dc4d398e6d5f2a52e5d123ac6eb0f34b0876500dac3cc64766603ad19ac5dfae48c2fb6b44ddd1dfbe65eede90ca17815de3baa9b3d6b7daecbbe4fa7f33887216f1a7c6622bb6ac0f204caa4f2d2ad0d8d0362db313d0b05b82e4df5e375a801dac4626bdd966614d5004dad2f9cc1d28c2cea479b7e15c62493efc3f8d81c89976110eff26d55fa36ff48fbf0f18187968f997d8bdbe296b0ad29b36c9df25f54f4f0a1ce700c4407da89601b6879320858791f687cf98d324e0de173410ffbeaaf7c944471c49d274f43e34306b4e94eb078fb7078bd9330a5d5a30f3250d12a7ea1c1cca2dd71e59a62584874f1bcbf1a77a2b72e2da2f1fd04f13370de8a082b04ca11344efd17d87c48603cd04af6d0bab7a01f477d51ba2257b39b8c8eee4a4f6941602ae1f326fec489d02a59822560ddb0d1811e3779b1d84688e22be7fb7837d73bd86ee1e4ba6be22db5e2093933c31b598c0aa50359a3bc51efc35d39ad24d5868eb3cbe52a06718573ff3a27203bd5b2457eef6a231a64fa43369ace96bb3ebd1ae28bf2190f573bf55ccf17b52b539b85c26aa241c2af95399b50200dd2c12cc9500805cac214f93e2afd7abf994a82d94b39b42216856abd09a64ef8cb39cfe5e0537d36bead0c8eb20b55f29e945ff60b421458d84b6fa3050a060dae0d1fab79191b72ef24179d4094047eaa4c1f09969b033083c64eb08e0de04f999592c43758326954bd8c489921e1e84619aaa2f3059f06e4833f7568d866379f9c3b94436f99acf0e0423ed4ce2e24da8441a5f9fafd3525f19f21ef5867a66df319e35f6e149cdf69ee99890482259a0a10c11e81c3daedc3a3290403dea3463f2d68d1cfe9276d15717d77c836fec3d2e9340e8209092a9bff2bb2e236f435446c0c7562de6977fd83095c0da62c9020f519d2fe729c2e9d04fe4b58d5ec1c8c87fe3f42db796639edb9fe20ffb438eae81d2a863dca0880f4df798de7715fc7eb0f3032e44f68ea3a20e2d08e105536c5de6b8e3af4cbf8f713d300947c52ed9d285da9819822a961681fceeea0ae739d6e05ccc2ef7ff796227b03ed321ed2640464412ac1413a54b465c1d3145ebdc815c9da4a297e858e8031f827980f8a8c22cb407825545ba7dcec07b6d067b6a4a9e9c3e36dfc06732208d72f2862c9d09dbd0f51c8f6c8667f07babad0a88f5b3ad0148b446e6c816bb7cdd84ea0134982fb0928f07e02a56845e1d11ed673deb1ecb74b986a9fea251493c7c6f6e641c067a307f52417a22b3634a72965f86d1a3dacaecb93ee62fce609da3431de6d070161e087d13a79b4c7b6d8b14e0a35e8862be42f0e4fd4f825f1c5815b2dbd4f63349dd31ae5a9546deaf9449bb43956b407096259e38494e7930e7a95a7d4748330d2fc3d20becfda9c2456c278cee117da59a3238035d614832bd64710f7fa232a967c877e27d628415a8872a277a81eaa94016226622f37501c8d6eb6e1f85a069c721689d6f5ad797b66d4674e37f1e890bdaf7b584a826c8c703558b6e879ed229d7c1b164c2bb7594b975948fac7e6634ff0f843b3ccd2bf97ff52a3d504e485c13b2202c0fb27d74ad42bb8b72b6e7227db7b0bd4355aa0952d42e85ca2319b4924d0d8aceb79595e17840874bb7197c07c15df868753e0757a0068ed4b3f3f219f9250ed89d570a016cbcec12ca47b4e073ebb7b95126b06b24b071efe493c699bf8deac0291567f30cd0eb08cddac8ce85036f99c0fe354be66603d613cb7cdf949c19aedccc499f5e35da5511d5b98a9c6a640c87dc6cb6a0f109a81667de1024b405f13a5cce13d8a3d78c04591c5731f5d8131e2bf9ef1eb242b6ad7f175facf25bc0ad323d345fdc953d4395cbe0e82fda4e34c033757081c3a96fba8dd304c8c847ae9bf3d5728a33d0fbff2c858ef382a5177e912f70bc19e4d8bb3ff69975a3c6879704534b2ea791540dc4ae32b163da0845202ef747eaca08909b4590eb1f5370d0958717b0dfa36ffd7a09c2ae4c10357ff6c52e7214a2c9afae41922f6f340060b5e72baa2b774a3007f2e6718d405975fa2c003fd9254565f9a961bfc870bdda050d328126a0a3ac42f65958d5bb7dff1c06b09cc9eb786962e4ba38258f9d8048b8e6eab322f0ff1006c5ec7a58de0dff774821d5f65b4034a0ca9ab401f552907e353107e8b4e1b4cf3cf77e593dd8fe106ac8dda745ccf5910a6d10c2956dc25ecaf8a8e33916cee53ca599c5569996ee2e01cfcbf97be8fddc52822e030152e800ab7c2e7bb00204f0760a3a8c33b5ff5deeaf37a886aaf1e834f3389a659b38e8722ed6d37129789caf038ba1d222fe89002268260e706c3d96cdd143996c98ab79de256cd83532a0eed5c9e6a427a3c58c06fb4dc81da22667b96aa1295deb21df6e79ca4b5c337cd37555175e0ea0eaf036a941a4aa6458d264ab0e6c439dd6cfd0b25d488d8c40e848ce40f7c7e592e2e08b9971541067f16dbc83155eeb2c313c9c20c050eaa11627edcc5c9337d0eb31edbda0ec5cd66a51781f0135edf348579951bc7428d02cdf8133f0430a404efba722717f02cccaf60d767deb3b5a0d712bb8c48c0f3d8ab386f9f1586e664f83cbd4adf6e3c3427eefe14593c11d70db6c01785f5cd777e79347cb8e1aafa90406f0768c4772f55111a1277cdf8e9d0a8e1cfd61194d6e1fb103fa2e060e8bd8b24eed6a4899b03adc4f703d5a30bd90f61a4d01f18c9ea31b535de78cddc54cd24553c791d1d1703815e7567f3f5cbaee417a6d424dd6ae569756387d4b57d16687e82173df6286056bf128ca9970753c292b2c902a614552f3d19275c7040cd54e8727c59422fb42fe79f89144102ef885ca88c43d7bbe97e7bd727ca2d06a627d84ec1da7ae73b610ae156be3320afb50b0be7e27e6bb63421c6aad21a307cfc84da7ab6b826c42f0865e06c91c6a948e3438bf2029b64f6dbe0285d31fb5758d20ea3da2b834fb70dfaa6214f17a6a0d2136e5fbe386d520fcb5e95ff52baf293138c8125893af3a66df217bf92dbedbc7c35cca54342139decd08269352b4424872cc11bc0e478b1ae8c46d043eedb99bcde6fe3bb61099d17577b6257e137b35ee8ddab2c38ddc2e61b3ee4f61d986297275c6bdcf0380ca3bc7b17d428a16872f0ee75ffba857b6d926d85222ece751ab5b47406e9467c888f4e0da7323dd947cd3359458d19358f2655f1ad1faac8bd8d4fab4ad872c19b92d4cfcbc4db52ac4930d9ed8e30c92f8c56d1f43816bfbcf86510d1d094e2d7bb37d557e11879f44e731e37121c0c0ec525f67d06a57cc88560831f1047d3cf4b62bd153a713718fe01f1ca0474d594566f95411466e9d2e7bf2caaa16d74594dfddb8b7f1bb39b5b688f428e8ead16aa45a7d5a40c280260c1e45fab2bc729373c7d715b8679cec550191843f3d1f7b52ec08070cb27d4c9ac064af48952d04c8513889312308d48a55d95a50ec61527396071e7aec712b8ac253cd5bfe840db067d11002025d161803472c31f99fbfb107aef98a4e16300545fd365a00673a8fa61dabf4d880d8100fd9dedddddbd1e96f6e4fa9baceacf4863058bb2e4d36f2464d7237e2b741d88a864b662b06c2cac05d54398750ed3906a709014adbeaef4cb752ef2e0bb655a0660c03b0e83761dc69eee7f239e02140533be1e92c46fd0232459c52fa6348ff461ebec971cb7d0a19524937036beb6633cb364c93259a8bb989c94c04602e139131ce6e5b6b6837ceec4221637d4ab111cb6260332a1e907fd42cee3c9c7844d5976c596135362859e87f73e42122f96b54d74d94825b7d1d64f2da7f8d465f1887883743214d79039a39426cbcde32719d4b7bc43b705e2f45d7b2055fcb5cbe691049296a82f9e4d2c4328d199adacb5b5f51b9444ef4e088b05e10ae64b0bb3df75e764d425e41929c9054016e9aa6fb9907f7b19e4ec8c50e2f7da649b77ee9e1b66859262e428e81d265ccf82c8627c319a366d89e84e5887eccf30a5a3395fe982375d2536aecf27c58ca40a968c634c1129366bd33952141412d4cda0146a02f23948fbac430a2120b9599ec77321658ae9030a96833605d229b07a0c2b65646e0feed384cbbf05eed2f5d2e60c5a87cc52a3e5cef0425cd0253fca2abfade43e9bf00cb1c60a3a2bb2ebbfb6d68b862617e0d7b993ee0101c27361fec423441c271ac6ef333b0d04a6d41e976f3da6c511f00277661ae2086096633edf4210b2bb0845ed7b2e2bb2ea53f91066ad34fc0571f97a286acf210016f0ce5ccef602865ac10f587eb8e87c59e897f49370a77b96bd827e48b0d7163f5f928ec1937fbe66fbaa20e1e5c055ad5b203f2dad375e5588a05dc93e4401528eb60eda16a7c431f3400a2775b23395bf41fee2efc143427e8a117640931ab58b0c25d7be33e9546d3740b5c0546c15cecf12882f36628992379e411d0c78920a2248758491043a7ec8c232fc8aa5553bc2bd84ad3953c7b5eee379c6759bebbbdcd84534089ab43a871bbff8224492e2661bdfbcd99e516b1d36b2ad9d2b745eb3753802169016afed6545e81dbe24dc79586d03ce0b97cdb4f583045b3b043da2decf8d8c1f741d353aefad57f6a694ceee6e191015d545e49cfe20fba7a0bdfebc6f4365d644c08f628b807527707e493c88425bf8b787e051fdbc45c139345e6a2e133cab3dec1f97ee3b96cabfd52d6f5ec4d5a266eac4546b44483005f34e4e9252c0a820e64b091bc9434b96bedc06f880c35910c91ddf9e9e1081bf9470144fcd084a28d2b29efd2fb36bf23f26044621f80d5965d411d4a68bba46f6249b4b3b8317964af7d4283b8ab77a0280810e29e7fa881f66b35d8da812e142e759511dfeb23e023237e779959533fd3d166fe4986f8bade792f611a1dbd112c58be6e74f40b6dcf57773157f4c0ef738c0e0a90ad1e42aba5ce2921c315d359bf180cca5d0595d770eaf4022a9a058d8e1fded9ca84a8b8e02b147919eaa4a23dbbb648b959b7cf8b942967de302967d0a16da6e777a6f2acbc53fa22a5b1c35b71d0d57b9989c523f5ac43b45c8462630cacb2fbfb70a069e6d2a1e1586e3a1e05a37d826927b1d2430d0edf9bc870f927b1856d0ec057b4174f87a025a2cba773ae864eece987caeff269a3535b746bdd72cbed4e37bc436418548a96dc948d21fecd29c9a0e0440c82bef2db86497aa9a64c6327a59c8d2db506685947d31cdd955ac0673e2cfec884f04166a126a011f30de1c90fad2091b6295a31f1dd31fd91043693829cf16cb93d820ddd0495675b997186d62069c71bc568136f99bfee32b4f9183b516a81e84e6a450f3e22ba04048e8a84cb54f3fd02dd7f59d06a015ef40e73284e57c2a2755fb1d98a3585ce18ff880f0c8c45e0ac53fb4dfdc96c5d449ec5d86f60a15ac0ee9332695ea34bfc1b81bcecd5076419ca10ad9cc3c5b8c79ffd514bc8b6b412d4009cb9f02844194ec5c42dc4974f50840fc25e6ebb6760046289ccbe34a85a2eefc4a894cec59fcfb30564e2af934f3c63e74a6003c7002020422302104369d54c05e77fd2977e8d0b4515bda9b8b10e4b35d1e1c2831f72678b84fd424e7bef87b3e61ee792e26789a94041930a755ae426bcbf5c114674200aab7bd1adc2fbb7454a58c393a1ec0010ed33aa87aee2b7b7695c36a7ec9b0d82e0a4120257792c7a311282ffd1d8234d207797e2268cdd5c193c9a2425071b729f8c3ffdfac53bbfd06ca7f268f117e5ec65fd2ba7b9eceed64b5fc133988de73cc14bd8bb25fa3807e47190536c7975d64015432574ba738e423b8f65a903dbd5f1824573eae09273641e8f35bd45beb25ff4963554e32017a9da741c7275ec38c027adb4658809dbc60ef96771d628c7e27ca92d4cbdb6f65277bb309bf2df142bdfde7f12060282e4b72a3a4d7ba5b408383dc59b45bac7e3209ddd5cca14d91e74f09c8ef4fa13304e42060df7401220cb6bbe1ddfa153909624bdf5f51974ab4941ba175f810e2829ee502abc5c010379b332500d4dc9c7144498dbed774c28c1f5353445c6f9ffa8bd9a43d5274ccb799ab71ba1e0c37bda525048cbd74c8595faaddd8d909283331436afe2d47ef8278c48995dfd8ca3331fc8eeb7d1129416d814956809783c7ac34d52c23bfd9c2b620927c1ba81df57388baeb69157dcc42de2b4f66fcdbfb2092e6e0ef44f53b0a0cdd13e9e243870d95ca90d5788138366bda78e5acff06357ec7e4e63e31f72b0a249db0a5b78cdbc08c2fee4a417dd54685df5778ea0aed40c050dae90b3fc8e8488074e78ebe36cc8f4dc37f6a9fc08872b8510af2878c3595f54d92584dc2819bc4f3fcb8574863975d01baa9716020b611d435bafbd4cbab5e65a2c6fb2f64d46e54fabfafe9ff2ed3f72ec6f72ff6bc75cddde7d650a4f4bae56708a5a45ab174a79da8589fcf0098bc29ff86f49bc2d7fe2538cad7f8fec8439ad3703e59fc9554f0013462cfd8b1b3f679cc34eac24079b3c5630ed0ef2e3ba6d6c766ef261d1cea30e943ad6fb113ee36a7c549368bc7ad3cc8c13f0cb1134a4ddd1b2cd5c69cd6bb089598795ab1867cdd818e1688a22fe3480fde67d6c7446f481a922fbe823fc72be912424acccd53cafcd71127c8e0ddf9adef1485523b1f736cf36ea0fc77cffedbc239f74b69d196dfd651b6688351905f3a444d1b43620907ab3a2b2a4960a8cc3df113b02d974277be6182cd677c357f26aece75a02174b4928e7c66e9010dbbbf539823c3dcec9f4f10ecfd6cb1a0376122afd2d92aa330a775e34c499a06a41f4f077a757bb29c658593882d39bd5189f9c992ffae00eeb5e464a2d007636b579388311e1d367f4c5ffa3f48635f25eccb3d9665a8204829508360cdfe1787afe3cc7485d9a8e396aa0566f750ba2a41e76300529f28ffe84d51630977c94eb5aab257d049d2d9c7ecb92c1570535546185433b63011a5bb5bb81be0783f8d1b3423a63559173b46759d5cc61197142f1568a6dba4a39928dbbc4056a073ff2b65857cd147b5c440c2465d317d62288c2ac720be8fbf2c2b60a83e76265907e585caf56bde7077911dd4ff192e6d1fc1cb826778f9d2e27c3fede4b0071875c74bf3e3d95487ccdc299d88f277f23fa4aa3133a0b9c53a25719ca4f6c1ce4787543ac045d0bed70dddf10b1786e52a3ca3740404bd5b4b47718cc012565457fd8a77d613385b7c423b6272edd36006bea7de6f4b243688611559e05c0464ddefa44e7eec4be1f987ae641783ef40be562ac16f34028af1d8fd547886e5ff1d3e8b0488d56c79c2a0b8537c7c98c13506ff0e07fd34a1ca0b125def961f42ba3732a7cc5de5383d301284349a131fbe5b1704976b3c3fb1265a4c09d36abe76ae06cd8d6939a508b75d1e915fb31024bdefd184e582c0d44d5af51e4225df9e8c0e534a1f86b8e98eefbc28ee50679e28c7ef64b66a6f1629f904163703b585215b8b35e0f1ac1a52d61790a8249cd475f31d78f416ea296ef2e3d93bf408302819201277365c1d77c87c07bf40f3adf45a592181fbcc2448bde7ed21acfc6751dbec69d0d82cdf9c9e45bfbef65278dda6892bad0b7004657e8651d61177b790d271e6fa2c27a94129cee2730d5dce81e178d9f4d327cf5141edf4222b41b2c60490ab77db15015e752382363a7a326311286aeb61dd964d5710a42614bb3fb6271fd6dadd332469be41a6da3367b5023f5ba02c35984aaae491ec751966fa724f89907fee303ef353c0005b51fc59ad798c0a0243836148c97ba3f52e6b4b16730ad1d19275928f01f1291dd1f0111d8593269dd53ec62cd15a3323b56af881694fd0d628741546b02ab55e2658cc9c8374d8bcef71b05040d0fe482fda36d04c2c7348a80b58fa5f09f74e34afdf3ddba817cae1edbfee7dd14f4eaeddc265b97ec1b6a3c77f04e5640d73b2d9f1e015bf8d9ba66d87c351ac7ba1576ba9f5840aadcba2666604381cb92e9ec897a6a8e4af9edbe129a3951096af596b58c499c72293ecdd1b3eae2c432690188f9c3237b9f28d0de9860f98da6feb52c94ba37c658b80ea7fd05cc1d8933d5862ca51889dddeeab8ce0961b1ce2b0752c0214c174594631c68f0b6930ac361bbdedc7be8fd8f411dbe8c2769d7ecf859381104183cd66c03fbab26c17ef07d926165fe6076b94984865611cac6d7f7dc3bcb364daac6e99119cd6402f77e6b159c9e67f1ac78b29cf8027170dab35cc6d9b2d18009adaf4089592232ac3f7a4e0519dd1e7502441669a2320e1c6d2b8c7fbafaf3e775bfd8838cd7e844c145867a104c1675cf2ca2f2bfd035a44a91498ab3978b38918720ee9b23e1656d3f157ef744a24093484ee416e5d74fe2c97fa8fdbc24f41a49a919a009ad1e82bea98bdadac77a3c91f453cd6aeb17bf8eeea2168908b466410e266adf1099ad97622a95dfa6dca705b34cf9d91d6c86036be1fc97d9d5a0d3840032a1b63e89d8bcc16248c15c3ced8e1d4d217a827f11522baa02f7e5256d24e3246ea6c61f1046b7c551452b821802be36ee6f1d0241d0d034dcee738e66d966bf0c195ae5c202305472ef472f2bbe3e82c164036853b74cc624b04cfe1b51f2ebe0621596925db9edaa11f7a46daf6b4aa6b7510ca15ea82662592b56b867af5b1e1b8fae78ece179485e31877b675ee7370515434835a5cacd0bd6ae42a99da0f3d8bd3c2ce1854bbc7a7c29e0778ee3dc2dc83cb9ab850a7590b336ad224cfc2715130518e146edeb0ee9614dee5567d92d044e8485a6dd0035b57094857c63376f7e219aa50a3c0d1467640b3b041ce8590215aa4f24eddac0865be727b1b8d8695cc68eab2f777aeaaa100eb6bacbf741ac0351289bb90f8870e578cfcfcb3f4571ac8df2d5494167c197b94fc5f8c82564b786301f56688bfdb00a159158963168f2791e82de4dcbed505d26c373bc49b29dac548d979d6d3ef2490f65e9b2c4167d4404419ed6d3e3fe6e7990d360caf3faeb2dba23b76f0209149faf863bc4867eb2f070cd96fe63a28b3e4b59aa60df7492c0777169c1b58458f873b6dfebc5b4bbeb592a73dc1eda0011765693fc1d11e7657127d2034bb9838ea4e7c1b0b315212204b7ed4cc58c3588976bd545478e1fe82bbe9e489f58932ae472988f1ea8a668c4dc3d2d52a72ad584e43de11f42657fb320b13bc6333bd75e295f48ce2a8bd648fb889fafa88822e12e6d4cd318ebd93c58116feea5a71da60b1d2b45ddcf8bcfb8f22e5a69affce1099d0b7fd51ae062494ac87f39d6f4ab98708bc0c726125225218efc8a8d8a4faaf1707d741b85a7ffb2f42cca59a5c32718253feec24bb7b02fecb2bb54854e87bfd18273241cb951d680460f61f7a1f430d6e9931bd58a86f0bd68afbdfba8710304b7e4b04bb51aac1eb6e8a59b74af99d067853935b0b20bfdd07e3f0fca38a786eba1ab644aa986d2aef69aaf3ab60f562d95f32769277fd2a682655200c62a73f1c59b5b4d5f85a6c27f08de1a5cbc0474d6ff53f6dc9e4fac76b98b58a26165b5030032107561c109c042d513d73de8bb9b0dd8f27e21c110e95de72c6d769ae57e86b79665773b841840b99db01e7e17905cea759d76f95a2a966c19d299aaef0e51663cc972b0b6a77290ba216d9ba3c527e9683c831c22c4b1052350666d592896198391be5b3e4ad992b295dac3bb6cac30d32fdd7cc25855f736d6be6135ba7875ceac16a2f8d2194a86b33b9cc1bc49f8f19d643112ab6521fc0a0416b2ec0d59c765ccee87b85ed54feeed57fa6244f7f1d2e009d594f77d3d7bfebf60398d33fcbd1a8f2c56ad0c314ff7d6c0508df538d32599d99f32f2fd6723f63a82779a476fa02d9d54105342856dd23edc3429b859cd7294c66a23102e5dfd5e6c6c52f3cb29eab39fe237644156dc489170b6b6acde125accfd78a7f748fe13c217b4f4148ec64185bfa96233083f508096783bfe2ac2d1710c43c6cb84f307897580611cb3cdce7c816142965ad387b93bd289ffe4acb33210ff67c4eb302341a5f9d3530b71503648be6b4e484f1daecb75018f43cfdeb99fec3fd7e56fa6ef11c3a05022837bec39c7f55426309d63457a474b1f5babef6528a81d89feb602d1ff2a3d05571e64219ca7204b77c45ec8de019f89e269d6200b2bde2e1cf25359d857ce3ff331c2669b8f61cdd08647dfc0b6057ae2ce18490cf2b53a30c4f9fae48f17548edf4ce8fdae9564ffb15149c9d512e1720f6a5a3694c2430aaf243e533bb189105bffb761a56623af4436c8e986cb874ff5033aeedada7195189a517ae56a49606755f486eab64b8b560f99cd1c8438522b019e77dc4b9dfb3f0b85ccddd70f8aec1898cd14c0a8123d9ab608f61def637c3a72e97a89b74ae105c52c3b264857c9c5bffa94512ef6de66378d8f7c35ec9c114e5c52f02907832373f5fca6b347d3cec7c7e13d63c68b3f5f449bac76ca7dcf8f330662de53511e294a53303eeeae7744d251072fdf99039e49c76a6f292f759d74654d7f2bbd8ec776d3b8a8c30eb6803f7cc143563c7f2c8f7881bbf1fa45203e291b3dadf97c3634c51b7eb872a107a4e5c9e106093c9feb4d9dcbd8a217a9dc7aee831cf94ec58bbd0d8a4cf68c4777fb38a6b0a832a20a3e99d87f8a5bc1cf2bcd37d6352ebf10d3173c3fc3a57d5d342ee6102b4b7361fabe189a7e49bf7db3225dc391a87bc1309c2340835f81843e8ae683b97954ab2d0ccc9d455b7cd42b6825b59508b43ed39b2665d58ae15a5c2d9d272a69bc6500f40ce5ae2186a0d4b57d95aa3312e2fb577a07dcea8679c4e4607b94837f19079cba5154b82157c07e755ada79723439a3cc622399a290b99b5043ad7384b78ef0dfe674cf7ce6fb6109458fe5699f0b2c4e78344a8880fa446715983653ffc17f58e0b798f0b7be0484e584b3d0b509eaa4cb5eeae62fe864233a43fb415670c66cedad33c39684576a44d3415683d696d55bc5b8008125168c214d6bcf1c279dd4669e2c643fabaf14b1a5d9d38780fc2bd0cf1813ef7c141e8704b4516b5a47f5a6d0d2ade76e1dd35b919f45b034e55b49999de3017a89ea3620fdfe6bc1949cb72f594bc365999504e6180c7b2656966b971968000402e1043fbef3c417a0964c4f77fdca63a07d72874487f346c9e06e8de3360efd1928c035fe2d226799636626464415e6da30dd24096eb28dd2a2e409ec9c2fef6d9d3b608f1b7c16fd54d522b45b3cb4af800cf22129103c31cc18cc8f3b08c8c200f5ba12c9f417b3ca64b33c74bf0784ee001ca6dc04c4d61255da87d97cc2f3e413f8260c5cbe328ceedd43f014ce84f99ea6a2587b2eb701aeed7bce2a66314a4d3489c041bea3cfdad022d2ffb0d3e399cb9fa50d0c4bce6fb41dbcfdb2164c60d2b959c239bc829bf1a8b3be5b94bcaeb08d3131673f8e1ac2133b0d99a5f07ccb92cb3b3c33083599d3ab810d5708911c3c090aa5785c1bdae8888cd4428c4782cbb836cf11034ccd008152cca15b5f382abfe156c108423d430ac31f7477cd4c751756bd4009659099614ca8eec2ee86a3b1836f85fd0cedcd636212c5688d8e87bdb91d2a0e9aeedf1bb05bdaed4bfc04274891d15c43eb7b14f16d8087a1044680e6fd588290470289278170c24e3d7a94c781cef361fb8c47920b4b36db47adb597022100973455ad4d63b99a94d8d04ea32dd8b2eca5f85820e513b20c5cb8f8b95d5e748630d3fe98e8545d5f57f628b4e0eb6b685793ca9a9bb35aa92de16a4c0f02979171895ead7d223c561f1a80279637044b04397423dad58855864eed157971647832365f40ac3d7df3c05363ab1caf460e843da2b7c44051a49242237edd45ac37950d3a234e510710cf3368d5599c9c7c5484dd52461f9f67be73927498a0e658a9d5b940b0388524a49671328aa64a5903f8069847c33cb000bb0c86986ee75dd03b364e05611cebfd818c966af8d0ba7335891fbda7738a0ed73dc2de7c76cc24e2f45eb2c3b6993288afdac5efb701da2831cec2cb4467de3c84ed59389d88be79f7f2113d1ae4331f5869479234be68ca4d56630eb32980176b0dbb3176a92d1620ce7e91931098daca445354e3e43abffe53db34881682d9f5d6dfda2739513ab972fc8bd0d9f4f7d3e28f6ef8c470ff4b02fcdd4e96e7b5133eabf28da033719dff3a1400cf28cce56b83aee5995c9476984b95d11ef5b6ffa2e5d8115f5e38801d91a2660f19f7ff1918a3026f8771160ed482d7ee964acde4b784757d2338e2545c1a7427b0b25d2277019b7ad1bf3328606d8d3ad73789ce9f080270e9a1a4d35e39bf77e188c637b8fc3fdd44836195d0d711b7044c7c4a8600198ed78a963d573336a27bd10419725e7250cb184179093d6e03723edd2f7b452b5eedfa5d832bf3386427b25de6d50dbb6ee806153a3f4638d4cc12d27a0d9594506baec64325ee731bc76d5a64105c7491426884e35580ddff4bf02f1de27c7be753c3afdc25afa9a5c95c7eb410d5454d00061ec496d4f7d828dd8da83e0af90babd191d7bdf559c03f5f4fc7dbfc86654863f55ae7e1f68eb491190808f5a11a9c02b107a154a3c8ecaf0498eac202b5444bbfed983de8b0eee955eb8195e64500bb6b3133ccaa04b749c704da3f2cfc6132c25e775abce46c3675f7c04d28269e9fce4d6c01ccbb343c566b19d315da0d8b18b4fa80c38bd4da5573e8212264ec47afe4b1e2b4f0202bd497e9b5d9986c2e39fa19a91c2cbf7a698f202c0e287ce14895bcdbe18ee0d54f2bd18b23787dfe0af37533f0c27ee6cd9315ce977db929e19671c00724d9cf721cba75b136312e1ac0eb5a608a7a40b0b5e24de105bb732120a675d229c45f0ddf33dd201c63dd166ae2e1313c8f1d2ad69c80490f131349d954539bfd97f88d8929c03bc840b1391237555af274923e0199d822e23ef476c0c1aaefc71ccf65cb52720bf4db69ecc7f24100fbaf3212e90d9f970d5cc2ab97ac9045d2f7eee0666db65b013e42033c92ceab60667c42a4153783b18b062fd91aa3e09959811ba72195468091ae9c41de8164e661956d173e30c4f2f4ad75fcd9f8676b500675667f3448f0625ce00ae1854a97db14974331a5725fef40ccad47a5399cf7366925df282a5b96c824c4941074134e1d3ea37bc5ef8744c2fa3c2d99a4ff81423b5ba6668c4d413bef6d320e71b10156116234bc9d7c71dcb2006d8ffb3bc5b0778e36dc99396bcc9b70d184f3e01e4cc84a73f6f1476b850e8553c377fd93ff0b8a78e3e95e162b4a5d71f62c68899503cf94090877ee6787ead7b9265e3215cb139d2b5f580f413115527373e42f6eec143031148e313e06d322b4447718971d4d387232081ba61a1f671ad507e19681fbc82bb492e8b34bc5f912f128ef18206403c002858b4b2c763764fc8d1bd78d7399cc24ea0c0ad94c711db0c34649e451da2eda43035729ddde6abf8dcf1f671564d09c16b5166ebdf8b8039b7399aaf0e21de1ab09726bc8ba12c20e7e62ab7550b5842a259f670b6e1a18a4e8d5f6aa6728458fc105c64aaaeec4b70a29fb5150bf08ebae2aeec781c242400c0052e0e81d1b121a9ee82f1b0c3bcecbe3813eee5052fe43f570bf910ba71c2f749244480d3e3a0817387de74ee8bf30f1e85789c2a1725e99a7bc2ec06f1576117ca798c70b37e8fd2287ebe46b6c45ec2ca4a725b304b544022a88a7a22b6d6907ae5d868acf6e2304a6800fb4c25b97892149a2d1149249beab4ee59ffe55f2bbfd55dc904516c3c5213edd6d0cfc60b731a3624258ae08668bfae42a07ebc14e2a9d7aeac42591c778515185775e7acac4a4d03dfa0a3931700f6c23bff74d04a2d7cfb60d6e0a7231733cd13aec2616bdfee1a4af2aecb3f58625942e11671639dd16368bcbf3cd4709e9e34e121701fc8fcd5de56c66e700b2605559d1ceb7f1f1ef6dbc46cbe043143f483a1a1b4de5fdb9738aea3c477bafd2a568e1c78c362a065438e480a0a3d28abb4b0b8a15838525fc6aacdc3f174d9a21b7b2eb9fe4942ece14caec7a47a5254ea74e75387bf83180cc92574fe46b32be2aed21b1543ce2ed5e277d41aba273ee534948cd8b5cf159f7ccab70dbcec9d3abb7b278ff71ae0f5edef0632ce9ef113ae5019ba5c50c47cfa8cbdd2b9b0bec18c584e221f709bb0bb70aa70d86bbd0b4fe0d9e28e4e42ff6c6f8d9479a9d5a640404fb4c1b5d88a2d5a0689d8b396a5c3a6bd1562def1131dbf99385ae168e8461b46aa480d55677079ae09868be7f8c71468d3238bb1dd35076bbf22a75c32da12ff7cc94a1f943ea2fdf4b406e31074f823d854e31a6ce2eab228e480eac105381aad7551ca1162dcd744b23a85a9d064525ccc904e01aaeb39d6eee9d31a2568ced9146e018001796276a720b1c04918cb1c241b1d47f8d68a19b8369570c8986360a212ce7dfa5fea6e552d8d3dec38c1cdeb90340f1ebdb4517955792bbe343543982a990a0fe2b73cb8c2c52c8ae853f80a56258dbb5d3765c691794a897d931263a40f2b6449c03c7219b2d2990800decda6a3cc6143e8afb347129d9dedf799b11e7fb900079349f8177ddd27eb9c3cc3bcd8ec2c842d5a6018e7b7a7bd1325709e04844f5fc9dc8f8cca33ebf0c743df9ca6456f9919fbdbb95a390251cb46832947bd0d297a7a06391a17f3848dd14fa2343206071e2172b24083e3e84dd45a74de346f05099ec66a79929a425eac0557cb00a4268e12adb2d5e3f1aa949d584ee3a7e13685b90a7fcf6e0d36fd0bc38af9734cefd41fc2596b7cf792e214a12ee13fcf0972d2342370a73a659de5383daac0c16a0b45a761c4a36b880638db0f472cdc30efdd730519bbfbfda6f3f18b780a1a002ae49957d9ec64580964ed40022cbf33e9a5f3eadd62e19314a2916afcb9aa811133c90003c121469f9d06dffee4fb62724f392bf98c7d60f79a3654ee3dc6b50a43ae92cc540d19813b0c0c321f42de73c0e696083cdde2aa6214c4d24baff62764de6e4a538cb5275007e199f065bb109e4da020dc1e7ea6477238ae62c4e68977b84b467a73e07f399ec8ee77847e29201280268f1fc9a96612d088e8f386c7b81a0e18368b7c65141bdb5fb43a30aca768e7b007dc100844738f4b200b7a9416018271d54dceb8b6a04502dcdeb89f4f6fd09b2a9128e8a56e8048743c2a65d3eeaad409ea07460526993e431808c35c73003ac5ba1625fcc4f71c4ebc9d71a48da6b61062c22482abcaece6789b12d958eec6022903dd029bb9f669a4beb73f19319795b1d64d7c58a88609a8a60ff1a7b6ad272196ff3278efd4f83795bba90bf9300bb8266a677125cb7806b7ffabe9f10ac4e09fc666c43475bae9da76a21e9f8386138dad57356f61abbc6f8b84810ac839a7e1cd15bd88e5b409ceb60bbdab08c1c887472ca07b1bce7c22e898eed2d5f130fdc2c1080dedf09cd0432d75288fbd537b2ba54ac88a338956fd75d132abdcc6b49cbec2e1d5166edfb3ebe8ef9fbb9261ff92c26afa965ed9187790458b371b949af7b957fb958435909ca525b3d99d609c668b1dd72f8dbc0316f504f03b8edd45ec96af2e01b43de6a95dc0f7165917530ba31ff24cdcba1a0488fe9feca3b26a5930cd18e67f8a85826fbdf87ba879eeaefdd42a6c6a0a3f09dd651cc1ceb4d3cc95ddc00f75ee6ecc2595aaced40bf4037f24d1def8a8642e050ce3a53ff7dfd3a7b2227b4f26226c9b1dc3178b1000591947d7e372aab7186fa6d6c52591d5500831d6f0d88de42766daf9148bc9c6ef4125865820f1f60ef585400a5ad0f3d0a722176e930c48270340ab04aff631a661533c30b2001b6e6322f17f4997aecbe8769a34e51eea6d8d768256b5c55a06bcf3b614522f6ac414fdf1affa414e99763e6d783d0f2472f8b390bddc7003e7ca57a9d055a3e50e1f03f5bc016e2f30c1b9eabd52dd22e50aa102e213549ebf455a130891ceb82fc33be960cedfe61ae73b0ef8004b54c7f81fbfff725fd04d065258efb57446edeb5c434194dc92992b0b6c45615a5f7c4559693f3a2e998e8fa46bdddf30e63d69d15d021d6f832046d221d9122a9adeb33e57681c1648e4927eb29a4b3b36929238d9b4798fd79e545f0d1b7d820c8716a9db2c2a0403122d2ae96353bdb204fd3306ef395191a7bc44e68bd42f2f419a98bc83aa2cd5c2f0303377e12336f7f041786de782e1e94c5873b2f1a5ad16dfa21167120589ab9685a09d3c6d500cee5b6d0a7c581b4eff9ee51072a1d736af85cf8ca3dec43fe1b67aeb700509a9756b093dfcccc01b22d2bf182a1d38fd42f1e7cdd80180d9af366c3367a81696bd37e50e05612e74fd2090090868f75ef2897d969413e42b55f8fcb4474f3311e06eddc76d2bdd205653583bdf3d8178b4559fc4adc4af0841d53d98e04f3ebeffdc84e30b14e70c3214196ac969433bf305093663124884866c3905d6f88dacaade9f9582a17c8e8db96fd2ba589380a02c55a88c137f9b98c037581a54707f61317eff5c1e47064a0accdfb3fec21521192a2aeb2647028ec72432eb15ba07ec2ac220fe9db884e86a503b533735e1df4043fddebdf93016187b48a4b215a0cc9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
