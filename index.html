<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bab5de35b4b308a5933a6d952abeaa1bca50e92073db7f50dcd2e02401e4caf66bda14b97e5f179c28019e58ed0a65f4fb6ee8f1904842af3360b91f91a0da531953f40be513a0896d0b5a7ee4059f7a74ef12154f2859965f964f9fd78d5b08c38870fa9f6ee8b7e926b373b330675dee06a2706f11f0fedca9af6de14bc47643d31b3e88ae0662e55590fc30b91e3df82ae0d8f81b1e17de0e5bc6fa10a4feb7ba1edf174725871b8fd04cbdc933bb05a5d049b8242df20bba5f330db84a06d8491c993915df69b9295cc1c18a052bfb5a7791d79916850f7c849d85fef13a1275dab90889dfc7df3c05df8ec399c26970885f17ba07da14563b24a9dc5996bc1c36e9e09934fbd15b97afe6b9ece05f0642088b03529df64d7f566417c8037ae3d841acf9314804b785e3f3be048e7d950cd86a3a1abf64457ca2dd7e3154086703513509c70465df58166ea35fa03879692f259ca4a55b3f38f0201bf2de1034468320d95ff4953cf2f913d8b474a50252c3a3e34ff582881c84a3fbaef9504352defb7d7e2b8be561f4a407fa3f28cd74a91b6d522fc6676ecaffaca3e60f7c474088f5d2443aaaf74a99381144d34d640beaa8ecee7ad7f03f4fffeba81e008a3f479d6666be7c41749c2ac52ab5d70cce36a4ef5044932c6bff32d1f0dcdff9f29eea9570182213e6ba1dc559f1dd069c118284ba897baf56649aa23ecad1da8c09e5fd8b0f5dff64faa5d1678cbfc3c478bd66621bc5c2e3321562249fc2e41097d34165638334ea0f7d3ef058d2cdfc23334f7e28be718830640e248aa31711d32f13d7575597549ff29729c5386d932d3a2160f9ad74121b289c63acbbb6124e307fe14308f549d0b62592bcbc6a9438166a6d9b27a77440ce837287b99a0a9e93d4f85a3c89e94748bee2d37900fc5b328d4629050571ef0a96d7833afc05bb04ce7cbeb8908015736daacc619af87309b9d47da782c40114c45f2312ddef8745523db597a0e7cbb01fbcf48faae60df9e88da839cf2230c5a9e3d5b04b0c6e5cd9955942044a1c6e0529ffe844216abcd5bc01280a39aec18ddf48481986b47db733da8089822482c2bd82d6f577deb315fc41674d5e3a9c797850d7d89d87bbae12df3049ee3c6224d92c85d8f967a52556552b44299762c6be884156cf73ab4709cd9e6b693afcf12d9c071225d13c169fb7fec02035fbace690c2d24892c7648e19eaebd88193e2c7cbe514ee2e48e401522ce0879a6f619cf2ff67a16be664979e92b6fbd689425e62ce4bc85221d7e6cea91b07256faa0983ee7277486e144c7868471810af861085245d2467b3596f2cad8b59d4d68748a2c20c381518558d33aefd32a857a2fdc87fba6f86902d952125503ebabe80c43ea91a160c6981f599fd7f7592474dfc4a6295d3ff4f99eb4518cdf121500767e030fa34c77cd7af7d80c017995a82395468b8cdecb577ec6d8de803232ef861b902d7fd27ed837d16d02c7a352c0daf6670642f6ed579012ac154e4530a12b941e2a3a2eda8c60a5b1e46e724512f040eb61c9ba00fe518a07249393cba4e37a4f66cec867c9cd3e8b7536199dd6998b70a65dcec0bc80234c1124c42143af199ba852fbc87ab80f3bdff8907fc32aa7c7828450db11d2ba6bef69c78adeedd01c9f751f209fab0360b7c6a096ce143d1969a763af3d47a439f5f3f02cffcf45c061b0992a1e157c5ae9d4ca8f68fca986f1834e6e70afd9a3f39184f1b148e7ad45031a37996dd75ae60472dbbc843ea684532060d167b798f94aa08fe334bf6f8d0e1c6a545bf0e907b0c13e181842a69a2b6272161ad41333811fa6f0c4b7024b1c7d3037b7e8a8ced3e92c14656e2fd0755f9b1c4cf11a9941e737c642da055b1edc1b90147b88a6d22e7ba3a93aceb604dedf2d37c15730c8a816a715e28d125132c5e24bbc7e62bdbd2fbc458b853a45a5976c0be18e92d069316d8e2f671c967acb737b1fa7baf652ed76bf5b8739feb537c3b5015b0ec30f49f5fe4fd1512d8307f29dd33d94ad9722f4226032f1de6cbb9b5e4ccaca052b520aec93179dae05804aef83a9b3763604952043a197276a46ca70939108be83637621810397d1e67f16b8f3fdbb03997d31a30421c35d691438c3eab855f9a9656ff645abc99be22fd629ebf53a8059109b10fdc0baed5d3fe33b9dd8c9f4d38102860a1b4c0200f4a2c67bed9d172c9ed993f65c46990f7d2759ff4dbb97be56a034484922524920e8e2ecf9e8cbce590becda15541fe32690ce0886224e1b33619d38941835afe5f2662b82856e656e1307d681848972a37beee849f62c5bebfa26124d7104a03d25f1b779b3e1b5351c5e0ad6ac9a1dfd6cd49d284b3fbd9c4c4122a8035101e65115ae375d8fda610a2309655a0e6918ad184b5c2c21005927603825ebbfc1b3c3629193503f079d01ab1ed9325a55c4f2ea805d15ee51c8f5e70f0e9209d53b9932361fea4b6ecfbd473bb8ad154ccde5fcd8f67b7a5c8bf417dfe1e6c56659b951a8a4929077b7238da55e2d261a286f36bee615f57af8c5c1e1edc0806407b16820a2409ccc885fbe194949835f07c08b2c2d7b9a4d81a533787e68c838ce13ea90ea884cc137bacd715d5f7f916178e59d51fbbb311bd4a790d7ef266879dc107018688fd9ef2cb587ccb48c3658d55c1b844fcd1e5c8f4b6cd74d33cdaf24e73d7d85fbe1aa86eb4dfd5245abc7f0fe79de4830de46dd1187ea2328c3eb295dcdbd896de343fb764c0a168528503616b01d14b98e5a0d620fad171d92134e1f2f2f07fd9b76b0bba6537294d02e5ebbc782a337e13718eca8d68547d0eda07b089a00fd845da034697eedbd4b0a80006cd223714029a920b62815f18011ef296f95ac1ca4992a4a2cdc4ce231293a94a74c8f7a4d82949176897399971b058da88799d3ed1edf3f32cc57df56bf718876277f0215e3afe1710e1d16e76f21d2ff884878ad9628ae3cb0588a63b4dd7b28e742e763fcb4a133664cd28e07eb6b25b48f7bff0633ab15ebad34f0680d8bf3d1a6b24a2f041cb3ebb9a073ad66c7ad62021341a3e2bc39c9dfac3ba3aa0ccc9a41e3be2cb34c63b6c565709fb7f929ec288f4c9b7d1188df5f379818c0b0a1939c2469e99b5a597d51f8e164f10233e5595eb93882ca4329cd7e2eb72fcc2cf45010e7db1017f9fc831984d502b01ed15eb3310ae370656968974084caea0b0912511fca53d7838963e6f05d9b038ee1e63166e369a35d8779a7dd166313f0a7b45ec3eb55915adb2159baf4ae84afa23f8603db30c5087e15d186c31067d20944b8b7432e2a2c298206a519412f594009178bb63b157cba1149c6d0e80cc4e59048da08e6f4e6c93e9bdef93e07587fe0b41d4fa63c0aebecac582f4353427a5c05655b2d9f150465f77ce3a84042d31a4a8e28a7c499dfb86fcbf7bd99d617dda7969ba241363b3e8c0678c4563ae66054f953633fa723b2fb47a6da25ecb4739c5f2e95bff0e6c565a6aca16fc7df4283006e210fe307e3edf216f0a55d24ae74129ce82df74498956e4aeaa23c834764da72bf350a810b452a57ebe0a21a4aca13ccdb0ead5fb460216fd2b77103ae43aba8068da41e8c21cda361f0d14b778fd2ab8248ef1b431369e8b6e0e61ca0da74801037476ffcf8029e1e687e08045ea8a7e5a6b04a401f6a04b5f75fdd5f1c7aadda7a51e1c1603ac6e1887a6a0c6cce9c725938dc7bcb6d9cd9527eac30226b61915d6abe0653315447467f39848af61a7e39cd4e3c24dfe1728cfb4819ad426401b5fc1cbf7bc5bad8b8ac4c2316b9e7648f5cabd95821d1e463f8aafe1c811593c7feb49427a8ad6302e057cd33098a4e175731d95716ea433137495d8f9332173e3df8b45ef056c1ee458084a6d2bb0faecf0745fceb3409308ccd14afae053e921f69791d2b921c2f7ec7bd73bdbfae2c7e6476e677dd95f8e9ce68ec460483835db662eee5837237ca22716207759782ab4274367e4a4ad712e5bef966739492a41ea19d092dc58f11c0f2ac6d870e1908b07b01ae058702fd95d4ff205656928589392f6ea3ecce4149d297a38ccd77315fa0e035d1a1df5f79c94011a450f9390acf208944cd08225ecafa06e12ff7835c65c4aced119ccd76771dc067e489bd0370582e7602d9169333ff9d95a4347b32775ea1dc4e468d77e0cc08b3a3b70138bedac6146b37da1035a0b7d80a40d7e6d4d43de2476ab6ae58028cac2ab3d0646ac652d0be3bc86775a7b318b0e789111ed51dce37f5a7b1c85d429a443ca3a3edcb6eb572184b141f1168d1af74dedb4c237d65c5757946f934d8a3b6ea2c11d1d3999a24a983dcd10d38167645638382ec5e08955d1785bf9709497d13e9812595060ddb88b17eaac7f0c3d2426a9c996efd78ad3c8700e1ca47f15d23cff0527eddd991fd30617f2ae048eb641fd277bbe7bebe483c28db35bf27583a352527224f35597c86dd0b2349b263f222632e0a093c651b94069040192f80bed21e2c54ae55a206e61acb2304cf39b7433627c7c5acbcb36d08f3382f6c94dfd302fe633181fff4353b3c600f00b38c30e02088407176170576834324dc1b3ae37e39c51f1d559d883765e5e5c88176434ce85dd03b65b5b22d27f4658b2aeebe393a23101094524f429cbbe279c2343209d8bc58e747d08fbd3009e52801e8ad45b7135fa935aca99814ca89575a87458820dac677180af93aabdc9ff1c5cb4de1236805276774c1a32886fe93840cdc64032236daff49d02a08b9f254c21e670716647716e6d0695305c004a1e9e1423dacdc78cd9b74da150018466ed52f238e74b84a5f59c99943ce57c0f9e4805c42a0dd1541952ac4bf9a57cce3a06b2c51aeb325f8d664c1e9e153aa54629446870905a996e55c0c35bee65f2966975ffdab5278c82cbbc0175b2768f7963e8937683aa1cc2a0bbca968fdd2150f8fcd16322d637c493b114908745738596fa406f490f698602cb66c16dbf623f2253329b80665d17428062cfa03e5fbec2f9d03595bee1884cb8d784fa1616046d9fa6c5e9d923fc9db7e09d09db3f8e2b8bbc5fed98b93fe83733683eaac2e2d3f58d0dc1395e7fe06da87c782a9bc20f9bcc548f01c6f6c436f59007d53a183d827822d878a6b878226521903495a8aed2eddfb24b1de935c756681fcfdae4a91557694b7dbd2aabeddae74f02aa0676c4efadac71d4b559aecb56da48f2250130144c1449e575f9fbd700577c97fecc1257a26c4df84572bb1ab2957468944530258815cae3c96a5a96c3cc4a4a4bbf2fc4c8a9d5bf96593c28a9df0e0db24b50577c6f46daa621ea4b185b03b3e60a4bff5fb879a5db77ed4e8985e55b8cf8c3fb46a1bcfeb05007f72cb7dce1e96ca7316dba15daeda5705f39d1e4d529d06f03fdef71ce46a5292ce36cef0a0b2355b7f37a4e8f5cb0722c96c153340b8e3a2f0c115f734c03b3531607f903c762d9a41b7fd28506eba9a7c071ed20aff90acf84313f2f9cf03e643f1e965efe608b0db3d1de0a3de282880041fc0798ae8694c35f368379310107346afec7fa70357c236b8ffa89d3c7d77c0825178452a901ef4be4df68a0f4918666f798ba7e40bc3e30a10bdcb252a065256485198b14fd926268885b6c607f6003b2d860f195094f8e73d61546e378abed1f1bd6ced4ee7bfbda46d9c2b2084572e5fc3d3d3c9691d32d06b552bedf9313198bceeb859b3dcf5c763af1cfc0b5fc3006f0ae041615833710948c146c04505bec6f106b30e591c2a8098028ee54b4c9ebd3415afb38d3f5e5b5885839b1400078a16e7492806730e0aedeb70dcaab3298907458a6e5777111c54b8d8f113f5b4e7380305c7462f64b212cfa3c0f776fea76924693563dcbfffe7f1612642c100937e4525b10ec8bcd1697a3e37a9b7f20948b3653b5546d2e37cd9f41e38acd4943453448bfddd4b2ed516a7ea9775f03a01d08bd309b586501ebb5d0e25b17e2a8351edc35b3b023f07eda0b133233a8865820a3850989e4c08d92eaa8b3666387196d5d8da84c4ec7a8e2195e91c5513aed36ffa4ad853256a22a92d5c177fc9eaff6ac0ea3f9a0a9d913f6152c81c9c9730dec6249b662d2e8e520d5c881e051a8d15a51f654be05e89b73b1965977359093a3605b326b922bfae9439eb868a629beb74eb69a801d7308d0eb912b2802ed013261a2ac8fa942fdecb8b3887b8d6b594b56633a17795a33954f315eec2cb376746942f221bc8c1817b74023e8ca71102de3e998eaa8c45a07d13c62c728d961cad079917f8aea9ae450891c33e0630dd2b6c929fb89b1e2518bca4d9b309258f53095d473a2580f654924001d94c9f05d4e366e063216ca52bd53fe6986e046f13a27b804c3a1e0b07dc16615e13a972eb68bf37b0ef5b678bbf6c46f85b1c2ea6c99c585140ce1c67aa1e91acaffe271d65db64ea939dd03d4c66e8138826e40d1e9bc0264c477b6b107ff3ecb0980d94efb73f1065359bb19b9ae4e046aa07101e837b3bd441f2e8826454b7e54a15cf5fe0b5033585bb647b52b0fab47a17d9a1dfaed9541fff384da9aa928a37960a88a8bf7d6d55e6c6749b94e6cbc03ed8ed0990383b147aec4d659c3f093c940fb2d1f8ec1f2869290aec04e90dda32e392d8c91f8c5d087f2cf43f940524fbc02f9fa8870b0eee89c9cc3b56e8f98586a173b00a686b266e670ce27a8886754088e2714acca99cf3580ed27a0735332779d3f7741ff3c9368f4750b9e4dd796665a0ec72e5b152a623f0b30a1317071a181d76311df48c9da808df37d087f6b1bab1a015e50dbffac8c1293cfea48fd241013c597b062a25830d0b75cea49bc2ec555a55aa2aba2a4819c7704eebb4202aa441e8b858f156ba002b90474c692452b6cbfa4094b3cfe64ff3ca0d23198cc2d578006eb836349bb7682e7f1fe6fe2e42b9530fa29e7c9d8f10903c76ea12492b358b82453c0a373edf228c96ad5675988bb902f50dae237429378b8d3ce72fb227b02d8eeb5d84badb945d46e2fedbd6076267875f7ec670e152a14bdd6d10742f6b9d84f49b9a7e52f019ba8e52dbc58b36db2a96c7b2b2685bb4bca2bd934432dea55fda0d0e05d92c0cb7019792398981be9ed8ee82039c2967322ab2a335a28abff0dd54810fb9bcd653410a4e272d573616a5d027585a81018cd56496f2588b801b65d9adf8a951d551644f7a9eca4c84783023ad4d2231db7b6c086c861f3b4bca1622803d166b9621caccea416fd69a537a08f2095c1fc5873a005cbfbcced32eb693641a294ff1856117db0dcdfba897fd025f750400d42747d100d33a60b23b4b70461b987bb42778ea376acd354f17c88cd9cfbc82c6369745924d699cb076339b212937ab1d0f1e2eb733def97adcfa84f50ca6b4943321607995e5a09e7e3b99274762f02a9acd6c35c78671cd9f012926f1aa5a9dd321fa8bd3583ec7d5a78a13b4c0a458ba060456e49a2aea59bf0c80044591b8e27509ef8ae73f9af73c45ae2c6dcea09b5d27c3dc05e3c954a95c2fdf41c1e9e3c2bae15f7c9339103658602a73e34e8d7159e30827e9c80d84b672e26b2d8342e4a2ca47e774223b88e04daed1cdb2e9a21d4e89976a11923abc232d68d9c3bab2578c5c0f92a59ce0fe6451210bcab54b330de8f69fd74ca9c1d158f4d2df03e55cd186c3480deda06c265ddad42db82ad23cd3689ace1660a23bba84719e41f57fbeac6650deacf3d037c1df869f95f1ceb9f9c4f90e17f8345ec12e6c5e3f55dafcf230becec5079b3d98cc2b8fd8b7345c0fa9904190490d887d3a58290ab91791e1d09db2020d1ba037d3364def12b354b4e55430dcef1afe6874edbdffa83afadb8a93ddd7d189e14fddeb526551f1099a91217f871830c2ebadfbfcddb08db9390f4705531f1370bd2089f883a36ba3a3fc1e0bcda6ddd8445def8dbaf1a1d5e3da5224cac93420cb0a4178c3672b9b1e915535db58781e02d02980f47699b12fefa7dd6775c1fe76f2e8a0e3c6e0c461a2919df9fd09417a450c7de58ac706f3776a0626f7a76ec88f2ca7971fcd762ecfbfc4bea8d5bceead8c03d3152db9da0091e6ed5395ff46b218b928ff8f66afe1b7d4597e7e3876f474c318a87e0b724120808d548e1735b175372f9804a4c476a269b3316811ab06d363e5bcc199ccd36adc56abb54140a323b1a7adfef2c5f18fc7d9cf3e8914011fa43d357b17901d438340715e7caa5a9c9a50a2d36f4595800e8d4815052ef4edbfdca91cb5e4b278cc74b918a6a83ebbceefc8fe31f18318af3561f2018220c661b44c42d69baba2b6f7d7c424f5807ee9cdca256d2884c673a790ff3b4301723c8f1b26b37cf591042e64d5a7a2b8438ea375bef0b60a7b2cb77fe3d75bec5128ab882b4acbc62fa799894ef330b285c7b2ad8c1c1f5ab158e034912a9a356315675b755a9d7ed183bd007f1363b956bb1fb8e251ac4ca6b080d34ddb992d25818085d8e34d5f22ddec65ee84dec4c6cb678d0fc9b71c6786aedca28e7b88eb0d0a428a261e19e7b6dd0a9a3c86f44ba823154620b963128095aac893b240af2f811e374296c8b11a9a94923b4268a61ac73c37b107c72e534cc53b7b94ad1c136b8e6f901a5c4b552ea77acf480ed72ecec3bb123374d28326fa4a59c778cbf871fd20715014df41f1fe07be35000a2e3d88b5b6979f101f3b79c93864f4c6f4a020cf3aecbcc4bf88a0a69acd8e76eea92b03ab5f8ed42fae9aa598fa397785dc3a7c63fc1df171c9fd1c04528e051c396f4156e7756f54faf28d179e8ad788d26f5436cc3802da02d761640c30b9603006daff9f1c3a54b778acea59cbde16de61168e920a1a83e275da7bb3a2f0dd84e5f945a223f5c204b318dd20fb921e0784bd241d376a1d68faaa167778c9eec0724f1a8f292cf8fb9e2c73bcc5bcaf657d847c0c9f5b61685487032f91ca3de7dffc8ffedca9069c07206a1b76209e431b1e696770cd8129e5bc1667d7f05463849b617d3ab8f1510e72e37eab34a36de56592224bd17f6c0a49c278d906325e51a54cb9f9741be8c00750da8c056c3a081b042179ca81fba16b9cc6b0d211d1480b0bc2f5220877bd9ccd9ba08a031bc9828b004f7c506ef41fa7a247b445de243c6cc073a9c6c3b8e1b9105c335c9f152776a3bca9df9c7d04f7fa457c8887fdb0f08e2d8e254845a7427634c51901cef70803128ff6ae91fefb276c3bd3b64acc830c58925b0d6a74c3792e5b0a8262b5e44de2b2c42cac3a3fce302a7d1ef5d03f2973f2f10621d23a2a36082d6230b71c67990b4f3912fa07010c76dc6bb92485d9516e3fe2906aa82b907a9526bc10bf15711e869fc0f07493d27c5a62e78c8602afdd020f21abbafbabc0c2e09e22373e0087c1583a2195dc73cf3e3530a76f32fb308a24d76938c151c08a103a464d91ba142dfb337eb92d99accd34fc751086fe794cbd1aeea5c03a29926730cb814d36e30939a3e9666cae19a8b4da36ba89df3d50f9de9fdb1c6696d8944cd1bf09d60adf42d26701894f7c755b35005af5b51d3f1fac9fc66f4009c1544170ede209a9ecab45b5025f9404a3f8b1887d958a8107c54ffb4ed91bcd1cbeec62481d21b1bf7f87db3dd9ee103059d8abfbb4d6ed53cf411f7948bc24ca797965c438e0c225309f9b50b7304958f051cda2ecb49d6973a8c3a7d0dd230264d72e10ce786f9a63ee8fb22390cf98133e0bb6a06937abe4c85034f617e848e3cc76765b17ec7dae6365d0aafd4e763c46848ea508636f1b2e8f511bf09962fc13bd1397bf53582b4fae7a92f671e2f359e1284c3a2f33f444c3c0bbede024c0804dc9150fcf18eb9c3a277914e7f9aed63e325eacfeb099e79a6b4aace6bc4ed89e19553beda5439e0fb9995fad9d20e7469c878801366a07e547f5ba7e6e253cdb31e8bc887e138b14e27e27d05cc928d3a374e9dc54898ed133e7df8386b3e32f1765fda415e10fd19efc7a7d320ae63848f95e1009be1a94ee2afb599e9026e05bf41e59fefeed5356e570fb8d0bb8511cad11e2eced08e5af61ffd854a6e824a959c181b9bd8c186eefb933bf40e7da4fb7f61afa3c7efefd2388e694e829553622ff5d10f021d091fb6b0f10ee9099f8d749029fb994b77e6b58fe5e577761157e8dca2f8eba9a31eb9ac93906db0dc87f5538573b5d686afbfef82780fffb6c03ec2063f7c5db8816cc4276cbb29ca80123517006b15f591a155988cd622b59149a04aca9e9bfa17e6d0e81034ed1fb5658778da141c7ee20c35f8ff8c2742d6e5cb95e8b4dc96ad8091eafe59bb0ee3d04cbc5e4e34cfefeb86c4be3cfe0a6de7f6ec4e1b4296918cf3ed442c3c86f3ec6d117835b44a6df2ef9f401fa370d4f90eb380116eeb85bae872b6374af17df1329d4512432fdf178bf4f082436c7a6bff0f602d9589846d8f7f56db6cf317719f9144a240a7130708d92a833143a577add76c3e5fd882aee529170ecd0b9d08f6be1c7d9426df3a7bd8bf7f850300efac1e2050d555242fb85e2bf4bd632ad5614ea107dbe75d534cec985b0700420fc29bcca205a8c7d139b2a192ffef5fe9d3c2fd718f2aa81028b27464e373ad539137111797445fa480516d14ac86818f14e8c1b1a78e2428ac2136d7d827ada54d6d9c5f20a94ee4248514305572fa15619bed40ab1bd4090be754bd666b5db5437830783a2eb162cd303d4a2bd674bbea9014d4a28f842b23abafd13e2745202b1f925df11d4bb5071fb13548db68bf2fac6bb8221b7def0ae65c678ff506d50eaf7fab8ebfb1ca0adead2c02dd9ce8f9136260f0a9edc4f7beae104aaeef0a25cc5ed89ffb50bc9fb8b203f5675350588fd9c795ef629fb71c1d17306004f236fa801c1af08b016529a6052efe70ce10c9f58f0eea88d5e5a0ff74ce1019266bc627b1ca2d4b4ce949257ebf35aba3eacb40b1816e47b7bb1e9a10837e843e9091a6270f160f610f793c48a69dcfa9900b4a10fd6364ea26f834fe5676dcc941c8e89a703a10eeabffe3355b8fed48006726e71c7c2b5468437f4d1ad74e1bc6bdec719516f43bff5fba835ac8f3ce46cd46c88c8fa861b9a4ecff28c3c712119821b2979a4a2622ddce78fb05b3047b4d657bf7642288ad12b01232daa880ad5a062b2eaf72909830f528a50f0e84abece7a5a13aa1798c47007a71cc948fe429421d02292c21b630f23857607b24c4947d639019bf85922732ce47c2200d80ee354f7822da4f9f1e10ba325b9f46aca22368e10bb0d3dd6733d9ba773cd568801c7150bf5cb1d01c76c4f09f16f9ac9144f12bd150475c983c0d5940073a1e58054c4bf93679c7abe58fcaf2c6a2d4f94eb51a4de84e29bfbf66f4fe127a11c55dbfeb97045a2570c25fe4fdcb1ca6675930c1e4744c56cb4d607efa03c0634481be530953818c941d4d786373081d15694b36d541614183347c62c9d79b3859dce9f5b3f23cbe0f459c0a7509dcbba6fbea0a5540b1b08d76c507f9cdf00ec0af6809e3a2f4a8ccdcfc1792c34aecc9ee7fb46c5c9420e3d3e9ab622b3e79711c73df6a8dfdd53d9eac2b636d7170ce505f48588ce6901f1fa1a5b5db8150febce9f04e109759b9b24bd89be52f1e5374a4e8e1149d78cba2122aac15a0e3a12c68723df822669bc1a54e5f9c51dc343123694d344920566a9a3327ce2faee6eb04378edc96a22ddeb64d205163f5920a2b99a7edcee8e276498b2448528cc708dffa37a66694df3416dc06250374cd150302ccaee9555009e6b77d0f19804303b9e7fc2396d015f3ac7cbaf8ad229a5ace8d45fd23ad777059e233de90e52bca464ecb00ade26eebf667d2e5277a5896c35eada6a06dba0e4873b0213f2a8c4d06bf1b7b5ea124a0588ed4c888ab22c6f649d7524058f5cf330d564de96ea639856b92b190aead35e75b312af760ef03c2466212a638f0a3c4568ae1acbfac7e7cab55fbc4be6f6dbf9c77cc87a2eb80550ffdf668d63c9d659b9112da2f9b2a61dbac1fa43e9c90244c55422963837588730d834b12567e14caf6a3a5d794aee87dd4aee4e88243c82009126070887ec007774081218b2590bc049470e0f5d25f526210a501079980ed55f2570b65cc4e9e46c4ed40b3452afb6662c7bb7d9db4c0df251c513b38f78e0345e85c2953003b38a7d55ce6e516ebf8b4ee91f4d3bb7483951518605db137c6848d2b744622d237fb28c336a2247bec1cbabebee86d513fc705f992c7e56bd6a203df014649604091018e874af4e841ce302003c5b7042e0b3999d50a9dd17aa59c080fcadf75d5f398ce45f14a2a183145d5158a3c95292f60339725bac352f5a567ae88ea4ea27c228f32e6648db923125b3ee7466c8ddb362471e144b8478126b4b6aeb5aa13d75178024a7ce81b8a8198d26b10f6d6342ed640d6d05bf5d9d76a89efe2805da97beba155a9c5c7e0dc2f80e211145eee5ac57520c16791bc8af832c05623170aaf501e2335d3141d66050c8db2c92600636fbece48fcaaaf8df08940f4d6849119e957f9e56509ebb4af0c52a1675255d9e27a4efeeb7d65a981122ee6e4d22f715b2281f73f95680b977dbbbef1a762fa453f6a606fd45c9fb59ffc4d1f3235939eead02f698a569d2b21756d280840596d203911bb0769b0a725c35ee5db06857fced5190ecf35a71375647c89745dfddd94e5a2b842c2f92fba1da4af7f6a0ab3933b44a48d64d4983a4bf6abe80b3741de0b2ee978b8fa97596d04271dc4eaa94a0cf6bf7207484cc892e6b0b256f1e93d673c9ed3321e2d7b550cbf9c7e0b7936054e2b292f1b65d18bed1183049751757ef61437cd4c9518cda847cfeb94df73c54113db8ecb53e3235d16bfeafc31b3de4a0c75b5ea5098a637adb5eb500c26cf6f120558206d3612983bda9fbf30e2469aeed9a4a13e62445b3bf03c8ae19775c68e4c932fb7b0f9dbf68e620f36ec09a43bc8ed9e3bb1974617c5c11bbb7973d202f95ad0a40a8ccf801632867525147a72cbe278f4c784be5ef357d5984d427ba82f22ad81841401ca27ecca39621fd0562136e3be3319cfc239a267ab65515469ea4b9763ac5642ff3aa22d6371aec6e2ab7c1550ab5381ff72efb19882b61314ffea1fe1abcf5a7aa9d62d277ea2a58b12afa164671c4dbc6d8a17f131a3b7f265464eede0cecbd1998f228f27a404f1132584e37df28e8be957708c2a9f0fde743773a40115cadca9730a49b6c193a7d772a969949a2dd33990bb21680f3d2957539ef62820cc8ecb8ed9a8732c713827f9ba8b9b732a755e2d367abd60813affed5c7ce2032a02bd2cd69739b4d82d2ad21e4504d5081924c7a7dd9533a38fe7760dad2c12d45944a2f9cfbd1b55a87cc0b8c077054ced373316025c42218a15341cc4c2e8c6713da37b86b459e28bb86225740ee9529a2c24f693c0c3f5ff3f2c058c5623fee308465b4abe72bb4128110bc3898c3087745a4c3513de10a9e24b594f238e84bce3e84cb2be81f168540c16d513575d2d7f5da2b2e2c8e187d4c741e0609f65df85d1e24d76778a708da550462a33c80f1e8b832e021400eaa0ed5c4554d85b11a479646dae4f05df857f276fc5156936de87f17e32edc3f8781903739d81cd984113b6a414d9acbb51889cb2ece5cacd5d149a977140ea0ba956af508c6d721f594d17261068d87870fc04c5e9882e505f3f19a602e4a69d716efad42f6a6a47e73fed2c6f616ef6c46a4068afda51cf44a81e44b521e29c87d5ac506fb74f578b5bf61fa02f4f1acac821ee485ecd54f96f726d4ecb1fde681077463777430a8626dee04715c24b2376f7f7db744476c2cca927f4555e897279d7f7b9ae5441f502f42b6ba0ab9341efaf2752068723be94d82bdfce60fa976b6b6fb540a626f33726481611aad89e7d6df60e1edf687c8084a4991b3660e39857175afabd803fab451d4e8f8682aaee310b3d241aa8c6f0d4b176ce7520a0026a2f06f571526304c707be9a225e8a57fdbf683dc415b78e38d564aad6ac9c735c2bf0e8d100e9d9e7620b86880bf9f6c7cb2221819c623a0d8e1f9e1eb41f7e193cdc6ad9cb18dc15a83763a6ea8646976fc06ae513dcd9884b6fce806f13985c11f778a1d42e5866c617c228af08e05ec420a24c3f7265e0863dc5a5dcf98a0e68804441d5d044a54f52d22c8527bbf616c6f08998199ab3a3ea7a00d0bde7c903a2b209ada8f4781759f45ad71206b52f3664284f8d4fa56aca9bd22a6a13fa672256160f964560e552d20f641041a5b1c84cc9838e425ad825796d5a361c0db0802fc180b6df5efc18e79a4c99fc27b65a42d71d412c5acfafe1bb6ff8821651c7c438300e5eea578d685241a7433dacc8d5b382524ac1c218caced22beb11b4e7bb0c613de16095a07cf754278fe99cd118f79e8b8ee7bdf0defc2f9f37b9acd76c0a7608dde8e2571cace42a0b1f42258f6b2ed2561902b3e394df7b345a9bef5b4a9a11f1e061313a75751389fa233cc7146d7b6548fd0944dd4cd960b495f0b2342c42da9d33ea589d60d6a31fca14b106708603a2a6e40cfc32ec301b5f5c3850e8ca399494f0fe5b70b62ec6384fe3eac9d820dc8cb616bd9c95e87af622e9ea4d9f4d3985008beb208f09ce1bf580600ebd546be77cbd5742adfeb11394c9237eba0f769b1c54b7adbf7f126a806c11a39cc816cf6ea71da217e68aaf31738559b83d6358808f3a3722f3289caa1b6c20a85c6fc79e7ffe7eac41cebd91fb12c6b6f3a912444e96cf1831be98b6b56055c61d96c68a8948385427296e13c5e6d4d46553995126ffe660840e501ba76e2d92e58bf968d74389f4223004e9404f110f40055c8af77deaea84b2384f2b5b3c8fe4ab36e7cafd93b5bb75bd8b7110cf6d46b643e35197d5b3636869627d0f383dfc711495463dc3b170ea1e41d78a90e721767fe147287d92f5abfa22225806566a550e5054d675f1221e5cd514ac1f0484e8698b924e97cad54f47133908dfce320efc8e48d272a11d08f97224b4d339aaedba68ae8f2abdffee08d563f47b1608adb8a7819cdf4d2018b56c78d980ba4e99c9b9359b7151411a005528ee1b352157cbdc9a3de487d97c4d6c0fd6795d6e218d17b513ea3b67287e522fc8f8f61c264a51c758bf27811d37945212229f61df11c9f876eef9609bb745efbfa65a8c9dc48b460d255e10d0be4f4e3e625cda379a9819305975cbaa13dd9fff727827d386c92fe4ad0a0a21c8b5e3d1ac1e31c80425299b36f26582ade2c183a2575b5f7debb1c16a423b81d70f242c437a8bf8d838e446691b051555cb0b997cc591752da76524a6861c6d072467883737ad5feff9c7345076fca878ad3d85e000dc700a97e0915829e9b2e50a64d01d10bebba7ba0752e58a03c3c57f2c80c53865380173fadeed72410685d1f8fdf91ede8b7c143625721dd23703b43178166063d876558c377e250e940ca70b144cff5cee79a74f6177a0f20bc8b9c57eaa243cd828b024b3807d5adcf25f3e7190c144339e3094051803df8dc01ec792a99af7a0fd5ef3bf193f32bbff7f6aca414e27087cf645acba7bcf3c5f3ac4d6a2dd6c33a07a12b00e3deb4933d0a198905fb7110e319b9b9c8c01e9a75fb763f15734be7116e68e28b95b1c12349d6fa816ccd10115ebe4b1555003011f323f28dc2e5d1b9cc11cdaa5923e32331038fd83bb52acfb4e1255f6b352cb949d95178a3123b55c1f218c64562f17bdc82e52e0d4466c5cda132abbb8975507c59978c3b739a1fa1fa7ba5f50109c3702b74fb28534581793f35c1e99aae711417df139e0066219f27faee94264ff0031cc097d835520051cd4a4876b542f5d87947b1b6333327c9e30ebc0a5a7ec0f1050a20676e583202be0b79d3b2b0c1c2eccb809619e83eefc7b05198cf589dc8d1b162b0f46ded565152133e930720cf8a9894ad83a854bbe11d7a3898830c13df7813c4236e099e0970c6fad86de596ae7a72b41f7603001ef82bd1f37637742613f47c2293bec0401eff334e0d930b63c0e48006de4d520438b7ae0e6b0c09a337b56b225711534d56ac6885d6775c7d76611980a7b069930affc0be28e4758398eadd5e30915f0a0cfb92492ef921ad3350540048142025c2e37c3f25f0129e922f7e03bbefba48ce2ae3609e47ff51c2c865e5bdb24eade0ac99bbe585a199ca0e9eae33efad6848a398205019579d07ed40c061ed14c12ec8da68a2d57d6b6bda78036335846030213f3f9e8b173cd1678e8fddf111e068e4dc9bfb55a0de411a167eb6ca93737a5c21f43d7d13dc327c58183bf7b67f74fa7c3e32391b8e0ddb0b695d2ec050302ec2b4dbb24cf0654344a8824ecfda4b294a1793e9e7dcb55dede32d177e03dab3b05dad1462c6eb3f190cdf415af29ef6ad11111626dc4a8991a4b913af14da722b605965ad0ab3aa2ae7b8a062343da2e39461f1496783450764e36f147dded156590f56894351165c302af6f363046e8739ad198fe4d4aee3ff013a4b7d8204604170db1fe90092499f7ceb9d9219132739a8a2ae74d3d09981f4d73e66a825745aaaa852b5b2634b6baae3a3a688127238078f3d07cbf2183ad6dc3c3c59cf80a7f671195d25cd18be2dfb2584b73cf25d3f420fd271eaa2a3ff3fc1b74689e4f483c593a9610d66acd13cb3b954285af01d964ce234571d2664425d9441b14c56cc555dba3e5c7bd363c5ed3b60039446e72668c47f7eac177524291be331fae0ae6a138fc365f7168b737566d1dde66e3677a086c2810d935b51c98f8cad3af2f315a9a364b15c43fb3b03f324ed3909387d0984898280c91f30e9b1af48d79d09b393adefa59d162e0df62487b3f405e83ff78738b2cc60c052531c83ad5b9635a822579a0a86cd81a1cbdf628cf80700434a2cfde624ca816e14348e0f0cd9f05fc399148b196d542b05353694078814cd53065229ce259f7eabe87541a5f87600a877c8decc0361df2f93df3c48683c0563691069995566819d06a59a67d1f2fc55a22473df22527d5b498fdaacdab89b37e58b505ed0a11e66260749baaf68a5e79d208362e3355351277a289040a5a00938ff2b929a9a6f07d211e598a5f1bbe2598797b178009b4671db48382845d5363fab8ab83504baee001c39da015c67c94416b51ba100c1ee0e241c6cbb79268e6f9987365f7eb13ac28fb80d9072d90cc3cdce61cb2db6ec6ff4945ec5397fa770607be06244cec3eca4a43f84cef97a48572bb931d2b7543aad63c938213fedff9cfbe69dceeec50836a64bfe7be837ad811a9df9ffc9eebbd0035c625cbf097ed21888b27c0fb5873","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
