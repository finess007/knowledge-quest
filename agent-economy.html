<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9bee235311da7c78065321c5d40b69f70fa29af8216e8caa79a5342f71d13de79f88ac1324e4dcb61e203d50c904902e450886a497db0aafc471d7a1dcd30757d2ccab990d1201751303de4f1c4ce6d906708c9df67d69efb28b03d3bc623177fc9bc678b56b0a6523accf4a74ffc52f1b3fdc0671fd0e6a1953f39fc6c68c0a891137d81a8054c57b87186ca44e7a79e39e046f02fee99d0bcf75908378e50061929a52ffab3ea1ce60b05488cc5775e6a49850768ad29c816c68a408d8219d231fe650db0fccbaf66aa88495770c6fb94c936546ece7f4cdade305f6040d733ca949e4e794aca8715874ddce83decf6c30cbd6948a6104ffdccbe26bdf3487962b5a69f8e722bbb11182eb939d52a9e2878136aea7b4e8c47ba6254db89f275b22f7cdae1309904df11d6e03a10c3e91bc4854b3c57a1b02499985ab3f10d951499f5e55decd643a81507bd6f2c258397ddd2ce10e2e526864afeb8e592f13d19bc35d82f8cdb1f60799d341d17ceba3459b231d67284da100db05f6d487a3655338b2caa2a562eb58eb7d6500934f88e80e2470277e9dd3629aec3b85d5520e5ae91b8391ca1ee5cb720023b0bbffce63c51a825a3b41070515f8c578ec1a092a59a658b855f421201ec86cc18500f172b8fbfc214b298481bbe4e8aeab31e3740a6ca5be5224a65aa3dff7559c1227fdcf341dc852aa7120a042da1c33b61b725bdffe06b7b0496df1bc0738f20918403e559d7137d60ad0093d96aea3ea3db2d18136714a9ff3d23f16fc204c532ff1b432fdd0acaa1b9eedc04cf95379ce67dc4d45b616108182d8b7f46af54cb8ee3324afbb040155ce641100f86bff4077dcb522cd4a2b8de854842a5df3eae990c28df2e8f65a5c208ccc891b8634c4478a78b2e7ada8e5a65406ddc8b92dde0fb98f139c8073ecbe1b6dd3d0ac7c103cf3751d547ac6e4460b2440fcbafaf377c53252afd0a1970a67dccf0bc2317a0807a86163b56ba427130a2472d1879971fb60460f08ccde8a2fef14d4385e033022411b7d5f735cf3bbaa03db7a6e2a2dde5d66b70e6148efb9c5943e80dcb27b89b6c0761ed160c49b2eabb7b0fcabc0a8aae8f46be1cacaa2eac5aa11966d3a5a2e06469a2abd9b617bb27aa5f2e9bfc3196fae20ef0a1a4295c5ab1978140259157de529bae3c2a029be29b3b3172caf5874fac5a05abd0dacb6db9a6cd0cdd2add4e2e8a0181fe8a4a1eea810930e419aadfb6402028ec969e082fe2257638d8006d914f52a4ffcaf1c1acc91c7efa950add4e3df05fea3f09c45cd99d90843d655cf0e8dda0a832892a03999f4ea95fc1148879518d27cdced053541290149b987ab90215721d5a457f42eda01f52e6c124f859aeae09c7b6c0cc70c5f3eab610c700e3810da6f69b1737728472b47bb1ef619c0e4335d5108c0f5ff83674816f2bf16b9423093f863e6e5d9ef8f9776096b43c717ccfdd27357d0571446949bb70ed75115ad4a0a8159adae1437eaced13e173e0037c9bfee72d6560be135e18b15bdb479eb4bead839a9ffa4b511b1042721beb3f783f535b55533c0b71be0c400de69db29bd7b72c9ca9dbfe38754b83fdd92ebe15503d07be8812e6a720df85184cb3f4d09f3339834f928c7b2b9409e2d023ef25743665f5cb6b5bad418e59dfea3e9e74f3cce5a59bbd3a38a8342b3df828422850934a6c1d720b1240e658bda9de329fd63384c207f02bd56a6f0d15d59d1ed772105801b9e746b4166bb8c8191f684701263e9f107e0de8d848b4747edda82aa3048bb6af598e76883c3d6cc8b0efaf0f56e8ba5c6f279cd440d9c22452b3637663a889b00343d708ff84ecbcb81c39b2b311b5d52736ffb1f548f749cb99936739f1de696d5d3602a11eef659bb794a1dc1742f6d0f8d389691e77136adecd7ad595bcd21479a4c2ac56c5d1671a882af3a676276688b8dfd8251f9873044178ae6746df88a9188c6ef24260ad210179adab1a67e516a5070c502b3bfdd75fdf65ff3f2d5c4bfb05c288111f16b4b08ae8c244c5fbad101f07bafb1fcaa5e49a1a7cf31c141971fd6a772ff5dfd9fbf6b61aae63e785f74f285ac3df0a1797d14dc293dcafd295f06a6c3188bca4d5d85dee5f6e82b8a0cdcb9fa226af5a770d635c036ec74cd681cd390019fc257a61b1b71ed9fe31808a1d7502fa145c9c4dcfb653298c41c82a3336914cbc3c32e105ca02f2267d394cd1326adc83a5c8b0e31d7cfa8fa28f81798c2940cb14c60c8dc821f9f9b18555f72089a7bbc3db13941c6549d9e25b25472a8ceed5c8e29f45af68d53077849d91694a5b8da4c655d1170c66332844a15f44493127bbdcba11ecd09ce75a0ea1daa5b18708923ac19b76ff09b0888a3e88f57870119afeffe0ed601fbd02c3d7c23396127e8fb2a36d08a129efcda6e3de1aeea69b17ba4c74e0be5e17711e5b5d9fb32bc83fb522dafe3ff20ded0050b689e88d4dd055b346dccfd1b14a73737856c2debca11659a74138b4a1b9c7727335e7a943d271a1b510a816b2bb3a11187c9b9257d2908a0b3042ebd5f4bf8dcaa7e28ffbe7e23a21fe4b8cea8897d97df388a110797e3de7e17b87a9600f0b3cb857902755d907f02113a8625d6ae33a839a098f33088070c42cf81232fdccbd6702caa9dfdc1e117d76b2b87adce9662a9f10b5ef818cc99da0fd57508f4cac329df2ca4c506266275d0f2d80b4989fb0f4dbaf67fbd0db6d6c82115fe1bebae0ca7ecf888cbca9b1f1ef0df3a8114f9912b22a7bffabc1f923229f82bc1224f754c6352929ae1500e6be4cb7dd9ed01719a7a370ae711d7be902a02fd28db3c8bc60effc95518752affd84eb18b44f79cc66611b7ccf8488589cd3f23aff17a3d7552d378680c82499806a19037f96b84e5da67454afcfbbba60213d2a7c34be8b9fb17a0f0fbab2da052d0ccb78b6744b811829d7a3bb0cd755a09ffe5a1d32d76130106a525ce1f73654b279a65212a81e3e00a5678241b643f5aa35442060337f598ced12cfa8c8ae9cc7be4dfc13dee732de7ce0141c731a3b63b1d3960f84ec6476c142913ba24ebd26baeb77d73743556852bcccdb6dd2d5a2d1233c2a5f2659e7fb4ce349ba5c1d47374c7fa6297436fe0d319962301be434cb6ff3ef185f36367fef3cce2bf6e4dadd8e447e10512db74c20c535cbf97cda2592b59329284fa3ab6a7244f764c464d89031969bd6b71ce5cadfc83f640f57bb1ee8de3419b6e86b62a9362a9a5f1c9186f52e3e4a5478bacebd0729a373f113e6923debad32d6b35fecd1869b750a222362df2ff1d3023fa11514cf228c1a58ba6f54e959c92c74c06525f9a7b8b3d232d342b963a8d3b943b15b2bd30b5b7c0f0a8afddf97565b0d2011b05d4b1badb9f64ccef198829343b123f0aef14f7f73f90df1fa956791fe5bacf5093d3afb3a0db3e3e8059fae67ada12edf902da5b13030ffd39e04da9cb668a6bef92b82315fc72faaf2f238fc1b6b212883f892bb1d200e1be1b3f1403bb71835ee17f0c4d392658f565cbf96f64531a122b6837aa9e5f353f73684784b56f56c7b54a2f723c490f3498198812de8ba5e17433a5ceb63d289dff1f8e86b4b13d7d6b70f4ba8b4650ecb210dd6e5313ae03d88df491856084807e050a8afc655182bd9cd1db5fbee04e7064eb3064559131d6f0e553de70f9090d0ffa5c52d2f2e7f7c16fd247bd426a4e870af44de3b2177b3367b8729d05f232ba7a652ac5c7c5dffb0f327075e5f23efe843a8a0464205e01ebfcaf570993ca5fb49c74735fe2f4a087494f761108e050237d6b7764732ca307be1fd7e594c79b5cd7169bf01f28cf0052571ce408c68b8f79fba3ba583cb5533126b81643917ae5cc908946826028ec617985eead067fad2e702b343f42a34065a2c1f286fd7d5947c10b8e5a1825e47b8ff5a9b5de17a3cc7b1a2987c7f0bc7052e4d7ef18256293d07335d299e84552cbca0da35d831be3a6d50e9f24ef657c5f6e8937b6907054c6a7f88dd38a798827fb6b7deb66be2a0582898cf4eb51209191aea70ad9aebb028e752cbb4cf5a92c03414210a96631d68118da262a11cd77e6dc60236ec28dcf23d383fad55394a2d7aad01a0f5f3741b7bf6d1c8c02019463f4d61c7d53ce8fc68c0478f48978dced64861d8a07cdbdb386c4ca29e65eb6f0b79ee31bb7939b77a8abffc8d441dae9c020a385ee202e30b6d8184720a94efc0fcc6fa47d9452797254b78fc44e9146c72c80555228cd14f49d81e198932dbfb1ab9fe50efc3b0bfd13503d25141771032b6532b5b2855383388dd2b20c324106b79ce2134eb2b6ae1cc6dbb284a93e19909fe4883aac32f86d4e3a56b17d179f028fab1799c70d9a0a56b6b6ad3049edac0ae4fb29f5d9f6a233b3580927e64ff37201b0ec35e23391b5a38d0b1ee40e05dc328f875f36342036efdd6a46bc88c2ebefc27a74311fc0740a3cab86f3916baebe2bed2dd84270e99d62ad7e314014594c912c7221874af6c6b492ff4d329dbac85c97ebcb24757fd708fe11d70972c718e2a732463612e84f502656c736d2c56bf0e094978028630c7caf51a5baf216c69ea09f43f59df466d0c516805713c5822ecc9a2935220b43dd267a3ab0c6d44b4612dea6fe045658274189ae72679243377079dfe1e9e5da687ad53c489791b7aef3c34f7707e275cae0d70950b4a86a2c9b4fd883f605055d98fe24a6dde5bb15d3bab3445d877d83914bf05d6b5180b76f2ae0d38932004c87c7ae72cc7a8c25a3aa4940af25efb33a0915d02438ae29e609b422138b5ae0e85b2f074c3fbe63bb611247524a97cb3812cbe4d6649abd43ef65d7286386059e3b0984166cdfa1638a7508c3bcec622fe6b6d08441b427150e26e9f441b219fab9824aa969303b552b6204c1ace5c0ee7259ab2ea878e24282cdfe7cbdb2550f828d823bac04e61684d7acec0da7a1ad1601e53a7b1e3420665cf01f3f224ef4aeb4e1618a69975213e30636fb272cc116dee9bcb34e43a9857c2f7da5791d91253982638211f2dbd764c8df7bb48ce2d38f40d9be33ba23dbd90d931ecf5043d64acd8197deae10aa75309d78497b932c75c80111c8e2e0f420568f50f6ae615b5e064046954c98c81900d4aeb9ae1303077fe2b91a8b32b06a8416e7b4166f7977e023bf2db08967c399fc89b6d6d3817d4e6d673cbbfc971a160d78d83d34c3675db04d0c12a5cec60197d73fbfd2a00638cf920668d6c4e01ae8075712d3ba490b986fe0ca5267720e40074c85c92c240bb88fb5b6cec8e8681777a621d2c3bcd14c96fb1a4d75cd203105ec29f764211cd5411acbc8787953c1b2663643b23af46c365729535215ddc6a455b935fbc2ac97c0718e682490bda46f09d4d5eeeead303724b56608934ea6b2877f506e6ea1d0292be1924044541b9ad768fad8d968adc53f9d0a8cfee02572d2b0c706ddd456daf21dd875d823fe3d7734a5b662b33279d15820d6fd4792d3dd2749c2b332e99ce4c01e51f902b0ac2778964630533b6eb5e0fbc067f806b359537cac2d1da86ba71730bb1498c9b62acc3918320ea3c6c1a868fc73f5bd122405e87eba7f5c10d33a102f1b767c4a27a8b4bd6742b45656b460a361f832c539293b837594639b89ff24f0269836844a05eca3ef38842c5cf495d7791ffa9708778bac8106a5a083d684a91e4884375291f78a0996b4a02b539bf78e1a250ec1ee2fc7e4174b4fc9827dba1a7020e26c7833d45b0b4c8f3690b02befff708cf328cb1539009ec512d40b3589d3140d216583e1bb03cc50d4df29d6f6934b10f9643454a9117be8497989e5d6ec3e8f196c77b40f291f00a1f87b227a1d3e74cc13e0f659c9d2bbd21019262d6b2b2ba58a64e16f2326b69c9c6aacb067d733510579e3a7525c263b6f468daceea706c75ccd4d365caf0f218749486c676eee7af1729d6759ee266f5e4e659f078ebd35c19d6dc3661fc3c4e0fcbebe56ec5a8d08ef99accc7c9357ea7b7d5f79d993674d7edf1916e9c829cf4fb1b2c1e0445393a7cd976b30d2cb88b633cce4cd2d92c8453a548d7c2adf09da6ba68e333814a28741cb178911215685fc608a6c4a1876e274cfa9c60120d028df455112f8a0a5572204b01f3fa98b6123a001dee00ddeb009621d9191537a94b75339b2391f2b8e14b05fb3535dc5bc328e3e1014c1bc2218d056adb3727838efc769fb93870b737af3b15e5dedf335954f0a3b5f9699fd9c1def6b782278b54aa7466d51f9e55fc38348a03e1ed0c4281c7886d8860012d6159487e1b902dce86096dcd9c8009e86e27c681dffb0f3bb0eaeac8ee616cce408814eef531d51fe5730892d25b0c9b922513ac6fc21a917021d0d2d682899f87b226d0115c5b32d931a781faf3c4c0cba125665005a6124cae3d189f899cb5c7c9bb003a343a51b83990f878c2926303791dd807bd758543fb45c63e8aae09e62d1d35e0d1b237e7ea3d6b87948be3996516fbdba3df752be248c3daae1615808aa6813e304776beb0bedec2647cafb54f306ceffc51e14b9421fee385afb62f35fe7085d0e52b29f8281b24ae29c9d607c14c99cab376a0a3376db6561b609d9de7bfeb99b278728ca3226e3889629900e25106e01ee0e58064468a7e1edef880b596fd0296adf17cb9041d4440cefa7a601567f284692d2a63ae7fd3ddd4ee13776a31e8af846333d3aaa821f817834abec21d783f08a9712bf5cfda7ead794ffe85f5efa54bdca11b5417d51a74e3e8143532e1d59a3fefad15d9f04832be2e1ad7d3701442187134904d2bfd81f302d990353623b955a9aeb012510dd92f92be3aede8b54e92e6584cd642574620ef5a9a8525fea5b8f9575ed6ee59ed002a5cbc1a53bce22720c64ad249f4815cbad509e180b609d8ed39913cb4ebae56920dc35ea3bcda5c64388775aedbd173c88d52e78dfbbee302f6b66a91f45d4099eb3c11c803b1260f1532ad8ab57c842ac0fdde49af816d2d9e8984a835ec748d7cf5c6c5d4a9fcba1ca9c9ccefe10fcba86fc18cc4c4d1979697cda2e4d1691bdc1e95b7a52342e5cd4690d5bcc26a6fa3b4ff3c78db09ec72948168bf0b174c161c6608e1586ffa000d45ac0246d0caef8997f9998851ac4c1375b035da179dda9ea289069aff65fb0bca76f8378e68b20d0efe8adc9f4d7ff82f4466e9c309f5d4dc1f2e9ef0768f78b1735589f68a5d73fc9779a07b6ac3b025c47b24549b6c12ed3bfd864c64ad51d64b4f30caa389f80d441d65042b0b34cb15e03903ffd6bf0ef7c8d47d427bbc014bf7daa1f502940d759627f74f0ab9cdd0460c037be170be7b3a3a0a5395f1b11299bb799fd25b4e0b9b2b7e06f21596b687d2a2e10ffa85b261b15051de2b05faedd2f4086f90f5b21dcb662965ebe9a853eecf5a98af19c4147c28c8484816f2e9d6727310454bd6a441655900968d439397fdc9f89a76ba2165d30bcadfa42cfdf9ed96c6b3d49578c2d1fd0a2eda8e495df1cbf2bcfef99aa1e186fac0f8c34434d1303af57cc230f2d026ccb9fb721928f0a36a5db63524218a319f1059b18452d0651046141bc8473bf4ffcee9f4320f1e0415caed5371a902ed313fb8e117d87aac850dad245fa6e5e91a4eb51a069d0d6d4663ed282a36c00c76a45ce0be77a3cf4429ce79cb7656ec1bf3c88dcb299c433d263931e4be76ef32787e7b9126c6faf42331dc4091442064690ddc84ae2f26083c799f3c7f9e7d9da8d5c506685b2ecf168d32683f224df602d1eb32534e5737a0b202a264008a0aec8a843b71f886a0584eac9cab1d5703ec06a4647a310c29448332b75f4964268e90742d567dfeb0dd09c883b147a36398b8cb608d16be8422965fa34bace75f06ef55e3e0dae80b7a4c4e162ac07e185379e6ed3a54e8db4bda697d230ddb33cdb072ebc26b299973f3a3e40adcf50863c5b8317ccb67486ae05368580ca490e122aa412f154762fe31ef547e21d26bf5ff3923c7550b429d9ced3300bbf216d650f330c5fa40e2acd70eac64e4ae4b484c139cb7bcf04b006028f26bdf2e2078ffc8656719cac4f38e3f870db4a42ae75914a89d270d8c5d31317564dd47f462f8c23882c25508a0e23911b9cbd66df286c806410e9b2fb176f970f69d74bfe0f56b473511e4f0a7d930967b232d31742c82eec83907a4272bfd7ac51d67492de09b8f4c2f41ca0092c58f50e98c8aec71d7e35589512683140d9573a941f8c43d15c11c5e2d9ac8624f3892495dd020c916dd3a8e477f56dfac80ff08e67c43ca4c0ee79b20e7621ce34b5d40d3a1f39fbaac5a09fe358ce3f858f67e7507b8b3e81c1af81a861649fbfbe35f3d943743ecc33422b1bb6b7198e02768f2e83fc05c82a6ad62aae62ba8767b82ef9480f0c97e0f54f214802dbcf5c6dc99e17992ba1b8978d84a94fff6502b78fae258435347b09e740d33ea1d0dfa933e2a562e1eb2d9bd0c0a5ea43161f1cf367e594becfc3254d2d3e51b39b567e17dd0d76570df7c635992eab26433f763be08fcc29c3ba478113dceb4bd230b1fc553db052da7a8e11a0d12f50c3db3ce8990f51a007895f65f0cff92ceae84e542eb8dd7e8ab3d7f323a0e110d9ba962e04b9c971dd3dd0a85df3a4f66b92d34799fd027febef44c925fb082a08fbe50a19bc19f1e65273c96e8680ab5776d3861c8c06cfbbe71eaaf7a54a5ff9d6fe518db78a417c0b04eacd9c35f76ecf6f9d2fc837d54aafceaf5de6da2bc816704474ed9ef0e3d36aee5b5ca5023a5419589ffaca9e42966b4765dfab2207c41265ada6beb54fc6e22309eef2796f4ee3f97799374985cfb0a915fba2cf96ba4edc6473764fc359bca646ee2b618741c06f5f8a64ee370bcb5dc28c8af6dc79c8b84c1970dd81193fda6baa2eba5af433e2bef920d1e6347554393c01501bc1a59c7672423ec5fa9bfe2dda9a96b105cbb5d1f01399c6e0178d0fe32eeae59f22439bc05f491c4e2b674a00e1f8acc1b590a1a967fc10e536f5a81846de36fb3d0dfd2d5b4cae12a87c123b322ae32f9db618dd20d4dac8b7e4af73e036f22bcbb193aff6010ff0e019447b9d75876e7ad4014f5cfdf8a3de6c135b8fc310bc6e7fcf1e2f21b159cb52caa31c72f09418ee5493715cdfe63281fc3c08ae369ab7e6216f822e6182af8f683c2f92dbb12ea805a79e760b1b1edfd63beb344d520d1ed6023d3ac8d1145df768dd0709e31ee79e8c98de1bdc8878ae47e84743e013aadba44610d15ceb92cff6ed56cba66b4f08960b1813b759ec64c1f0d2fda5656258374db191b2f76465dbbe949c149834be2955d5ecf1e0b71d00f6a001ec0f798c97dead190b747848e9110dd1915de1a5e761ecbfcab77e05ba8a77d3882b8dc4c88de950ca21c56b65766d2333c5ebdd556aac9b986967ae2451c8d89949ba2c395bae75c36aeb791e99d36c86994c6cb73dd30861100e6f690c1c5bb6909b3d47b70b03209c62e67de50e77dd3d6831367cfc5b280faf37f15646bf0301491ea7c4fd18e0710f15f2863a5d24c3cdd87990bef0973bbccc87e46a6042423dc71844fbc640f508af834e270465d98fcb478530af04991f165a085ca63e0f69cfa881afb8581738cece28b5d2217fd920064244ed8d1fad52a54c2ba3ef8dbfca94c3ed0f5477b0762fd5eee0ae5be7ef83977932db7dd5485f957572e50af14e457e3414ed243cb9bace2b4fd40b4f1aee735428d9a80f6b3588cfb45939def5e63a2723134a3b92fb7bf009d5715a9e4a3effc81d6382bf0dcf91e6df6a4f5f27f3ef458fbc3b48116f81a7496aaa50a4a3ee5f9bc07cd03adc106d0a6b974559ede2b848786bef63a4ea728ff82db69b0a46558244ac9f820862de3056758b466ff20498ae41b656ec9f607754fc700ef670a87f34fab417c00cd9a988c3cd77ab7e021ea54e904c506c15eb0d284cabfa667ec40e005f2fd24fbf33ca965b5c74e7bf965c0ebd1f165a1d97f2bbcc649dd85c28b5e32ed258b6237ea13644a72738844d38967f7953164f0026df3db33d97fc3019081345121d461c5ba958dee6d75fbb7c574bd6689726bd427985577717dd92be6d5c795437064c942bd25d8c76c5342cc880eef103b62199dd16c2551c0c397831b6ac19c57d50d6600d2a2e4bb589018025921a25b69ddb2748a0a9dc405ef4d72471af4cdfa9ca049f7c910536005d1d5a8b708a713b83e30e4fa2afe1be9dacaecf7796b159d27a9c68b368c11ad6653ac1e77d8b5a206bf0b9728b3f043f888946eea7763b732d89f509b76a20fa49e8aacc2eafbef7d8bb1a8989f96457608ddd5bca8c70ad6da0d0d0cf1ca87d11b4bbcc31e6c340b674ec6a4437673c3b89df89c71e23f94b740506733150a9926a5ab20c07f4287d6198f7bc3419e25783d01fa8569b481f23aac9807c7af36a1a986f8546283113996827c88995110f2362bb9a061131158aef788f01f59ee4fc740a3c830ed19cb21d82ca6269c6583ba845fb38d6e39a08581ee0961960bb4c9cd38fcb87d8980790e2362bde5b3e45faa6d89c13c4fa7c60fe4017c20cc69fea904de9910e2ae2221b2fa29b23069166e53f579cc25d05300c32783826d831a8e137dc797642f0b54b9fe7f46f36ccb9b0d466381c6f3b06405e5086cd617dd6fdde03ecfe4451d619c2bfbcee491cfef9f3c049dbeda9424af8d89874e27a9d1d07d4d529ea4f4700cd57f8e61fda6bdaf4eaa2cdef70fbcfd7a7876f1168f5d5015563afb3dd2053031bca22aa6a50590b7c0f804494f93d31e25a7a04403f359b2584b7f9577f53d5f684a13f3444f030471d07d2d4673eb38ed5cb0008b911dae7c4b7f621ff023766e2ad54962fa512e0adc1154faa930cfbd01bcce07a0d2cbe8a572bb6e11c75c5aadd73dcaff6a5b6dc71a42f2b48438b4fc2081c1cc07dec93a0753232b3eb28f4371061aa111043c61e6b6d2bf487894e03f41581314d9177139c6d1507d1035b675f232dccfd62d4400713683fcff235dabdd2a6324064c4f5a20d6586e9d434a86bc48fa15e6ae49585b3373f633ae92c2c04728302bbfe5a802a1f3d39eec8d1707b3299eaf8e247a2f423f0c7e702e040c3e896d2e1a16f3bd23a41ef80ade76b73c02218d62a005bf6d18214e9b2f69c1fbcc96a3860ca41902eed2644fcd58ef8f0c6f9644e8ad93c2c7754dd8dcaeaf26d7847e0e9eec7daa37c3ae9709919b91ed54e9fdafde193ced27f41d62bb03e70f5f1ff34f05c6a0d06a2a448ad56b601aefe8b9f8d28bf9bfab8c15034f458c6fe0b19f135db73692a74883e1fe1288de951bbc9fb9eabada52f8be923462cc9f3d53becf3227c532d22dc030edfc72caf0912aad603a7784853b7c968568dc345da20237dbaa27a04bd0601faf47dd58821003af476c43ff59c5e39b5e4429cc0d4e79510a7b96cc039b834a7ae8af267487a6aec0951abded7c2d81f845e0c44b98612bc6af18aa82fbc3b42d73b58eec8ce7c16604c4c98730bcd6c68c798a21466405ff0c5fa835927c6823fdf6d69b9b6b8ccd42c7d0be8d8a97019d52ce99e36960faf88c32830a98785e50d1a31ec73f7a8bb96b10a8bc3bed8e4e8fde6189a7fb7207cd4fdd398d9cdfc9b2d8dddde42dd5d6f59d13816ef343189050cbf3188648f567abdaa6de5cf1a3bdb6d46b6f499c56494699adaf61954a80c5bfdc9c0c4c40123b0e59f0f74235fd75c13466f019a69be45b90a0acb22d6d261ebe5ef8fdac2cb40a5d1fefe438c444291a7c58da0aa7fb1045a01afb4ace72c6daa8fb6dc424420db6d44d096b89ac7740a6830553a37aa8a27b27f9739e475295f779cf7bf829970e3c228fa4cc4a9a09f12b5b9472dd597cb650b82b16aa85ffdac08b901b2a50f92b4a7a63ec34845fa8b13bae56bdde457d64327927a82840723961913f4ef3d5f1c2b70b428a546f31eb17b67b66bd0edf8c6c2b1568728dcd4b8cc8bc8801acf7c2a10f267069507c85cab5897b54fe5b9b76d476412c75fdecf536b27bfae864e6ac4764849f124fb603d272f7bca3f5a64e3a521efc9d94927d0c2873b73637dcf90dd32999492a206e22779fa12322396dfff3ddf08102ba0ac30c49d3503f2b4fe282f274c6a95b196eee312ad421ce2a64785426a9b9a861ee90ba3479ba1af6e270d7642871912cf9d7315d49e6094d52703110fffd21ef38ba3ccf5a33887ca82b90ed8484d28b742f35bc33570dd6320442c6e6a5d044396216c65e110e78f60e6b6694b317dc0384e375896ed1627c16dc32bc704d95c7f66812dd1a989371a5618c957099613b309d904bbd9e746c064a1054fc459efd7c8938775674dbc5c3bf8df4ba7248fe34386ec32ec590f8c2895100fa947791d7805c8c7adb3d04aa4f82c0e2cdd831f260d85817adfa1c5d4789d7422a8522fec7cbdd5c47535e2a68b061d6ab31b9f96ef0a2874ebf380d440e1cfb7205c5eb4ebe8094171db00c1991b7027277641ba1f1d256658ef893214d2bb50c3416c2e0513ad0ddad8a3b1b2315f4b14049409c874e6ca104b6c1c0d767621f20f9670158ff66de9a6046b80a59fdfb060cc4df2080d0470ce8fd7ff59d349d3741e8bf56cfc7fefc2cc90919e0c9c93bdd3eedc4d534dd25d5343932b65b36d8bef418d1edf233953a735702e000fb35095bf67e5b809c8c9ddaf3a88ed6b0fd12113c26d3c1955b39e17623ed02870197d436d650ab3c1c740277038c9764a32d9c5670e5c5f55f273f1cbc23bae0a724ad6d85ff360acf1e3d8e5e79d84ba10aaaadd115563d6a1844f4d0ceedb3239ab0acd7a0b4cec568266d70e99f5e9dfc5abf64ed3a557996bec27e733eb433d26f1276cfec790f43b7b5f73d7dab9b059877ebfa18da398016077c99f5be632d2b76727d0d038ba14ddf0a81cd2f92be95fb55cad5e60dea6cfa58059e4c119098241d2fc42398a7fc3a462d6267ec15b66310635309710148fac9bb51d5896980c4d2f1af6d1538c461fa067a03c4fb11d5639de22de3edc6939e370940d23fcaa221c49275ff7416ebe9f94678618f59532097b2639f82aeca35c43e6675ce4ae299a438fa1e496b9f5fda59309ea317d51f82f166cde7a762bf98104de96d967674e82a9bec7cd6c2c2487e13dd2c80df841551f55894917bb5406828f228e5259daa76287ae405ba3fc3419cec613dbc33d2a1547ef3cf99d9579fec4aa20aec565beb5fcffbad9989ff71afc088306f19cb5e438c39a2bb48f3c524f2d8a39768c68f04223003cf1a21005e6a7f6d42cdea058cf40814176e8bd57b75b4f163b6224598f46982bd6e9d17e84ede68942a43e87ffe8eccd788a12f62628e8b188c8fa82bc7a89b1a44cd2c475f3d7f9a79786e169e7da3b09e9a39cb9cbac6b1a88afb271e90ba6c3c7b1bb30677c5d20b3abf4d3b577e692964258bd8ab8f7864efcce77b271ec192cbe78e8136db09089c56658ff7855bb37d09ab98b8e2a069d6b98f7affe05050661c2eba51ec9b1a10eb1c162622a8064749947ef9dfb59a4e221792428f8edd87dd255e5c3a16828797857c948b337d8a3eed2bbd3a4e65bdfdd0938386283d488c4c7a455339a041fde22c9f7a5a716372d5c9a3decb95d2a50c867ec52029d121f95b93b48f2d2f6eedd378ef7d34f1e55f936ca5ede800bf4202f5a45616287b9bb07b95cbfb92151e2aaedf4f97430dcca5096f4659253a0c4383c987433681ebc3565682891c8cfff9e87f0d8c33148a170273b50c948c7c0aa40d200b09fefd4d9977b7872649be8a2151de72b3925428b984c4b358b6cd09ea43bb0581415962c9e8467e7b4cbc51d51d283ed3ed26dd2e6695ae753fef7bfe8ea6a70d422142c8493495aabaffd9eb732bbd1c2c3d576ff4dd00b4194dae9c2157372a6aaec54187aae54f56aba44dae2b2e3e4d1d772d3bd43990c1151e2fab834347561483ccf46ea72623816c2c30e68269ab209a0aa0e13971ec2fb9845173ce7b15ab7af488747844ae147e54ceff69c3c282f4aa923de428af402dbae5107154d5bcec7b6494a5ebcf6964981727bedff4822ac9404393cf69e0c70365b297ba94f6bcf556631528398774cec9c6130db0d8f5af2014bd00908e78cfc7087e5b2da51d7ccd8b37469763225b47f51a6fb7491e1ea1deeb78f2979b301577350023491608bb21975e64cef89d8e1a3e843feb5f67e9723f3723dfd68fcf9aa42cdef9c12ff3285755dc9f2ff02565f818b68b5e37a688f9f93dda74fc666c76537bf1ff686450b1cd1dfd4ffeb980fa08e263fd0b1ffc4ddd2309be678606816eefdc5a4625ce94c7b97781c3bf980b4847185baf1950d139a9480c62e9ef0384169a07af9ab8f689d02f432d378fa8840e6e8e517f0e7ab6a3164be9fd8b2272e123a85fe67338f8a214ec590521109a23e514b0df2a077b577ae384d476f9c4a2da5eec3713006cacc0d048c9600abce5ad206f8d1155c665f3732cd93e9f5a08b1578b3f66b99acce16bee6bcb095646b58ae41fb66ce2f18389ed7da3f437fb041b5bf2de4f9ae059cebe252ef4b283a1b4a1b07eb464cfe090798b1f58442e7a1be8bb13abe0980fc02067dfbe4d7754467815e71676d30e4795de496fa5f958ab8d89271a622f7cd75822e5ea2937cabaf360c3eb42ba09bd3a2fb90d837a9e3a710695eab177b13b0654aa45b593596ee8744de3f6fb4413c89c61a5d8f09852204c72509819feaa62c5b9ce47c86ba7e2c08433ada0100659d529269d3abcea97e3d8d3bdf497e306591ea2acffefa01056f736aacf7700fb19948c28f560fc6e9b6c51d793d4f6578230b00044e66a3514cffea9fe1cfc9c0804da60a4c09bbcef200989736b5d75b8db51947d70a841dedb611c09502da93c29749b3cc5cc9aa33769488e17f006208f964b2dd02c4e7d014b66e352c5593fa5de9e1e15b336779ae57e93539c0dc365a79d8eb94c2dde01417a14d4161bc26a671f24b0396d72ceabff8e8772e99beebbe909884047fef9309fb6c8b8b1f35da24adca428853fb25e9a5a028b29978c7ee38e781ed6624b0451e619fa1f1c9089dd47c78b6eb50fcaabd3b8d426ee4b4c3261d753bf87495133e0acb568850b82bc5851522f0895fe774b25d51c917045b0edfbfafdb54464e0a93f1a5addf629d3b26f1dcf17ba1072523fcdab1c5e28f33e8570a8457e90ea8cd75881aa67896312efd8440b03f276943771d4e639d866e807e28aba61f5703778234b32a34ccd8d25662d4be37d7dc345ae9d45a65ab327180e18c910b09883dfa01a2f8b43edb34bb387a90c3ee14ebcc70512f286396e8d7ff46080d520077fbb0f935f7902fe6568b29e1edda710a0b7e7351eab2f04e6edb4aaffe4966171af59e3e3057c2911d0f16fd98b338a379e63551577e5646491389250e7e83f187f5aabbfdcf8ede4689c078bfe971ac88660d1bd4962b90eaf97585eb7c634f3288624a9a037615d9d2d5099e06267a6a6e3295fbed8b8febf222d67f3a754c7c88786ac0d17bee94fdb7373f34b3e3e9e952ff4ccf5d1574a066a8d84dedd8a98f26f043da17c3fa22d39b7c11546fe2d89b7b4a951346264e172ed5ef7224a5e40e41a51954984632a24aa9d4fe383171a934e59e66c161cc769787c593df04be05a228a74c7dd5917096c507111ddf806bf9143844f319007bb8b8a5fc57b11afb9ae7a65688b9e12f2af650272d452dabd8f0ffa06da76af5bec13696e4a0edeff7036f6aea263c53a7964e3f2188bf2aef5bb60703e03cca4a2ecc34d465cd89414a4b70b823f65b1fd36ea01c2477ccc40d50b143b9ab42af","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
