<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ed781eff311a765aa10ee173b32967fc23d35c0cd4d00aac79dc875e3470c30ae28ac38298329045877064f63ebbc5e26ab48c946d06e2d0e7683df83410f2bc78c0ec0c72a9b363a6df2fc943e0733c4d526a5350d4553c091ba18dde138f71a1dc3461046caf220cd8113877fa032582ac9e67a3718a596f8d45392a9ee01641788223149e9c1e31d11a9408760acc60c06e3519180ec6e6ff6f387a743b374dbccef575c707e7916e89163d07df04d16eaabf55a648947127ba2c9baf69eb1e9818413959acd7125b88d8b47ae52238d7187682a853b28515d8c0aa7c763a740dd3f5d73742706edb5293042946fea80ceb6cb05eec5a52ac7e531981ab9d62fd302ce288c946e9c7e625ec5f71ab65c7caa5eee992a5ff73e3b31f5b4c550a7087e10bb36710d5f57c47b46fa2212317f7cee1d16a5139b6d344e2ecef89aa1aa5878e0662b59ba6abc9018bebc326e23a1871d9ecabc90c5d3a605aa668a838eb29f6445a6c7b6c0490bb9e03229cb1ef5bdedacb0b8950de7270b00497d1abed751fcf4bd89d1bbed0943d6618fd42d670aba4e34ac4de536c6c3aa398199e8778774f68d920469b772b12f4f0cbc8e5f5749cf374a1f7f8379eae9c292939319c9ce99363444c2abe4874214a11cbc32cbbc8041454cd4d25234c1f3de5992cb2c29dd6927a4491dbbd6be49567aec0159aeca4c47e5f24dff72605895d156814ab396bd70ec6deea93c58f171acdbeb8347f1b89ab5e0d1fb70ff2e76a0b1d6fe75753c2f920c76663857ea29dbc10df4b8cda84129c73b79c2c5f2d40d6d2575a4fceb0571423f73f9976b0fd7fee26f6a633411dae2ccc522b9478985a353af6e4eee5eb3371c842e5c88e4e9349732ca5649e142ad5b51ac5038a19aab923620eaa877919b66f3df38fa91e653340198890d2f258f5e83a6acff220b2d6e315d19ff08237653cb29b58deaaf40b46da47e1b697e396eeeed24175924357f31d8e9dfe11c9f34ac4b041c21361309624645dd9db2aa312b1505e53b3b1afbcbac12687b1af425a5bc384f965e75f4540927a1183957d8146de22e08b4923362ecff4beced6c001e07dfaf281ed50188e81ca22b7a920525a0d43b20f49842528bdfb771cb3874850fd2ab80d132a48f79e98574f13c0a6552bd4ffe5bf8ee652b08eac558549840bd4b07338fdddc17de555869bafc76bbc2b8c0d2c69ca612e62fc9ea7d63520ad259a2b9d02493f881d5e8662871f83fb88f5e97ae3a0caa361f05b8d5ba84c0c53781323ff652eae744816c49203b07eb2f8f43d8b81e5affdc4365fe101680a8d3f1429ece799b0815ae69dff27b45b24485392d3c69d3d63e2ffbd2a871b37384e49aaa3517101b3e6ec8a5dcfe9c09f109e44ff19e08e9b08ead0b2731bfcab476ca2461d9c76b599d3f7049a8128525edb57e7cb75e871881d1f92dcfd9e1ec339b829102bc3b19611a8534621db1e647824a14c883d05c4793f48c51e0ffb02ec99d454fa8247c6fb289f8bd6c5ec56b4e241343076dc9c879b083850b27aabfd1d2c605f1136fa2fa9331a80ae3a49c114937e70ffb7252c3df05bd8fd068f5cedd7ec7f80cea76a0a42244c7a42918feeab9b17d2c256d786e96720f6c8b9014a2c35803e0302a9af68eaab1d69b1a25d3c6adde10fd0d669f3145488881a6e391034f383b6c37df4f0edb8800951b6c1548fafb6153bb4f56bbf6b471e87f0ec9295140d27360eea2e26e65d117f04dc17890fb01e10b94c2f25c1a8ab82da56ba98781cdb20cc9109fcda6f33440e6183578dc91cfa14840ffe9342769cac3fc16f3f0140170abce04554675f0917af0943a320f251a1bfb88ce960b00694184efaad1b3d902d1de146e7a466a39800381fb57329001fa275a757236c132593c3f18014861598048545dbfc3c7ea27b07af275de455a1a850a9cd1750b0d94863600887cddf10b27fa3cba4cd38d407b52a3760948b6e3457346911e5a2a7d4cba3d73ea4e21b67a8ba89af2f6382ffab0548dbf6654d98f53334d6d240278fe0c43b96a8b97572aa574eaf639c25d5bd5a04e5b5f1534dacd4bfec521fcda0d473f3741b8a0988579567ac8b8e70ff0042d2e0209da2d94417f1c6e53a6216fa9853374284c2e18d391088c0751d8c7ad25adcefa3fbea894c141c4c6e1c77cd272bcddf45a917135cbf208fd5c3631fc18c06c285117ca4ba1e0b341ade00fc2619b1c2278d2cc1fa2cb642c4fbdf5b0a54ac5986287b75695e5f8fa46f91d59d00afd5f8a6799713690d25ea862a95ddf7e338ad0582f6dc9acf317a53c3c4db5ad6ac700daa81c555f3f4fdc25d471e0a79d8395f40c639e7293068955a47ac608025fde9ac9930ed487237c9d62deb9ceebeeeef691effa679c3c895242ba19e4c764fc7abee46c2bc966eb1274c530dff05485055c12533c3b5555a84b19d2de2f8c6cdd54a8a28f4b98c392315b66bce7339b33539b28766b0a441cd2ff4411fd26ef7ab010b5813aa3508529d04796fabbadfd89837aa4281d561929d76bd5a014ab37e0ac68bd4f59f2df85990621faaed922f921b72b321fb0699506ca6a9433505fa93e0921faaa7c308b0274dafe1f49adeee989fb23acb4af2c35d51fb1039311432524405a34f7fee754fc621b6a16f333e4ac2a08f38d3297e37dd4350211d21b63a3a3d1e9f81e17ed00cc18269e11cb346b4df54a787f911956e9f5ae4f3fe79a126e97f387dcc40b3477e41af0247c194343ed916bd8effcd8cde5d44e35f86e13b5ecc9a5fd7da8b835ace50faa6e7280d28863e12fff5d78bcc391cc9b40ab3186a9e5c42377fa7df2cfa83890af7ce81fddc2b9de2d3f117f30297ef6a3a80fdcf874e6452d3386a2996c614a3d64032aae6031b2f2d28db21b7e6748a77d0cda29b2f8e10b2a155b0db96132864054421de10e80c6a4afbb0d40047335361211d30b98946cc8d5eb17bfe094ba5b21eb500d6fb1d550c474e2c0922bc775f5cfc72202a21d58a6ae27b0b20d8fb28686ce75c5284fd5098d7eb3d98c2f920d3b859d6574b55da6fa2d21fa912b9bf0c15d4ff30d812bc7f24ec081644a9acf89353a0dc9e72c153b9eeaa53ded05d97698b190a30b6ab5f20460557e5861baf5970c79b92196531234e1f03f3b99028c08234f98b9ce68632f64aa70799e4adac49f6bef1d8605c23f91e190aaa7bd961f626918066782c08276cb6476d7d59dc6534d3dea2397a04d78a08c55da8efa2575489c67c5ad238cc7c0edc145bf020d9658a897ffb86c0e3f8b7fe00d2c8c5b44113b0e14bf7f3011cf04fb11787e6f18f09c50200e2840c0101c57eb1fc2eac747667d6e7a561cb9b9866798ef020dd5f968fd5916ed1ab2d4160be0d5375448c0a8956ad7a917874459d6b282f5b7ba03b4add5b1b86e650f2c12f3c6f3237df94d669e71509622a1f6945d7a6b9287840f46f22782ad49042bf8bb13360931232fc272943367d33dfb07cd41bd0dc0e0c2e30cfa31d6e27ff74a1d86b65124e31a2ab8bdfb632fe6d05d4983a69588b780e6101c7383bdd6a8faa486d1633c007341d5a13c5a7039809070c22d7c2d4ada1537ae59d6091d21e666db2124145dd230b5f3aeef2598ececee28e80d21d88f2901f7aaba15f47cd3c17b4d5d2510f2afcebfb058640e232e4379c8160f46f863febc81b538e9b6af9c975aae3d082e241f35267b6a8c2e6b46634996e140444a0a3829a63f9bd3e8519dd6f1dacca97b68ced8a2fe9021496cd93efb430079be2b416db50d63652881f213013288a29de040240770da0c01ca9530c99311f2e7da907caadb6323cccd702aacf921940a91bc0ee7e88c513721a09770005a20a6ba87fcf3fedaa6e09cd7a096630c55c2de33d1a9a4966811af9cdcc698dc352c6b77cf4f25425e71badae745d30c883cecb4aba03dd820882f843cba4201143908fd093a250777a3462ca28f75d06df621114e5e76ccdea84305676b356a3bd762bbf4684ca4c46b0af48dfcc6f3df910272511c019417a79e092257bef72644ccc0795c2efd52e2e9cae3196b8ec0df438f92ba1b093d47bdf846950fbefd057d6e2baca33e39137ac2ed51ce2683277f495a9bfa42aaea072238e516aad2656dc49504e6d7c1ac8d5798583202e03bed69ea4432d646d9da72117f63d73760a59e00355363692294a1c8f409f6df190bb4ca6ed363866a8ab9d953d74c8048496f8a36ab65dbfc58948f50cbefa0c70d1b490cc0b3a6d2219a476a3b1f56989bf5132a30db32a051d9ddd23aeb0ccd5e144dc792fed2a22a480a32c4464553a358be2d35a288bae54fe956052490a64a627134a00a5816b15a0868e910578f1b75ecf880bf368c81e5455ef2c0360346dc0dc98c5c646ba6f00cd4992e21fe0f55b616df814365f3f62a8bdfb59d09a910f50e0ff945137646f9ec4c9873c60936f4c6ac57407255c8dd8e4743a9fbd4839cfaf79d920ff4a63653abd8a8faa88355e204baa187544f4a72dcd31d2877a3ab90059ac6645bd5c177001d323c7e4b68beca5a3ed785a2f6ba2de947b83ef2dfefee08ad2fe260cbd1f51eb9e0412071ffb1a90fc6236c07d666b0e248b52ebd2a4fab21a8e256a168a5f0d8266eb641046ae1708f9571bab09065959763f2dd12c6695ab95c485e7578047f4d83e1b2e8d2d34007c5e7b43df2ae494a4af3a83f5c0ac6e9d3ea3790dabba3717ddc48001235497fdf3fcce02ff5dc107f80f1b234f860787f6d33caa325bcbad772dcee120ef2c8e51b0c0309bd30bd756adadc2fe16154704dbc3781f933270c5106b282c4ed7a6050425b8d99d458fbdecfc812f310d06213d7d61a9c49fcc6e9dfa28c53aba369ba75dcb58ed2e006cea8af1eaf908977241f6b47a392731e1f7be1988f3feae7432784617ba4722a114755f9f72ae4dc253e03df0f0e04c22de7f53fb732a034ab26d38d2b8f157e03f479e008f59b12a3d61f599ba2e2a023314287a9ca2f15d8bd2871159792a84a9ecc5e188dafc2e52c07e98c36eacb9dd7939deb2339e44a6d388f268c81370a9dc12c62eba962b8b79166135aa8b6b8b50641bca31005bd379c151547d4260f5b931e4b9d8811b61dd3a5102bc4350f8dc520346fdf4fbaf203dcef522bb2907db1a70a1a8ab23b46c881c5eb306800ca64e9844b028d76d2ff3cd0c34a6906db019e0980c433f810021fe1d85ccb6001d33b6cc0a278440d74ad5d171edb72041af515bab6cea5eeed14ae3f873fa63979d9ff3aac8a6e8fb35e0a76f616629bd9596ced4c05b14e62de92a6267ee6ec69885960de3c0c5622b80e9705e9ce58e2ebb18cbfedb3c1d0b4a8229e06ad3ffa2b87e2ae5029dc19cc00b9f497c5f28a7411138c83ccea502a16b661f4857084760820de11280c64b0339c7625e48aad268f0650ce70c01b406c3aa8e6e7a2978dab93b4fa319d3b881bf0614611ea7853fd4c44332970cc62ae4440296d15ed9d57f605c19412d45f26d66b4a4146ec7779b2825a559402bc6f5ce579ae1d2488fa8593e6e23a44f7781519d46280c17a98e1dba4e4dd7eff37fc09b023dc9500dbd9fa19f187f9007ba97bc8351c25508cbc40d6fc10fe03c07861a7d66739545f6ec2d8d1c19f1424060ef8400abb17bf6c1b4de5c3d2f24d5b7c87276f2f53bc88c2dd9d3a33678af5ed74466d8576b9fff014665578e7ecb6b4680744427387fd7d89bcd0794cb329feacbd603333039a55fe777da8d69978636397fa25902fc487d7d20c2be56df305d679e422d583cd6d81d82a1be82f645121435b14e1012599052baca8ade1bc8ca1ab981751fed484e96dcc9a8901f640aceebf5fff33dd7af8e0e77860a19db18ca5f0dc3edada96306ea8414f8948ee3b146cc0e1b6a87d77b8a789441630e569dea42f4e48e850557e10e39f069c711d3dc9defcfcce302e5b72e41724ac5ab173cf29855d3a14739ab3047e0eb4f91adeabcf4e34a87c2fc43158b1e56970ec96403c704ceb1e2d4dea49fdb4cc31b30d6cb653c288f2e2f1fef38b37b7d7d0bf8faf3925c0b624f0ba906f0f87f87e081ec5c9ac6c0064846e3f3fdba20906a15eb5531ff8e55d736613b272191c3679511dfadefca272ae07556b433d9d652de62d8d09cd4e760ebe6142fb149fefb078c3265a5a2a26d24614a036f26b994c5289db690ceacc00dbe444602336730e0d070d0e86fa6377ec59380950e58f90f926d5ba8e70f6a466d3b9dd558fc76d2c47cf19c62ad1ec5f9e8da8b4b751a16a039c46078361ce0fead9bc15c4b63e18e4a7124d1eaceb98686ba4b8c4c50e1d6e92ed039b6cf1256a9f99eeac9e9ea4a24078e68acb3ea59e7f94711fc2efdbdedb2998e1389e1b8bdf148a5a74badda466841b04edb89d51163e1ed7a1260a79916baa61d2e1f66cd94a2d6c611bb3eba2e86ad11f473244c932dd794415c09d5517848a790b9dadcb87f3d0c4140c0bf58958e82ea0096a4b37dda8704e5adebbad9228792eb9d0f924940a5600e995f5cf44e22856a5c91e9a06c167f46934fc5e65a66b2bfb11014c596fd19ee570b7e236af4f85a57d1291a59a1fc37f3f6ce3c5171d1fa4aa8cd218a1c1d4434d2717ef7ea965d122633205edb1daddae7de0addb1dc71216a34f83cf7896ad0e1d210f7d86706b9ccfbee22164f502c281d0ff2cfa7b840f492672cdbd813aa85ef5d184d96b5ae39e5c31668abe20be044ca2bec856fe344aed05a8fd924d9aca92f27333868c0f4839adc540f6d7d919979395653dc3da9da14c8499c60e897f05042df5994f6fb955c38957293700c782270908bc091e3b5f1fa31e404e29e7679e8583832bcc26c1cdcc11e379ee8af0ab02631351c45a8ed9bcd6468b25a63655ea758ef467c3171ecde59a8d15f0948cbbff76280864b17a6f73fbe8da662169edc0357ab60297cd3489f138c0a97f22e1aadf861283fad4751d0433a60c3a0bb09f0e7ca8022702344604daa6fc77e22fb97214eefb9568e2bdff07a3bf09aad443dc18b915965537247b48bb8e6746c297189b2ecb86646abf415d30e9b8585b34034bcaf05559511d75e57e66d289208062423f8a73fc6a59a293efc1681875ea8ab63596f3f3c5bed4717661aa5e6bc575791afdd3033577b69f40ed8231143dc4e87f8a3c6bbe26ad9b71c1d383eebdefcff33a8a901b5c0d72b24edde113fbb0328be74287484d82be78ccfb2c301e2a4329ae07ea805a5c4d48497488501e8404c956a5a7071df0e60cef370c3259f19c077902119084d122911cea5c02f3865a774ce7b937a4362114f9f73fecc38d59e93f5d62d4c4e4cecc9214eac8bcfa10524ebd2ce4f90aa4d289d67768329967d6ea7cdff509f0ff563659f28e097053ebe099dc3052b951090d84ba52039ec0770412faa22756ff33f28000810432a810a8c19f40e45ea6ea6bffc53d010d07c649afe815f6ef703c447544e5d3a2e02b8feafa03663bd36293d98cc79ae6f007efd7cfa68e862dec57d4ebeba5bcf28d018c4f07bf543bf0f09af80b4ace048fbdd9e97d2f83d63ef5d0b3fe51b6504fa1b5aedd6e53d800f4e847e0d6b4e9d07584c89c5bb5910d66abd088ef91db71fd3d065eec50ef13eff97c574e456bff7d85a59965d69fb801b1269b8143874960f6a0777592377ee6bb3821c6d76f253ba242a8f37a290ed9aefc3c68171b1f5e84e40959f71d7a7334ac5131550e207d9289c82dd4c06e303ef1d95c9f7ef51ce5fb0df3bcdefea3f44da9ab17663b0a95832d3edbf299702a59ad9cefc632b371b61843c1a97878494bbd45680fd0e88784f20f08fc68e51bd45973daf3f3d7c8e60b6ef0c22d6955aea2b69d95978d9ede93c04272a505b88cf47b7335a9d56876e9afe2c169201b5eac29fac928a906ee9da2c0def2cb1956462ce23f433c7e868a60ca3ba7543f01067924b0048578293d0ba2a1f8e200f52035a698401d6ba8b6e4ec6221011d3c6ea1ffe6025d80eaaf6aeacb93837da348e535f6c2f6faa308d97afea107fef946a59cc1aba1841a3301318949640ef510caf430191a4e796f2fed00282c7bdf4192d0eb7c4d75059b376779c4a3034b856da094a07887489f36ac03b47e25972498bb496ad4c080259820c49aad04dd7981d58d30a9211261257fa2b785ff9e9355e1975360ae9827ed170ab24b671637d1e362d111abbceb779def30b7aacc3875db02a1cf3c58f13b19edc95a684cdc4fa4d373c02820d8fa0bf00c7725eb20c13787e1ac7f542fe6e4fea72f51bc176999f4c974174c577f14acf933b094579c12e0989d1b415d7a36f558412b04e944ba21c382e3406bfadaaf8cb2a280c472eba8d27715af0d497c51d16b557a555f19a9eb4671fecce724253e37568cb0f343f5a242fe5c6b9aaa584ca2aa8e77dbe0041ba76abc26976564316a9e888a14a0f011e3e05da65e6ef0bfde94413747b5e08f413e97f9a5119166dced6347daa6d4b6c1daff1ff97f3bd0a6961263c666931896a5a84f34dd4107d4d84928e39861386989d9bb2518e4350208a56a6e160c6065c98c14c229a9105e96e204586ec5cece1fe2440ccd28c1ff204a78691d7fc29c713f9fb0fd5ad258ce7ebb1ffbe4ff21930fe62221c9a72a0fa39e1ee27fd155a7c4719ed9183558243d5afd4f2ce61146004b6380970f22e8c8627c740152e1369e323497a3daecf48ae0ef7fef5af76e6c346d2b3f61248d83f48581ba4020ad20dc2691a360f440f346b4bdad82d81ff6b05e0cae7bfdc74cf10b023ef15d35e201d73aa0380c6a5a1b03bfe553d379ac2c68e4071c163cae3275f761aae8b79e979294baabb6e11d777f759ba8f6a7709d9d42139e33d3f5e1c7bd709523f8fee5ed92fa67b22ae8f0f7d03a240e1832b5c6c478b5680ac6801d32cbdc94bf076b7e9f3caaaea403f042d6c67732b48493f5a4393fd694b6a5d2f0c8951ae749edf0850afcecc1f4b3a371faa6250bfadf60ec896ab2a22e2dd31f3b6441454090e730ebe60bdc1aa2194c7f0cbe3afa1eb9da53553c76a5083b00f55caeafe83bf370035a005274ef55a0436a5f5ae09f4def26d42a7c82431d59e006d11f1b79076ab702e459918cfe66bee57caf42f75e1fde109db53b5b1ad36994d7f91a2382740f2624b76e01f80ed676567733625eed6dd144bf1b77e012057f0404db74fe13af68dc47eeae11163732f1876ce33a1ba7d189ca644521c2a206c3412060f8716ade63a38b2295ffc38b75ae9e723eb63733d8396409fea65ecb6a2cbcb0686a91b8498fb87b60f4b10190bc928e743f95ccd9b0f4d10b3faf992f0e5c7e0a0c42fced833082984d7f6e4f36bd7dc6795a508e287035a3bc632188c3675981097ca845c4e0b6ac07c5afc86a134f638c1cf75041a9d7165a425649861034f5ed6d281cd32605ee4b4b68f0012151a830d0b1693ca856b18ada031c164ba209bbd1b79eb5ba0b7b37cb48040fb63520d96d639823572bf9a2081b211c3713ffbebe78109d4b822127ce079725436ee9547fb21afa478ebc49dffbbe22ab12db6b7535db5e64ce3c3b2df9d70451be2341b4a5b97fd68664343208f23afbfab3af1d41037282ad10b07bbbae78661b5a915d08625ad752ce6f1c330d00fb1b7344eb67f248d703fe365f0a5f96971bbab1a53222cef166c1620b3def33a8371c4d0f660b506215d0580c2845d128f3a7641a1a69c8e53cca0bb109289904c57d2cb19deaee280fc57692fcfb7d292e030089c46966bffdf02d6222bd08b60f55bebef3a3e8ee37b7d39280d813d2bd9d123673b261d7e9a6a54f9ec58edf8714064d58350f917946d32f3a284074f214573cb415ba07798d7b5fbfe14953df1b3548b1209297e1479bc6464c45a4f8a9049fda2a060af0eb253a45798967068d951ddaf4d76e3c54326175c6ea9daa14c71c1b121894df97c3d27c43fb72c7ccc822a1022bca8c6218feed5592d42bda8b274674fda278b3f58875f7eb7b5b04c833e02f05e024e914b90fefcf702c3ac6fc11618055ad24608afa065662f704d984cd7a52d52964225ea93f24416d6a3082287e0c7ed73759af147bd5721b3bbb9e0ac1eea63b515d17ab6673df893f3ac0e110252eed7e6a5dcca394f31723129b48fb99953fd48200cb33edbc04326b0e7a04c2fda254a46d38e9a475d9fd97bc484811ab9afc01f566b5590c0bfb2706d8c9dde5b97e072833f8d37d75f4949aa2575bcfd06f5a9e4d0d0488856f8771de070ac74708fc9761ebeb479df44bd78a251ebbab5401497d57009297d5d34fdd65440ddcbf298e9037bcb2bf3213f53c8171a46c35d234bae89af0c5c9516d977b74c32f50b73a8e730892296c6b74f5cc8dda906cefb5b61c38be0fbb99257a808b3e6d92d5ceed0a9bbcf8202c4e73da6d469b9ac50dcf277ec9218abafec2f021c6f816923a420355bd77542b45dd8b98024f350cb728b8f5a08e5104d4c43306f07e8a4e221cb21dfc7453e76b2b82d0b887758e573f905c36e36922746031b00184b70592296a9a59488b3bbf02872fa22930bb473397823d6b3be8b10509bcd742f19905a6ec3a66ae0e95ddd11bbab1ee898253f41c95a2d803f0157d4c34c645a9c17c8b18b4f66a6f19b40b421844a2915915362c194b08bca294f6db6d2a1e4480807bce885abb8bda3e986916660fc55e966f4ba6071eb0abee361d7715410de5198018218c485f5db3b8aff66119e0f9cd0a9c7a488525f9defdaf3f0a50715d685fd519a2aaf739b1e948832f476a9de4025b382a63d5fcaaa49ec2c8cd9fe7516c2fb2a8f2067e62736241a9adc71b7634ec9f61a7efd751c89a0a87637d6a13d81d7f61c4b58b055dbfdf59295ed3d4b00b9b41ee44ffdf8d0f9a2f02ac5f0d3943c87bc7602caf0af6132f262ec10569fbde24ef5437fb52e3f19571f34262eb3a211b2d26ebd97ac529ba2ecd3e916ed32326aee439b45bb715c9259f737dc50e500468724646fee11d3e141e1ad86f7ee0830a7e536239992d2fc129d8289f906edd1879fe3e8057f6dae944e9352358a472c9c1b240f394771148dad390cff2629295f1412896d0b3e9aacde5fc069bff6f9cae81f49aacbea6eacc5421865d395c15c5d334d07dcf40553c6d2fd951b8f09fe1094a5f9d847233f829648bdbe6109073fed919a1ac47c6c0395f8cc23e82c0086a8d4b63b0191654dd4d2760a832b3fed3e8efe8bbee9cd5e53eecbc2af3469756933084afc3f11db0b2e8f846672f82fdbc87640a83962f2deb9e629c8e9d182a80cb0521b239ebc353eec4768deca1efb62dc7783edcffcca02c60e067b34069f9849e2738d7467cccbb1f4eed991c68db425717e534d50fd4db6175b1bac9a181fd57a878e82576e42571d911e4540603a3af1f9c234c19873b05698b7aaaef016e325e20c45eca5a25e5d06ebf07080a8f7ded85c6a8983d0457c27d0655ea3bc0a13a137cbb9fb85baf6cb6d373fe55659371a7238fbe2cc0d36b28c254d8ab912cd756fcf23db8055ebecd5256d1861fe1eb0163665418bf13a84a33dfc8868ab096db746c594e0f8c657c7be9089f62ff906dc9be6104c03de3c53a0c081f4e27ee87f706f24d42b1a2280d2b6e6fff3533ae33d7cad6a3ee7317de3b5adf86566097450379ca4095508a9a0f8786323301b235701be18087183c890867fd0d51dd23fe2a10480fc921b3f9d02faae5c2ea8abd3766a0504ccf45fa62d4296b1e9680356b7357fd5d71e997d18219e9b61788f63c9aba4d139f8c7c3595d503619e71acc254ec307bc5a8ee6432534fddbbd429455c0c960ca1af026c6b9c48b8ad2a60cb497ea4244ede0c94e849294634c8b4de3062df9eec779def8753935b3924944f48795839905c493e678101453fa6d5d82a72c4303e3d49b7a7440f5bc4b79ee14d585d3cd248fc41ef1f2c4f07085378774c96ff24bd768cd51f1995d4cc6d7305dd1457ffd165c428d7b2774a5d62f81ff58794c83a30c7663f4c177881aea50f0fbe6be4a080b5359e571eea40f2824cc5aa921a0a105af8c24ee69ba4163f5e9e4490c338fb288e0a2b7e55ebfea1fc2e382636d1f5a57a15714cda252e425a8ea48ab4ca6eabe116f5099bc5216954c251bc03a89aa4c99299ad39377cf730df9ac2b146a528ce72e935317ace97e8d1b0dd26e4411faad94069afb2d6fcd1a76ddd17a7c20b7fc31f323db0942cdecd4dd7b02706f7c2c221c83ada03ca4847968680628e31bc710f93ef2a86e77bf6579bc2971496dabd23046a9491a53fb0fb88ae4d2842c99feb18c674181611000fcadea7460e87deba0882406f3983aacb8d40e152b1445ca74917fc6922c1d1ba80c0525183011b7a675dc8c4102247020672fce4f85041f0f102ca2469bdb2b47b4ac8d41b3f2adc3ba59e14743662eaba3d8c5e01efe2053265438f5fd3232fd7a0728c33955da6d9fd6c914ed3c60e5a8747c159c1ac5461e7847a3b473e394d14c8c6065023a1be47ab9225154d02a08f5a80d70fdccdbea71f7b77f890dffbc853d9a17f26af26d325c774aef4dc09af1fac967ddf74fc292a893bfba98bb0c53ec62e03dd82d6668b6b9085648e8a935fbb97bb5af0249c4b5e2870094589b2c57a37cf6996ece2893bc825c71ff4abc863aae1723797d8dbdb4c80e3404c0a90191b82a6e7a070049b7b3c9e605b3be5ae6e3ba38c44f738be56c00b2d30ea3f7de8a70f37e2b3d5e6b6838a0475715bb325933984873ad7ee8f103909b8a88db05659d7a7130a8052951d6cebea566ee50447e64911bc254f3351d1675281787fb86a9129ae6f658554dc73fbaed432ac2f01b6d83c92f44a97671d0519193e78141539fe611b36cee258af92ddbf84ae9e954851eb147170915250b2a49cb10d16019628cc8603730a80d86aeb5c220057f055afed34c3afa365b4ea8e46effb0bd85184774e4d783c1de681b8256923b8a149573b852275a2f13f17a008d8eab39c9ca6b3c0f22f9d61ca73dd2b31ae391da8c9442d6d3edc9d94d893a366663d6995bf2495510cd99c608c13a1ec9764a557a97d181b8811531052486ca89d59e3390e7b53ff36fbeb3579cd7f422d7138e87db9d4f5eda8ce1994d805a35f750866117bad063c17a75f480f5917579881e88daf86d130301608f23b1112302375b1dc64774b8f7567e8bd6c42a859060af9d2b1445dbdc45e09a1842f04f5e8bfc6655af128e2cf20b13da9b7668e801b4f1c154ec50d015acb106d513ec168f0802d047e874f3959eff1d3edffc1d27fbee79c839af08e3a23e45626fb501afaa941d2604d21c76d1576aeb46f381387322cfacfc3da39d9468b97b2ea01cc5ab0f5c6c00a657ded93f25e3b5102bfc62ecdd655670a7f31bb7b5d74b7cf9a0ced3564d52974c946a9eb22233dec9bb89537c6784d09f7195b1d19558e4d8b4028f93ce10a86e566c9be25c04dd29ddac78339846a85114d239059d88f6d39b43d4aa94001b8e0958ba1a7c3943482c92d59d4a431ced11f475f7748610cd7e07f845cd4ed993d6013573b4b69250219224119e55d1d7f07f1dac24b3ff101a10a63a953ed4b287d171becefdf4459feb81fa16f334d73d05ab390996e22388921e08bcb7104813ffe9046adafbc0fcc23b3c5c98d742d531a67c9d80ebe616df3d1b299120f54372c10a4b69d6bddcbd57f6aa07eddeac19a72b40d9bc88fc836d3e5cc58eaa29e30ec1ce8b99100b3f5225696e1014db905433afb941539382d93522ac67381466e52475414f6211709fae20799d21b3c3126bd5073eccc33751ceb8e4adb55c73081d5c3f6a321559775435cc50e9b4640f7e62ca5616f728831925e9a8c409638920441301a324856ce08c11c4d980cc2b2e189ce1cf7d35719f2f6f076d1d4390fbff8817a4840a89dd01e383536f736f5e9973344e1769cdd21382a33f7242f31f8c8abf78442dec6529041a771c72aa6333a431e77081bd29f56f23d1f48362cf86d2e2846d3cb2c693eac968beb7b268815d28692d1bd80ec6cc3cc0320629ae785330d492a242f1a294050448726ca4c77fea7c3c376227f1844ecadd9c2caaf0a616edff372fa6948e870a4b7d4a20f5bafa946613b0d05c26eed761a35373e648fceb58fc826c759749c77e43fb3d99bb476151460a8b10a6b408a2b81734b3f164a613d13dc6009adb27fbdea27aac19c4a60ea163f5eb66d9b3a90db7fba68ca8f719cde80ce5ce9952374de3add69d8b1a6b2dcf8f23a9a922b5390635ae67cbd54d711b47b8210191d15836021a4ecedfdfb468c286a90487960a69ed506f460a773d1af8b0659581b6978a6226e8f996c1b7a47fba20c10d108ec36672035df70b57641c73debb37c89cfb3e8615dde895aa1c44b5108c0b860bcfc624fb79a7f058b2fb4e29cebc575c8923ba154b50baf1b2ab8016f0cfcce632e4ebb5be246790290e024057218a66646a7e41f60a4de85eef7157f811333fbae2f59cbc6a4c3c697507180eddd317a9bc904b5ad5a7acb77ecbf932ec292a8adb860da3a2c58908338d2ed97bbc48a8b6c3c13e8bcb9572e3562bcf3667528220c82e501f98288b4258428e4b9001159eba555542e2f2dd72d3453dfa59e464113105f6879ba1061e0a8aa29d7c9b5f3efe78cfefa94e8a8608cc86feaeaa17ef8a418c123bf3dec436fb3762642c6696cac42532c5c3c79460c2c7396dde4bf712141a922a565568f4dc6ee74a17dde4d935d25233f001b008d5eb039b67cfba78c02747651a4b14f1f3a1558be992e32a9ef5ff084ece7687d06654915059888cb2d47fbd643b58dde647fd66ec5404d2cb9e874926c665500ce6e43ad757fcaaafbc2a1f60ea0be24e48f36061ef8fd13ceb418f23039977f9d8bb6d8decee820ddfc4a4ee71afe5f37bf68c536e352af3368de959b3e23f884c183e61d58a07939b804a23242f5d271b4976b91a886cd0298053ca0a1dc212b8b247ef55e1c86ec36daffd43686c6e20945e6d4dea17342661c60573ca270cd6e0fc16c029feb299368ae9cae6bc4ced42eb47d3b0da23ca995b469057ed28273ae19f4075fa921ac4c998c32b5b96b94281c2a8400bf95ea7fba7405916b348ca52a4a409cfbfb91c0cbaf0288b2d01f787c9eb894b4522a43afefda4ad90c9b867ae57419ed7bf6be63cec9b1c5f338bad9dc1ef1d489d486df04f9aa2620faf43194b23aa1a6fff287316d671191caa6c858a3a58a55c176aad0207e5b7b71eda43fcebf8794e0b945d758d32a214f8e0702012643efeef73ee9fcd9647b2474f0075bff5a047e6c69d3113b5984da04e8af6dcc55521da6b6c9c367e7adc76e107cfb0af8f3e505060960ec970b458083ea26b160d6bcc969d1605745fe7ddfa13b57afc6828d420902e522536b034026da9a6fcdc3592eb77d85ad55867c67b45c212743e65ad2c84a4ba8e8bbe722e79570f13239f199a3939aff44bf5f1e3ce076e92e7810dc38252c8c35137480c493281107ae9475eb04800e8242716bab91c0f68b7700247e00b2d44ec44e40bf2cee5623bdb9db6937b764577221ba791628b46390ed89646001f0f2362c8b10ee150f1f7bf6f4543ca89d1f97691de59d23372be894f0297ee6f518c91e6f635318956d2489483d3243973d8b5c8fbd76a5a3589fc776e9ceb871ced60893f0559923ea049ddb371beaf9bc98e74674a87fff67f8813fe13de2ccd5c206e6003265e89fe73edec2e873e25b69f22edd9ee774361bfef13105a7ef50aff9e4bf11508b706ceba7611be706aaadd949d890cf9d175350c8f3eb1ba3edab5180efe272f3dbc","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
