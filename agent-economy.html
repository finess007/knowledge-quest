<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81c905ee19f27c58f06540ee142b4dc090a8377a6748bfd7a65e84d6cf6a8fda199b0edd1588d8a9e7bd6c6248d225f1619faab546907d494a1acb1919a28faf8414197b3230c13217ce47302fd2d94fd15a5ae866a1e9eca5ae634070b2ac81b3989791cf5375beae968db3810d88cdd9cb545dda9b4c1991e2190d14598b3ba67f710cc8e66194801b4787862c00b8a72cfbff48ae0ddca50edf52f1d8aea2d367200198e3b04dc3fbd7557c67f314fa048c669a09aad1aea9aeb9b19173a96d38d59d592cc87b31c501b59c1028b70ec0b236ceff83e9e67cf6aab02e2f13e20227fc879381c246ef5eb036513d100cabc15cf81cd572f1ffcbe12eccbbc72ed193e069eae05b8d8349423e4f441e0f72e491d90771c95fe96a692ec3728e9e9f3ff41c894bff53bab6300b4b3692c283cde55b4d62681016089a66f218f156a48b6cf402e01e711b3051f91166c1fd176cb958959e9179ccc2593f3a44daaee7143ca7349977feecce11c1b27a530c594cb27676ff74663de283c4ef4ec87d01096dedcc41753ec48088b6b6bd1976e8d9eee24c2e1fd946d57d3b2f823d2d647072d6a8b1ae3bc7fa8b002ce705ed6b7ddf6d130f370295dedc3bdf1e2a0df60b700ec5570768cfa34bb81993e3812985310ada5ea4fa5abae775ac8cca8fb680e19a60a5d9e9bd30ac6e588e840ff8c4110a9f65132205de1b230d94b1a82f0107949b802c34d0a8b905809fbded455268a22d04e62cf44896df0d580c22a6097e211d3a86f6df28ec84f9f0aad5c995f0e714f81fd84985522637c43fc8f8edb13bb5be1df7668bbeff9c99ae9f3d4ecee9e39f78aab287818232a06bb9a18ffa24c59a137a0034bc3ff68aa21f607b8f0a28ac25b7217d24cea269bdd1594bc0f5595c07912268bc35f780a0329252376ba08993406fc6774ae417742bc9061e5161b203a41b417de0105e8f626f151d22befd44e87d8a0daca07970f1804c51b566d07432b13290396a42623eedbcfe6ecc104775a95f4c80569cf739c1d3b5825e0e67947fed185bd03b39facb0bff1f1e3fd490aba8a124bab04228a46c46f337393bfb8b07da9e697200dc136a40b193c717b99432b23517b0180ba31c6d29d4f7a42239023fcd6ed9692f08c42bc678b5c85c8c976389d9c447f216c969672834f91208ac06ea9f1134bb04de29d34a9b9a8619c75d5333657e3e7a62cf8720b688708de943314c338865976c61d3727e6907ec702cd60cf0ee4558e34194329e771999c0915a7b0fc7027ef713c89a4c05ebf1a3c081735e466b95d3970e391201b3e28f4b410e7fd35541f2e5695dc7601e8dd4ef0fa520c3e619fd0a390f522c7d02da993f07075bec620d43ac7c413f32af64c4f8cc7d66b385519bfe1ea7e2aa42524f81321071878bfcd4d4c71264bff5f3306044ad5c2b0459edfb3487bc7b1ae0d15820b7704d38964351eaf7af01dbbef3aec9cfee1a305c5cda6fec043d6fccdf49ec7e8463f4178b98ee605f2e433c841c03660c49402a6b67a5c30e1ff4507a2eda9a7e9705b73c6f031e2ea9f5dd1c10de73f243c3a99d5aeb0ea476955e2ac40d2095a85189e7e24fc786d304d1e7652bc4da7fd8275d6260fb0f91d3fedf66976a9800d07c0cc034fc5d48e1ac78cc3a800cd24c70dfdbf800a326194e9bb6eb9740750462dfd802ec67cce78b982387c7b70d9ec736556acf3f2106071e70087d954d45aead68e284b833ea35b8a4f94b401d4bdee1136f2747c9b54176fbb01be681c6ca1526070001fa7a5702b259f1e3ac3bb966bcca2055bdb5b7fe40dc18258941dfb1914da4a594ae76ae470be9f3da09a1a22e198e24d6554b6fe0eea77ef8f8e2e42bc8766983e4e24646c754047fd9edb977de28856309edd41665ea77c76062848ca1a8cdc19cc94e34cf48ad53d3b201460c3d0a719137f2b00004fb10db411e22aac2e36dc1ad5c3c64240f06ccf53e36476302055cf72da5f6dd35973a6ace7c0ca73b67236c1d831d32ccf2b94c3d8b2abbc96d9e79b8f7c4b391373661b1a77e196b51e2e41729fb71e7255322a90d4e6cb129f35b3baa1af7af6e1c77c2057ab73e7402064ac3a55acc2417ba88aee01b692e21eb05534e89698bdc27375862900252383f97b8a26d8072ae46b2d2a43f020dd26c80f4c06541e3168eb1e65e5893b603e64de640c91a73d3947efa88adc0c5c938dc58f4ee8de26b73f98b354b18965f0db1c1c87da0530aa65ca18a70a0e8143a2e2e606136637947d104e86a39454aa1754934c4071f9ce9212421fa0cfdead242346bf7ce63289f56ca412ef7f3213d7703d1d6aafa2f6d38fe2baf9ca522500da196a5c46be4e4023d26e38f13e3ab4c50980a8d4f0a20eac51a52fcf354ba0f98114ce64873ac1f069400773a9697e8b41f649682158e24cbd5aab9a3cf3562cb54a2057bcbdc04d2b126013a342c93fdc7becaec6710dff688b0537a5f887abd8f016b560e2a6416448413332615157e3ead3dee370df29571464419575452f8582ace68bf8962ca05e62e89ceb4225d6c4f3931213774f028e1304f13ff83bf50057e001b5a4ef614e934cf1a8766801b93a1fe81d668a27d01e56aeb2df030b402ca322542e972411002a3dd0513ae45e0a1ea9eab9438c1b6096e0f1674a877c27c777a8d309cff7720c23efa71b2da6c8f13519c60dbf653f440e1774125b094e444fd65b30d66c6904b6a56787f58c7fe7420987395d7141e75cbb14934c1de80d980b4dfd695d8659d5738b8b58f56e436f0ef23c9b20c2a6994e49919cceba71c4b56af786cf4bdf787a070cb7ab338910ba9f4aa6cce6eb3ffe8f90a1706f26d5a8a2e881a409ecc68685b6f90c73a61b4c3ff5ad925b1cff6fff5cb6a7547c4d85effafe58f1970386fefe427c1320f52ccf978ea40de249a3861a2d45d3b2d27cbb2a2f7d9ba5018f0a2b6783cf5701e7f21b924fc2d4986f52c4ed7a1ada7e7c6235de71384716f51852d63bd78bfcfbc59edd5497d04dba793675ae1d06f683a6405912d240c0139920b655777baef8976d806bd667eb7074ba5454e69ea89284cb707198ba6a830ff1a71f0af001c0b847a6495792bc4bf8dbdead58936d78b02aa732d7ca906b899b795b940dad1f694df0898afc99253cdf31263dd5e274e89e00549291c39927aca77ebf7aef0c76257d720571882c80547730014ab5fc495f80cfa3e8d8f907d70b67cf2e12fecc185094c654e160249c54766634fd5a1d84fa1fdb464be05e55536766537a9c8587636958420f0c46c16dc9e36412f8dad8ac3adfded2895e2dedf2befed2eb81db22de7e7d5cd0a8e71496eb30ffddc6be80183851ef0260d63517b71f5b65c9517df01c736dfd78da581197a6be6a441ad0a36e61c642a23cfd4614e7ccec4289186492a4adac940257ce740c3d10ca5910ac30eb2ed4ac874d49dc39f4aa420611192d146c7450e350e3b30d5549ea62bb7c79eed1dca807a69fd1c8e78697a67467f7d1303dc174c2482dc649f35b4262c27adcb57f02a88145064cab0378ea05e388f4c5f59a5c3bff6a67b38ce46087c086b33c26cab970a82e0b44a1fda1754519a90ab2ca496f290d7f818b6a22750773913c280f8aae1990ac3c19ec1867fc0fda1d6aa6904f96a51d31acd7bbfff18e417c2f6fb8917938dd0075f8c6f422ba590fe8c5c4131dcc97af3a5bf3f9bef5468cafb90332e08ef370e0f73bca40de35bce52064e0f1a479a9ee7eb84990d4ae79ad5bf5e94d5a3cff3306c61d7cab63a0f30c3d76859ac56910a12c469ff36bf4162369c8778ad30df68fb53ffbee03ad84f32e2c805c735c27bf8f980a140efb1c6d96f3fb455f4c3e473bcd8150f4279353f5b08c3c621392a44884e92af8ffe9ce162ff8b5c2bde7fcb08137eafde14bbb52001b07b6d2f85a33d3fd25f3abe1e6ce98cad763c37f67a8c286b13e3d06654c1e2084c457d1a8d4cbef5f71f0ea4d40a15b14f3a50bef75387cf48a2b77d13548e7f2faad9ca36145112c948b28d993866f35e274008679de41e0929c299671e2a4fbcfeb0e531e5a7868d2a7fa3e5a3c7b075d6f04688f1e8a2bdcea7eed9f7925dce4929da24eccdaa5dea3b369c1458274b7302bbd09b5f8297de00c4abe685212cc117719bdc7a6005dc2d960ea9d5d38d766c79c69f11c26b64b809f8daebd21f17146543ff29fb8ca312f43b8bc0b19750a00205c92b05ab931d274e26257f1144bd7d2b91c6611559c0d7bb04b6266bce1f5003cdd8ea9555fa982d7f5cbb402fe30aced250ab3b56e65fa5fe3278ed80ad63bfb10a6803ba7658ef9069f009589b5190158d68587122e043231c86b8705707469aa77371a72796d22e26ee98cbb708597ff266fc1029606e53ccd24b22c5dee21d24964b6355e4827e6389375bb1b85a0aef07251281078b3de103423d53f988380599ddfe51c7182963e0d4fd97233c3a8c7899bff0e2aedf41abe8928c6c6980c184c83e373bfb4251b6a8d2ce0e924f2f64bb7bb9d8f53be936272fe7bbbb4719b73a4ee6b5f7d77d3047caa47225370551f1905e33983cf58ced458ce076543a0d13a7674f0b6604cf42d2752bd70181d2c93ee3d91f580974e5cedc1e74c7dae0bdab78aa334d38d6dde8c4b4b1e0214e6c5f3a3b0ca96c37bc79cf1d87d7595ea4ccdadd3a28e47a96f4d417d708bdae09eabc92ad007261552e3f797a399e8db3f9431c9f595b8e651a36fae79940af15433b734295984dba52b791f46799423d55623a75ba46dce7e5286059db944de190c66c08165d579fbe5a8e4a12da407ee6710aafa53dfa66a6b5acf94638c411468b36191dc679ace133cb89463d894a28da030462197b21fbc4a58a66defdd84fb93f0cbba50387f4f30ae9c0bc65745d59aed8005b7e5bc463db29e2fe2c5e7248ff375d55c6e429304f5d04dab32b69066634cba56a3cfaabb5b6c86f7b9362bcba43c6b27a7945a466a9c1c39332c3940c02cfa8a0bb773b4ead50ddb237a80ea7bb0fe72c2af7362998373f51eefc6dd7a25e35d177e537dd5262e84053a47bb9dbd90df5df1ac5442d07ef5d91e7c1991d67915fa6b84ba239f6ecc872fc154c0c4c261db00c0444f669baff2d4fa6073461f50c5f4998d9e9b29d488de194e3d760ee5a6df92f3eb5aed269febb8455c92f40bb6786eb17fa8c6051254c466fc3a98a911379c472d4f8a6ca9c6b2365a3608d193875b53f8af7984fc8e62f4fc3f573e53dd7cead01bb3e79eb85998fa8f53a0bcc21b3e0d20e319685f7b1edf904ecb67a4a6ce36648634a52c1a6fe6e4b93a83a5fb5caf2c9a9bedbee646c5441b20c2c60210998de1d4a1831f76cfcc0a25f2f15ae54788dc7f42892d77bee225a89893f5a9beae716bab76a00d630321ef2477fcbeca6385b839101e7a5a349c5d97df12236844f2dd0b4a77f7535c402ae0ea5cf3e044106ff58c86f9ec8a21872b77ccd70373f3bc095cce14268a6b7ea9ff815228e6f5a10fcd3112994f277e6228e44782393386061e589f825a8da10ceece32e9f1247e952ed94bc7afc800a6aa87d329a0b8f6e1bbecc18ece4dec064c6be2ebafb3e2fb4621ede2aef6309909dc37ec80ea53178cc53aa1b5b83e7717ab6d7fcf240213a9092b1a248cc408989481f0078897a41c434af8cd697241a02fae440442dac6930c27c69f9281ac127784267a499d009c109e7ec4622ccf26f190badfeb748ed5f0387637ae7de11ad6dd3bc70efc5615d3cbd3afde52a6cfcc67f671bbac321f3094ceb8e05ffaea0db34e3ae62397355a6e5f16308ed9068b8f43f1fa8c80a814365f26b5bded3547ed79b10eadf8c6ccf04efd5b98eddb26889220dd7df85e6706d4d79044ccda03ebd74f1e68003d162b8ef9c32153d14c4c813bcc0072377f86950f9f121d4fc53cac46189d783ad5318e8ad882cd0d1f5fcbced71abe633de66273c0171e92453974442844aabf11bfcf741ca1887b445dd8e21228fdcf5c152a7a5026c64452a34659142028270f14b6237b5ee21b107ac6b1674668ca931a255adfe288afdb1f1e6fcb61abf337c7ff527def38dfdcbc512f599157d5e30a7638032abb89039e5903ac19ebadfcedac3ee02eeaa6f4448d3a8d5edc02ec23eec3d49ffb5b618bc241cc05ce32f6ef25f6f73bce72e51ad657bb794f35379b2836f4f8bd2a58dd419d59b8c60a5d1e7b0cfaa756b22ad11239cc4824b16ad9e20e8923bb795dcda511921a6605cc165ca9bf6c907685b4f3d72163b9b0bcd59761637727fd74166b83e47b92d17b9799dcee07f42de09a2a54124d07e181967db90ed18284538ec47e2cdfe34f5b1b69f22c6e098a02e671fb62d45878ce49049c9e097fe807d238938428e3c179a9c49a3bce08caf7a5dfff98c885ce9066d5834b0d2960d8c004dccd5fd25df8ac35868f907cdb93b34f0f77590d5331e5088df57fc545ec4e03b1731abf2df7a017778fe0bbddc55de3438e3a447e9b8f3da45944eb5aa695f608c0bbf2b3aa5c6b1ea296fbd66c13ba1145a88264749f3146fb55fc5c9a277c196ca22adc32b99e172470c29db8fb87a4d933ab75f9a24efd524ccda6ca8345fda2b2d8b2c3fdc8f93c77406de51082f7c798a3130fd2eba2936db6165dad78aff9e8a393fdb557da00034befc09ac4be6181a02c980feae012113ce6e74d62921a659067b6ee2bc78ad9090c9e5cd3a619a814aade89000bb33f6defc6b8f2f8b986c507053528e49b449dce32efa5c22e884bbde3ad40d8cae43d809b5c55b78f6e598f4875bc03f6042be9a97cc1460c199de6911b9829f3873617235e73839cabcf3d8edf9839e77a8f06e8ee23cc493ab8b57f562045f8794e9ad262b0a5b946b73bbaa196691cffdc4197af78b49f0e6ce6043ad8a0b15954ce5084315eb9bfd6929991b9def16396d8dadde2f75f02f6ed0710a8a23ca8dfb8000e21f987a6446e5eda445f06dc24ff896ea31ef52092de251dd49cd01377dc1e61835de2128d2d9578e962cabbe7a8911fbd5e3aa75e4c5879a8e2fad93167226989451876495f12605abe0e0e4240c1d6d36252cb3367530d7b5d3663a810b4ac607c17b24c5992671a3e9a2fe5ee5c87a70334334653aad79fbc702a2b91091cb6da44a02cb05f1a4fe2d40165dc047b4beb9fc9d1d44ca554c8eecc7666bf1e5133a45b98f27a7e4222a3d4de4fffbb88aee04e787b0e54bc59c6a80315128767ab3b9193c8afe998b5ed023df18f71138172b37cacc0749f79ec71ec3a4f261130b8e9906bc23224b74639f0f6b36f722063d5d10b9b6493a0226ccdea0ff5dcb78cbbf0ff1683466214be66e9442083db100b4a7fde25d71a927f6f617ceef22e33cb4a43225a0d139d10b4b5648d55cfb593c261db20b1795a781cb948088f2a03026a3ca44d1b4e9eeaac359a14e9ebb08324e4b1f17be5dca59c34a282ddb7b38cc5559d3874c511e519ebbd8a49b480d8b523750aa29cd2dff74fe998f641b55ab140b84ed4f5e311e46f80ea0247d265aef782a596f7e504641c4e3f0247f76c31c2a706a5de4ee134db4961bbff83427df597c29864fc025d7c80c5e5ca31a84ed51dfbdcad91c079a0be55b5e3caeea6c92229e801c0cbe7d58da4dcc37182c8f4571dd08036c888585289ca9513ba1b52ee2d9f4a5f75ce70c2e8d900222e1308f6fa640346d40aff4ff4603a46d95b14ba531ac3e5599a1be5a40d1861847bf3aaa0f4790dff83839923fa9279facddc845c8ea9b1df71e4560626b0744be66a011e002eca69bfc7c0770cc339aa4a9ef2e1459b366578cafc7bf053ad4a67c1759f177ca3be3130e2a16aa9a4ea2f0162781cbdb3ab96087778ee34aceda20d6309cb39c1e4b20db160b21810c92682ccaac89203ca1d73f4065bcb71818229953d3dec8a4c14b99460f1e47117861965fc0b5576126c6eeba6df062f4d25fc13b1300d62b20ba28c225b23b90ee18be1dda2eee5e4c98384d7637125f9c052df68ff2c56793c890aa9f3333d94ac0cfce1406c504b64f79f9605bdff5de305502f13bdc6c564ad4bb40b69fb9b466a3d18d261af2e09f0027910729fd439cbb724f6fc78d658a4188a4c4c294283530a18dbe5e31c0e05737d2b3cd1770bf487fa611680ca67da58bde93879e9ed77f60bd460c431716ef9da039e34863525d0efb0db066a2398b9f01065d1d42f118c886362ab5ad282d663390589c2ce146c5549bc9e6b1e7c79423359904c2e3dba39cc631fe9818e6797ad17c966059ad6c4f86dce0d0e490955d192bce77ada0b9da8a3452de8ea15f98db9b58913ded8ce65253bfc29c164398499b4efc2bd90403b099b7d5ae0b0328542465451d34842d9261acb4678c06380c284f2fd8b117586e87bbe3aa1f0a15ff421c833ac54e01ddae2cca305219295cf87d1758ae1081f2a0bba3770cc36bb7eaac3f0a87215af7e67bbf754d1cf454b11552255b17ab05a3db28ac5551d86a94f0b6f232d2644d62a2358b0018b329329f4ae9b735a0c405d6e85ed424dc3d22b85f8bb8bfb84c537b099e0212e15d1924f76d404189630b8892473d5722949e6152ad8577f2f5a64247ef64b70749cd676fbca5b2c68c92a56ee69a51eb6d378bf344075cda0f94ed6069172fa1a3b888901c8d8ac14d054d062be75c8d5570be4714d0f7537de9e8d93853c33e30d8879cd98af9c6b9a2f43b89731e08d305c94c29b4b08d799647a5daaa50ca5890f28ffe228004c5ff3ee940b18b5188b1b7e05554398584da60761cf71a56b9b196330d0b5be1c59d4a7eae7e39baef382e9a2b51b124c42c6f93e09ee3a13a12e7796a9d4e4ca273118324695caae93fda74d918138f516d00d3cdd018bb832d1dc57ad22ed9fd8aec8baa8eb9d97351c076bb9c0fc16aeec4d5930407fb0bcf5a34ef7cc8b95c0049beb20d0df6c5dfbd51ddd3a34279e295764b786bb118a75e5754cf2237a8b59558cd271bebbc7a17744420f5dc235d5767a8a331d81c765fe284dc113d9bb941db476dfa50ab8b777d739f8f34000315ad2f1c82bc8331dfe704051d71debdbb84b50e3bbc1aff7a8ed4aff9d2d9101dffd989f8930c13cfb075a651d526d2a729a8a5fb6a18a74b5e9b68344cef63b661c1629a0c7aa1a1470571e71d70a3ff71f3a31923acdf4b8c4b528ba04fc0f5f3266eee5b6117d219c521e0af0f1d51546a7da5fe1c1b0c31077dce758fa5dd7c55357e70cee26828f09d2b2bf9bc31bcad7b0bc684070ae0d475f4e1aae17d6e00a6a79eea8c84c8613ac1eef0209a6069c48d26afea5af3cf62d68ab586558addba1be03fb8681fc695dbf2054ea7bf19e89521295f777d6e20a29def00dfb36afe0f585756823c9ef42c69d3de3015fcf4e21b6d7807ff9754c5cd74f11838413a23e5d319c6df054fd32d56b6b0d568ef0982b4e554f0b98ae1165d1c02e2149db36a8bd60d1fdc9ecf2fa1d90219d00fd3484fdf3afcff6468a1a330a4903499d5f286ced69797acdf41abba8cc0dd666b3ac087bd43debbef01c49937366c7690ff0d9aa8a4c4e52644baeee763202eb85f66ef05ff06043964729ed423d65ead962899f9f1b2e65bfa3f5d1606fd2b4a6ce622d7e0bd89df61cdf117be710f2ddd47d829eef932a07905599dcef73360f6bc2b8d57ebbc477a863ec1faafc197687e6b1f210fc3e824b98bb30caf2ec7d3763a42caa12087db5d1f160b0b71b5f05424e1438abdb3af29a416c1d0b406daf78d0d48b4a6df37bfa548f3423d002bee8c377033fce31e8e33ab43971785a39832138c2670a6ad4835e1f42d894d23e3635346884324d96f36d6fd411553919dd6592eff71bea17634d29991e69076e7a50c561e6705aa16e499cbacc106720b9f4172bdb13df90a1516f8c6f6ee51efb7a509ba1db1713cac846f6eba1d74222bf94c8c5b16f8b52a91f666c1787c6f4225004e2e9b1f00e3a8f1932ea775dd9625e8ca63b0fedc18ca6d21abd62796ca1489ac7afde4b74f4a0d137e785ac577f6af69616512182a5014ff0814d440247e3d7c20e1761d877fe2c98bb9eb9401269fd2b7bb1979a2e05c2237f0c2219662f5e56edb2b38578f92d24ce5a8375ed7b64e47fd160a8fcdf9c13772450b6568fc13ca9c3b74437fbd76bcc608f26d9b61b7cf40a17d02fb95dfcf7d5575ccd6256bbf2058f68a397a1b1505230d112b363753fa337f9477b0bf3691d0e0bde1047b37b1a98d7df46414ec04cbf1959d364bdfcff61f0b19a7a9722eba18c4580bfea2f6791591dc4e603d03805b1b174b5b8e0dccf5f9241c6651cba6bb1888f372d20bba54b77dad4bf5462af21d4f12f941d5c89a852d8516e6527aaff783b82d48c28822424a23ca59c638a1fa4d023dc5b5ffdb345f88b50f13ea987e0c80998007e314a3de94a3f98928e1074c425587c920a25969c8cf620bbe17cf9d400b8898abea0676ae8e0b8a2c7c896803f32d3acc7f1ae1b863fffc17c31103944e310c22da06ce83a24bc97a3be509d5e14c2ac910d814bdac007bf878343a6ce5c26716bbc8454819c8c3be81a0500db08562f644cced5763cada41837824bae6a9867499ede7f629a9c1f47a36ba1b7cab56466c1acd6c11a665fbdcc2dfc59029b351d0228adbc9c2cfac77bd90f97256fb1265e5d48bad31033daf75c92a499063535bf763625b575ba93a189cd80bc70fa7bf12f151e5678711550e3eb744253b7759c87954a79c8da5d79298ad10707ec3ae890812288391db2567f713c74d22fc2291f766375b0a39a29aaac245faf10f04b3322222a296427d8a5a2d3d4034ffd74058d66d01c5fcb567874dbd43a483cc482598fb844d0f5718e57b93e4cfc49286a5d30be0a097596f36d3e5922e30f4cc2207a1e3ca6688d58f2ad01e6aa237d93656ab453f52df5f867261f5359121ba4cace686fe3ca066ed7e2183980c6e602ad3ec763b3213b6f3548a04afcdb27448dd8c5507dcfed0ad46fcb3d6686198b244db4394848c129568ba938e41e7ad30287000a073b1eefd68caf670009fddb2e269ae64d167a957098439805399bb25de59b9439c1b3c89a6846f654f928213cebbc4fee18b50eac43cfff2c9e8a0164ec4abdd921c1b4da4e2e7ba71f612fc29c3d197cd3e10871263a4e49fb2742b71963d3138ee63da72a0b2b62633aa19a1909601a7e246ab288f0ec7af1b02285cd366fa41b46ce97f9c0f0579fe1766c7ce4afc5ff8ec3b399f9503fbb9daff2005b19c1033a359153d74343825114991e08e83368c6f1b934e2dd411ade44176a83aed6bb2ac413cee42389cc7ed9c29f95ba660d984d327ee8bc0f19b7c6d2539aee03af31096a21752ca00721283b7ad8be3ef1ae11d328518efe1baf8d67e22e66f840400f86acdac8d62f650c991450cef803947169b6adde8e38c2296060bfbb711da72e9f31dbd61ac88ac5b4712d814bd6b819fc37aada24d4958f4193b590f0e4bbde6773af30aa53d3f72f8df4b4e0357c0ec6db00e4093a0436e61031e0c82c8309b9a7997f5e98ee16db7e107fb246fe5c295add65c52a02b699d3ba1f62d54b5c76726cfced3f35cb0bc282b7ac3d0954cfe6fd4ddee7a0d42b1778440061e24ad6eebe3e54724da0c7a01398e78acbdc9ffcd4fb335b43a55d43aaaf8c4233459d7d3804adbd260859c37ce092ea09d11f6f518cbc6411b6e4195e157137af02ca9e2ad54a94aa4891bfdf9c014cbd3b0ffb4676dee69af7574e636a4ee83ceea99cf813df6a4f8202d01d5849a183e1efe1e57ff55acfbdea646e978f9a5b9d3caad2ecd4e7f9c3317a52e5ea2711634688c9fc2a35b8447660dbbe716f3a819652beb90680f9bb1153dab0445456188a1fc23d17d66a71c604b39c10a2199e9bdd363dbef606b3df0e41dc93ab822e47f483fa2ce5e2cbeb2198a2ec94ec535328a1fc330cbd9e0c16c0a29a4a6d378efaa4724b61ee3e136ac456fd40cfb3810ac64e70318156f6049a91a6be2ab74dff53b71dda07d6a9efe5923837ce7ce835f14d6c98c23829d03b6f8c7d88b4257602ec067a61bd098489296dc32a973d34248b26d4d2f9c1709982415a37db3891eab7e000347bdaf2e6a047f6c3241ec82b36eaa8051c7a9585bb32677eb25b58ae9a4fc289c973a6911174c221c8a89e79b36e0c6226a37617a87adb50b268f5d8ae7254fe2e6535628edf2aba049eae4954e5822c510b31f55fc1f6b47ba71ab765d7cd1b7cedef0ca3f1d2ca82d3b727e91b918ab14cb5e3b2fe5df50b18000ce2373d488f93b798f87025e1dd470852243154fdf11a31eab4f03c69a023907b83ec6234e9606f48789485ecaa90511d3a4aa1c6c5770ac724ee5cef6d174d6b4aff53873693f6484bafbefae6f0b6928ecae140372d0376ab7c341c4cbd1e8aed1970e64bdae4c4bd124407ba16d77ed8bf3cba5ee964135985744238b46c71c5ef5d561be5e254db92374a9c7e3475d3b6a950f7cf6ad0c04b1b0d413a86e5f4930b5a24da628eb94901341cc7bf5039c6185d9a22d270dc09226800ceb22c768514eddbec618aa9de970c7472418d60dd16f3354e763fa81163d7fb7af94fa0d3d91c7883bc25e7caa4bda46c311a3b846301e610508573f572068ae04f87dc6db5bf0ce2a587faed8d1e0081b7af3805df338180154835ec520db14120b1b7d3c66f1280e48107d02eba8874e777200ffa590f2c69b3158b579cb89e329b081850e54125495a6b56cc62732d766a5b94c31fa848a1fea0bed0ae073897489462dda7d75fadd8f182b86c358c2358536816aa887fc72c58ab2ff1f37a53b00662e4a6a994e4b8784c59456940e9f4cae1e4fb103103710c51ae64c5078d6238d98bbdea2c1a0672d24366acc1491416b7e418e9ec3142cc387edd9547f7d295c9fc6fb50a2d79ff01d3c75ac3c2825845237f83cea2b0cb1b1dbc6f8a38243ca51679a0e739e722e96a78dc709abeedc8a76b7f445c203345592125db08ac73354e97590f50107099d309d509f6b84a9d323016c3dad13a512367fde23676568fe4531e1e6ae8bd831794e7e85d366080de0c38f4d71a762dedb5625f3718acb28b6a8c391c4e0e7f681c43f77b8f013506ef995020189832f6e90377845ffa307d827d2d2a9aca20a098e5b278277e2e68f0ce1b32613602324d9d8d2425c009c61427d2d1229a6d924353603c465d013bed113f5469c0bc78882c772da24fe4290e08a13f56fdfba3b2bb7e894bd2f3873a0f8c03502f6a384313167e0cf4b41a20fa5f81081565e32094677d59a8ff038e52046cfe36320c70f7b6c3b81fc1c6e4a688fbf6a1219d10828a2b00bb7957a8f3429430ae2dc60cca2a8bae45648ca6bcf24b66e95f99b88b12def2d4a16e1a043f24b262488836ccac3e4e995608f37ef53459656fc9f48d5a11e7570d8cc788c4c53c5dd94e5669d99843b9d46315c43ddb153e18c2c62009d0947a545129c3429ec34fd85158c20b520129491de232b3bec8dabd8ca6e472c5bf22d113f13746f0d90a538a617613f0fd5a92e76a7733bd1c08494e6472bdb98faf97502d2cc785c8719252e53a628cb2a25e510a533a320c67ca9ad99aaeabe5823ed3391efe3bf2cfd77ac1951eeb9d7e2af22eac211cc0ae2dfc44ec0f1b961eeb06d182734cd5d0c127f90e94e18e1dba8df3ff8e1d4c35199e0e2083b9f502a8ff4bf0a9d112d36490fa2707d89fc0447725af4e32c6ab8c577f9bdae3112769aa7870a67103ce6a77a20ae47187b346ce2254fa0f9d9e806bc4a35fc64a5f886ea56d79d2dac00f483c8f795e57b0b3371f85a04e150db0e01424efa8bc05fa0d1f85e1313b7f15f41dde1ebd3d90036bbe8fbf6ea6bf9d624b685974744a53b9deb419a2018c5f1ff8d4b5ca73068baa25fd619acf710a6846165e9507dbaabe9dbcea6769e60aa2fef9b3adc43f0a93cc12f43539c4b18b0f4ea0a1b771b146d07a3ef03aef41e44249ee380cecd32d0c2da38f8ab50b6b90604661a12a08c6088004438c87ca9f5e17a5a03fd7ac575b87b16ccee3c274259db0c766ce06c8d2ca2de2846fd753f4b5da292c5584ed39b3c2c0978870902bac49d151146295b62312d3c7635445c3e5615e45cb7269ca6668c911862345fdf5c73980e7aa8d02dc6940a3b2152a2528f905231207871976c9818427b0e1befb1d8f9b7d00b43b3d3d2b51ab6b38a210e10f8e36e8bbeaa0f9dd4ad4ae7277bcd8e97d6e7105befe51b17448817ba8f06b3f9e4909d1004d34f2d078fe632b22e9540a838cdc5928af438616a56d8b293717d64cdcff2e71fe2ebac1a54b66ca27de60bdae27e12f8ce1852da8507fa34594e84508c4f10a8b661803c406c3bc2f20e97d02fff85758d9cce465924d0a1faf20a7df1abfb818016aeafdb7f874b96ea60b1238dc976135cb44d6d7ed7a1535dadc8bc573cd5a6f6eb56425b32dc4ccc08addd22740719e5a957f5c9a8c767eeef79b57d47cddcedcfd855fcb44cc03dd7843f63abd06cef86531466ddf1d4a0cba2c87c2973636a280d5988e63294d7eea5412a84884ff38502674c3ea025e9217b396cffcfc560b0ca8d63e3c0f367730b985d5dbe421e66f30aa841a761e2e771ae94e62eb0b2fd7eeca873a69b4b61de810a78876b13c8af7b553f92ca76c5ffd43b400b41428e5b123e2a16fcbc1f29a26a6db5e4788ef0167f8b2ff1c699e6a296695efc4c8e9b3c31e23df93001011d3a265194e0213d8e6299dab6badd7a6b5296a1baa9a1a3936e5135040963ba50ec3b33b8d30b80ff9c7cdfcd610c73ff5be290dd606f110fa7b7b29a342179d636312ff073d824dde23879ee11c98d54f59fad1f4d2b20f14a57f274f3251d5d098c97b916d3c063324c61fd4912d74c3294474cba6a6c8329182417182acf446783fb1553232d956af025c68728c7b9c9455c364b7e3b5bfe9d29f472f5b074ca328fe65ecc4212d45c83432d63bce42fe8e44c316c8825a51317b8dfe02274c54ad0f6a20b89fb5904aa8a0774ac4044c9291ddd4990bfd4718bcf42064790bc5161a24860adafd649efb644d98ee24bccf7cc4ab6fc04aaf378651087bb8da7b4db8cfa601292f5bb03e5f215818f16e6fa1ffd4568af6e94574f6cfa486b3ac02f673e81bf2dcd0c023a084e3442856ac32abe25aa2bc651a9fabdf8af3e9950b35f4f7c6547534f9937407f52626357182a1d0e0e498c0444f88099874708adab5503ebfd77a161ffa663fcfb815c4864dd1fc571d8d2d5dc2ed1af4374690b3ed9caedc3672dccde14c8776baaa070aecdfabe122777299f00047b4c6367b2f905e2bd0155d5b031b5b10b25eec4a20b7cbfc73d779026a120255cd6b51a8af334ec73cf330c800619215786700e708fef8fb90cd4c5dcb3d21342cfb1ce41483cf63db2f1aef331558d95c8dc7ac1793d7055f88e538c9d1bfb17ac2a55ce32a1d9fc7d843456e14f1a5eff74de5cd6841731a15066960f680ba9d4d2423dde01277bb39df8a19c52f57d086c79b2f7904f5fc16464d6ce1a4f02021ce5e7f0f4e4f26b8de22d3cad179479003ca33d3a30fb240b2fe3ac7317f6d891bb223775088597bd6ad7c81a832bcb19afac960ec544e64b01b11c47806ffd7e5f4b8aa2d74af79dfcdff14589379b5df43a72ec5c1cd3456b93e5b0727a4258657de4fea3686bd008391aa9c7cd2220b835652cdcb279491d7447292bc8ac10c7a33faf159f42634ebc84d7ce275892ad73931aa1da2a0b619a2789705eb58dc64fcd07e10e0de94383cc16d160d52028642fc160bdefe952fc10dc4127a1efd73e7ba0f6","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
