<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2cb2f9ee6a4a73d2a2291f6b252da5da97de78a28d0a6e1eb3727ca8eeab269712ec3dc0eac1da61e5d1a45d355aa035a6fd6640d2ef12f7871df016c0427b587fb647e284a32e24dc1236256fd5a11b4b0c61764b2bc85a1fa4cf1ae52fb55b9314cda69e40f3cdda3721f21342e12c825ae88faa138342004da63868277ff506f9f84f52773b4455e06b0d1e531ef5dc2978f986049a231ab2db85ee7449fde634485b997c488f160b3ade20e3721009d41218be43ba04dce3ec558277bfb3ff0ba9e0aff7782d1ab4d023b0286a27954e59c218ce27ba467680630e2f8409709b4f22aee1c2e5f0d0c0b828ee1c371f8b97d5858337e398c7c9553b948dda79cefec8958057892bfa7a1af225e782a94604095b11a6dd94a932b5fe9add8c4b7e1df6026d9509d0bddd654ec9ec874413805be4e05d08f52801b38dc73355aae7880ddc01d7ab09043dc21ec35ec91fdf073aee6cdf7dcc7d7c2b09bce379beb9b637eb84792b4fdcc4118e5147f2012319ab27dc8b5bc712338336f1384880b1f8548faf49914eba69a6df2f4e09b60abcf1785490a452f10c15b546f9c3bf32cfa792739a92b8dfd93639764c6785b9ceece05fdf95b21db44830645d1c58342665a365b6a9cad648ea3f198b43366aec42f188819c8aa8313e9ed404f5c5b0032794074e94d4dd3c087569984c1d285031ee87f097b246b9ca6294d6fd4d9e129624794bd85dc2d244d7fd5c9c9c8ab725345bd60db4aa8019874ecbf9f66dafceb9205b469966e4aee1907b051e72db79ac3e2ac77dba8a026792f0779820fdeef3c3c9e0aa8f50ba36b8c96e3efb38b3c958eb205654857a84bf9930e1b9a3452cb056993c343b6b0b2a452195668077697b62ed84340e3d4c6cbacf6412d86c47c0490db4bdfbaa0429bc7bf400fb2cf21fdb3300187eadc18269796dab9d8cf473d95c46144444dedfa2f54545d95af97f66d4b63dccc9216de2e9ef3c84fbd375b3b481467433989e595d50205c267156e5fb1f76347caa9d4f52bd0e78aafac1070584c5e2a3a38ece1083add33a6ba6f2ff22f287449141fd00396991bdac8c39a147820403aaf4a6a6eb36b023a504f77c6729ed74cad7e8b3cd103d3b45e0f195bf30d50e6a4538e1e754efce44bbcb77c22ec04806c56e9a383977abccc7b5f3c0b29d9788d951ad785166b5579e4c8b201f0b65566d6e2fb42e81d32824cedaffc1f802e80f6691bffa64a90baef34e95dff7e8308b80e619d08df87f238c015b3ac94ee330f59dee2c951d6c1461fd4ea8d665f0fb7f886b7d64b10c2b3cfd17ee8e6d7549d31c0dd8dee1c927a54f01012bafa1e8f33b1162c16776e6cbbbcdb0c23fc30be52ad0573e4f1e54ffc3b5d53ddde1995af48094eb03199df01310c42e344e35a548d575dedf1873af2da6eb538fb2369ebce13fb6c8b5a913ce37e1811927867d49728c291b257f2f1fec6a0e806d6449d868910c718b1b84d001bfb26051760b346e9963c9614c1e1a08cc1d3b5525890a719f9f12c71a0cfd53de6439b88c8290d74d6350604e1238ec49a5b9e0436ade3cf5e5d5f4c83a163e3bf01d04a0f96fc13a71b4971e843bc85db98897832cf75c08e3cb737818621f525619d8d3ad001c1bdb07d2529f6d81cfd40804b9c39d3032e17b88253e06fc619d1bbab31c4e50481f98ba4cf765d2121ac28b941b191f637d23864d7572b547005d4e6bce2e978638d5e41740241fadfecbf0e470d30301cf41f9893ade9e54813581b2d6cd809684d998eec3990169e90515e3fc62d529ad48d8cef86bfc614589dfcdbad7869e6a1cf816ce7b727c4a4b523f593d0ab9d7c4988afbb685cd8fb4cba1b72d77893d4719ba4bce325587acf9dd9378cb2347e7fdeb7cd235a3515b5a815375d93323148c90c108876f291a0146b3e25afd853632e1093869d5bc3b05423f29bbf1b5601d4341e221eb8c0a6b66912f0ad21a380c4056c8ff3a3fbfb1ad2fb11db1dd5b473555c00bb7ad8dfe6aa6357e228cb5a5e14bc46474b8a11d667cfe06c467281f50c8d4956467b9d4b8c94e49763193d77d0123769f514944144fdd154bf66eb12ed93a8fc048c252ef8fdcf8304ad03cd8526d36f8a87af8563f9e7f7456303adabd98dd8d2bad3b440c259e37e16f514748e93a5161930a2178f57d57bb4d86bf5009c7ebeb319593cfd92f071ccaeca2e5c71cb30002d0c577ada40c51dc02582c8795f230c7624ae8682195841c2b37ed265b2c066927e121046aa81513c297ec8d93585f5734c559d9f2f1c69bc2f4b8e79921cee906ffd3279de48cef2b429b0822cc76e67831b0412e20c698ee335c5ff70aeae63f46c7ba35b8d3dde08f880e007f3b2c0a2cb86331321d0ec0f4273402a3dd6fe78eb8fcadc6b0a28df7e4f47bcc7001f11e47fb10111b0d6cf4efa1fcdcbc4f23158e07d9964d73678c234fee260854a5b3de03aebed451ec27099811fd57eb5d442b08a979e17587fde0f3f3d9dd5c4414f4744a33496d51a7b8cf5c376c4b43a7623bb36c06ec298c44dc9927ac436329346ba0432f7f079572977c1b57c4132d9f282b7ca3535653332c5f23d6b677434b11a45d5f21236df51fcc4b0cfbacff8e97cdb7e028c491ca49c96f725e0e8a9831616656ed906b527b5ca96f7b9e36a36491c4221734786a30c79892c75f15670fb82bf65e0db2a6cbf2bcb20ad0274e0b72fac592ba8c1584c0fa4ffdb7a01f10e2cc1328983d54206fd8ccf1c767fd76be04a279c59cfb50606bb61e7f13346481c70f038537cc2842adecdc381249652ad9b872a959a50552f55943dc6ee5eedfe68d9d6dca7db66ba463d730b75a4c99d69e1fbddbd2a08b8d7eaf76e775d83e28b57bacf2eef32c68b96c5e734cd06e341fc8f5f56d9e9680f66e05bfd86fd0521618a670e3eb306d065eea3c6a9c14db1ffe9e1575f5d2ddeb99bd5cab2427665d420e566e04f1cc4afb1f9bcac70ceba8de488d382e0f9bb7482e5f2c64fa9b24638781a1651ca6fdac7cda5a4fd56ad97f5f1d9de36d1f2975195c131b76401d8179808b229544c453b47fd232b7df6fb11880a3142298b2c2064402889fa1772434c56b9e3c5e46b05c7e02f862e6cbf914ab48a69d7aed9bfb6c40043684d9700528b9967dfa4413665b9af8e3fc1bc7a5cd12f981204b3c7506eb3670d95dbc83bb2e5fa6c7e1f5c1fcefa26d947486f81b7c3fa0ff6ccd27964a97f7a841ebc1a456e51aba6d3f460f655f2ea61c6cd63944fb40b1e93c00d83ec20d67b3c5d8d5cb70e865b5ff6c2ed59f584aa484965e13ec61f37d7bcccc4f230bdd0f0a56584238c31768407744e027c87edbc485fd65c457d716402c80edcb3aeaa2861e5128764b951d3558b4689b11ee7528eebde614e8ab5da2c865302830e52db35bf09b4adb4dc2add25f5247c34d4ddede5431efd3f06cd13aa81c5ceab7378f192b331b834a8fa6b0c34d0dde29880128b30fad6e721be9d24e02ea22e50093a82ff82c21ad6101ebcd5413d6b580b9dfe50c5bda9da19a9ac17f701e630af4b3a7f7f692f00cf355f2867adabb67387bc18f3d1b14d7cf7cdc385b1566163477e7d6362d228571b7acdf769c65343ce573796fbf13f80162d4cbf4d89dee888acc3e44a18651c768ac17f7b71951dbf5aeac61a0d8346340e1dce9c52ab19f3ae4d8bdde166ba9ebf53e09a49abdc349e20b1a0f7558493be127e877d0fb4730b4a8ede9ef2e852f8f2a46c76f8b9a961cf6977d0215ee048964246b9374b907fc62b4feb540a6942c14473354cf2934effc1336b72e5236ebe42575ddd8aa258be21e95aaff48122170f92b671a4b31af355f7ea5e8daeda524447eafcf3ff769bff2e8c5a5dba83d75b34c1b7be29dfff0b09ff6c043985794585e0e7812df0a88bddbaf514be0899ba8fadab4b92b32d672098e7ec9cbc9e66b556308fa1a859cf5023c9420082fd92a037326071ca217c18a4bdb0a00343a5149a516e747b5fec1ef2920e5277eb277f34f8f63825fee97f7c28dc0fa9c09d4c62bafb358c479e5bd457d56a355cc3824d4837a415716bd5ec708ae88f4025ad2eaf2c374eb526c2d7b97c8185cbc679dc2fbb309eef40fb8b10710ab9cddef0b5e324deb0e7562b34e1c5ada431f6785002d69c0d891b77ad4f6e1206deaea6eef4a222862e785d4469ccad8045cd272033ee539a6ad16bb8f56dfc613ae8715220491d53a51bd4957921c93a1319bc18f7a7cfb98593645edca7ff28e85574c2aac4a0c85e4f531b0c974716906202fc050b94aa195a50c25f4479688b3b00b3a52d05c601da226a56b9f0725ed91579d6262220c67be0ec9b193dc9ece969f0666dc83b0e714426bb723af682fae7f150008d80d8d4ca10960c093fe5e1b010d3c3638ad58474cb1643a14c0e8e8e7b546f071218421165ecb1d344089d93b7ac5dda0f05536bed9747280336829b21ad507e31bab206ad9b65c7e37f826c8832df7744a865a913112b7b187937d7c0237b0a04fe68196cd1c5ef78732f4c0d5739096f7895d29d6a70347eabb5aae05378a27f7bd190b6f0a167471a8886ef494577f390d7046548cc1bbb883627581aa14ec63620e0a2d31cc1a28badb868bfa73e357049dcb42119ec52e64373a3c9aff84d14831fbbe1db28cc39212fbd3e2f6f127a0704743b445a04aa3c23754e3371cac56bf7cfa8e59cdea3332677a8dbbd15c07b5913c34144e6bee1b0ab1f9d3d4537a30bdc2089c5f8c7a568f866ea106bdd9acb05cdf6a7c68939827b36699da79233b69d16a56cfa736086797e620b099f8bbf721ea48e175da1d0eb79ca51c6f9a971fbe4927347654e579c143251db16ee5865f1cec2ed80335fd2eb28082b82d5d734615432989f6ab91d95690d9a75a12ce91bcc7182671ec5bde1e91c997d3b98ad3b4800507bc24c88ec44cf9d095a82f80d4fd1939b1225afa70c72dc8038f79a41b201c52fa8fbdaa91d3d60a747285547fe1dba0ecadce3ea12b81ebea5c22196c1a9513f87d6ad2dccba7e7d661857dcdb1f54fd6b9090af7ebf59244d45a56204ece0c166defc8f5043f90148cd7d5c88149395e0381099065aaefcb67935fdea0bcfec53a9c8601bdb4eed4f6ecbab5c8ff41a8310f2c76ace4a66d6bd52f9ec7534d9bb67a39aa1e1e0655540ca050a74704849755f38ff88de655ded490f11835b19b2dff369068ef3f29c7d9caf6f4ec06ccef838959716dbd66e091374184cfe2f6b7a455da7133e2944948452a6d711d66a3a5f99acc29df5f22e24546f7802362ba65b21b2aad0db96e1eaedb04ddbfa694aa3ee88d5fdf82101ed78edf9959f31d6be596831527ec88c9257f69b5a5e09102282064505a47acf359de386d94dc0d7b626b08d52cbe5af1549249cf7d89a82c689758c7aaa310cc23f430f80374711fa79f8c3be0f20ea567c7e52852a7b0496a23e0111df11da1f26a99b205ed20d8ef8ad02878f9987482df2cbc9c1872d6e98f387fc34ff016d31ac3316b551312cd80121f555b2ba11bee0a492e679ab6f36ad424dc04b77392620b1df62b0725162e6ffb6dc4075927e6bb7e423afd1a4d729ece9b30af4e0107a1f605d10f16c4c44408f8c96e17380bf75b2a798dc07917f29481b8c66e03ed61caf96372e97d67d24e88552c6b4b34cb0f5dad3860cda7ba3a638c358e8eb00630d7fa19d25cdfb589359b2ef7da9d53e999da6bef99a0700b26d67997d183b1ac5c6f409348007685a832e0c7ed43e574b3c28d945dd0c6211ea042219b83817f859678619527793485b5d1a86b285199fe574fd995fa46c4878d48d32105803137eec5cceb16fd2b452ac5c390a767f642cb744dac26190af05bf31f8b5f199650c85a0aba553277295486aa0c0152f87ab39b38f2303c559547d1289e148cf865e004e6665570f7582028da32b2d8a77cbf163d289e2ce5cabbe7e68243163e1f4264b4b7f761208fdd1836c8b59818b97277b106ab7d01d5e9e4c4fa7663b2a3dd8609dedd36e4b3c9d74fc183b37af6350b28e4ae5670836cc9b0a14d1e47881ffbc68d329582a597491f854bc8faeb48f81b8b004f83998ca188394e8efde2612f8a424aa2ae19785ce4ca61913e0e3f3ca9c24aa10bf06d04f9002c7a0869dc73dc1d567adb55214c1d7975d03f59091b56b572a4921b7e628a3ca6b154603ece8813fc8b341fe7a95b24cef5f217d1a0f5bdbeba63340f793ab4cd78633b1b5221c4060abb7103aff1536fb672bbf0075ed12e7bc33544b5a8d83def8c311ab741c0ced04176b188b4cce583889678a5eb904cbf8d0933251ca83d21c58606ca8a81574c4c9c3bb7240d4bf1b8b43db925496ce3b6540d51600ea775a845f7cb129e262dd9d790be31a3e64e5c93c4b11e4443bb356d3f80a728e51b59d07e9de49578534c130b9a5f74acdd4b468dff19276133c8fa20cf3e5b0dc5071df5b167793bf507b01150d2f5dddbb4b68020274602b6eb9921192284d433059fd62656daca54cc7f58b4a8e16aeb0dde75ae32d2c4e1de23b9ca11695d9c97379d5ecd89e61938a1c42294276270d7ecca10b1feacd19ce76d5955c28a7b5fa2c5f8c738797052bb07d04fa827e64b1685a56c29139be4a6d57b8dcff7376715befee1715210b2bd91c14b42c7d2901af3e025e2d922b47d6febfda10ffdca730465f2499cf356597df1b7ceab294aa3d34b993b9dc943f55357b6e03b8943f8ee8a0d478605c35e18625f061844b94f254eb3520ac55c49acbaf975d2d7db5aa21c5125baab9ffebd40f2b925a0e5855fbbc54259c5d80c264680ce61c0c6ff935d7e3836900501e7525d2fa4a1dafd9eac4f3eed1591ba2237f2e9c41ee5a1fa9422410beb4d7597b5d2b492df488ab5589dafd989cfc919c467ed99bb143bd394d056702cf6cb70542bd529dd9d9d9c49d2a9f851b3bad424adc89c3ea35ccd06c66c371532fc02f01017767cc85625a7f3b01039c4b8b6e36fc498f488b33a6b01c5ec1ca15c73e47eda8aad0a080be46a2869b4a2b5bdc26b90e2606771dc2d7ae18d32d8c71a77eabddd4e27d1c02530718f04e752873934669a8759b14b348d428ce444bfc89a9925cdd12b65c08577dc16c0e7e76f8a986c06fdbeadf8844808943182fa019d4226318e6581a713b86c0961cd0a0c35105af3fb5b994253dd00dfe24c9eec81e40b5da2f3deae3d0c5b5a0d22d0ee70e03a225e140c2c4ccc577d739e3e4b9306ebb431448dba3f8b0e318a719e58f661fb1623b6a962064e821e7aa64c3ff04aeef0ed9d832ae4edb8caac39afb1d0a7d1ddd60412591f2974593debedbb5e4901b073e5304b02662d1aabeba4ec70714aaac679c3acd424921dacf247e1aa210406447dd0f1c8e16e1147e66db513d04ef501945c79f54c961bacf62b69b7206d49d31d7f1a716f0a7e3549a67838b0895ecb33352d222a9e7d660047716302f8e608de1a5825c52f9de7a397ccac145af86b2ed58e50143ef3faa4645ab63239f592ad39f73268035efed40ceb94d9ba3ad828380ab815aab06e868ba5886b4419dcde0c291afa83192c116ce07a1645ef99d5b4c444f80a54b7edd5bd2dc4a3b6cf2b5400080066c9812068d904aa640bd949db03f4dd30bec89c0ca0cd1ab0c8ef36b2aca34f8ab1d0e279d8f2911b9829471fe5b572f55500b04f675c0495d3ca8fa130229330ed129928a2bc635642b4c526cb7ffabb6843511e5b18fa112aed547d3fcbe6bfeb57d83d49333dc3cdce52a9279b0161abe0d2edbed37800470781e56cb0f01e2194b64a44b120adea1dda06f4a2bce5dcef3d904dc5da3c73e473267b8bf036a38f439c3d2b8bfc3b02d47541cacfb66b0bd1d943c124bc89fce6cfca5fb76837c8dfe60b12e2f5c3229d739295b218a436117a2bfaf21e5f8869a850854d0a1f5e0bff719b488c8d95662a6ab588e7856668d9ded59456aa9c8a332347f5c9726f042346da5a1647feb7ee2c047ecb5856a8cdcda3b95124b9aff496e71087ab4f228fafa89da7fd1bd34d1b04ee681af0f8529e48c4d43279c3266bb58c2a8d850e386c9b1851b27399f1bde28b833cf5bf55dfd010047ef4a314858bd1ce49454f7867cbd77150f694c158bf5244b59a7a36789801dc386934cb60bbf76d1a77a17ccea5bc4b3fd4604e52e948eee0f18b2045705f93a296dbdcb3ef58f16decb71c970159c593f5b05e0d015c6543783d6a9dd337ba3c09664e4a7ae95bf6a58e549a477533dda03ee08488418831fc1629fb199defabfe37bdea8529d9783a11f5ef52c9b3723a820afacde39d7a7a6c1ee5bb0219a37b7adfb896c7416c387b673e0255f73d0404d45b1f5698bd2f194418755bcbafac077df585ce9cd39937145433031a8425236065c2ce96678673c96d8b0d8c200d4bd181bc6f1c0df2425818e618ca5e6cb9afce597ae7aca7a4810fdc075a0473c1548e067fd80241b963c3c98169fd53d0a5e34bbd71deb5fd46f76f33fc052daeae7860add429a7f6e2be17c28023be932c85b4f5e775af421ca0c288514c0c70b39de33a23a962fc1fee0dd2f6f51f260a20627f6e6569d9241d3d908aa5539130aafd492e041816c4c287a9c05dc86bbdb28dc429fc40c1396bb24fa3c7554ace892aee800df7dd191a25f8e9244666f538be85208a8d112aeb260d56b6050f89eb53bc554080645a72ee7bce924cb44f731de18f86a8108eddfc31fae0cb155f317312f7caa6f5a801759df87457e9c558ba541d8a7dcbf6d8bbfeeb487ce201001dacfc94aef17d5bdc0ffcac7e219b52f49f58faaf9ffe58342e90d34041d0a31e5bf8e75a43904a8f1e7a375dbc3a33acb869654f607168780d823be22c6e96b24c9a0d91ec7dbe7ea79506f3b41abb1bf101ed7abea4f8444d493e933a705b66f59c54ec1be7964d9f2f8526b77f6d82e77e7b2d8b8f723a2fc0729d0ec1c93c49628e91c88359222ec38e902783865fc1b03e176338183fd22904d6e3f6ab10778f0c64470093f8c3858d16404f15cb972b1cf89a527da8063784a05692830c64438dee5a6d7162bd29dd9487bd70086bdc9cf5ac0ff7d2942eb084ea395636ed6ea1349715e4f9f8ae49864dfc010b06b3f0c8bcc18f5a20666a7e6b77cfbe4d288a78343b9f996205274dcb1a1c7ca8c86a1bd3ad6c8ed487174c29af6f46d53c24e205857a98be4c03dd5ccfdf9ab46c157d6b8db68f87c6287ca5304b4b1253615c27a666045e22bef3b346178f0e004e4ae930d1f5e173e7c5dcca4ad80291613a433236794efb17c3fc039d960bab1613b6a952b284ae8b54715720d39b0d3370a432be7df3cc895e7c4741f684a14e842ca6a54068ef583012dd44459de457c12308dd3d2d21a2f3333459e71a2a595bef22368fae2bf6bb80eaf29c27cf14700f2f8e64654aa19b93045036d0658a12c3f4653901676cedff4c4c7319c6a2cc46ab38d3988ef7c8a197f28f35a09e91e1ac7aaafcb43e8e09c78acaaad157fdcc60f35af68b6b45ea1a1c92912c19706b7c0fd465c9ab48f487eb52ee470066eb6b584c76c2b11a6e7ccf64d18ed44a0327c1844b79e7492c03b4d698ffd4c481a0aef64f1b114010686e17d1bba99fce6fff2195552d8d4733c0884d269bdcc53c0cc3738702fdbf667ad07f3cd781782ea492fb7e31bcbb216b05e2ee5a79580fc4379a7d1dc2efb749587a45141724ef1cce53e89413029288b9a63e7eae98f6cbab83f36c0184672a80a156faf6147c9ec30529d7567209f488b242096dc1598604430a5db3a51f16b232b1d2bf9a345efb1135e236a721e48aea53a94981994c41f3cd16c0951a6c3a3f4a399b7eea6242a5810b6a948be295320d98e5185def3625a12e8ddf11f9572c44c9f7267cd10b05ac1bee06ce001b95bcaaf7e15743039bb0852f8ad5a04863255cb9ef714909426405838821cbcf535af2f240c56c434e881ff3ac2884a7182493567fd8182a4c733f789262b92d18a1c268d4f66dcb1627029850cd229e26fd82f1cdac0275aa9f0e82b96bd7053c492aeb59b6261cb54850895e56d9b2db204a1c2d8946a170fb5f7f613dbcd282e7b427193c853867bbcc61be297604fccf1bcea11ac569e3302cce05db187c15e11eade62bf0d630993932c35c278dc4341555f55048e257dbf590d537631096eac017f8919d05ccee4a8ecb54d7372a26ba6783e44892a05209b80552cf22e2153b1a754886a81991b4a6f438e2447cf6fd3ecf07be815af56edf1fad82e4e3e03c4c7331c17a48405dd226e47d431d856ba38de948c97370c9e4207716cf43f8cbd274138fd2006248c2e276b4fb3193412db373f5028670d65fad698a742bad1564a9c847c21c5b2d32260df73f855f8355dada9b9cb6c8f369a04ca8b7e128b746c42e5daf9571ce3d0635daf122a8325ad391b4162c6bce7bb368668eaaa4e25ce6697f1f6b54b4dccfbf74022e015dedcc04498a7996e7522b0f5cca126f253983d338a497d2ebcbd55056230f2f70ebad2760d0110a4ee795ddef05a019880d36609734ece87861db0d8f46cb2102135af69e702588a7a75f0a6b23be609a3a5be7df15051187cb2c7340482688d70867f73f62841a8826f6828e2b1f68577c3760ccd1b7dfd741f9601b6e5aec3bf3529eadaff95d4e2158c36759cc56f9ab320fd172f95bf1d30b9e506a06d3bc289fbb089b17c30a078ac13368e0d105baa5cb4b3cb382e36e9553a4ec3a6e10d9186d8095a63d30d4422ca7dc0eb34283e6545d7a5048835b2de5117b16f6d9bbae2cfd0278bbb39627cddd64dbf58e194d30f5c134c9cd6a565f387d4cc966155bb21479e89abc9e55915e78ec4338d75e5c0816d6c4dcd1842599fe3b107abbca00ca27dd852cb51999baf19eabcc5365338a078c595cba78127cd3527e7fdfb66cd5747385695acb19e80c36c90e95aa5c026167cd55527483707133b91a7538270fcd6063e0ae22712500eb8b76755cdcf4bffacbff41f4e84a918ce9e570456829ee3d4a23e49f6beab6500c00d0b74901197d7b0c91b9a52bbdb0636640cd8683cdefe8ceb50f9467ccb164bac03fac06f19ae3291344583c847bac43ff108f42c6948e36891127feb20acedd3c544454f8f548e8cc71f263878b0b715f185d0e9aab62981198de732d6732c87dfeb6c57bd3c79fe463f2f53bd237b7df479d283d6bb5e3f283c9afffc72f81e92c5ac02ec1c31f23c22b8c0ca78d050d1a1a9739a416bc55758bced530013a8d8e02484ad071c09377c0690dfefbf982f5897eb2cd509ff2ba649a0c78c746b9319c25967eea2adc4d4c5d4c419f9339d630eaed186046ce41d47a62faaaa9651009a33710478f2379883eadd236ed8048ea27431d3003094b369361d0213a3d541b70cfbff1d217f0acc22c43f94e50de754c6acfa5dbfbfc92a4cd9975ee4bf5364acb53e53db5ad0d5bd69d906a2aee269fe3ed5151505754fe28ffa94f49d8b5508179b19396b3609429885fe06f2189b73ded9f08a32d3f5bd65d29772dcb1fd8c1c643c190c32d2f38702cee506a0fb656e0d8f19b47f3e2c0d2733a94896dc7757e8565cf598c38098326ad02f28ff577c00b49a74a06b3119c11f5c6a9396d3f79f950f425b9de2baf16fe1811c03d61a0cac2ecf3bd85310d5675647956360133eadd0ad27d87df04be3695cd782bba461b94abd019dce366bd5bb8f5e9a0317b1fb381b9aa79264f85b2ec69a1787ee8e4cf4df613d53e5e5c5b16f94ca6b9b4db9eecaab3323384713abc64a06a422ca58acdfd26240551e4c79151b125b7a6a799e5a33af10cc2bb2b4a7c298be608da3f7872f590a35e4b015bcda3cd77da7b63fb2ea521a687b5778922e058d3d7343be3b6cccf4ecae1e476197efd9a5947e5356f2ba388c71f964787cdee0ded65236aebbd0e256ad5b21a0c46561aa7e8e5578b70c5f3e8b5613ac65a31fff89e17b0753d4369f999925d26c514a76625716af5cef39145174a08f147d85e330ced684bed1dad68875c0f610f364c9372743b6d2cb74f718bc24bfdc7a36735d58f2964472f7d2a7c42b3bc96b545c0c7ac3406c96202804423fc0d98b32fc5f3c3d34ab0b362afb735d274e232b71729a941ef2b6c28daa7aae964360bfb3ae44bd750f0bb9f04ae15c38525f8c6264477512f46a6a97e9bc914f6e4cd15ff70f8eb664a58c9cee70d8661805fe2700ff5a300ba855f1752d7e1653a4c38994c379f636259250732802df3ee36da3d93f620db367b9ce5b13697ace8c35b3864e70b4604aa37f7e1301391afffad35807076b4b08a063f19a0bfddd11245a0e2bc4f9721f4ec85ce22e9e26dace03c2a243c92f71c50a39b07c3d273b2a407682a19d3c9c3352fed0400d8d5296aff9832107fff011e39c0c148c951e4ff40f669c15044ff4a065320872a5f578c8d0f18edb98432e186a0b53eda672d36fb38ab1bcd055fbc771a6494e3e11427f13457a89f5baf6ab8a67b4ed5cdf48e944db76974cfeea4afc367060a1d3f47b48f80b8a522bbbaf8f6ff7b9b2714c227f2db859eab18cb26fcf655434183d0a39514b512aceaf988dda588f383c001fd09fd6678deab8f9a9fbeba151f0f29beeb1e4c76d3e34d29dbb053714a584dcb23da3fd97f32f71b93cbfcb0e896e197748bc0333cdec999e41b4124f93be982f04add23cfa1ff79c95fbf8493a359e2a978050c87dcac1f357411e8dba1444199649e08ac1df10c02ab1e4c21d842fcf3c41c45200a40d403ec6af6530f9775cfc4c493663df6eb94b61441fa1dadb5a249b8064e9239dd1cfae33f0dda7b48877840a4baaf121e4c0fc2f63044cdc79858c7009a9974126d6d3482c975f1dff783c2a0474b36669b9dc4420077e28ee71d4eb79aa7b2064d65b2fe9593e60cb4d3b12e78a86a8b8b1e84455237f3a13c7c74b3f46cdcb2f5befa2ce047aa4cc6127e55a91977e409bcb820a663bb6607b27e470912d799fa113a741024aa4a2fd447d0a25aebeece14d24308745cb25cacdcde6cb501e92f4a0d20da1bd6ba18649cde905b481e7976bf5cb3fa4730afb3e212e695c00ca86116c848b6d1240e7474f746b5f1de61f76d28a202eafb49f5ddfae288e34e511d87afe34c77456b12dd7b1f76af46537a93ed9594ecfe83b23295d4baa5279b761b739d2ea28d0cc360939fb8e379ea6b91991cc63c1806ce88942d3af31070fccebde5d474049c2216092cf7b658ddcf17a9a8b28e0634fad1f93e69a1f215b04bbbeae0cb163b01910bbfdaf92c7fe56ce8ee49fdaabf5dce3014a9c4522f4bebbddf740805563eb916d598def00c6f4a5c6ad6c77d4aca1d78c7e67382a1809c410e6373d4761a119cccecb1a66f8e2c10abbee009157669b31d4e41d843f44dc8b123de1a259c3ac91a0aa05884895e0bee313f1e77683a17e9b4753c04f20e9084ae77dd24311e016f545677e97aba347e6659ee934b61d25f365a7b8b6c5b88fa2604a5d325130d7766d1df5a99ba7433e352eab4ecfaccbe9ac2ae245c359181e57748e77a9481b655661aa00b81e02b63adfa9bfcb1544ecc54a24bbacd52b80314796c6dc8d4f57b9f2a6b6a4480aa54b7266eb6ed76b59e46c1a55a3788514acebd665cfec75cb75684018b5f02200279ffaa70a1ad4cd9dd6ad67dde0ae90849a692206dc9660d142bd1da65e98e5ef8add968bc974ec7f0586fbec800f93089dea3f10d4d4bef000c967840a9ba8573c58d32caed6869d93bd81ef76528fb84233b98aae649adf8bfefce1fcc83f53ea10adbbc97a17efa732f950bc1a72382231df5ba61823ffc062062c400ae0230722eb5841feb115308f00e39d9c9929a7e4992dc93f26e5c74d26574966446286aeb17c3df3aa4c104daafa599259890ae61c3ccd494a4fcbb9c7cd2e689355650355b05dc0a39ce642b456cdbd6fbe63de4434cd8a15df116f6115ce4eaa639f7ed6ddcda0db5baf3dda688f8d1df735b6e70973dfda850a53815e2d17fdf91e1fbe43ddf099b5f57b748a1bbecc8991a4724c2d54dab490579fbaf922844de1a9e93d1aacbc7871fa5b404b89796ae411aa409acc1a7ac47199f99570aa10729bd01aeef0784b688227a7af594d3380daa496a6397416b5e8d4ce695b4829c7e5365822f1b475347612cc15a2832b7b837eabd43dd953fb5d1c540fdd36873fc6447e200d29676a54d8883bb0e0fa94c20e6f4ec3829bac47022075012790b3fdfd82cd88a8eb2e84d98ad8d150ee12f8e9cd67fb91cc06cffbc844b5888564779b71daad5d13bef02a64a1655bcd3e0acaa3d091d7688466397b324d78c47257990918a2860c0da71d00a4107e4dc6edc9f6156aba755bfcdaac3875d241e9b571b23581427ffda3c6b5b309ba48965b1ca7c579d55f2a951984259e08635ab091b8ac1256af71eb950e4064264dc43627d14bdeaead91001844d81fb10aff6cee850c69536133ce706a51ffcfcc1910dffc6544c6898ebc577a74cd8b54f4e54fe84b078f4f0225346ba01fde8520849c672f6dbbc15c75147f61138fda837fc5340b2b4ee55f3448e0175e45e35b4cd074eaf90f0845bbb632b8ecdaaeab909d804bb0ed75891c0c0f5a4b313d6c6491f35735140c1c02abf355ec5d23392b9910bc0bf422c1cb854eba80a1df3793dfc61425292960fafa38b98f4ca5d260cc049c9a86c3b4c1a6efc438320b73ef94e66f7e294baa19d06004685fe27c3b5341069a52fad7bf6dfd2a642624be6a6cc540f670938620966543e58082be205351668d0779dcc9cadfff1f0efa538f2fc83228f383b23895682084854707fc63de63a780a9a6e41c042cb4c30e611fc1941fab63060a42811b05ae25d0b069fdfc23f94801e84992265c0e90f44e36f82937db2904aaebfb5e889864def666067b9cf21e8d56abbdda74de632a265a65ef498197efbaa4b160ce7dca7a9a0ba03f719ebb166b74cde282c4fe9f98d25bd3745aa9221e3abc5d484f3cb67b01d6b38e47d5e3468ba56888e775bfabd2aae1c41a9cb8b91263ac5ab1b3e1cf6e11dfb8e971c1695b1522a1ba9569034e56ca93e56e3d04bd4296985a7ce8e2e9dc6d69fc075e98791521d072988c43d18839d7f92530c954ddefc2b9113972a5fa3f97d34e59c9fd0ef4f88dbd476284399cf5ed5924c84a93d95ae810708de7a14f583e30e1406ba5b06068f5d75cce5c6651a4e1ac2cf790d24e739d056ef741fc10527a10b8846d7b02d2b47b6a2ba002c172dcaac2effebef7473ca95eb14ffc2c574351c9ae56af34e3258b2ed8d14a84b0ae549625c48152064a43ea8c7d5132b44bf886bd93ea29283fa990d49835484e5aec7bbf0c3afea086842bea3b2fe49d2b427571a45556b8f167662b3196ab13ab72b4d3ec6c11f5346d74adbb18476871386076f6410273dc43b9c0cd75ac4dd0e3ef79cdebcca2a149bad6520157886007820d723d092a9fde07996e6136e9fa4cb44fde9fc27a8f203fe82f6b47c5075a54dfae5a9ab09f5b13ca9de01d40289fc7559429ff8143454a11cf87e9e8dbd3674a9232e2c65b6888865da345b5cb7d43a03f3661cc3a253f99263e742f649fa89ecaeed0672795f70569f91ec075b3af41dcd48628cc67a5755a914328991c193245cdb0abf72ec26d93455d3141d66d0c38a2b3304d1d789411ead8079a53fe369140f5e1255020f2f0253490ed4000562ea74dc4253ebaeb6b09146ec39120a557fcf8b77dc32d7c1a4cb0c075e62d401c39f3a18515bd0bdc75b47be14d104f9c5e109c3602deed672b0c798685754a7adf41e0d014c1ca0fd23f2790501","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
