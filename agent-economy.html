<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4241e40997f7613007226cc710418b4f096b0c45118a9c2540b69e81e994c3ab263593aa43a76d05bdd9dbbc6264639c4e1418bb92d7ebb716aab403e7fcc490bcba82f2edd6c7300ebbc414a724e7ef8eb113b352b1cea68d647a48290e3a5fde2b5fb6b8ae63cd49d15238ffe5441907e8449da7d20c87450d4d96831167f1bb42bbfc6460cd8cabb9a602f2da4d30fa532fe222826cd1470923b4eeddbcb44e36100bf3e677aa708e187db40d886e9601342aa887469c03ab8a47d3bdd30f258690ae47cc42475e03b8737bcbbb0840186c60ad9a5aced9c46c0f0c6fe44864adfec5a67860508cf04c164f014740c56cfd6fdf5f40d773aec02bf09292f54b1cd6236e9f6d7f5a2c04a99f14faed2cb5be88071e768f414b2ad185f861c9bcdc26599eb34315aa5d0f666fd072b590c71f14fa55beae7edb16b55bf753c01884c2fb87539f7e718cf38610161d2749ea9b3e50fd1e5b3d68fac0c930fb70470706bea753c5039e55e34383627c11a2c7499befb2b494d1e9567bd9ca5e5a3b467335e17c002feca7c7d8a3ef126797e086b19f785fdc9b744eb93c92447075c6797ea250da47ee2a196046506837210c8a5a0cb27b7b642a6eafd83080054e002e6bcf65622309443f99dcc2085c00b40c7d8bcb2b0ae03fc703e389dc722be47de9b9e02d3d852d1a8e9eaac1e90a2433c49470e76651c5d060524c48180952c1486560abf10b1c79b13220ea96e61a0cfa063bf7f9c31ce1b7eff730ecab91545eda41e23a23c63c2d41c9057ec04eafe935107a432211627517c632749626d88a92b4d73c35f129db6f1110d342b007efd15a9ab52973f73f4e3f5bf6089291bbef78ce24df0b4165eac4a5b9092be580388f900ffa482de93479a0b684159f721836f9f70c0a31afd9162b9f0c147126ad286503c246f36cba758d5bbe906615ccac7f8d7b01d69d0e65d4b863374b737d47b95a5fa7491def18dd0c3853d8f3fef3131b6f8010770047c5dc11bbfa3cf4d9555468b5a0db0610406372a43f9594978de0e09c96d4fdab0b9094275cc2f754cdd760061b2507eb748ad5894cdc5bc6be76e001ae52db99f6a3e4507f08aa5e5ea3c89f55f10ddb18dd2bf05e409f57ff7a41553526a838774c8480b424213d3fee41a1bf81818af2dc314a346e10204fba6a30a9f902f4838d2d8809ed9d14de92236392660c2d08cf577f9d15456e4cb990ebd8a8ab5d49fa5a14c44aabbbcaa4705b9340908eeb7aef896ed211d48139ed50e21898c1542b35166ee11288a22c8946b5af75a5b81023a323faba29ae14ac6a2e8c42bf42c27c3bb9887d293dc122bd100666513d37e440d02e1165a9a0645b3ab499822827f3fc04379b898e818c6277a03181dea61286df9b91f22c1f337e865ddc90c32d4a24509d42b1384206a045da1cbf0551a159b2b7794eb2149b69d5f780279ec4a0e35e9ea981b12589cc554e246e0047b74d8a4b7160db06817dac70b19d285a08dec4f2692b22cac50df7d8b47e04e2f8e98ae19c1a0db7d694e4aca865a237a2e97f42de568a86921abbf75669bc2a02fe864f57631e01004157546e8f8da20902b22c313399fce225664d1e748c228c0c16564e3a4b5199dcddc5ffb277a265678f88c3abbfba6cb34f2778f5b9c478c92e2dc2e58bb19b0751e094b0e2f55ee82b314477f2b2cccc709052c69265cb0f0071c43c264acdac030f901ce55e3cbed26627883587e636fabe90ad88ab0b365d34f238fe03836daf08913c14d0d0c9889b62eda0627cc2330dc1dbd990c5e944c75782ec7dbda1d3ac4983d0d2fdfd6dd47e840a2b53fd7575ffc3e1a782f0b2dbc2f9f42004553a049044b02f12ce815529526d92e53febb8f4a10858d3389ee5c47412f64a66d4d4965cee98fff50888baeb4b609250834dc4b17d9cfe766d63739dd83a09e94e900bee3573bac9f674a7b11e5786525ec73d6a7fe9e54f96806efb59131abcae4b4483a842a2aad2145e3626cabc03131c5a29509d56fd1500072b2c27016a0260b7720a065eca205035288d787070a05918ae837679a65a47f436640dec160e226a15ead367b30b49cfdd1ae8032e54ed3506f529eb2b8e3fca4445cc825bd82147919d7570d648372ad935417951a6bc2f81b195a869077e05de401d28543d3c8e1c4dc378cb23d2099e4e9653b07de5576ad8567f3699c9854f32524f48d96efe4f0f00b24cfd1f665fda434651ce983b1a2b9c6a8fe3e919167e0dcb5c6757b3970225713665769e88abba4048f445f7186d4f0fa098c97af883a1e7ad33e9171bc764f92c118f40bf1bf7a18a714aca0e9ccf9c2906b5c3120dcfe430f28797e04a3cd38e229379782522c7e4a271b82f91593d80fcf68081cf5258edcb51ddea0fd4c6f2b99f8f8927154805c7bcd11d195acade0ac9103b8bed147237ebf4f75c5009df190e51e808c277c3c22ee1ddfb376f2315e9156931d3661986257acedffe3c5dd7719f67053710f820992da1f17af4f59fbec88768d369076ebc733531da44ae482d5aafc37df0177aed41f459ffb84b75c6e56e616e5df555d5801102bfb3d6c63f2eefbd2ef93cda4693e55c98d632e7a9cb7f816fdb9b759cdda51abb0785ee2d36164c32537fb5fc9f45278a4e7860f742f09d3f844e6e4841506df8af1b20aeea664520931482ebc509bfc0c351dbaeb84dbd95d6fe763915a0d8a0bd6945ede075f995d40ed10011c52cdf70e4b01e1de0404c333e168bf09bd55b2bb5e7768fceb152b08e910f3ed5284e616f0e9dccd27b29cb23215cc0d846dff730bbc360c41b214414b26e91fa4b34779237b50a2a3b9af7b37c678c152b914ab4ca4c2be3c7ff8cb59a24deb3f930b822a415efa51ab3663aef76e50e4ad18122dab12a5a288989c4cb1650d7ae39b2abb0172cb3d961a97e16f3dc414232e115c6e374a0981674725a86d5e1f5db3b6f552ea0ef2ee5fe104019fd9eef81e0412946e370bd6f5b6bdb5f2ca26698daf93bf63af6de81d22c7830e292c7408bac46a893e4530067d33cc89c9f54914632dd3b22b94535ca19734b58a3488d622ed6c87733090b12efa83ecbe38b62eca0b8263f6ccf61b9183a3e64b900c1134fc37acb496ca0bcf42f0c9a1fecd3f0fbb48a356fbb1854790fb1d2d251f26e4ec392511d0d18b56f1db1de693f7586ad33674c024d9d00d8d52bd75d43728f9d5da5208a0a764966f3d1738fa81a8a9d35088aebc68b1800be36d080562ff500269ce3f6a863bbf2eb54cc0cb5b24ac75602304ffed00754c6c7309c16c609a8ad264b71e4da5e5470e9f1f01630cbe3f834230b5fea7a37f7c8453915d33aa46160a5eb7bd634891eded49dad6094a25fe9c971a707bfb9c4cca1a825a06855a756e057dd3f9ed4e0cd0031c27a6138881b5ef33065c5d6e3b83681f671e052f5403d4cb1394fe5c5b0183259bbb29980c4f215294444dcbf00e27bb8a2098386b53d24218b529a853f0bc8b0118f63683a5b15fb16792fbfc9b6e928cc0c35aab0e4fec19f64cb3b0ed70e31fd78303ec90c930460e0c1b9c5ddf21eac4129d3f7f16a8da7ae5fb478984351dfa417211fa026a27f6ae4c6b90258e415d7ffe911a226bb69075c3a5d54ce9b6a1fa69a89806b8382e36dcc6e5717063f4e66eaa45da9ca93a7238699ccceaca7ead92450f42f694002b33de52ec6d6b5f6bfb8369cc61eb816495156005cbba49ba3ba585114bdcfc2236b6a3cb6b39066925cb724bc384cd8374ee9351e9714cf2dbcf626fe64cd4922c6697045033281fa05537ffeeae2efbcb5a727c1b63edf80f112080e0ac1462afd2d48106459a72248282ecf7a305f165f9036342cf340e428575f189f4943c82c97ebfde6a3cf5622fc67d044a7e6d6e1460864a8932818e20ed62e2c20b66a1d13522677a15cd2bca7087423cc35c3c88d75a084485f0b56f27736757488ec3c1c091d01e94d5a010e27bbca7eae5391b555142b6f3360f6f3d98140d3e11f2f7435f70055f9c9c5efad06694220e794992de28e076d52f811c3fc9f6e7c6e929fa797961c1e08a33f3c51c85032b11d64ea9e9544c15cd89110842bcb6ef39438bf056e7ae12fc3bbec1a0c09fa906f47f8b50c83ff7e6ec6a7d32f11e021e29c142d99322bc5468c2bea927c25d06b3223cff2e6789275ffe4bc08a093cf19ecfd7ddb32f8ac0f929b9659fc1fa0f7d2777cec66e9b6cca940989d9026c114e7b5b851cb42fa156ff607bb30e1ca2f232a16be1ce6be607e20dc219ca0ac360267ab67df7cc89941cfbcb778f6b675e8195cdde159c776670466d3c8f6d006e3a41c167824e2a819399fd0e2c4f7e6f73159404eb373aa0957c23459bdad1d207acb6f94646250441c5bbc5a59e4f2dad05a2c4099d574265430d1bf2df2758ec34e4e6f4a54bcf903c3e783c6cd06ec650e74ab6f448323659839b1116d11b9848ecec4579706a58ac0159666f6d47bdb3b683ce421f1690b044726f69481c35915b04ecebc9faa0ea8e616ad7161a5a28f4707c7783d0e9ad79757c9f1a64f6572d57995a64febfd8412e199073f9245571070a33acad53d38d4e5168f4af5b95b19a1ac61ff1039350d96668450f80490ffb549b9ac7032aae635bc8e59868060b64fc3e638cbce0620c0bd29bcd4cce41f18ea640dafe303a3cde2da453c93687a43a6748e7ede7ceac991575be810be8cf7394f11d146f4a0261959a2edb9b27e97e42ed2a1519d0cdb087202deccef7b1ca0a42961069f49757056be2fb56b9a09537efafbcf5462dbadd8330623e9839651472d59acc24c96871fe5a34bf13b2e60e886991ec0eabb9093df01db042568cc8efaa68248294a0fbb52d63ddb0e37b827b5993c9829a0fbe0e735a81efc062f28bbee856aad48ed9b8dfc674437f1214bbf88db1e2b53394f46a6225fae12cc4fa3166a184ac7cd1588ea534c2006bd1082cde4cb2ef9efd1d390dee41821d550a04045a77b50b5122921a19ea1a722a1d4f31d3a784eee9ee10d15535c3b4027d87d5c3f7360263f718668a83599d05532ec132e4591c5710ddc7607ed04dd02263ac37ef5b077b4e2677391a8ee26b4c60d2380d473245651def69d21281a1cc1705df395fb9df11c06d1fa37e2b4ae8c03901fa018dd7d0ab7075d66655fb6dc2f0577b2d557bf8100e89d68374a8484f4b509ae36320cfbd1cc3ad396960b3479c161f811e5ec76c84dde3826b4d36f15cb8609182b8a69aa6d643b71955a0ec585e4030449640f271e306ace996ca31d47b7e8b457edd25d26e6d21b387c07807ab239bee93819867b523a4ee4d363ca5f85d4ed10ef5d1b9d915dce83dd2b7a24e8147c5e2e5364eb730fba1ce3a53bddb6b07a59ab86addee1c73b19871c209b4f97bda3a82f99ea57511fc5efeb59dbd421f7b43b7c3783c199ce4f3584e72143a3d82d605365f4551fca15b9694c3dabe7d3985fbcb9ea6bde2a5043c230f1e92756cad2725207f65a5e6c4a09d454758a7f4d43509d1bc0650f828d8dd09ea76e48f7e9188b400015dab63964dd206cb56e9f22f78d562ebc6b3707f4350ec326af691b2969473257f6732775255cb453cff702309a8d13e713aa103aee21bbc69c583d3b2cecfba1e85f2d20ef8c1275191c812d4c0d8646c11ec913a05ca064ede5380e285e4a4b7d8190bf710473f04c2e1a8b15337620d18310a98e8ce624e271a7998a2e2e8026053b927faf29c2513591aa913b0f4ef0b5c16f1063f04add15ff50cb90e0cfd55e3c4bf1bb18960c3dd3a8c646fa9fb94619847df3a1ec1e6d17ab2935cf778d1ed27c2c368072e0f54c6210366a99054da35bd68302de972bbb9645eb82d8886d900fc3abafcdb1c47101205582234e4ef4ce57f37895c5902a4b5c7e2fd9bc9e63a6ef49c8ed88eda41564b39e863656635e16332bf6fb5d51cbe17f6aa0243e4d0d9a444fd12f4f54c4b8842d7ff270608a1d92a152ac774458dedda56e027a31ba478a83b4ea7f6f2ef1d6da338080c9ec6ef63dea5712c98b999bd280a87e12d9b3d415b91568db18cec6d5b6a036ff14055d18bee813a8c07818d7bf1cbbbebc8661edb9009b5ed20b993a913893adc2cf7844314d3b8b9a21206e878752898e364d0a36d8b39be5702373c29c31d866142fe4360194809b25bd8afe11668e2a22fbaa2866c0ce000844a91c3b13145d709df9fe94617dbe92c5b4500b68c0f37f8ad00f0752e9234c5af034d659cf8c6b62edfe8460756939ed578a3f8c79ff749ed492091d1f722628805c82e3fc1b8586e231da335abb595b1f61f931a2206a067b6ee3ebe353f2ace835bb927c58e7881e47d3a63399830f51bb0b1334bece38f56ce8a2fc4950f824b289a79ae2a539aab11dc3403b15fdfa48a35d8c76fa3250a816896e528d1f5e81101e617587feb9d16a8de9a3f5f62e5d35bb13f398f5f685279df98a5e88507313315cd7564fa05b0f2f5b16b8236cc225a0aabdd52fdf31ef6c5ce480702d6047c23f7f8e18ff66ece4b13df36510cb68e3d723e66797bc7301b87ede04c749921e9b6d6aa1435df74d2e1ec79ccc9f7cbb7f1554edbb1be2979eb1181e5d6d9fb9ba69a745765fd870ce6b0bfadadddf311df914e4b30080f4bb89f8cfbbcba77da4102e607945c555edae40cc72a717d8d5266b9837a5a7e778f8c4a1f75f99c834f79acdcca88a9566f399ee5130b1dd1ec7a6a73cabbb674a3835132c6b99f20afa649e7cacb738580b38e5a9e3c7e0eec27bd2bb0c289a847e358dec774d09e1490ebb925c5cb0b35140305fc7960810cbb41f55c9110f26cd26d61ceae48dce276edbf02d5425b8695fd2143c89d8895c2e46ac369254434901a91a1b23e75ca7b1d849172d7e53bbf4382fcc70c72b15dd1e73ab19d0293300af4a2b8cf821d0a42ab51d4ba634f8cec3b3600f016c8366365528aefd7d3bb0ca416915e09e73e5e1a2fc303d6fdc52019189e38b11dc79db6f45707dba9ec8d33ee9b8b0d0a6db413d4b5e2b34147cb1649c0f54f5d761fa9bd232f2e5ff0cb05fff0cba16becf147dfed08d214ed0df987f1a27290fee7b312f7a5389595ed55abeffa252b91fb51e099598b6c528a095ad40c4ef465c5dc54b15d36c36af271dbfbc2e4b6600588b10db8e220f22b1789d3bdaa653cb01142e13fc57792dbff5b19cae7b815445b36d63fd3195a8ac26aa937c78cafba21ae96c19a0540ef5990b60ab333982988371ea6ba3c057a2b4fba3f783214c06ac19728497c6f229cef7d818fc780742d9849c9205d481993fedac5048ec2df6adcb79088b8b8206fbc337ddfaddb8eb3484afbc1dbe43eff4a3e956d89f045ce635825cf2fb956b7bd052c9d3ab836bb31cad8c4d6cd79717e343c822d7ed42c6dee4f81083c9a0aed8660f8b97f4728f97a962cdafed3c41ed5490e36e7c9853b844b43993c6f394c1a7f97481c2ea4ea71d6b5d8b5ce8e576eaba627beafa14170aeb264e46155d10e8e9930817c933410074a948088e97391b3a7832b0913a652525c0b1d79518372c23c9cf65785edb5fcdb70fef65823b839d18e4c946a847e50018ac75bd535c18a85a1386327464e002e9f1b4e434ec74b348f1ec66154bae95b6184171cde31cfa5fe67d95afcf3478ab16a85ae7f23cbc03fc4341e5a2896e5a6bdd03af8292ba1a5c40688b85e51390c1e506664a4dd4233232edc70480e120192431bed80ed5768c72b493c40cd470d6d9983d2c307606324c4d8be534e98f9d4cec387bf55c6a0c91e019a609a33e3b04f7c3e6eb4e2ccb4351b00e216ff4154926c7c5424a58bc91d026372271574fc50d6074cb27053cd8829b80bba51c84f1427ba363b675d9ad2f367c66211d913d72570b971d335f1b90ebd81738ae0ec07ed65b94acc321b40f446c7f863944dd8aab111d91a8ea98cb9defb586beb62d3687253aa15bde72f4061da86f409976f1af0a32e53bbcfc14d68d5aa77ae4c749be2099e87a7c369e2efe1b0e005412423b2817b04833671c4a836aa730c5dda3248244f042215ce3e7be9a7744ea2286065ede19fa26fc1b231b92c24b6cacf3f6b87ab70cf03e648c504712478082f439824421486424dea4058094a8e5cd5c4e09ac7b2d00d7a75601767a3233160c173b3dbedd66e830d6ffb9b01c9b745208247cfeb74fef5d1b3b1507a9edc1dd691d8b355e9abddd5d99c7f032e993d1b8c2860bce1cb9552f637b9c9c7a1a3cfc27df5561122d20366a730aae2d6aebd79c951cc08b424f81e0cb65bb50b26fee249146fe285bd1c7196695d346ff9c2e4e023dd69d4ce24e596391f60f509bd8823ee88ddfc60c610d24937efd29e3a87e856a473479f388904c6e493f7eaeeb954856806ac8ee02e6f3ee9340b26010b0b0389016a3da2f2e19d9fcf7ae8020907da4edbd9ad5f41ed5bbcbc3d6bb1ba7190b4d22dd1b2df8639d1f9dd8d2c7c64d8c70a9d630dcc4ba459abedadac1638dccedda5de5a0ccea4da5335f32030006fa98edad3ea5d5df6fba9eecba409ac29fcba26eb76354407126a3621c846909fcde6c81e75b18ba18aeb41f4e4d74fbb41db0251b0b9d3cd221eec19ef5c7965b346bbba26ea9be414e40297d9155af28571b4424f628f3ddcafab947b3bc34b52eb133e3be5bd1aeeca1d70c00422eb5c8c2ae2a5ee6bc0dba223c8edf36c47dcff8a70b27ad4370488e2b035ad9e852481160b233597fbbe700cdc106219bd5c24802863d31a30ff59e6d33549c026f078b0ba95c2f7a95d5b18a9b72c34e34ec2af739547dc30fb1ea8e8481b36ab08422cbf75adba0d8e1a0144625c8e04e0f7cc3c4d63a5d673a8cbe9d40fde31b075c55e3530ceeb5dc1d8827300f35b9c1faa848cd879f1e835da4737b12744d723c1c2cc65091ac501f6cb4a01bd46999840db006590eb3118730a5874041ca07d305352bb94ae85b9309d0b7e2e3984d599293e2e57c14ebf81215f4165c667cd2c9e4664c5fe6560b05151de575263d3668df2cb0b704c71c480f13921f4397a92c541f2b610305414ac7f482f8b4cdc8847e1fdcabf8220ab6aa88617227a8ce66ee5e187f7fecffd9426dbaee057ce7a10577868d0774c2d7fe5f63ee8d4c5a0a4f38c01f05caf8d07e1b3160dbbe8d6fb8915389a085e32696f76cd3fcdeae6781c15162455b995abbd0575ec8fefd60af106609eeff7514e24bfe8da3883f43e0c6b58fde4ac5b6645fbc06ae3ff45b341bb2553db2dfd97ecb2976c98558bfb6b77bb66f23a1223e98774b7246f438a5b2539922ebeb70d507acd1b80803627fc9d98fd4eaf2347e9c31d5371ba8471f10c75ffe7b643150e67d245b73bcd077e0a80528691ad680d0e16ad30a0e470f00c7ac7df680bf8cdc4166527aa1be2151075b2f38f1aad6ae52647af255b6f74f1647495e056fa40c2e21bce5ba8c70e0f2c2810423ccd4cb70fa75b591a4227d258232e4ce94ade7bb57399f67daa88acae7ed0e7bd5926070d35a39430f19f6293452a3c619f6f9f3226b06291c422eaff8d63478dd33816bdc48da670929c06c4ea4dad5463fe06b7566155da8c37f759f0d6424ed860528048ba928521c6e0fcdfb46caaea8fe91c398f1e5fc3926b48548103eb6c11d6f647b4809c8c2e908c6cc68f36b0f2a0aeb8a27ef3b97df7d8b8f60aef12a5192d39fc34c968c736cc36cc8d96c9dbae0433d98a4745e5d3b2180b94434baf115c0d943d4816c93936ccbc82d86444ba550db1b9bb0eaf7df87934a269d73c39617e1576ae11461684a926d8d0b2aeef9fce81271c953deb16c1c185966fb6c6e9bfbe9761eddfa7def437d1184e67eb2599b43286ecf462bd2da044980edff9056bb48d90d4416ff54eb22afe81a4e318108df231b0223b07334646616f03aebe0add2dc3bda6fe4fb546648eac7a3ff8bd61fd2cdc3cc8e5bd4120825a0a949e9d7a2534406a30d59b0699b4ef8e1cbbac86632a097646ac1d44fe0e58d396e60e6ed42e5c75a021dcca14f386ce11e70cf81d5fa87be262db3b57889c598c0b4805d3592fabc548063cc661006897b6cc4176ff0a9bca9c2aa7289aac9b60dafa95380982e5fc681ba33f05b875f95108319ed62080ecf208ea1dc239a3305e6e43f178ef3f9f8c7a3896d676eeb3ff616baa99e7c4a0e250f0b681fa48673759fc33ea887bbbcffe97d873ab42e5ec7b69d499fd1a57e7312dea3775b946566b65c09c8ba1a9dd16d3474d84ebff35d87566de195dbb219aa0aa613d7f006fdf6dab98867b45103a4a8f5fb0b271b3c4bbcea36baa2efcf0f6be918f0b4dca7a6d91e6ac859e2fb60b363ba38c356e24f6f136a79ce12d1e3ef0cba36557694f70530b2f0c6aa2d60340b5d72fdc326d0cca5112d8a2a9ceed6127182a9b63f86170b48308f708f7f06ec1da051fcf7dc0c1a174caf58c056ea9c6eec535f305d6f64cba192806b9ddd7543f862d168c7cc9f01c3290da185fef95c05d5c170a8b1e8bed04a0cf716325de7570010079460e731a3a8b95ec9150d5d98de7c8974fb5f531f0a677f22c2cb36fae3795a08a55370d6d8b3bd5daf2efb6e5fdf23a3c62de8ef1d24fc0384b1be3bc9dee72b5951bb12f0fc27ec1d89438bcacb8602951a57bd7cd5e83eff1dc788736fd728186b3dd9b1933f54434226e56c4ea38a7cbab725b4ded69b95e1cf5ec0d28c702fc37a447ba6d65c1fbd21a9f44ca91a9eebe209c2c79f24f82ae3c3ddcd1af1e4ec23b812f9fa748cd717ee0f54b7724be813bc13d8e87ce20c46b3df0896ebba0a396eebcbc4d0d898d7cd6a557b815a7bd83370d0e5150eea32763eb9e830997c1d5202335ed2ed734e392ac6674ee0116eb358e5a316c6c3ff702cab2fafa0c471ce08e20b37da0699f46e16c01a59f1c784c4a9fee643ffb72336083d641f1c28428bbc7a11ddd9b0305321bab9cecaa77b7d9c760682dee536b0dd3fa2572a8b8c66fc725933d1255000a3995a8a4d9d5ec64d59f86811d7850760f81315e8670b6f5e5cbc3fed244612b456f305e418f04df9c478c31b23e467e1f4db28e71e4303ca3d9e90219b758dab8c0db9b92141c5062330a4f87be85f2e00761af9f78cde3464da9e190f780b5587b28b7c41b1c654ddff7c8365c1c9932beac99d9eafc4de08fd7ec408a471a35ab0bce64cc5fedb3ef6a4cd7d41766756530ab37ee5f5b1b405f131fc0d8702869c2c52eed0011fb78827b88aff73f47dd93b08c38ebd83a7fba3588aa170d7f0c91c739fc091ea59656b97dbcfb8b106d32e4c3b9d480b3adb9f6ecc84e34dc09bb899d09a3cebab2e893661eddb0ef6bf89d7a9c82ac6e9c036ac785c9cea6ac91636014b3faba7a88acd92621f44db363f0fb2b7f2910a7f8e08b699068873a0beef0f59e6a507f13c837fcfcbaa27a94a0b5b2f44322e9b306b7e33ab5f745585d81509e06239297b8edaa5e65d5e843148c3b44ccf97ce251ce54d4755137faa4b62a38eb4e4c2ae7e1f9b45edd47f35fe9a924221ca12b9223cc7674df92d29ba49a85750e952ee9ffd0a933715fa8c16699cc0e209b3c01044233eecd855e3f49f8628c169f31170fdc6582570b0689ad32c35cab3ab95ed8665fc9233cc29ca47aab7c56daa975b6783df08303ec03a73fbedd2a681cba4466cc3eb5e46a4ca083861bcad40a0d1c59c5aa039aa3af15100599c100c22b18e9d03d2f76280522b19513c37195f2d3f7683537d7b2b05ef9f127564f48efdcef8b89c5d3addb2c1671de28f0155d97af3f58add85b7518ff8855bae54d7b4f8d1909d1cdc47457c3d1640d2ee750006bd103e71b9d6ad947b2b4e81fab87aa7c8892ec1e0a473d7330d4350a5faa748e0000b020dfc8394fb2205f8184ab3af950a540fd689ee5232d29f2764977a49c0814d4470c83b7cfdc3f6dc8d49a1ee8e61110d4d4dac6dd596b36f266a43e5111c69d6ab29fb1cc283067d2841f653d672a56b787eca57c327ce56df2ff59023fa2ea19334e95d8ad848a0392b6ac2385fae0d9fb3653941c396fe9edac02c6d89635b8c17348be42f62de1730f319907ee53983db18eb9a483c573d3a168f3f8ed9486d53780f3e05fd3768f0ed67189b503a3893221e5f86e63e6421a1ac511042742ad1233a60acc1ed145840f4782722f688573382b5e885eeec7a2a9893f43cabec84803cb81e085aebfbfd41c61c1b54624952ecde5eb574b10d9505c3c110e2ce73cab0c01038d1028b7fcb3c606f6e84d034864e79f33f5581dbc3cf1c64d1533f06bcf0e587ca57ee73524803e7ae15368f3b3d77f8243cc4f0e54a31fa6f1d5f42d6e35ec0d84c247ded2884790083a6c1908b3d464499e3956cb39295cec87c47508346bc7cfce2f71e98b73a604430733caa1659946164e8c14de4da861c2ea03d40a9e6bd758fd88a3483b6765c68d9f1b2fd6df221f4f099d370612c7482f72b2b42f1d61ed93d7caa238c2fb944cf203b3f097eceda9d68c33cd57b347a552b0f348d45a36461b49c55281b3ecb5bba05c1dd55baaf1f68b0667095636af936bffc99adca9159211fccf77d94c5fd63041fc835940bede2260065882a95d1f6aae8db67a2224c2a43fc8674e739026908e784e6744dff7efce12b0c3baa7c8a8a0e1cc0e2199a00c11ecef03b37862cff707df9eeb9aa2e4ae7064b3cf895575ebae4d52bb306991f2fa91767b62c4a0c36178e685fb2e92a445db445ff86c3a56e4d5a836bd60ccaa64b05cfb96c5de2f49f543ff06d428c2e61cd9b8b0133f961b0bf3f538c31cf6596a02d0e91c92a37b70b9dc821584e94545d0d746172c16cb8024337d77aa9f8b3673442251b0b7911308e00cdcbb197c6cb21df961dea4924fafcbc4cdcc15320b5213eedace45bb069901b0cd81b40a31b5bca219b493f35570cf22f71785971babf347bc0ea393934fe87082bd2b2e289b14cd07599b60eaea9b5e05881f557a5b89db002c5d5fcb878fafeea0715868a4185c82dc126c6b18327c84d6a4d0695e18376524b331a932c2dfb9720896a4b8807813afaa484ff34dee0e70b716acfa69ea513edb85d886f8a8d2b17d6e75e55fc11f537f8989c9e36095279cf48d0fe7577ef39ecc1940ec20131a19f44481c39816d55773d794dce5d3e9e1f1978e9b2d4ec61fccb263da92148436d248a711ec66a43093d3cb8c80d1a53d78bbe6d1083024cf5259565120a0f83f25b622fb1f9ddb31a7983c2fc8a339b2fb1410b1c9653f63637ddb52bd5ae73cc1ee6e83f320aafcdb0e36193464c7bdd26e86ac7c22ed661fe474d54f23d81d335d36d0b351cc35dd0a57ccf293537022bee45dec4403f3c0e6d7d05fa8f9279a5d839ac8713807136a8c04f944997528fc734672d2df6387f8b37f238a856d33de4d7053f5e07d211498dc8c9e031e69ba59917580b61c0a7c1c25294af85d31a7fbd6916a6edb99715243ae14cffdf173551035e9827026b99fb790dbeb358342663d382d61e17a8123c4bc020377c0ab1657140a56a3e68251c31b70d00ab0aa073d036ff83104fc7d9794b848444c1f7b95cd72dd4f7bb47dc5c3ba4514ebf6cf8d9cf5685b32de105bd55f02affda16184765810e13ff991ae07b169550621a3163ea685e8c07d877f0d078d5f6af4e8d214960a3f094da56250a9a1dbf13084e5c4318c1b7d5013e951e1433ddc2dfdf88771b01e046c6fb169b8efbf5c8d831ac265c1976e3fb91687f89c56928540f3ac12e8533075f815cb2bd6f33705cd0c772103e9a20872af4f15df8a1cf1a0ecc1bce8a0258350b4f60b5dc1ef88d1651232ebdd1b676e38b933c05d30a7b4e2f0adf082cf319a0ff1b60df7bba2c49106ed199b910ececaa5a8bfc33446053bbae7e7670aac1f4bb15b7d1a2a8e599fe3b387d518b0980dac4aa1a19b0272caef708d88740f70d391d0a90c53f8ae272090eeef6d89a2f0c46084bfa8d2c845809ff2972084b2e301e4980580485168faf5c70b64d7ccdb2f2b76285c6d9a525ae49aa1a6640054262d1f0931137e62c2eaa0d849df9756902636c30eb80acfb43160588bcfdf701262764c561a41389a743562133f64c76e7f04db16abc957f32415ad4262f51e46b068d016c008727a1aa264b6ab090e6a8143e4c81edc524c58bc3bdca3e062f78299ae955efb32cb748d2a1a89e29c7760636817435cdbcd6b6021c77cfa9ef6be9172b5cc9ccf99bd10e319d800f1404082e8928cd4eb7d95de182e762a6858178fbb0d93fbcd76513f666b4241cd54896f47d87ebff46cac31b90cb034e78825f62926cb4d6c570e0dab6516b5531c603e333fed29df5029a7fe33479f37eb04c01643efaabe16a1fa5c52229d0544572ef66df61eaf2605260cd687bd35541638936907370d81eee233d84c2589e9a57218ac396fb17f1be9586765b4216af565f88427c78aefe64e9379d56ea765e9f368f3d1d0377a865f4a597a51e736407c360aac852bcff112817a3e84c56246a807215ea8772e05b9532d26d615dd0199cf62668652dafcab3e644eae664006c24a543a93e3e71e7efc5232bc2c8b6f777e27fcf86355986fc3498c49900455c248f58bc2bc25b36454a5e0f26de580db56130cdf656b53465fda5af0e1d344415667a71bcf4a0abf8bce5287760f20206d0355857b79b46c6de3e12876abc43b9be8903a8714b433e04cd7f2fc4369047b701ce5ba60519ada4e365ca8246ebb6835691c84825fe1dfe3ef180b859a951f793979eed5143628f9b0b0a9df0fdd43608ea20a38ff3bc306710cef229782f222890c7b5fed1338e3aa453bd75e1b433355fee8c7f56613cbb479829681173917b0206cae8890ff4e13067bf4ec3639335e87bc4da730e67b366ce7ee6f9fcea43356011fc6f9e790494e1c198e7447191d44f306c12b66691b8f32ea4bbb2b3001f0ba48f2686ec1ea15c5074ebd3b885a162affb59c7f13d5aa721cc9bd52b61a947ce19491e251e7d6908ef6b00aea20ffc7d35b6aee864c7524be3e4fe0937bba72c48a475b2516e86f80c76c2bc1bfa62513383c20ade44340d3187fcb2bc8692acc53a1e1124bf4b984bccd9b06698eda453dc318085b323e9f9c3717775d1d82aaebc21704ae9d405d2a02013c3ae512005219f415b7a8a14f7d01275a4e9a55082219a9846eecbcef9b52b5d9565b18ab2577b1d15564d589339e1f17d6bd004999004283994c298270848d7c2892da0d8530914a15c732c43afd76cb404e059382ba185ada0722730dbb47f3f65493929ab5feb3db04f794726127b9c314c09d3f178e927971dffb3830aa274b57c67f92b74cfd2861d446ebdc8014a34a56193683ca84b0b1025cf25532006d04c2d215509aa64e29f6eafe2cf34f9fb8fbf602a9e96667bb344e5fc9730c40c9a7eea2c7b138385fbff4265bfcfe7b39c0b83573941a59d4d01f718fb22a447243e08716e1855f1494099735e5491de8430876f07cf3c5da5b0e1d8d928222910d4482bfae911bc9d08dde213baf266f80d5bc2c972dc41e14ccfe02e54d70800e22bfbf5480849cbee82a0a488d7b4611167ff4511e668464b54b8d496ed5d4431fbd950cc46b09ff67a8ac84fb8aace2b83e3f7d8fd30617d57e956e967dc9c897446bb1a322fa6c56654c8b34321f1643897868400c7515e6a995f84bc38d4811710022518c2737f7b60077aae8f5f5ccff01b724b4a79cf32701a97a7d1a77ad7dd65972914f49757d06a351529fdcc2158f1b89cf28038c6c83f1eebc13554473bdd0cc405f45928faad3ae0ab11f3ecb5426755a4263c0ad7e30b06dd407aa80f299fa4bfa5bf21918dba5609","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
