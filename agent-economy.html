<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"792ada665907ead3facb142fd44291d18ae3036e87e70a90a3ffc70a9b91bda50d3c87cc90f2b28154a4f446f4fd4766a587e7a55bb7ddb24c44fe24ce89c27274c7bbb8d67339f61992c6b22bc54d3097e870ce53c45c8d00331c22fe34c9e2f7fcd3d1372db76ed437e15dd36801dd7c8fdd6b65aacd5ab45c30883a35017bdeddf8737c4ab6c442dd22f56c4e223eabcaaaab2ac8a188be319f1153a7e7bf7336ead6b4c81f57f075fe473c1fb4376d9b9998d7c14f8d01db59f83b0e6658314c4605e09dc8d2f73b9e6cef6a7f0ea41834349b311787f3303e326ae7cdc58bb8ed491beb7beaa0dc87318e2e9f718aedbcc5967bdae87355135e03501edc037bd4dd924a00a93efaf0159883230296b38c6125f56b06ec7218ce8e342e0b975c9d974781e86f1f327c20986979b450f572e981ea58f78d43fb0268c5b67183d3173b721b9921db4cfdef8d7c3e69665b7ca78e3606fcb3dcd59da6b7c57649294e3fb742fac158630ef12a0cb8e7964d74ff6bce4d602eebb3925a25571d64899c6940ecc9a2d732671d51bfc388e156d5ef334bcf3595fdd48534ba3b01c6e969461af755d87129a9efd6a625e6d18520479a6c3243b911b674d87dd726d8fcf97cb55671b26731aaf8782b5ab2ef117c46171b432b774631039624bd65a0d7e4b21fc8c0b3e911a317ad406c54d58be1ab501df3c18247f0046f0286ec03431118627e097f7b26aea324fe21490c1dcc62a20dd89b9f41d52ed6bddb60a49c0c43c2c1d3ec218773548dd294bf704f61438c8dce3648188de29277d8b18664b1558643489b0b5829b8d22d6d406bcda77f4d759fb88bbb3197887a06a3aa605371aa5f83920a878932542edf010db49bd1d78d3aadaf2016147c335f9ee20e55ba723c6678e6fc7dcb94b71a9f0b8264dca712db24cfb484ed9bcfacc32917f0bc495c961a8781f485ab9934264617bc3f2e3d3ef9df1b16a5d2c801b2ed41523138eb5b95fe88217ecad2cd6eabd102a882bb179c705793e135009420fbe074fd06c22e828c213dc3c827179e9587ab0a89f2f640a1531efbf6b6391b26fe6bc842b5b5f2c8927a58190c8afa4a1c2dc6216bc41afd73a3ac2640d83e28e92b2bcf119622c51af3f909e6fa2dbb31fd7d0eaa2fe33899587d7240a2586182f058bb6f1b54fd9094913b7c75227f3d95068224619462bfb44e28384346a3e0b4eef1eb890ab2eb336d60a98a34ea21bdb311c82d9b05e2027f11943166a74bd8058fc036fb266276f572611b58a46ad3038b74e6f929f89c44992bd2475e728c0e33fc516d9b2deccb46c74e91c5f8ceb86119d6e90d8a88ce440756ceb438729a218be220847ea0c8a0f4f1420308c2e7c060577a7632a69e1cde25a92ee88abf27226ee88b3bef083cd3b612ddbb6281511e5cf7bee150d8fbcd184ac907a09e222c52def67a883c6e9d10f902580dc1c4ceff63de6a1f442a36bf02af872a994fa3d1a760280c75dd3f2e62579da9e57c49be9fff9a12cf2b66bdf51e29497c263d05bf83998bff04f82edc692b46678a48e623becbbc56ae10195b01e3eb320db804b626fb91b56bbe17fb36213f1843507c7521272c422a8c0df35ba9fd7272679fdb10306ef89dda44889da756f7841ae9dfa44dee68654e8ffb087bc231e89941f6f15be54307007ab09f4355cfc7fc45369c6cd5aae825d940603909c57e5bff99fefccfba727a3ccb07b9e5c267ac44dad61dc15502b22d8a7051fb6db82287f348a757758edd31bbee2067648df55dceca16e21960c9faac0bd188b0b56576141e43787a790ee5d7edd8f520076f090faaadba7e3dd4130b9e457352dec0c7326856165219e22260bdd4f570a205194baa5546d7f3c3ede5049556bf9918501595ffc026ddbcd9e7d3cbd89bae34c521b6854fdc507cd328d28b42441c5579879a6090e7746d45515798633c0279905a4c75424e009f9e0e6007aefb44edf2bc1ffc02694ca7978d8c489007715d1abe0d1df1ef031d803beff264208d073e8a93dd2a6e359677ec070486a4feeab862b66618a3c05c21291146b12831905d35fd269559d0d712a806197d3504c00919bc1962f9c2723cdf617ee58af89572399faf49894d55d7a3141fb79cfaf3000525fbd8c9013e215655ae9eff240b75f6eed1b068252779963cbcbd891c2d88addaf72535ba9f792df08cd725afe855c4600b7a33fec7e78bb843d2a2e463dd48adabfb2c23454433a595ae971c5a43d821fcc79b1633dd783544dd5011d1e23b4dbc4dbd51c5dfd4ddb570405a1df69aa31d23cbf3f63e8b8fcc1ba654364834270510e469e5dfc180c745d2ba3bd563787634590561bc0cd34c651c554094c7a1a89653000df77e7a842eb99d9aba1cd07eba11bb4b79e60c6746c0f565a876fa41c272e68c75c1618884883c282e3a4198cd1d88defde37f913da7c1a5b8749800b7245e9410a20df2e85187f49b8ea40ffcb918c704f8bab9ef4730f474c553d9e73cf679f835b151569213d4d7f0faa052558207fc63a9441cfdfc429a68acbec4e30fbe65cde2eaebc0df3dd4c7ad569322d674d236f43bfb57258c6f41f10a010e2a4867037d23cccd90e759e701e5260ed34980edcaadb569c89d87adf1c9313818caab300696d813ed515b0963044a9776e4e8e886c085bffaef62aaa2dc5549974fab39b859947a341e942212f64d2b41cbebeb51bc79993075511f89a41335ba8853213fd88cc5548e0de4e17ec0c649dabc215a2dcc8ee2f8aa65565c67348e3b389e347be14db1782491f71c148e44e8b662ce90ab7975ce37826cdd5896a20baaaf17fd56d3ddd6156ea3794379eba28ba1ef750727130cad3f651f9b5dd8d2a497b76ba18dec7d8df4abe6f4bb2aff2c86f1af0c09d6a950b935497166b8973ca7ae8b5e424c47a55275d313feb005eebc21cd738f58c4ce04d47651efa4541328724edaf49119f39b6bb7459c86bd704a3a46c6ad8a926a7c0ab59315af30558911852152e2da7f75d4a131b5ffb4a3b354a3d167bc0276810866e118a62546dc07409d05ade1cfb79f0fa49e5b083ac3072b620706fd8e780263bae543745e56f6af26b0de8b2192a8392e60d7b32102b29eae66a876db45912f50172b271db689766fea9f56d878e3138fd36e96cd2d121fb913b2f2b249dcaab1fec40329abd64b4efb9e3fcd619b24dc92cbe7a0af0841ed992e976e2a17efbe05eac53c31a8504df2021a52b2dc8133d9c7844657ccdbecf760d93a74221180c9801592560b92baba069f49660a54db67b1a5066dcde3d8041cd3572baf8088a619cfc29f92d8fe6d2f0d0dc9049b3e51ee5ddcde1bf44fa41f076b1145a100131c0c6d5c34a99b9cd4ae7b9b2d065a1b79f834b480fc6ccdb4ca836fd8fb1a79eff2993ca0b399a9cb8daf50448018e044ea53ae8e3c42c362bb2d29dd95a86e8fbab712aed7b769b46851e2232607a51a09b27cd77734f1c497bd6f80e880bc283b68ed77f64df97a00c070aafd93948b2139a374e90a152d8861ec3a294bd889753d425a9b2dc60fb02b512239ed894f1dbed0e81b863b9ed959509d5c8d7860edab21a911e111bc27180f6027cc6f1527b98b6c65a94eb86188944545bf3cb7ee58531c3727ddf53b0b55a568d103c71cf178b22bd0f8cfab0506710606480ef2ad3d651d8ee212181b3dd914df07969f8aee20e5ef8d2834d0583e3c7feb32b6fef8bb5634ccccce8a55d2c50c2e22d83665a036c09b906e98fb31bfc3f908ce56246194e84440cd783baf4592c1f251dc4be37ae603ec6ed415889e240123dbf19d409a493fd99d5700940f62416b2192c82aea07087320b21fb7bac6f7cbe114704e2253b57ab61589ea9a30012dce231c32cf024a3be7b7ff31c2a4a066fb07dac8495957ce7b5e73e58152baa3d2008af28f3cc5d431aeca097928088ce0eafda8b35690bbe5ff4d440aa0a4d788d6929219ea001532b7e98bd16a92fbbd0d83583b1e0d4617b908d8e3aa011627e1362cbacc7a0a888c8d3419794e30bbcc2413733b9c85884ec5c115520afe89c08bfa41e4557b64a24b035b20e2c5a34c8bba78929e2bd7c9cc703ea37e2e30839968df55375689b814d168661fc39d673eaf86a3f700e7198f406d9378b8932a699169a8f298972cf7f1b46bf1ad1c4ec5ff0d9551d79c855e80aff064c9927177b26b135430f4a3c6ac85f3b78085264d8a2690992ae0f913d06c6e1efc8b6a5d34b9b2f6d245b9fcb358f33f38db41498ff8aa4455a4098c59204611985968a2e54de3c40735df2ed194e5ffba6fe97a51a1018558c9f4eb23cb2ba0afea3a3179c4f35f54255219c2f6f10efc360a7aa30b6d3ad4dcf57a94835e8ded7d8c28ebfdee1af9f5c72060203f8a5ff8bcc0b6e483797786339d103fae9f1e9163f5c39426dec6cd9229ec5ec4103c8c3b6d2ba313ac62f8c4d3fde0c567badf1fcb061de1509d6d7818e9725f3f83c6ad8fe37db8a11ab01eceed8386b87b2aca4f7ebfdeee381019a5914351efda47c32a5016623e01e6c7476904195ee77358ac267c137349227914186e52bee4b0055d17742cbfcc5c00c9a6bc8f5ae2ca904ed1e7db75a44f467e319b3d0a198ae8802727bcb3c9f97eac0b03127669911d6b6a6ef490ec4f8411f90929ae86d3e6a1fce299a56d1fc335aea9ddb956fd059e8d4747e35a7134d2f0a91c9959772a4cce5f580a3ab78e63e39bee4a07c920b43b1562ff3558deba47c8a37bf17d94476d3d9a2454d8402bd2a74cc77545abe3a39527f9e241afa0459c9628cda16fce9578e000e2dea846127cacde988ea47349d16625ec92068c87bfcf7997838be782d553f9ed6dafafb39f233caee90f3496c0dc6b759cadbb1b890fc1256607b9a667296d9bee54e294cad7989238e765fd11a0b07730d2a47af2c684bca1de8f3bbafe882828b32d50c33e0e841a5c4964da46e0b708df6cfa34867bf4756e252923e7fcf0636007dae30bd22726019bae2118f858be21f9ea41949d28f3794fb6df99a0b6b7f6f5c4f415751660a22e37267e5cb220cf927cf22b198113c966b6a96125476d3a7d2b22ca69fcadf7d1893b275e33c78be3328877185de0c5f6168f0e367710dc6439c7093508645c350323aa7ded5177b1b55fc31ded319590a225d45d491f6af8f27a064dad89840251c291de8fc261004d006a40f8bea37cbe058404e4bf8b5987961feecefd01ffa9c7d7e63b1de0f66087d1415ea8471d4106c545e00741a82ed323938208d598670d8fbe83a64c5b3b89ccf010ec602c50d198662f0ba856a9c3c96a5efe11ae2f82e74c2880260bcd97434350855fef08f7aedd4eb62b958059d1b853ab1f034a1b7b203404aa5904ea69ced9a43815caa3abb730a86c29a34435f81c053a3b600f97a5ea224c47b29c8420f842f44e0bac7b3b88d816effe399fc114a622f0d1913b9e8bbeb4baf858d71268c2d780e3354c191c64fe7fc4e07ca1d3266cf31376692f3d881bcddf39bd2eeb1b54c3e181d562a282aafe7106ab77d1055a62470fb86196bac59c653f0cccbae6ff35c4a626348692d57b2728a35765e171db488270bfb5b659702f12e27fb716750835674f1223fd6f09181c40d0bd8a1ade8c38fb1019aa2976bece9decb656610fc101ba253850247e14813cfcee567ca8036e4c4d98972598b4f4ddc75b34677fd3e623d058ca4542a56db6c87669894d3757af1f7614afa4908097a70a6a82733f1a37896f4b56a53f58c5585060e532f58808e992b5711bbb13d73dcc9058c37da5607da0dfb2ad702739ed6e1b035576087e4406a977ea7b5cea1ba4e2582edff521a586dc927b5d6e61f809b9bfc1bf634c6c00e3c229d7998e093d153a19f8561d9f96ee30f6af6fc682e2a5acd59dde57db91006ad25fc0429157f18c43766c2c97628ac2b6a395bb3a353511478c763b6df70efa56223cf88c62cc616f64a15b5edc90c0ca2c49d823e7b2b67b6fa4a2e7f29c6a6c1b51eb59e2ef25f1c95bcb02d1e4fae3aa90881d6affc250aac2939e5e80587a7580c3c59ac14d8c038dd90a5814662039bb93ee928fb0d3f39b2aba0aea0687a2e0d5067112aa51b7f03571d2b445d5c4ec5e59ce597dc48309397323b732261925d72f541563adde50cc77bfb81e28e13d71aec4c12024edb95ab9d7520c842dd4b178c0eb574d373bb37462ec749cc9bbeba562bb08cfd411608525a6b92797c1b1d576612c309f2c3abba767d2f9297afa1e8705f63c2fc9feeed708be90dfb01cf96af1c32171cedd7b5ea54c48ac76b4d0b818262cda05c5f56896df5e2850410910be820b1ce34f6a5d6404fc80a94cb9721b9de9aff39b4ec09843f742cf70eb37d3d2ed089c7d6020cf92f54a970a7865de36396dfae6ebf04519328715ae8ff2bd639b279f20e7606021aa2153035655e3d589f344d9c4d544fe49408f8a73d6fb9bad6eae6fe5c08cf9b059cf82a953aa1c2fcb3524639bbe0c3567daeb7da148609d97e6002d2f9ee68e5d1204600b1f607d2fcf820bfc9ed68e83a107463fd4cc2e71157b570cb5426c08de0060eb6ebb498306391fcebaaffe9c3af7ab0433c90169c05679004eab66b7f5d718fdcba69fbb6f761e020cc1d029a51d669a1137eda75decc148379cd521dd5ddd817ae2f642faa8780caefc31cdb6f952fe864986e0dc6165bc0b95538c827af7a7ba742b6fcc37c655076a54fb0f6ff220334a968fcdd6c430d788f819d88c84c6dc63f49b2397e3fb49fe388fd895b7cc987981fec379f78174e4e8b50a9465090dac8fc661cf68e861aca13d9c5013b34b48e97ecf15566b6f560de991310f48b2d2823009758fd1091be095c7e3fc167cba1aad1041878dcb633e53799202925b64c34abc879818a1c620eb080532b9300803496b4b43deee3b75c13677744231d62f3a871084543664a7abdf289ae71f3fdd169541aa42d144ad43da6ca8f680637eff02a0a25fb0ce1a33cc3346bf155dc1bf4c4fd48f57bc7985e2b974cee85d177f533e3ca4e240acabd1a41b89f021ebd2a211e97d4378a3e32686e78400ef932bc345b3b0929f875f8edd0d1b2afd86f3b241aac238a80dc306ddc0bf620f0757e261ffd430b4dd63fe3bd8c2b96b9c83b9ddef1be5fd3f3af15ffff2c1b56eff7ee4a4504d560bb650fe291fc4843242d1d7770d5de62a75a0e1e25ca618331f5611e02a7c250fbdba12bb88fcec811b239709e26d8efd5e73c125f442ac19b1b50b0f73dcf16147775f1f01f68e242222b0be617af961ecf9b8fb4eebbe8c2f052539d6b969c648cd4328b0886b8a5043bf629076808cc1f07dd76ddb00f3367eb0a3913054a9ee46151a8282f8d4ea0d99c57b3b01f738329aea552b1354306bc5293bb650564bcf3b31320477b6d9472491ab38ed5da5d086a0d3546b926876c9ef8b54250f3526bbbdb9fafeee3f6a670efa435cdfd2a832fc2ba811abdd11d1338f91ab593986921a602bf75cfe56f92c016cc71762f4d26c247acf60fac21939c18217901b99546bb0a70024947e0c61081b23b532c95596c69b63ba2fde6de88e63d1b66923954930e2e5c3297402ae6c785abeaaad48b84d8232d7859f95745d66eccc54b5fac7f7eec4e35d131d36cb44a25cf37be376eb2703ac990a51c6620905f412ba7829f4f2c328f9550b925251aca19d16a37449af2d35c277586d9b1b2d03d1491a5e31f895ef0bdabdd0b4c3af56f579146f223d2e2fd3dd4288b45d752ea4b92b07fc5e82398f189063b4f5384140f1fa335e692ef9bf96e42d24a03bec37ce7f9d19e7a77b7aa372a9279b6af257230b677f70cb7b5b2c29af01b91a6cb01a1ea08bdbc53daa41d4c2bd2d9d1fa453febd8f7d2c1699e6b0521bf1fc05e3815a54c047adc23b7b45fa8c84c89ba479f5f7e11d3e02fde5f04ea448c4bc5c1d03c381c2aed622b0aa2652bc578625078edf9e433a02c2d26d7af05514b4b77b342fe628e91e9a1d00e40c858077562ff48dbf0d33c293d97a70f895f0f15ce74c6db4820d8169850cb8bf837f00113835bff311e23c0769fd3e31c4f8e7f14e6319f9290a0144178053046442a66df8cc7657e89d4fcaee03740bc9566dcc03708c98c42b1b8fed26174e004dbab162694d61496b3cd5fb774feceb534d36e583e1cd9039a12a62859dc17f87085b1e67f8fb1b5e9f5af18b0a581bce36f33fef740c602f5154f9b1127f08d18d43d034d771d86a04b403747260db0be07cb179b630c13d3d784850f1da00867ef8ae4693f7da4e662aa8e54a1c1f5761c485bb29098bad491894ef7484d486e15efff086c99e2af66135f90e5342f00a9ab08edbb7c21d5c27b0064be12213a740a521d90dedb0262e6f3464c5c26f304b3f20f94072832cb9c1fe257d8ad3b8836509cfaffb52227a8ebdba1ec44388e126714b5241b873a7eabc8a3770fd211130712e6a21156b5d994bafe1f9295d0712a4e33d012c839b340a186da1e726e766041680d37db83382d9260bcd03f2fa0710a35924935738f60974fb7422d5f711e190e00173c44eef06868c5e63b75f1e93c349c380c8263d9aec9eb18da22fb94fdbf3aad24329c5149ca8818904ff93b8fb54d0258dd4c56dbae48eed36f62ea7c01a25d4fcd82d6374af2c5992fe7e2946c05e7b6271bcad44173f5acdcf08033482128187e4d3fb4e008c1e82500c51be124b38967a7d447c2b1550b240dbcc1f140607f1e3fd2c568f2cd49f05d8dc83da4b4ed0de6b6efa4726b35d605007dcb46393b4b682523fd5bd978453277ed93117eaa0c27d43e82d65c83d77be0fe3c878046c5a7ca6472b0ccec56d7b2ffb5b44f3836d7832ad163bfe64b1ba84ad641135c6fd4b0ece6b04067774eabf6ecad8721727d53521fcfe1caab04d7db7ce43b1c0606c9bec29061fff0670aebf0a3b2059cc6f772e2a44d21c6cb02de2ac6e37ef754e7e830d1e780de6e804abc5c251d25502952718783e4a15f3016fe89ba4662b9a3d2a71de117a84c1192980ea392ab7ca65a5769aafba9c70a3415dd13cdd570e256a20d020d68d21265509d7967b6b9af5b208aa8af5557dc9d94f934efd1f2c102c313ba2f7ef91f92073d72f7479c38894aaf8ac1a4965754707221ebdda22efe3e5d87cb0b457032d5204f5d6de36201f717c7fe4df519d4b706297472bec61cd9a68de2fd01fccddd195a0e01dd1ac6b1fa1fc6adbb45f117ed6aec99ceb55a4815d73b4defd814980eb4cb4ceb9222e373e3c18a2113727aebb4d164e362952a7945d1ce5844e8c65edc04e8c86457fcf56a81f203225000665b4bc1fa1821b10a70873974050e5bdda9ee53e09b1a63734b8fd0ef7c27a21fec30cd5ce67e807656e6e99d70f7f341c00281963e5693c7466f85489af2e8900b69eaa464f376af5513dd899fd2cbb8110c7c12545dcf1c7d6a6f3909d1551fe10d1670e2b7c8937b75b4cf2d6093b8df1c3ded967caea2264610fcfb32555f68e785297d6cfecf063b0ef0a8f548de9b0b4997f9f6443856ed8942f2683c604a40917455f52e3c03af3fa7fc4d57a61111160df1284fc446825808c5a48d7e0b729fbfa1a33be93b2de756edc9f52511b17c82500d96b9aa788ac2c0a58031ada0bef852226ebd0362659c1c72b26a7ebd731a8726324634fde44c8e0ff28fee506bc98dfc705992e3d1c05764a81bbb7517f9c80305a4bebc0da3a74fa7f90c08873c4d6e2ab5ace64eeec2c0c915d482734e8c1ee91eb5d20cc1e92673b4b0609afef95403d65b4a11e973bf0d2cddb67657e2c57ecafb3cbf56324202af9c8381afda72009f4e2344c5ccc862618eb04fbea5cbb7db0b11f8c51572d33fdfd2c5333ffd26506c03214e63c8d68a1519770742bfc4a6c642bdd01a709fc785e625697cc1cd6a436f52df37fba5f2a7e3443e1d623875f583239a11cb3801495a9173b71ce0255ba10d1a616fb8af0b86ca353599507ba29dadc1c5ead7a7c9c892f7f8133a15ff41b5d77e5b8ae3eba0927f3401aad79481ebb9c4ffd4d7b9ae566533da6c963392e719f018470cc6d14c635038aac5f92db59ad2dd4af3261fdeff383c09aa7137f76547df864c29a08f163fbf05b770e77b1cdafac9d24c0f5c254496ea28cec2245083aeebab0a46aedc219775de1b250d1afcd8bb0e36e8e00bec19bb646fd5e16d4e857e7fa6974ba2a41218d1ebc7dd2f472055f19b0e4a261041880be1826c8345f0a0ec0c32e42edd90c35f0c01dd093fed78f00ebf60a628cdd5603b561c8955aa2095a91fab78f6072c6c433401e5fb78d38f86835017ab8719ddd8faa88a397b366f470a933f76bc850edea661409f8c34543489e484ec3254398ed423646e7d724fd4d6eccc52c0a1a5d810bdbf0ee2ee77c6ba7aa398093bdd186a2a1bcfb55b7710685919ff0ee05081c4d54c0299f48b75f469ca0f54ba5f25bc1c6ab85ee51577a892684e643547d3a613ea69dcd58becd0956d565c00159b3ff4581badc635b3d3c6ce0e82dd605bd179ff4332d39ed7ea76ece5851eddc50fb858692a9d932efb20e7809c70b57edd266dc7639e3b30535a432ae54a5da5d4f6806e2e306a678c79f5e56513c7ae789d92e33bf221e6203698fd2b2d611c6a03e4d7ca7f061667acf8c0237aa55b22a60c1870a960c526474fc79f0229aefbd5d390c9beb2ab90794e28e917ee0befec4b9f76a04457c712597ba6b39cad8f46d711be9f3f6431f642bb77f121c501809ca21701506a9230a66ed418940354bc59f655328eaa375938fa99453c4c10d42f0594b62c8359a3b82bab3b291a6dcb4de30d67086e332ab237b057aaff84cabf60f564c35dd6ca5b142d993b5ba3ebf350a2f9eda5792286bf85951264c55bb078b156af79446d7a60d5448b5ef8e9c070b670088f37f1a57a0f7702e9da2200b0a8078b2406bee202f675a381f65559f37cbcb93eb1b286e848cdd7daac7b7e9c574e0ed9a386678c927e546983047f444fd8c492259ebccf4375bd0c3fc3a5d08cd2ace3f3771d34364f76c067b14b0188df22bddfa4c2c69a69126224ac547cc5f277da0d7d638906faa6e5fa7c5fcab0d5fca54c6a18a614d9ff44980dd562b9cc75aa71aa4ed37f4ed88ddb9b7f76b2cfe1abd55106d5ff4ad7928e216f422bbac651e23c5ec4c90a7739405a2520cbc5f77925c4cb23a216beab782ad6d667f02a9514d7939facecfe763caafbc20a603031360ce04ea14b587d9fac0d60c7278d1283508590fea77acea83165b861185b393cf9430c553bd1364b40118c0c76fd6a030eff7d2567e9e16995543ab361615a7ac6bc8e6b54f7f4f0c8a3cf2b9abee3a94b7410333a5ee1fa7833efb881905bdf7f836a9d1df02c86f117ddf43d8ab18bbd34717764fb6079460498fcf1f16d9b489fcef3a336b7ea73c509fc511a7a9e01d1ac2ee8d2d8d28e22733ac32dd693d06db09d0caf72c94f4e5ae4cf6f16a716df12416341634c807c08eae64d74eb3514d8b3afebc8a7af34cfd0672ee599f9e1ff051713c1022cbaca20f36cb7c5e16a0862a37ec1848691b4bdd1c6bd2501af8d0fa428c6caf2bd3c33e3b37d5cbd0cf2846ef40311acf4780d4152ae29ee50a813e60b35d30a18482e7fde0ecf5ef1a84f9d2ce6bfaddebbfadd68cec6f2d0bbb730865c9cd791dd7951dd92dee97532cf6d3056457cde40c23207b2ebc844f77ac56712fd263b4c956b6ec6f46f2a3bc766d4818cc69441795b88475788623895a881e5ce485f02db527a3a4a23d2222d8ee6d9c3672d0e18d57a9584c079a29315d2774472fdc0b888b5fe45046d3112cada0d936689f06b2721a8989e3d59f2200fda7def0d71414affdadc77b9743ed4c22d598d7867e6893f627f365c123c2848ed225b7abdf7ca333c0f36bdaa667df6d47d1901bf0b36990c7b1a41f1817f2de45c3171ca716c8a167e7fda25e75fa7906a79b91ea049b7a1f4d74133e4610dca704e8dfae8d42b49caa9698a307fa1dd390b2ff407d162eece4d59d0172ecacfb51ce13e5cd89a662a8a12712e39802a14fe07ba8c3c1703ba78a79fb9cf1bbaef17ecef79ee271d9b5f0497d15ba55517b23b0afa0e48af77210a8aa7cf34cb144cefb9ae8fbfbe85db251bb080e2459212851015fb589e5f94885d4b85ac14dcc090dc7ee7ed3ae2773490c5ccb97ec4f49e88c4730e45be29ae36e28649aa6d8e93b0ab1954ef790001db1920d3e4744c42eaefefe4724dc66b538985d075e6fc4e2f7907c723d962be053df0b073f234960fe73ca82f585b0a16255d12fbbe6d5715957148e8bc1154efe59a2cf2a3dbb491f208d0610c23ec679421d93f58c6e1bbd2428524ddce63921c3a70a24668ac1fd177f761c2992ee609aba3117265803b66060e111f62b3d3cb223801a92e376c07b44d36232826212ade340d12ed032c1d3f1eaaa667dbbb778e01be21a3bf4804de79fe16f67316ac3e26d52aede0b2705e3b93b349a00762b136e178a8d3c282744fde4b24c02c21eb61e359ab9627ca978a23918d4c9982b0837be83d9575eb1972d1f284dd2539b2206ca94988f281dbd05f4b4878203ae60ac8522bf937593d58f15218b4a0f732d09e59947644c6d190bd7fe3c345d23c53effff17ae6775f70ef8ed7b0f01276ec308fbaf4e6763cbc5109fad046e65e54dc2086c900bbd3eef1d92b4c83b707820938f28d46eb99947778d4740f6c1738acc84f10c5b24517d2990f5ea7ebfb65645584251a074c2818bcdf263e24d2bbd6360a7c451d0fff9899b75008f481157cb045852a807634905d3b4d9a47c64357f1bafcf3388e9ceae4fcfb57f635da789344a295b5dbdf1da1342544e5c18d08d05882ad097f4c0eb0fecb049a8d6fc3ba8278aaf5a58daebad0de96cfc2821ee9385ad5b53ad1f9e4b865ee5e5376bf1fd967e1da68901d8d22cecc62bc9ffbf019cc97f17bd2c9323602dc70a73204ee99f6c7395c4fe6192d75bc5e5c2a3851a78ef40f4cc505d20ac88e5250e732b0b888fdd54d9d2558d9e0d92dd1636ce1d1997703432d5eb50aa6db2e515734d256a59d0fd2e0fe0fa6a582bb5ca1cb767bfc862e39ae5b43fa0c92befba57224993ce936f24714136613ae05e9e27743349a3941b8395e288859b5fa6b9dde748a05afc799a71b099379bc0ffb27714a6ce0629bb811acbb10fc78e8c12f3eaddc26a069e1ad16d441fe7adc5d1de944a61373e3bc4699cd8764aafc8dc624e2c41a6b1f9b8db5765a6c69e9d72a96fd34bdf423573054245c7a819effd21f191ef029a4a4b3148d1ab18a5a1ccbe27168ffdf939e7e45afefec49351d1ad800e1ddac76af556eb86d92b59ff479ec42bb44d10c5f0511fecce8ba2a61a75e8cb9603c1d5b8ede4f02123f3bf6df3ab68482546b4b3ab412c6e3892511c42d6a4b1c12c5fba34998efd582c8af9cfac65d17ee0442bc5335fc1ef3d8b1f6cec312b96856a57386352b204f41615fefbdaa48989ee585b87b0728085ef37e515a9b0fc8b254a28136be2f8b036ef9471f0a5185335483753e894dfcc999b8dad26c96103b0f9947080307191aac07fc21a7b552434de47b9cfe0195d6beec01f0c5924f70b4b3f357750250dea7290add9ec4157a38bf440aa56a4ef891f9a0217b581f0d849059d6eed5179f491bb3b62033c2d97a2cf54474f5197778ad8c3a0450d43fec4d535e03bbfdbd8c72d68a487c01ca2e8ffa281adada6040603835073b2ca4f58ad718b05747bc5b040da7df0b6833c27f30f4a8f3a817e9195def3d507efa1d579ea2e120b72c53b9371c699900b0ca6dbf0591329236a2b706178c3a453beace4dd99de10eb34fda9a057f8d065c062262c8c03a8babf82432042cdec6b4e4287ab4af7e858142dc2804aa61344f067680fce2eb8b790a51c49302cfc8e946863e2145d62e8e192a0cc05c27c2fae6c6a8cf3104a302058b8592028555d52df47ae26ee5e38eadfb6a8270b33d77b3ae51da813ca48978825b0c8828f280b37dbd3414fbaa65581a54fe548d3c539d216a42f401411f8d0546d86de7595a9127046ac58a79856d1c82afd2882a8f2b047a1f732f469401b5ee39a0f0a3ec4fabe4c16fd19c9299e0bbfcdc303954f1c5c134ae98767bd97ba2f386b5de1e6c32b29d7ce0b0df675789ac9c3dcaec892b424978c3496f2b4d97828bb06c939385383f3fa2cdd2d80c1efbd6144ef59b30d6dcb52912a9559dd3cdb750cce7ece6bed27b4b2eb05a607a9fbabcfb18ef5e55eec6228544c4c4218e4af23a29db0b80d52108a658b62ac8e613bbcf438cdf0d2286fb459aeca074478370e30eefccddbaf2bf22fbdb73986a2291d62b1fa3c3245a0559060fe4541bc0a184c2333c6f29b88c0c7c10c0016a27c08a871d4e0fb3074d8924d2def8e91c5c26563a22771f7dac50dca05fcc8f80b02c8ca548ebb02a75d12cdd3b016e5ab2e0b2c66e3c1a6b6e56fb50c51be3fcf6b6535d20be7f1f891385e04583ca370128cd354fb0592606fb69fc03a4b5a960208cdd6c1d9f210325d8006b11ff1da5d00bbd9e9c10bd59460de87e58b0a7819532381ded631f64e079451add0092ef9888a33b1b7d81af1b5c096d89db757e93072e8b7aeab8af569ebdec5d98a94995544fc37bf701c106b05c4f455f1375f962bc03a7ea6a1d3c0bdcdcb3f5a0048ae80f7af841176eb7290d3943f1b9fbe8cb92a7204aabda3e35d8e186c9ad70d816daeb2b6d4c06cd312c84399fa4a5d9b1e44dad676a769c1b317841f9d66bb2e1c332d51b1b39d83d09800f6d79e117dfd62a391b8fb2bbf6c5ac1e822459eab748965481cadc6e5b753386aeb518403f01fc05615a046ce38f1d5cebac6f3b6b8db624e3f38dbad89c6d85f0d52e5d36aa5bc7deda9a46ada6059bbc6f2782324e48e32416b8f516ef7a0ffa1c4e5baf62ee1638e4769b3018262e695413b97108ac07486d1f01732d7662af8be74c8055a698daebde98f9b8c184fa290473454fc594843e4eff1f75bc49f13d0a651028afe35fdfbd85c726bfe5631bbb999265d1dc443a193e6fa6be9d6219e7526e74f2c4989642212b06e71c9a49be2041e2540f77b111d97cd9d604b3cea6bb63bb00b5ecaa4d9f9db915ddd215fb600f1ea8f979530abaa19712e5b5ffbc0751dd725495a69175778d4d2333f2e14ecb23ed8e80831746ac95cc831f7a93fa8703c5c3082322b35be7296d77d1e84ea80afff70ccb252fa54c20df8a036582886ca8e5f09b3be4bb5a132b32e3fe314a38b425342e70c5fef2fbe8fa07305fbac72034034c35c7dfa752c83d4069657f04d17ca64e402500934902a2eac76f557fb3d15d50e97b08dc79ca6d6d2920720cf9f69d44b4669ce3787e5430bd7db8ff6c97eaf2b8d8e733d17cc78cfcb465421cbd1173999231041a3d506d75ad07568b29950186cb52d2520cc469e50e00626fe91657bdc4b902ede81a5867fb6dc05d3a199ab329e576fa03f9882934acc9d9a95ac7cd2b3e6d133d98df57f92c6689bda4a6814cc6577b7a73048b9bb45fedf806580616de1203f41b1882af298812f94655a79d6bafe15b3a5715e209cbaa6f05f977a3b55a48f7bbdde3f981e31956ee56476f7143361643c0f9999deda52e033a4ada49139c544e2445aed2226ec615ad9b2424664984e26127b0b0097d1a67b57602fe82b07ead2822ff146ae4853962ccd47f8b81a7a6fe0e179b9e94e8f8423dcbacd242491683c293e935586580062c4d9f26ce1c5568229c1eb4beab0eddc0edd26caf2056cb1796a7bdf5caea7d3411670a380e219b3118f0a6cbd3e95","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
