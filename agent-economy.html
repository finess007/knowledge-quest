<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0292d9b5e6cbd536ba1c9ade091e17bd25742eb9ea9a2bcfa575e0b9a9c5be752f7f11d8691a478d12561d658aa73a7c03dfc844a5be2ae259511e31facafda13d57d7a4fc9fffa9bb9ee995b4c2dbbf2ff44ec739bb3aae225aceed0e52cf5383efce0d6c516229e31e8bc8827a249a4f7f76c37e33dc8c48f12dae47e495552c317defb74947ba4d1edcf25249a800ede6c21596060a1556ce206032e35bd8fb79ae3dd8d09f2b637f0bf5a1ea136e3924a72fa8c90a0f7ba46e71ad75aa84531ee4d2f5819865bbb8b6158128ab9778e23f3a8efbc50f35591af93facc78b64a530786ebf22f3c48e3409c9ab3a83c2d26a1ac4c18378420353488da6a25e321dea21b0b5fe488bc8f0dda0eba3365db39d9491363739744fef612160e8fc45435207130248923035bb27aa0f45b6d0dc65cc51f335140ba9d1bf3f0912e20c8ee275d7ebeff25d30746da436657c86aca62aa2f1d063230b8d3a7b6f223f873cfb6e25c9679194e18f174d6fad168cac53cfbe5f4c52191ca2c97ef986ede8117455bbec92c5bdb4e6c09165cc9b8f8e7a390aae5a59f971502ec23bbb7a032ff1f48c51136dd85eea88bb254f269ab946e9d83baf8087f7d0d5d31f59041d50f4f3f83f8576ad096c151ba5d94b9066b4bfdb3aad74dcc3e2c968ee8d254df90adb9a9f29003bb71a880f642bef5f29f8bc378147e2d1249176a7689759972b7bddd3544eff276815e65bdfaa759d445e9d50b5470dfacd3857df05b3183bf1c635b17fd88a83ff81d7b6a394c95a966ce30bfb03491bebeb7c0d1ee4b8ed98559f5d78f67766f638dbb1117037124d091908a8c53cf97e06e2e8c23c3a8ce3104dcfeb7be54b836b1300216e19323e8eb577ae5861e2518992885659868fd502432b9f1dd9c69c8af474b1cdc7334c09b72cbbc55726be282c9fed2a4d272d59702969a4b86c62401286f4836a4d4edf8759027a85dbecc9edd0f426a9e48c3152b0e479b83a272bfa12d7cdba8eb171c85fcba764146e3dc0c7c2376666976f1342a4c7b2fb72dcdb54845fe48765f73b32c102993e9644ab211e8596d410085007c167b70256e2890a407cb438f9a938931932b6748eab7f3166c83476f8d641273a31035bb9be2b861150e10ad15e7d706df7a7bfd9832d897588ecc538ff0c3c38310acca2268bf8db850197364876bb84b147c88acd3ce78873bd9652c2f049b0bf93fe640392fe6aaa8043c6816697f597bf8b642d4e920e80405c09b080b3f2eca201ff86244583048cf92e3297f2585400a6b8ae475f42255bfa824a7043e1abb776c9ed1fdc1086c131a726a872c9b82bdf075a882ff59ef9dbee9eeb214da0b5467adca51546c045168f227a48492fa061b3022f2fb5e649853339bab05565acd16b8fad94decd003522ed14a5cb8073d8061daa473b272e8302f52b429cf7ad8e8a058527ff6838ebd77b25a30b01f1ab93816af8d5cd0c7c66f8bd1f277dcee038a0eab141a0b20111b5c2be0d7712a24bc15e421e2c00fecf03d0a9f090548a79251292e72a1c8c5da59f407d63d6945376ab49e1c11dbae7591fb60349511b493b4906812d307cb8154e48aea1e89de287c9a4e0c28fd4fdad275ff31a034123c606d639027f228ba4232f7425eb7d157e1834fa5361eb1788d7a293434ce56403a307ce4ed3aaf552751160928f835e00d2bd3a37775ba4dcbc88a2beffabfa8b2e8474aeec44ebe4219e9dd0158d7c93dee95042f5c283a4c8b8529a72b9d532668a7e7088f52c1e115117187d6c628946346b5a9294c904ebf1c07e9796de3d42705bee360b6ee05968f343a884cd710adf40640512ed70296a22a8bd0f3d4295a007e79f13f318af1905165777232ff6536a9c251ac73ee94e937b3c2563f227a7b7af0d4e8ee9d5d3d665c943f8c3e380027facdf3aad2a10cae3d4cce9dc2f639084d7deef840d2e24e481a07e2530c6e08f5908e86586ef23886fa9bcfd875b7414d51bea5d9bcd8b00f3fdcbf2b77f1690878898eb0838db704a3ad9372c45ea346f069fe652f849c9477341471c41ce2f704a8e8262ceeacd58e135009e94aab916bf2d325048b4446b774a5e4a98379f3a33ba7aa792a6e25566f114c62abfe5397d1851a1727ea96c7c53aab300825f65d61860f3569123a2d95973b76cb572e914f703efeada6f48263c2936d65e705d5cbbff3326758fca5d20758d9a9304b3660960bb31a8bd62f08f559af4dd15d764e110fae1cc87f5e6c811fea64196f8522c544824c3c1620d9cdab48b698f0bb21ebf4e85c521cc93999e414615421f680367b6b99e1727cf92c646c4ee4d329b84ddaaf89ee50275550e16f2bc8cf239387351200432e93fa7ceaae1074b754f48a094ac8316ee35537bbb3208503e32cab4683b6692e9451c477576573691c760d642442a86a13ef62697c0029c7dd9b35ba35964c1d3e002022a3160382554a0710dde62fc96add72ed460b1ef0a60c1ecd83b482fb2b7ad7babb143e857081d68b2e57e4b4837f28a518b8568ef31ad0491645118bda10f1ea1dfa6818c10b45d83e319846db6da924fda488286d0610a9830e5e8d4b23ed14a76bc08c0a42d38f4b7ae2443094b7956d0d1a910f520fc3fb10ca0310d61137c697384689f93c9df858922692d30ece7d5dffa2a9e0f02deacb23e0ab73c53c582cd2a0c3cabafa878365ced965c926a0cd50ae98ca213491d660ef43e95d2a19527134fe012066676cc7e570bae4c0a7bb49f2c22a0ea3b42720dcf01396925e4a2411da0fbc230dcf114abbeacd2419221a414432b502494e2a7718cfe9ddbe034b7f7296e43d8437640ad627b551b5e534ac1eff54f5f1d30d31fe618d12a8fe64953b2b37bdbaedb076fd1b172ef8b5765c44294c0b914298d0af96a8ced4f06711ccfa63ac6f58d01156577df1797bb42f4a7fec1981f03f66297db168fd5918344fa1a2a9f1c6bf905b258fd95996769a93d87828826e2802c563906f79e3fd6a55992c801fa925072eb6b4f629a4fda541bc0e1f8f1f6f2fc3cca2e1f04ce05469711cbb7e9862915b1fdae33107f041a8c89992984454f8bb6b715e6c227f60def75a2c3682bb2fe6089e9c5276e5647f908931ab98e419cfb7d7b5b2230cdfafd0acfb8692d53bc54b16fc896e1807891d0bc59ea8f6fbcd8872bc3525829c6966fb1e3bfa9e2fc1cba3e359cf3470b442b77d747a40142b8f2d57c4467c2c45244ba89028f2d506452fb1408c1f460d20c3ec1d0c8dc6b12ee780355b7f04707bb8026a87e5747fc9ffa89fb711fefe6f7c1c719c1b21a1018f86c93528c25581a3232caa417d9fa8bea562fcdf6444cd04573cc567243017074d2d39a789258fd3d09e83b68c7b43f90fd82724c28f5841a1ca1507127c61c34d2d00652e9bd062d174db5e189f8b94bf57a850696a7f50441a16fc27fec95d145cd5ff07606969285744cd7732395584f85ec5b98587b6b37f1e2b259fa2d2f72017361543c096315e30924895cbefa9519266e608f8efc642346eef10654beace343207112bc511bbeae5a8703974eed581ee6bd829137aa2aa1a0e32f3b2c53f5c954b73ce28fa1252af61846a205f6c068cb2d52df88e4e1110e0e90c181faa0d15a3bae1c28e434c7291192b5647058ce5bbb31998a49ba81ce86f22656ce50ae6abaac94ca7de2dff4df748583f2e635e7aa50472557bc55adcdc7f9cfeca17064060fad94e61d550aeb0e42b93ce7099e4f552bfd656698e3ea9315ade0e5ecc204529324ab04d104deb866030fc5ed8f92b2782ab10ae2466f9b27599db00b865c5e1870194fce6be3ffc688416b0cce788e56728a6909f0f3e6eefc3f6680abfc3f124516dc6dd56f1bc8d928ee04939db63d7ab8e4f2b3c9ebb11de80667c3ce22f498ff1f044e1139f9f7c5b96c637c48d42b371d78a6421947593e738784f5beef66458c60fca4bd378c2bbe1b456555af9bfa84f4f5e1893b5e8dfb13054a28138a6f668c959067aa73f1c3bf7cea712141a93cb8f7f3355a65be870d60e46a50324fcbb5b3747c81c16208b63ab5d38bf87b30372f480225f3a2e9b8024e42ad44e78fa8a368a71da2073dc2501518e92366df91a81156fccf19025f66ed8645eb5a986a68c77f247ce272516e23febc5a1a9996a5e40e4deeafc8093d94d6192cc56c16782b1d3d8f299d50ff31b7f8980421077a08e80dd724cbc91de9c4a6e384507da9a1291accf6dc702144cb505416e6c5bd47388e32a67b75d26daa5e849d01db09d8620ad8b50d0bec5cf6994e997a7b8702d36ab12f718cf62a47b927cfde60e76683972ee2f83ae624ce57f582f9e23441859734223a61a2adc492731912f253f09f235bf8c8410183ee73b11f2bb8714a82fcb3ec01054216476ccf8ca03854d2ae6a7ad1382fb0903435ff5a2c06f0b74afc4e79684508c15c56f60c3ae8996a90233b741fbb1c2395e4f56f39560fefd8aa3a45ad8a6d849991ba593ff161dd2500caa4bdf718a2412be248bbd40289fb10d5555058e4fc15a3863deb813de618f4318a14fe9c599031de132526d0a8a2059f24cd2df439199d7bd9fcc51ad9cdb3f735f29073716744d330fbd048d5cd5ba36dd6aec10c6ec72680a04bf2e29240cf1fb7671963ef66484f4c0185a8e5255eda3c4e80c3431837fb511764448ae772487bdab839c7d5e8d2b0800b8c4264ea37bbfa4d74ed4673245429da0ecc33e8cae57f585f9a5668c89008b783ad1e1cce36578b30ccae21b1082dfd12b6da91a58c48f33c8e61fb02a1cb96577352e08a98b038f4f7cf2a3a75ae9f3085f025fb9238d467a8ba3ef8905180ad266dc08e7828c8d9f85cf153bdf9067711bb4b2dc6f6e1f574abd89be0f5afb7567edd4a3181279b4b4503668564b29ac52531fa94b59e08d7b8a22b3fe7091060bb39acc63e1361f100ced2103af66705a208472f93f5a80592b62e0b95b31d0b351b5bf2a68e1b0cab9f2c7821d86d3cf5e0f07801ec45b8e07c1e77241ddfbaf85cb74f5a3a5931de55ece159c530656ddcf55a3457a0dfed281e84376fdeecd1697a6f2714d1fc0416c7008ea5a557ebceeb12af84a4e6b85039f889b8f30c7a2883e1c06d0e5401f9d5dfa4429feb396550d3a1507e59ddfa28fb5016875d05cc7d7cfe7b0590cc4a512fa8d3a0c7a4817300b90995d1ab976cec1d962811985d9d659e9e3b1719590534282cb75d47dff895122ad94ee0527354b0b9df5b5e071fcb9ad5118de2727115e34cff41ce09e9a2f70f4f34c52bb4f8ba2c321a04229be1d6b8ee049156b332fa2b3a3cf73d913aaf13df11d624bd02693d13a184319a93f9128f78db833d17db38eb6ab7d4e60a7cb1f64210dce7a247820c3786eed25b58bcc7ae109f9fd013c7431ee5149e6d08737365a0755761d6038519aef1d3bada0b2f462e33698b991a2afe71ba2621a58787af37e3b7ff5e8314706c00b76a477fa598402495dc131c9967a779fdd9f481f64667b4ac0e5dab7aa3b0a6807b191b98d6830ee15362b38a96f0c54ca74e48fa0c62058c20ef655fe120e71200f0a9af9fb5f53caa3fe3ee119a984188b1631761adc9f5d6da4006e0600e4da0245bab708c04863d899bbbec2a1f5117c239e91bca2f8c17a3a41605790de5128d2b72ff9d9648e9fd3f5be90e88651b91f48a0669578a14c6cc12bbc3ff5b48ee2e46f2ec4f8c456c631b0e17e0830f60d2772f082f619845cc01a2345891e929e876d857fe50605cc9499286d4c3005cea17ed7e9a36395be1a69794c5bb78d23e7de2034853d9380dd5a9093b346f5c6e0c0f6ee466f8e206be056b05b48a5894316edabe2012ed68b7075e40491c7cfc9f58361aa03492ea0e8c01170c0d7c73b681f24e0dc739f94dfd8b81e26546fb38e48f46947ae59bef3a7926fad65e6ee4bb448534e82822d3f76d4226d8279275b6c461e70573dc3e8f0f094cfc8f02c164fbf0df5bd552681991837070420aefd6e704ff8c5f4b22b3485e79c76d040e48cc6a4a0a9c536df751bc0f2f888af97d946d4853b34a5e9e2f15f99b466bfcaa3a19098222f6d6b409c00d68563db482b6fb8f1419951cd6ab438c50444fbd4e191b0fd0e5177846dd37cfccbe09a81ed43e01fa39804dba478cb178bab8d6359bc64812b01ca66da8ea5a9eaedcf3300c17291342e3c95634880520f139f59df8ec8d0cfbc9e8da1a1c6e31d909f12424b6c0286c05954ee38a7a0fa329a5bc2b4523e50f94297c35d553f74908262430434790a2337c805bd0e5685961e5d3d224c418fec41da99600210fd24d196fd15dbf4afadec10fefc9552ac4f4d1e7e12b29977f423918d671175dc0220365e363a8d170c7113aa24f299c47ae3ba49cd85577acb813c6168858ada5aa929954ce5e2b70c751ce3e90969d94d3d262341169360a96021728d3c1a99f2e64748290de72d44d92a3efcafcc6650679ef3df90859220b289418cef45edc7c7996402b24e925d2b95a15bdb4b985619f1feb822ea37338ee8a06d6297201093253457dae2f41c1494a8750df65224b3c7f053b9cfa8664abe7f978795154ddef341cb37f1734710b1eddbd2e0792c3c0936769d05462cac5e1db3497ab12e472986073bf6d37defdf9ea4e1372af3ed080fbd0f6d7764f061bb1af7cfc3b22cafbe568e221b0890b9f6fa2b19cc4759f69ad7142a090379586000830637b0280a1d0b38e38243dfa59c2463572602ccf441c4d02ddd84594c19d7966f3af7e87f5f3a28f77a0d385600a1d6a19f34c0c37d5748e4ed8b3be4cc4d04898d72c3e34118ee50395b8e9c954adea0a12441964fa4140f4aee35e2166dd96e699c5679f849f132e99f2ba556bbc6ca54cec9d4887d58600c6afe1db1ff2172915a5b9b53d1c435bf1c816e4fdd4319e6781577c00f2cd6e01905f6f9bb55cdba2aab4a5f36168a3fbef79764e8c3130cf448a1d191372db0e487c59526c7e6e6f8ca4c5063ed2d9dc8f75e2abddfbb8e13f4680b00c307d75e7882a70f1b343f969cf9b0c5dca6ebd97f83aca671dc99f2618645e490d7929c0d53844ca7862e8fdf7396b6392d5370d6e251aa0611398547697ff55a464fdd4b2ec30d95cb069ffabd761d8dd0fc37e06fbc24164340ab69842ff006687c5caa0af8c6e03d0da4f97719a6138f4172a450bea997eb4125f44e6c85ecf997e9e3492fd173d7b753ce0d591d6abd68327733b637a7cf4530da66ab7ac179b011439a875937d2eeea1428aa3a4c7e47e6cbbc2396b8190fef391670df4129e6cae88b1c43122eaabf4f038221ca095d9dcaf1cf3bdf93bc20c787ce8e5b843766be23b1e61e8205c089ce5ecd3d56feca7f7c716114fe9ef5a78a3aed663c3b059ea6d8f29fab22fb8bf783ae0312c02f2e80de83998d8812a3f745f4f9fe177ed727b6606be08198c06e3d19152d5fb9a948c173c5ed90288702cf44a3c6b5bfc073066a2434de8b945bbaca0aae2a2ef1abfbbc0893eb8fc0b601abef1aa0b5f8a34e49c63e2c21373f3c7c5eb962937af4a5d953d0a997ab5b936427c6d6e2cfa9fc6118a87b89c1ef62a6d8e081c7ada1ea83a7dd945935f3c95a2a86976fdcb084fdcb32b8710f6436155ea09d80827d14967a0a0affa9512e30da694dfce1ccc57e62a5e9012df1ddba604eb6d1c929e43a175bf3701cf1e2d54a10054cd2e0cb6517703402a57104b9fe991cc22024d1e314bcbd5addd66c49b2ee180afc164e17ea2e2de4f4ffd22bc6cdc8f7b5023ab78ccf65302fe9aa5e33d5bdc06f0e968368c986af30228f7a573079a6be65c34f0a98a07da85844462a6d436a93090b3c4111b2722acde0e49e2ee65e796faf834fce5112288d710a60b14507070e5f78286bc8d422c9d91b4719a35aa8c5ab609af71664ff9874c5e7e0a3d827882e00e5b1fdae13a47cb0b20e9679feb31531a6eef834ef83b1d2bee2077a66b348142d33c1d42dc9288a66703db4b8fc1b389aaf6e6e729336365382f6d35f2984be4d570bee5f8e7c7ffabce2bf301f593605d47750e870d44454cd7c9244a7c9469ceb8613d0c98a022fb156e784fb1953cfb226c5e8c0bd78ffa3bf7a382c32af07a0c507b318f47ebdbebb72ff5cafc18aabecadf93b5d2780f2650aa27fb5c2f758ccf96333e025fcf2c76854e3c676a073646f30561b30803f0f80df4367307759072e1b2ec5797b84d6478a72b5c66abfc05bfed7461901c452e80eabfd925b6a7d47de53c1da463dadc62b9a0579dccdd5551970c8c7ab17d6d7f5caaea116e3ace1db0fe0a7194a02d2ecb4def638d7f35bebf3a16c3f84d8da74d5710fa852368b7a081f26a10bbe42ccf0de6cb05eb2e19b9dc35f5fa455fc0f13405c3bce7223b38f84c2659124b2092b1d0b6fa920b8cf035f874974eaa3b92355198111e9d0f9a3dad9c74615f60a23acb2e1ee4f2b51fb8bdf74a5df521b764fde85da0da15af7e7e944aa4d18d284ff25c62181131be13ca46b4710a3f8c1e2b931b7c0b1126328c17c1d902562401c68fa17d2e3d5d58db0836ff83032dd49e0ab55f4bcef47cc838b146b1096838704f3918772f7b859766631c32bd45ad82fcb67eaae86f10103fbedcb92d1a6009c8150e969cc6b16e11a42eb7eb5a77eb2345e150db01b9d858e3722d87790bd42a24a8a7b8f18e267b5b3d1c4e5a691dc1c395bf60ba6e6edc06276756410a89404f1cbcd522ce74f989013bf4fae66d2a5c79e38a1bb88f3cb361eba3bfe97698ed954c525a3344dbf1cc7043462dee5a53fa04a48ed59c8b39b29ebde580c046e5001218faede49bb8326d6d047d157bf2cd677ee15eb9bab6110a13cdd23edca3e34b50265f4edb9b3eb26e9ea91c1b9d842fa23c457abf3c29c9d6397eb984f7baf9f32679c20e6f036268edc891b85a18272062527404eaaa7cce8a5c67c2ff524a35cc65708b46ee03657dd74826b0df408f03de54142e37ba01357f76a041ee4fd67fe0a8d245df5775c8b9c9b5d1ac328befa2c553608d3c7ed56089e98f38c9c15b97967804d5ec7a6f5c440fec3234fc1694fe183723472ef497eb08cbd6e65c41e8fdc28bb60ba84bca79f8474abe6601609f2d04aed471a93d64123c3c31d22948c81027b2dae91a2d44fab8ef9044af763ae6ab5468a3f88b8e7e6521881d9a0316c7bd469456f73a6972cd290c4002437c6eb52d2ee297f46a1bc73197fc79373bf30b51470256a6fae4015cc14b5e5bfba7d3e159662313425f7d0aa5cb31b564145c4242de7d08d8899f7cb695f42e726edb98d06f3e1ce96641fc435b8892686dfbb2865961df28cc519543600769689294ff2d91841b0826d7879738a3a35ab48672fc0cec6166b28e8a14b2e69e2098a6018e39f0cfe5f852984580198a688ec522b2525e3c638f7d3afc521b8709942a97d3b4178860c7b4d62b97b6f85d80f0cd50ec315704d0a60ba1c5980241ce45e75ecc9ed8443aca3b810c557eee115aa1d78319c2440f42e0e836e51c77b5e259b8f0adc63c4b9ef2acdb33b550d597b6d2259dd77108f538815590f67c8b11e559d96b681f7ac0804f08f936d8c8123ebf7c18ec57bf8ba638849f6a9a7094a233bb234ddcd0dc205115bed7d9292c3a75fd5488d4cf8a9fb2de845fd82712df8e8d14230353643b6c24d3e5ef501c48e8c7f055b6977a8b367f3310ea47c1955f24337eece35e9ea5619e526c4d8266336e7463373cc4feae7a0cf5f5ed16d3f8f3c6dc8a3f30922ca0fa0253267d604b560f3bfb384b61bc11154d8b1b0b42cabad9c9ff4edd8d4e493bcdc9749b920940cb19b9f59fca9aeabae12e2c8eaf4ca509447d4e505a13b3002bb0e097b0c999e1befd077f4d1904b43f1a8c94a0cedde9e5e630816dd3e44cec5c3fe876301bb8dcc8f704580774bc1a9cbdd5671adbddcb95e5b8e54b743c19541f695e3c0ce9517e40e26d65425d1e86afc50f447d6e40afe78e3e428ebd10db0a3651d452385790a2d167bbbb41ba7e5ce1d931f7da13777bd696892d5be49adc112f0aebb5c20b296875aaf8975107059bb6774941af7bc2ba77d979c914d2010d3531490538147350f2ef7f68f278190ff83fa95de4fb23d1a23f907cda1e307de2a45844485aaab2f68378611d1929f7d02b6701f3719999c88bc4aa1c20a71ce022e70c1599dcd0353ac17b54a2a6f039a9bf9888596e0677a85e38a3bd0207b4e111fd5d557b0822547c0f97f456c51c294bbe90a92f554130c29309cfb1d0b05f9e169b3060403dc7d38371a6cd907f20b6fd528ef4d9ece7487b0d1f0db26bb7f024f71173e9dde89f8944e4cd6ad6c1f42f48c7a1681a615ab26e677ade1161a315b10bf15d50ef8f5bdfd7149c22176b568079d53db68d3558e0d80728977e63907fcfa8d16b7a6b7cb90cd899e66ed3297edd0227a15ce0d81465b9c5d246193e305b74263480b43b2be19a1dc6b9bc66f5052b64a8b8e70825d2d06926d267dacfd0485e4e5a0bd89d4f78b77f4326b88bb3334138820eb06030c806b69c041db1ce538b9c6a429e2cf509f9ac0d2d91d2e325b5d57792b6e0afd653eb5bc8083f9d5bc4953300e5dcd634f981f8ed566cdcf5503609f86a4a68275cb43d9d1d82600d30a34989d1a1d724857ee3d062df864e3367445ac5f7801c7b0435c0c62d688bfd8d09baad3ed6ebb7ac89ab1f585699f94b2254e73e45908ca96db789719839c0d27b183babaa4b15b913c1e7380132af4533139c0b925403c3063125aa44c92b64e69f55dc3976eda85a09d9352f9be4450770f57833cd90c2abb7a0e9b4a30ad211c5ddab05c0456ab52c7484d85246f99267bf5ce3d71bd1c295171b85566c4e2f59d5e6bfd49b9e94c3e1204c5e8f1b1d62421a0485182167c6dd74d782fa701c01ed278b18b3edabfad6419d3cf3218f783970a36820f75989edd6ee977aff7ddf21960026cf43156a6e48c80a830b9d4ebd24ce077dcca5ace4bb88be1d0d2e05dcdf19c5340f6ad6819e2c72fdaed1b8d9598ef23a757bb726bf250ab930d5b8418a6c144edd005f3aaa9a75932578d15fee58fcf3aeb6b2414e03563d7ebb847e8cd2463ee39200547c2654c987fc028d030c096a6cb1ac5e4c4cb122a3d957a22b99d2b6aa03ef9bd10d83832a2e4a94ea3251dfda74068e533166013130138a39a50e616b5ff69441ca519645422c761c37308fd2483eabd2877537b1769731286af402dad24348383c9acbb009156c6ffb9e9078f74bad4160d06b0bfc479f50792f0eb6d9a2b556fb89b4baf4c8e0a3ecde311b04380cf404fad708d0b3d1df7d65c7cbaa574bb363c6e9b0bf4e8b629066a1377384da3fd8588b5fc9e0399f03e613ccba5da59b9f61c54987255e1e55b281177b48933e9d7d3b44d91c9b1c67fc19e103677e040156b568c8d6c9ae86b96b86dd164114850dcb2c793e5629cbbcba9c4ac132a29220df75de7d0280921658cae009a3568804693f354025f5e94a4a494dab6cb3002a9fa7f6b5a2a4793df7585032f8dd089fbb67dc45d0801e0fe115628f35a159cd3c6b464675a27dbbcba2d741cc045b7ded5fdfdc68a0cd7d98fa7ee2ff54f822b0879fe1b105b0e6d744da6a8ff7d835696abd761cc995f392c3b0a2a6d1646ac65f02496358ced367472c6c4343463af07034a0b4fcbed98dd904e62d5c9a5834fbd5eb88e738b983945d0a8e878820c92141122e08d4d6526f0d9babbbc7b53307978ef6520ef45d2eb3b0f29623393e51a2f72e5927ea92730cc3df8866fab8c4824920bcfa2b2cfdd95eda541ef6118e6a473031a88a638011855981a2ca744519325f8cfde0c9d0ff376bdc0c85327feecc2864eb0da04db2bb4b857133c984e6c6ecaca2aa29dd5b592960cd9af8c9a4c01eb8c27742372d943ccad5e2d806c8a75d7c1378c1384f7d0ed97fa935db3cd21f56d415e3668e93e74ebf58607d6baea5899eda0ba0927fe157e202d18b3e44617c9a639e86231503a31efb8fe095d7a3883495d0b7fad6b6acceabb46a49bb89d06916d58c723de68a592d5f51113aa3dba372f9dfc2ce696749eb165358f19cd83ae047573bf4644054596ff4b21b1996a6c2c78a709f0b6a6b89ae11f579e36b9fd4f36d5cdc2e2a550add34a05a269646b378b2ce430bad4c80234c88557311171e5a896c8222b66dd5514c1a47a394d20a76a3590aa6fc90413318b92a69de7056164a1b2b43165b5b4d4b9dab9b404e275f1787a1b0301c8c2021faf0bae96a827aad205d4f336d6d20636aae4fa143476e4c607be8e236fbe8914e78098b91427208d484bfe0b639a776a7635b32cc42e4cc46004a35a93828802d65dfbd403612a1a2443c46609622134208ba689c0db590fe2bec48b6c06498db9ed40b72f6aea2db0e2ef431460b75b496646609b2bc83f0c1caa440b288109afe659aef1dbc021bf8ca961b2837ca08439894c6b9afdeac5ee114a82974894e7088b88768fe11cb3bc2432291b95268bedd641b4cb7a310417f4d21cd16b6c7c6494092d6d1cde9e726a3cc6920a81b2a4b52a8d94f0b887744ee387b6809495a5bb50d70ec8c61a7431d6575ead45cbd4ae4d89319f0b4af59ad5d705952f959bcf482682c607e98aeedd02995798c8ade1f225f3e2d3de048da505c9c4b5c75077f8578bdf5a4521c64846e7a4dc03a2634c5dd39b92ce49b066a38dbc0d8c598fff78405d86927528cff1c5bc23070687be2c12f8975a47d56231026c198f83e3017eca5bd74a64933ad22394997ad5229f9586aacac263423ebfcdb1359fc658f3890f89a0bb66081a7e9a6596318bfa81d99b63e05837db8bad36e9f5543a96237245ef16639cd110dcaf51b459c1ab868fecd1d4ccc4dd6f61829554daf214e94b96bf1c4a794fb01d5faccd6fb7ee9dfcef72b4e656a9c0b2bbb0c21002b58f006374d6389e3369b05a02e2eed496e86ffd394dd3244eff95109279565581f69f1bf3fcc4ed31b7fbfd5bc3df3353e23eeef0cc03fbacb3073eea1a402d8f996c1d2a94a29aa484393d462a6c07008563979223faa7f3ef1f579a2c45688e0eb411278ef8a379566403a492d467986b70b861756e57006e125f75cb62220fcb116263d03ac7311f8767bb3562ecc301e1dc848594952695ab5654acd495508d5edff740ebbe94019a23738dfd1abee48aee578ffcc283105aae444497cfdd91cdeb852bda988b51c34833a9b22c7f496a7585d2f2d26d9ee8d86e5aed47e06c6c59918a17a90e77c4e34306485929509d990b6daf49873c79e35f65dc2168cb6d24865ec17f53ad48c76e6aa4b69abd4553c67c710414fba7e69c61a6763becc8c0b8217dda43f2a678b03c5f5aed4af9c35c55072872cc9fc019243b3cf67465ac68a548e1ca5f050f8ac6302d05c9837321f50b6f0f6cc160e93c44b03506bdf205b64a69f446182e30d8acc102ee7071042b8dcade4273440a65b5eef7ce4e47bb193b5fff46efb6f45a6bfdf21826304ab4b194c851db21175388ab17d68d876822f11492790a1487bcff6fd86353dfd9cb584bf9e5883be95e1c46ca2a0887d1264d30f93a0f3129842497c0e74743078cbfc7fd150ac882370a1829a08310341b19a71cbdfb1050d5883fd776192a8ff0db8e46785286422281a0a28270790068be04a9b3cedade6f87f31fb46d6f81cc8e9e9084f03655cf6a10f397d585c4e3208a8070aa476a88022fbaf24d3a443e8650d94728a75df8b1bc96a8b2d9eb272df123bb29c92b9b711b017df1680582b3a9cf33e3acc0cd82ec7102c4ecdb23c9cf926f7b8fe5270a1faa47b4b3b41369f61014b6d4008e791b9b2e1104aedbeb27f2546e65953fa0b51caf1ebff27c446336b9dc1426351495c2946b4d1a8020d552ba7405a4df88e565e3a674e3e329423c67a3066d882dac83ea0b26a915ae7d67b24956dc9f87307cec80979554ea82388d8223fdf50e3e6171b699879876528b640093bb9948926e433d8466f3785444166e4e773aecb2de7f5d7e1339b36781be17575937df7b4703b6f3bac351f7c2159a4f53acc6a80f6e0c092dc61a737925d7d1726ecc4ae5e6683ad0bd092916beb1d57e213cd9567576385a428f1e41e2f523ce40d5c340927edf88a8d8eb52601546e2e6ecb125221f466632ee9cadbbc219b33094756b45f70fc03c13d6fded441e7022fdcf65d0c849e863b0abe19c088b92c737dfd8467362bda44c2ed3c498d66213658b16cb25174edeae4d0cbf2071c4d0dea65625ddefb317657638eb1fbf4802a5d719f57c2ac0ce46378824d99a8808ba45c658c4d4f7bd99e30cb75bc394301028f51e587806b88093136aa2b5e0570477dc609ea29ae60e4aee8393076c60f3273f45c93c6e3fce0f815308da7532d97e040f4ae68ebee05f93c39db802e1ff3f183a7cf0545ed912b79266f8c4b47caf5b96622f76f4bd1c30d2c5e925567bc78b3089385c897f7b93cfcf5a61a61cd9203b4f0f39dde5d194f365733ca58f3c52333d667ea14c0a59adbdc68fea575a79fcf122edf2f71adcd9f45936038745680e45368a9ea68823fe5d9f0a4b1dc82052708f214cd8d90c07f93544a64ab65ba4a48765469a0679ad977eb80c2f76e22e8e48317fb71536653580e0a687420ffb4f7ba82d9d27ea3f13ff6306cc4a4fc07c3b840a02421c65234c5d63df1e737e7e8cafb87279b33f56067f1f20a8a8e3b1651e17bab1aefa43ef50a87caa1f58614569fafd6045838e31af9b351b0813c46af8fdcecdf6a25f4b723d3c8d5ad96e55d9681c2d3b66b84d76ceb2ad149cb1edfe787b1b2ef5d759f8b00f2273154846a5911444bd65794f7c75c284946478f15098d987de96a96228a123f32afee70b99f3954d3d26d1625fafce1563a105ccadfc9e76eca20f7984c60e04722cd79fe3ba60e1413c2a8b9d87b2deb18fcc7caaf02f8c71ae301c94ef56385d55a8d3f24e41bfaf3731c84b7dfb00800ef2177572b7708ccdc1ba61cffcc788b825597f61d7bff7797fb25956c64a4a3625047972f3c6adf54c6517554d927b3795035766345fbabde38e7997ec462eab7ae247591fcbc2cc763cb4af4c07083834f0f0f143f95f26f5b2ff116a430b8e7a689554d353e43afe9cafa1e98aaf7c30de97da24e8820ab52b3b8ee3131b1568bd74b104cd7983e6dff1d0715007c55e02f1867f61d30977662510f770168950babfa9827c96101baaffb67dc7863dbedfb17ca33c177c106d4b51c50e5e0ec1dfda7b503ad6a98d8a1e0e4d44260ef147f4abdd6bc7ab7fe3c3c40fa9cd2ebaa220537480b6cdb7f02e4e07ed3c14b36dc7386a796ca73d14bf5f583e2467d6ec264d30c610945dc225554bcfe875b35988eace19457826da08371a549536d27de58c16fef242ecee06a3c1cf559807ba6f56a213d480496acfc4a1a88656ee085c94d4110906c4eac57f2c7c3507977607d16eee40fd51aa707d6bfdecd7f5865655ebe631a011831f44be04c7ce1c4e1409f1cb09d1890694040134f1d8068e79b1825836c4c9b5214dc98fd8caa8aeb8141200ec31b7000841db33a45e7a367b6e93bfbe04e01158ec867f221f511c98d00b333fde511fdd8bdda2945198df2a1ae23cc0d6ddc5dc6a49306","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
