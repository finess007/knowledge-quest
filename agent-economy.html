<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ae148e0c783b6e82e3253ee99a1c8849d4320fc94509246427a88652812e83eaa680078f6ba85d1eda37e7c899826e1ff0736f992dfca049db483bfe870877c19a9a399d6c0bf905add8b0a6c7f1e07d7abda355aad24a5324a519147b1e808ea8f3e71b68834d0ee88b5f41b70b2caa13e74cf2fc7a98a6f38f6c5f9afdb778cd57469983d381878b6837dd66b578631d5f530a6bcec389535d86f2eb8a27d20961c385002e851138b0c2929b59d5b3b2a8d66f260b97aa5fd0d52b25f9c60bca9cd7caa558b38187d8f1004c69310f770796c7dbec64f062732c0bc3a776c1e5bf2d57b2c26131a8c31176a2107e5086b22240ab3dbd9d59e06e3e031d4497694f93cea3b7bdfafda42510f815c111d2eb9332bba721ff9a8d78cb7b12d87193d88a862c53346ae0d34c47dc0b8abdc4213e75dd9ccbb60eeb43e793762e5995c8ee4e0e11df231c0049931e2472ee06af2b89c1fec89490b18a47bb1750a9e7dd629d39dfd1f003dd651fcc1c1d7ee78f52a05b359f322cc844916b0d8be79c981cad61fce11b34fdbc8b3d75e2e36546ca7e9f713d4360659fb998d8afcc0afce2eb6cdf32e79b3bc368ae0b1923d7441db1778cc7e2c7a9c71a481a483886c1e71902f9a6cd59c4aab880502a61f315d51edd7725212fbf96988846125e5c3db15fe5d9f0b8e890f599b855c03d18c12b167928b0f664ad64b1223bbb4b1beac0a37d09ee77d953466cae6f0a34092cd04f09d7f2b056f00a4f3238ce162c0dd160a39096c0d1311ec28347fb0d3454b65c08303aa671252f29736885f69e576db2de1439e3736b9da355606c9c02f0b90558d19ac3f80696aa3e27e2b44e1beb9bb793086f53b63fe03be3fd17d5fe3d7f5fe7c3760b559863e3e5c8ef5c2c66169fcf7de875c6bb009c95b4d282bd335442b177c5eb68b03da1a3eccd0704c8c5f3639386acb3b9b72790e77c465e7486f7f715e9c7e03d37382bbf1fb55ad21ce8db66baaf787e8976273e59c7d37e6bfc2d0ff451a2845fa661ecb70f215700f702d98cad11452f05d49cb88ec2226d95c53b257bc76b99b5df026de1d92b16de8bfed42862a13883401a2d8eff9fa591e7d497dd923fec502d5207ab05d11f88277b39d213cf01112453582c7bb7103fb2ebead8e7b6d671df9e55a36b1de5d759ef90d8a86716f37493790420975d3ddf607d3f09825cb5aca8e22e21507e9ac9a597f90919951f68e60eb406fcc36216098d0f29a784f8aecf07a60aea951f9b540a22fdb0251b1ef44b96d1a6ca67adff0c266746c68ec6aa17127e949ac99d6c94ed67015590fa5145d3d88eee682b8e1d53521bdaa2792e21d78cc7f315d5a9803ba1ff222e08046e60ba8619f7892894cbbf288cc732b38087bdc27c67f815d0efba27a3ac568cf459bb9ea191ef9323d6ac469faa698b356b19c61b225d709e3973eb71ff89b07ab700f5f016828521f3d38c33bab54a76ce1947cbbbb4f9ea5cf7e37ba3a8c6700d5bde5f84a404a69ef5f361a3ed95574963246d65c71f469c23fa142a26eb57bb97f32b111658547a7da45fdecc91e32f4a2aa4afb5adfa6a1e208e279b797e5b35234fc8458614bb52d9240ff1e9cfcf3c3d1df0b20dae239fbcf1a8af887cbe157a66f26d8473f07fceadf0c98778130b71460dee8463a0283bc3156375ac5263c7ba1cf17afafa43b4c36014c43d7860337bbd2fc61f4b5dae583d559e807ce24bba36804419dd5d82a79fee68c2b41ec6397b6fbecd2f5a916d2d8ca36651816be20ca286177fd5be3eb959023f2d2b4ff5da3d4b329ca898d3e591f1c52c9f8695900e01fd54b7a0446ce6078594f93e34b9b8ad92aefcbb3e798c13cbc6a25bac7dddd20c7e0ee7740da4b70659ac5ae7dbf9ad16f6b9b786532f0927beb4ce42118b4b8cf0ca4f31f2f3eea57814313d3434e3cabaab5763c9c5f7b21c071ff92c48e2e69e08c760ab9e8e1648250788678bf3c8330c0c2b5a2fe374d1b692e32c869fd74e6ae45187a291161bc47379b68be74d83f679db5557ccd8a1dd46e5a6d7b7d48ca9a9be7a987ac6b1f8c3759f48c7cbadbec7890929c59f74eb337203caff33f8b9eed3a63ede4f2b1b05aefc4c1807ecc4d85de1b93452447b00bf029a778ca2266d6219b53832a8a3bba7a2b37f1d9ea753bad8561d9e5f05928253c04e21462f053cec4559c78967a6f0126ebda6dcd0f3d8df83a30f8ad545f996c708eeb77c83d9b234ce961ab3daf92ad6513045eccbab9c611850a82e275400e40edd2678047be3125cec3be3e6ab25cd4f98ed96ba38d960c148f9bc3dd40b06beb6d99fee28453466fd949756f9ad673351e4322c3c28815493a65e488f1428725bf7a6cba41ed62945668e5fe118ff40fe1b593d4dd156aac3c486bc7c30bfd35e4f31334091c7326a9c3d097a7a5273831de7b19dc6c5e34f21b7e908cf47ee20c4f0c0e9540376668fa44c5de83e3da6436b12f34b9c6a0421434cb5b535e70c661aba952f3ebeb2c03ca56cd9d37975f4e55172d0105c7dd3d28b729b0fdd6a9e37d4433a34d925528dcbeb0cd0f9e5ca08a28e9a6a4eee06e913c5f97a0ddf86d950475326ff1f4c0cbe6e9ee6ea7f47cf73fcc780825edf04ceff61e4e7302e8230e5fcbfb023914064f2fdfa35535c17b14fa6a24c84fb2f1d11aa10d3578128d90a50f2e67374451087f00855c72aef868264f5914335e13d7a9b98d95276f3a7df92f155cc6752ec4a7f8b3637b701492dfdab0e116f78f0f4047f6b64f496f06098eb5968b0e0d3e1f00c44e86a37398f309fad9c1acbb6e611603014fc638254e90d1490233858091ab178f522fadb401e021ef139160967040a760a720cb4dc1ed3b96bc27f43a155475fbee44be95965c9b473a4323814d6c5afcd2f4142c83bffe456e487dd4acb4b608d4f8939fc4986fd9d0bc67531f5691355327015fd5232aff03ea528c6771372c73890ece77c45ac7add8cd11571ce2b4b77e8a4897e6966e54f6655cdd2253640d5a3d4f4c64b191a8c7dfc0af531e881b8dc3de5d549bba87ccd38fd4a052a84c441a1080e4868e17c37a50370add9f6211c3a6b912f65e9eb9830e7345980be9ca7fc9055f15c32e58a4540a27db8f8dc0587f0e32c0c96f2e7f9d28dc81c64498b8c39ec33d4caa46f5b2f0ddd2ebd5610189120375560fd6060ddbccbbdba8b313d1945bbe7cf6a8e4c74ee0d989950721b1fe7e40dcee637d8f6e1df5a8103e55ffe06c763f316296ce8e69b671894ae9728bc3ecb952efed41564199dc1d18b70c80cd3e9f8a94a4ba8f261b88182dcf635fc228c78a070d66b5d1921af78bd995b2d3f90dd357b0a273bd1ce02b741a8450fc281318af03455233326b3915783f4ca284dfdf49c90bffbb65e2cb63ac657700704442f872bf05aa4051db389625056c4d1ac9d074d06929b46986d94b4b7b57b5baad2cfad705dc39b5acb1f87965e3e4d8a03b66ef5152926d2cd6e3eed3c7a4c0885d0d41709cb65a720415ada5490a50a7aeead642bf0a9d7727eee83b95dd0ad0d64c63ad2a561b2daff701fd351271cdef03acd1cde93d0b9be75b10943185c353b33bef19cd2c95d819a26938818f567340a62bcfec1094c2ea76870470cd07f543247d7e8f7f36fa93bf3782a11c6b81ae26b2750a9de929a068f629b86792ecbb271202b5f6a81ca1d2575b9289276a33a6a3616cffa955ed2b51bdd0f1156ec372b7024cffd6b19e4e6d9e35f487a17f74ccff1ff76d7bb477a38902321e8132cfb41a160415e8adcd9fe2c2b0b2515ec339674e69dc095627e8b1a8e2fbd8b722abd63fde2d2086e7179c147f1fd7a4dba8fb914015c67ab947e0d7dd2d9cdcc44d8f87e8f622c7c27b51d12b2bbf459b62358f462aa029d469d8e5ff4cae1bf1bf32afbdf351a62a3762d48816e65534573857aba77e41bf27d39223b81e0d549622c4e7b31a028143162f11f0437eec91d5c7df08be393e64f84f0a2d15715f69b85fa0249f07474c4ea3b2583e574475257cca439ddb8b5198d14d24374b385ea5202275d55c7b7281472e9d877837d5b1d9c6fdfc0fe1ed1ccc9d822bf0bae9644d6a621726f01c61753002ad43e01bb7481bd15c049f056b70ceb93f5a55e448727727b0ee16c915cdc4f7eef6bf59daebc4c40ca2cb349733d5acbe94df24cb20be843050223d8c8ed7f3a2cfb2f181df9967b0adb02d1e9072260a22a6408da5badf55b715b73373d9f14b6b86311590b0018b4c20603f35da092a968d2aea63ff71f083e0f10f68f0e2a635a2238e1f0328f7e1c3d2ea21831b0834cd7a892029b5f16eed7f1fb79d53c5317712cdf53198bdca8533eff03994406dd01876e72976f80f09b98e80d16febae734ec0274708d851e5180ca25d55ccc34d26f8d76bd16b62d7a0609aa34c5fca182264dc397d6ae153b2c29c0ba450f74126fc04aa0bc6555f8ab18c92603158c198ecc4f445c88920189c0d0b52cc5d4253b58b3e42421550192319fb2613bc8aa810894f28b1f070d214ec936938ce1873d45536ca2c98e5aee1a370f9c34b73bc90aa23838400257a587c21a0e5a18ac9c43ce17cf3ffdae1de7a8f20cfd38fe75a844332b5fea6411e2bf7dfeb563198e02ddea95714fcaa0cad650ddee4e13dc28a597341786e81761aa7f177b0baaab4dcac4eb89a5e674055a73015e800d75848a80474e55a616d5f53304500c9d6ddc363de9e063bda2cab968a219e3b1468b6d0315e86a8c30084b7936dc8f614cbe616232d28b50e0425271c0b445b4bf51e659eb37a81d532e03d7a2ee8e39901cdaeef434da0f52d967da41e90fc91766f15d1a1a1f3c90aff7b1e486243f54dd6bbc5787bcdeb68290042d4479176c01268e7e33fb08a466e4599725959c904c319f8bc5cdc09a945d74946780c375d575fad5bb8839623d1b567b0310f228f49a2d9a3b98dff01c18d2b733d6f1e0a786c5afb3adbf9edf6f6ad809dc74784e9392ed91ef1752174e43e821663fc005ebd20da9cd1deb6b925d270b65be56a0394e308bdfa3fa0c008c0b74e3eb9833a7cf3c029d5a26d794a0eb69d291cffceba2cb880f4201185dba5475c20a77ab7e8872b419f79587c3f2bce4645ef5db28419f84ead01482cedea252a8767a3c7d42f23147087bf47258653e748aa161f64a4e5b1f95aac3c4880308e7e7a8ad5dda1c971de97720c6ac0203a5edfd2713265639751987096de43013c69b2e9ded5ac71096e17761675efc97bc332661384ef77531ef339f8552dfec4be460e9e5e1fed3de2ae39a71868030959e5a1525cf290aaf9789ec03f1c4c6e40e1a0676cea8fbd95de9cd0b20d551111ce49826f56074b46c4327a0e002eda17f1dfeef3ac008a1d32caf51808f32717b2b7f34d060d9594c32c040bd432c43abd7feb3075cd02c1f35b8cb08e0c85c3a18c07d262b95f1671142de10eee83bf683cb1e08dab5f83aadfcdebcc072630b3e88b8f02d9ae1eb55cdc97dacd8edcea659d1049626e8e4e5d63b7ff9304172d7c2bd3ab4dccec2f54ba5f5735e97ffe0f7da25d8baf0ee766eb5529791dc2144db70beebc3e1082e8a0735a9927daed82719e0ece824cc2c356f476a173fad73b60da764dc1df9b35d9cc617ba8943a2708cdb4583f3eba6d09b25ecad5e4dffd53d99fcea513e696f06a19e3138da8e7acade324402b2b270b108f600812fd9fc7d9151256a549845ea4a36bbdae81a18623667dbf4958b4fd0b854b30c84b77f6371289cb2e6b717e35f7c4895bc568fa26a22e567d39cf8d4befbb156f761cb07962c176f58bbdcf3c6685f8aa8b50833a7f6ab661e0674e2e0e71ad17260f0a7c56c360624c987041e752d5641198658b385f314f431a19c5fc20a269642ea48ce1dd6559749bb96926c8ae96716568ee884123927427c0808da01ffdb9a0da587cbe616309994a20da66130abd422917199534ce274a4c7a685b8e430d170e14b71a36f31187f1fb64ff1abe25e23bb46472862981478b9cab46568eb9f26a01aebc21c4cb5bb39cc02e43bd035fb504bcea478d47557beeb626b619d7d3e0f46a6d29d25cd22b84c9b353a18f442314f43c262603868a15827ad671b35e22f696dcf18e0f5809a02fb8be01a1977e45f78db84bf8508342c6438d0e6910f9dbc319a53675d7e78fc47280438ad7fe227200ab37bf229ff915f0471f827d6a77b77215d6857bae599b76a25d68faca99f04e18c303caabe41847349deb7c069f88fdf330bb3b2dd287c89e7bc851fd49ea79563a605c4642dd2e735f814167123f60b3d9e6d74c7ce154dea47e14f315840553b29cc0e804bb7e97ddcfb05c5a518a43c93de302d37f0d6839659bf8075df07741dc70e9fe1cb125c80e12fa14fddb46c306ed00cc46347c7d825951448336b49e1618268b4a0434e3dfdee8c74c028d5f1b5ca2f2ca089cf37612fa68e8728e8d4e601b7c2f0e0505389ac0dfd67c560a67c207be754c565af2aab9091c0e14ef35c1228a33257dc160b556a133282ccf72220aa50352e8df471b8c3fc67cd2f2ee7753b1fbd410c86961fdb13978bdb29015ebb6ba07ab8b7387f8f711e5937eff11b54635d7fc2b6a8d2102a6c900f5067b27a1b97adf632db0afedcfe0d8259a012068932408543c7f88ff15763e13004e7060dbaf3ac0870bb26d61515479fcda4e09d007b9762308960d4ed6a42f7cbd8757d252cc403e390f9b6450a7792b9dc682a87a31457b8a454935e94af81329d94e57b402a1ed5c073d39527f04bfee9e9b9102423cba933c17235dfe13e01e4a83035600655201e6dd7060cf1d50642d357b14e45c7999bc9989f66efb84bb323f031eeddc36615d39373b56f0d0ccf15735d5903ade1266e1c14405de9350e2faf3e42ab70a2c78ea610b633d09ef8bf313f0f55c564b345464efd6041bf3000c63ec476d394741835a5ef71aef0bade52d7ee1d4bdfbe27e220180c10f102caf88cb81ead076582385a2cb4544e262166ecc3634dd08f0e6376d38884d0c9e87a007a396bffe1de8b671c2bddb338e5e93ea87df25da3c51ebbacbcc1534226d9aa930b22b22f74cd35cf5d4e72191f21a060eac56b1ff915327c017ce438c240dca665a6ad7f53b61af0b8f2b5d80ae592043439f8e32e60af16d31ba695a388b12fc54c8aa8d863c70789601a7c5aa940e09fb4e70ae9e68cb9ef6b7802febd667c486ff621af90951702b3d32a0c6fb1b92f89c737dce84db4193b913667609b534e6b08c3bd772fc67c7cb3d7bb7999fa47daa63f17d5573bc41e985f94c6d8ef7fa789f0d9b1371f7dcd75842393391836d2e5c8aef817b4f5902d4c5963183dc85d4967b94a355664cc5bf4d4b3c3834382e57a6c5d599d0076c1e194ce8050e2a193427f4efdc8de838622fff68df111c673cff3961bac49b5a84d43854652502d5908f5b105c6e12eb49748dc32857776788abe0e369bfb9421669bf6a9daccdb97385f7d56d4adbb4507eb884c274323b462f2227ab53c6cba66216429ac14b31727eec0f57850bafd83a72fe1893e2d66af06b6403c0f97407d0994f4ab7abe9d82afdb4c0bf90690a53445a1dc8fb60f02959455ee1294adb012a1f9b25ffaadf785bf291d7c5a831934e8d686fc0bd51d8f7e87344eb0fc65a82b4d4aae67df0640dd99b8448529d6bf35ba1b6757cda7d913a9b13757ceef4bdb8761594d36d39cb98a80895c8c399ea69f063c661e15647494e5ccfab965bfb1668119a4c764bb781811f07e60bd918e62aceb1c08438ef44ba1a53a659b0027abf84d394a06d45c683cef7fd84c7009639e14eb9dd4401714323b5bb77d0661ae57a11f9efde5ed8b14f5566d89fb104b7346f196c47215a28ee6599dfea6cede6092fac0e2054487fad5c3e3d456f206784be087415e0e7e53e17da89dea619eece25899afa04cdda1e3231bd2b05c43164aed9fba1a541f7f882d423566a040e8f9f176ffd7eff9a1e27b7546402f29b57c69b61af80b66ed27e0f6d00595824abc14c0f8a4f16277eaff150391962b920ab316bb9ecd9bb11ddb4fb4905c95f39dc9731b21dcb7d463b19258463056f4ee6ef1a992619eff6e3f35a59e9181e2630537f4b5b507ecd4ee1a60b1e17060f73912558f521e63bf0f3a8455090958897db8d2096d7eff73be02fdd872528ff7e9217849bdc17c64a026003bb4978538a0ebfe0a4a258e3d693d6b5c803e055550ca195db19cc085e5bfc71e6a374b680dee2ed30d31ae544d9bc9a85e6d2f38109456d15e14a32304e8f5ddc4d14b3470fad31951f99cf14dbafaa6eeb2bc2a6c1f952bcb134358c5954b133cda45f6271d3269303d6cb00b6e823f7df84fa82c26b7b5c5d0d6f2f1ba0714e1835028ff120ff95b5bbb03e32a99a4d1844b8582127463984b74fe8a19d5f74322e99f124e7e559f41db1aa93eed1e62b333c2d7179ffe3b2e8a7693907f60b024d6da17a4353c24aa692129edeed83f9568a18f4ebb057cb188708a0c6386baba4be37511c5f2c8a7f12b53916d3309df5023317078686bb18fce4bd1b564ea11e0765a54469310021fa5ccdbe4b5b18ac3562cb214490dfbef349563d78fcad488fb406737bd9802ca448744c8cabe9b89646937c70da0b9972e00505d674290028ca70826def8cfc2e11559ac1652058061acc504a73d0226062dd5bad3324d0ebfc3fff467211844e2520ddec4d3570e5349936d8a94eb6fc3f35f961a06c141baec9aca562126ed774f7cb6d9ebd8060e69f8f5881493270d4d290e21cc412160db09456fb2d6d0e2b5481321aeee60045831820a9cefbfbd35a1cfc215120c3fd7771ae6a47fb594d06e9b77109a71c7e996db47b37cd36e7936db152534b846be2b77473464cd54055adce1302e307ea17110250a3cb8e250828d0b2cce776c47801c9e359296c074dac2a1b0620524893a22e4e0f8ac584003296e5ab7650b02775f80795a6481653120313e7b2eb3dfac36e4fda2d59753b3bbb6a679a3aae035e42dc81e34de7a1aaa2b1d634fe35119c1dab2cfdae4673e106abde0cdd3f7fcbf3a031d401c304771bba8e6a1b0e746c896fb542a382e42b439ebdc16846ad05893a62bd2f58fcda935aeea02eeb9b7f0e09e24b4f37bf728db71a409c57ce7e6d9d55235e440ebd8a79cf9954d98109e26945b308b6ecef2e7b588e986b11ffa277b9b5fc06c62afa2ed5c90b2e6d8af7eb28758a817336c0c2c34547479a4d096e39e1afacb99925f0b94b88a258db3b6440f9eafb0d8fb3d618360ab3b9d29d88a14a5d2020c2c065a81d646622941d64ac529cb3cb3daa2ac6c803c33b2a7d936c6c73005a42a72767612750cc5a28aa8b099dc8a6142da598a9989e17f932c8a2bcad3411073af56b6fef89d25b420d764e59b64c59b4166b7c8092eaac432b4b67e81428b3548e59877af6c5919d5d06f972880cfbb8f166aa87ac01dee2b22a195a868eb9d4db72693ac61c39590fc473f23bd8f6e10ba07b377cd4f12e998726706f0a8c83a2d50ac5f1e1852997f2690150cb4a0dbf350361653e08dff9d651bfd6e3ff3bbc7f7f656764e1c660aa6ed8ab9a469a36c875a1b675dcad32a3bd80eaac1a79f066c495575730d80618cc5099b4b9bd2f565355f414c0874addceacfb4cf9855525075e0715886217201ce5d019927d9fa8fce948fa062f06411482386b047c2f868a6017227bc2c67e8ccf88f4b9e09d68f4f9af5df5309eaa0bd1decf1caf8905c050f8de77e191a971d8c55f9f43bd9d6123f6f6b22c7ebfc15b00d4f727a65239fed07f784591d083eb2c1edf3b26da48af93fd017325ae1d1fba70bdf6464ac4d3f4e8de4e56eecb4740380c0cae221b26c731d16e138c0859872b107707b49568f4241eefd169f19d8c984a132dd6690d3b24655aa588428a0f8ed7fea2fc7e1940b63229ef661441315b5fe4555f4071c154fe4515fe20d2686d3158e031e6f9e3f7cc2dac438f8b54d4f6666012afeda596860a2e24bb8c9d2112778d55d8fd4aec81f2e638559d55e3988460824868518c7d7458cb3c387398387619536713a0dea2bf3fed07c233e0c6c28adcbf5675e62331b20f48039019483241e8dda9952349f5470889b4659d3ac3043610d98deea144de7a0b21372b04a6846d31e6724596c5210ea7089e00d8b79449456883b4b293cdf27db4ad0a6850110336e5d4d38593eb62b7ac75602f700043f6b30572e1fe6ebda9a4ea973bc95b0b3cc26dfdea8efc440bfb2c843ccd41e0c8fec01762a31e50204f002382afac425c0074c3559a8cf3a591e9376edfa9987c79f348cd4e1e4225b29c9f85d5c7e4e1446bbdd583490c2dc385157ecedd9b9bc78e4f6bb22a96a3ccfa4ca5bfa34e9632649a095145a76b9ed9b2c1ba554b5c6aaa4f5726ce7d3fbc2dd9e071a8749b1e1b09cf4b6aee4843fe3f6d30f52f4fa93ad3529ee0026726cf8a554c343037e3a0d9988aaaa225a2cf53e2dee6b464ee136fe3e85e9532b94c1240f182781caa794c664d4cdbf9ada2aa0da50ee28a60489c7d18354b0bbadf0ede5cb67512974220d9fd6e5512c532d919f730d09e383267973053ddfa7b79a7d44810ea651605d14c15373b247100660165e78f90bb7f05e36dec50a3b6f1f0a96dd9c7bce0974ce5cf9063f2e991ac1d935f952793e495041315b6ead21ef6c48ce1478ab7aa534fcaf14f3503ff31ee9d890716f7fe38ed7e4f7ae2607016891c2bc5dd283da6f508b361ba1317aa0651cb72ed78f86dfb2106c23995cb9e9da5c1f92460d21ca539b611221f73153c26f33cd55e9c9acdf4a697ba9400bbedd7229a584f6b711982e0d5dc60c3fc18036c1ad2036054f3f6487947f0e08659f6d71634602b3b69bd514c0666cdb9e2f17236ceafb6d115da09d0d6b50d35b9edb2598e4f4493dd24f53b714bd6ffffcf5f0c1acb79169bd75fd9c8db62e6b2b20df46c7ac5cf8fc9a2dd76147c93a9a00b91f52cbbbd3e8f57b202213e3ddfc15a42700c30a46b759f4fa97f620dcb1df1cec254d4cb213d50ccf67594a79d966255f0d0af64d6fe0979f41c75479ac62925ba3f34eb0d59de449d1f76dc29ed71fead45c7d867d6e9e026e3c122433e999e18550b83c40fd4dd047161f0d2a9f81e892dcabe23c82b9fa2c18e678c098d5db0d98974a1ae849659c684240d8569352663b4fcb75be047881f52473b3c15e66edd8792c0c6a48bb9cf10ae01f61c2c895b92bce4acb69f237944d90ee624608313dfb0c8eb07c2b71301e0b74e5a170ee494ee9e25cb761496c25a8a3667e3cdce5af3f41b14fcf9e558393f2aa1ffe3bb5001bec0ce0a0c8bd9204b9b1cd0a7b3df808a5a21233ec27cc54144a8f81ee2e058647db3c13acbfc8f199c7ff0e75eb84dc4e3e0446b2ed64f01344ab04c9279ad8b19aa9b8305c4370c072db1257138888c36ac00a5604b676937fb5ebdfc496d12e30a8b9f4e30ee67297cfe274450a513a516af5ab90ba078549430f7e664eceeb33400e23dfa4af8c1a5bdb4d7bd74a479409a1b7695518202e0795314c66d1d77d828ed0b630c347f887878a0aea95ad04aee8a28b16cddc6bbcf4a0637cc5b30f2a9010b7611fc0b1b72f0f3263db4f7aab2b90d9575f391740e68169c0725e4f4febe309fd0955b079b8b820b357eebdb810de5d769defa31ff3d4cd421686b7f5116479f9242c65048ea2496fea20a414abbc5ffc2ab9cf74d15da906942064b529ff001fb665a3014aeb19eb228145e066df69133e45348e9c2547abc25dc54994f197a83058353b2cf7c0873257c7e7b19fcc35749080932d6af0457df5f9a88b661c3e154c1654735b359a47783fa5a57cc825b25c01706266fdf73b6e2a9c051a9f979437f1e994ded7fc29f93ebc2545564304feba306fe5004caf88ec3097132724b062b635584926dee9d8c3b09705cc8836f30f5a7ed5a5a1d85b5c827c3f0570651e438075f1e0f46f2659eb00b30c0ea65c6b91fec997838fe9135afb6f9d535ecca4c19181afde35557dc86be7210a827cc720a82a042b092033b46980e51383ea5d8ab3148662e13ebd85b9f6624333572a78a35f4e6fe385086a3a0959377dfd4f134ecaaa75628f106faf7bcc77128a25a8a56f5f39f852ce5791c57d3732d6c99415980ef4935ebfbc4b66b696c627e3c2b8a483c1a30179c2cdd40573beb3ded07f1a37a9d20d10155243099cf85fa1b2b5bc92c99baaf988b24feb947f567350366c718df4ffbe584b8273b2895e4321097b27a82c2f003c62d96cdf79cf78d929342f6865ed5d82957a39410ee65ae47db0119aebdaf0098899c19dfe778f3237d593b295b349d73884f66024db7c89557416aaf6a0b2500b870365c78621e20fb26b060e0fb1e8c36b4ab4f701b41feb9ce346c79ec81c505fc621440b192089d3ec69fbae0aac0a8a449a884efeb8b3296f4d9e8340bb755da2177fd111c24c1549ba6679d0774da31ef21095ba113ecc54c4eca9c9462282efd650c7ba0297df1778ab6979544fc2f4ab3f55f6354b43a37a3b58e4bb33c259e6e75ca35dc4aafb3b27b85670e24f47b69182cea54305a6ce61223670e08b359fc57e593e4595e6a05e2bab408b2837f20ae24e77e200df3f19cb708073efcf61579e51949d7435cee7cb11774d27fe13a691fe87109020f0936586ba9313290812c44b3555ae85e5ae80f29d55612df07f982c985db0288452ee618673b6123a0ad3cf66c138102c3dc010444ffe6befa748bb14930d49e648ecc54542b013f03fc77b833044d216af4b4d027fe1cddd25fdea3af4f8a9d869c0f71b5b234a190f46be60024e2eeee9c6cc227b856600dd221064024366a53b47f28156b0b4fb3c5a6c4c633f49ef22f17090883d18ecd8b91c2e5571389640d85c4122220655c885561b79597740d256c0bf6be6b0b5fe1c5ce358b23194e48868aa8b3b5cd473b2d32abdffaa3448d035d01fee156d8d655e7254700371e8142e3397ba91d80414a0b51232d3843c01afbf9c2c038e7a857e986d8eba31a3f47ff6e40f41b05bcc45eae237bb65698d33a7f428a153e14fa357c478baada43dcc5095d83e1e6aadd21bca116cf1a9e3099aab2d3becfdf1e4e3962e2fc75a3155ef3c9806343525f7130846fe8e8ae35160c8417e32606c15e8cd2597476fa1b43b07aeb4bb199c56eb21a8b7a021e4eb2a0d96635c984ba811b85ae1f7b95499ff83621ed4d581bfc787078ad4b2469e50cdbced0918b8ac7428a41e0e940ddb04d0029cab36d77be5c9f0aef809b0f0cdf27def23787bfd5c6cbef4d09f27104ca3cc522c5122f888a00e26642ec93efdfbfe8d488c13d555272aab6106467e42e383e5d44fd980fc626354c350bca1758453ede96948d655a3eeccb7457888dd1a93023d79ed6b70073bf50b4e3dfe38e21b8cc61fd3f7ab77b8f4cbdadb938ade0c96f6091ef5a32375279f35fffd6919b7df44c4f6b88cad8b12a25d9a74998d2a0d8b2064ac62d99213ee9a747fbf4d55a2793ce34dffb1be025b0abba33052dfabf878d0fb4f31858b3d9c6ae83f650dcb8e1d9fe030de3183028e3212ea183a0bf977c1ec6b2facdd8579b6bf01dc95b714b8b8a815095f528aad445580c218f4410a81c51ba6615c6a72d7fa59f996013118d953e49ee5d7f8fd22fff6face77df57b57b9efef77e7a21e9fbfde49fafa72dcbd1ed274a1d5bfdd31a8f414f7ae1c80503d5a685e91a53803ac2727225dd0ff6721d1218be044949018683f7b6f3d4dc792c9e6000e2bfabcc0fdd42aa8f3951dc9cf1e27e847a461d2d5d4a0b2f678e5f9ae29620ded3a2cac348242db0fd3fffefd16fdf0eb86de6a65ceb45f5fd80ca17f6ce10842b1a53f11ce15c866283f1197fea485e6a41880f44564c37cf93615f1281c5580f432f07d014b265cc8c5c7f2e4dd145f3be921887cfb423b743d048c8eb6cb413393cd71cd8b2ff83832426f8109d88d37d318dca37ddf8c6c5fadfb28e641b7660057295e75b6c25e5289c31824c8b2749c1d93e3837c776ae4433a130a3b7f92c1e0abba8197f7a0fb83cad29bb91fa8f087c706028fe815125a28cf33e5fc5141b445498cd3a70d437163a6663b300a41ff0e4ebf989784ce99dff54d7816ddfecb19ff3df3a8ed62fbb1519efeddca2ecd00b79cbd42ff7ac1c5485969c03e36ab0d8994dde04047f07898adbc620afc6cc1ce713314c0c57c24396cc4131082f40cff1a996b23fd43f6222fdb54a251a6b394e34957ee6f26fa541c0bf8000694e66ef1d98263815b5e384f1d11ba92801afb731303fb528fba43379f6886cfe2b45f454127961d9cd6b69a774f659b295045107aeaa78c54a13c75345ed8a9c264f1e858a32a903f81a1b12a6db6141ce350edc797baa2f627e6b2574cd9fa8049bb38d93a9385b2d14c548892790ed038c5c0880ad20cd4cea3f0efe9352d3c0e3e7d251ae47e65a287cf397ff7223f56692ece8a7049a91dde87197c1f9a7f334effc82a835853b1040809593e122a6fd3bbbe15d1c09913a63a5103c5010503b3a3dc104e0546e7b37063dee341c7d0158402c7bb7da791feb925e11f07ea079941725be805dc64eba4cc220ed2c52934d5bba629cf386c76b922be6840d1bb066483f2c42ec5e501d91bd737d9d5bb39c72af628335a256d70abfa317be1dbfa9a5813696952eee245fb62b55903d6e363ef254584cfe03fa5b5cc618f071e3d9b4f024cc94596b2b69be65d5bb9e5b134903ff88395d3c9573ea670a3df160976c146630c4ae85175fddeed5a323f6d092d47ccd8d3be42f28a90ed92fb0828b41b7dd2f6a3fc3ea9756e6aa113f5f434c0c85a7aeb8c72b439c39b26ec39dac89507b11051879912b8c1258dbd66721a25d8862f6737f3784706c3820cbc17a682d9b2fa94f00b6f52f9de873fd2f0b3702a729d7a3b4ae55c5e42d1042ccae874851eaeba8f5c025b3808230e4dcb61bdf24b2e7e9788cdf6b6b3652aeec5f21019042120eae288183b67129426637335e9183e5337228205c95b55c0721548abfe079aeb39c3be5a08040fc649d98d744071ae92658a55b4d59543f4d33791fa6d80759d416aff232be63862f375a14864d4177a768ef2c8a57f2dfff0d3c99ae6e3f97fe39c18441597998f6a16b08538ef18283e1581f287c1d80867fea315a504034771b2f11022e23cac46bb31203b91fa5f5cd91a7d7a5f3f44dc0fc64d4da55aa685c4af31efcf8b07f75dd2ace70b735bfc676b44bd06067cfc3270b15af1985adf22890dc28ba92f37603a2ac4afcb6c55cc8303525677f3ce4e5606536d05ced0927a602829fa16ae36ead04732b8409a3a4c98a679f1aa99623a659e08860182205524ef89f7a91cc23802c2efe6aa3977ee2ed75556c3c67784fb6a04923caef8fc2cf1dc0630b21e924e719a035675705813c7fe867da736ba901c059743c4ff70524dee93cb5b8949662794eef7928c3330b4d4686b01f3e6c8a1ef1f93f93c128701ac28490f54a5529931b1e1c62b811f4942e4f984c74a1a069dc5cc2f7294ebc0b02bc1232ecf42e2674715ed45b6fffe3d18b01bbfd811cc027011f0092808ff013fa32d3e84b77445e13fb1e6c6d98a0832ae61b4bbeb1e54009023c91de15b313b90858c39fd3f0e3988779ef72bd0a25f27cd0cbebece596c5a561c7f0c9d5c5537e85ed8dda9022d6bc510328029e8def1715ebb485370aaedf0edd407e4d99fbb47ca30689f8534b597c7359a9e3ad12b466f9a0ae05babc28210cf0ddd20bac591e3b58e2ec3ec63d8341304f9762045081f1c9d9149f0984","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
